/*
 * Type Definitions for Gjs (https://gjs.guide/)
 *
 * These type definitions are automatically generated, do not edit them by hand.
 * If you found a bug fix it in `ts-for-gir` or create a bug report on https://github.com/gjsify/ts-for-gir
 */

import './gio-2.0-import.d.ts';
/**
 * Gio-2.0
 */

import type GLib from './glib-2.0.js';
import type GObject from './gobject-2.0.js';

export namespace Gio {
    /**
     * An enumeration for well-known message buses.
     */
    enum BusType {
        /**
         * An alias for the message bus that activated the process, if any.
         */
        STARTER,
        /**
         * Not a message bus.
         */
        NONE,
        /**
         * The system-wide message bus.
         */
        SYSTEM,
        /**
         * The login session message bus.
         */
        SESSION,
    }
    /**
     * Results returned from g_converter_convert().
     */
    enum ConverterResult {
        /**
         * There was an error during conversion.
         */
        ERROR,
        /**
         * Some data was consumed or produced
         */
        CONVERTED,
        /**
         * The conversion is finished
         */
        FINISHED,
        /**
         * Flushing is finished
         */
        FLUSHED,
    }
    /**
     * Enumeration describing different kinds of native credential types.
     */
    enum CredentialsType {
        /**
         * Indicates an invalid native credential type.
         */
        INVALID,
        /**
         * The native credentials type is a `struct ucred`.
         */
        LINUX_UCRED,
        /**
         * The native credentials type is a `struct cmsgcred`.
         */
        FREEBSD_CMSGCRED,
        /**
         * The native credentials type is a `struct sockpeercred`. Added in 2.30.
         */
        OPENBSD_SOCKPEERCRED,
        /**
         * The native credentials type is a `ucred_t`. Added in 2.40.
         */
        SOLARIS_UCRED,
        /**
         * The native credentials type is a `struct unpcbid`. Added in 2.42.
         */
        NETBSD_UNPCBID,
        /**
         * The native credentials type is a `struct xucred`. Added in 2.66.
         */
        APPLE_XUCRED,
        /**
         * The native credentials type is a PID `DWORD`. Added in 2.72.
         */
        WIN32_PID,
    }
    /**
     * Error codes for the %G_DBUS_ERROR error domain.
     */
    enum DBusError {
        /**
         * A generic error; "something went wrong" - see the error message for
         * more.
         */
        FAILED,
        /**
         * There was not enough memory to complete an operation.
         */
        NO_MEMORY,
        /**
         * The bus doesn't know how to launch a service to supply the bus name
         * you wanted.
         */
        SERVICE_UNKNOWN,
        /**
         * The bus name you referenced doesn't exist (i.e. no application owns
         * it).
         */
        NAME_HAS_NO_OWNER,
        /**
         * No reply to a message expecting one, usually means a timeout occurred.
         */
        NO_REPLY,
        /**
         * Something went wrong reading or writing to a socket, for example.
         */
        IO_ERROR,
        /**
         * A D-Bus bus address was malformed.
         */
        BAD_ADDRESS,
        /**
         * Requested operation isn't supported (like ENOSYS on UNIX).
         */
        NOT_SUPPORTED,
        /**
         * Some limited resource is exhausted.
         */
        LIMITS_EXCEEDED,
        /**
         * Security restrictions don't allow doing what you're trying to do.
         */
        ACCESS_DENIED,
        /**
         * Authentication didn't work.
         */
        AUTH_FAILED,
        /**
         * Unable to connect to server (probably caused by ECONNREFUSED on a
         * socket).
         */
        NO_SERVER,
        /**
         * Certain timeout errors, possibly ETIMEDOUT on a socket.  Note that
         * %G_DBUS_ERROR_NO_REPLY is used for message reply timeouts. Warning:
         * this is confusingly-named given that %G_DBUS_ERROR_TIMED_OUT also
         * exists. We can't fix it for compatibility reasons so just be
         * careful.
         */
        TIMEOUT,
        /**
         * No network access (probably ENETUNREACH on a socket).
         */
        NO_NETWORK,
        /**
         * Can't bind a socket since its address is in use (i.e. EADDRINUSE).
         */
        ADDRESS_IN_USE,
        /**
         * The connection is disconnected and you're trying to use it.
         */
        DISCONNECTED,
        /**
         * Invalid arguments passed to a method call.
         */
        INVALID_ARGS,
        /**
         * Missing file.
         */
        FILE_NOT_FOUND,
        /**
         * Existing file and the operation you're using does not silently overwrite.
         */
        FILE_EXISTS,
        /**
         * Method name you invoked isn't known by the object you invoked it on.
         */
        UNKNOWN_METHOD,
        /**
         * Certain timeout errors, e.g. while starting a service. Warning: this is
         * confusingly-named given that %G_DBUS_ERROR_TIMEOUT also exists. We
         * can't fix it for compatibility reasons so just be careful.
         */
        TIMED_OUT,
        /**
         * Tried to remove or modify a match rule that didn't exist.
         */
        MATCH_RULE_NOT_FOUND,
        /**
         * The match rule isn't syntactically valid.
         */
        MATCH_RULE_INVALID,
        /**
         * While starting a new process, the exec() call failed.
         */
        SPAWN_EXEC_FAILED,
        /**
         * While starting a new process, the fork() call failed.
         */
        SPAWN_FORK_FAILED,
        /**
         * While starting a new process, the child exited with a status code.
         */
        SPAWN_CHILD_EXITED,
        /**
         * While starting a new process, the child exited on a signal.
         */
        SPAWN_CHILD_SIGNALED,
        /**
         * While starting a new process, something went wrong.
         */
        SPAWN_FAILED,
        /**
         * We failed to setup the environment correctly.
         */
        SPAWN_SETUP_FAILED,
        /**
         * We failed to setup the config parser correctly.
         */
        SPAWN_CONFIG_INVALID,
        /**
         * Bus name was not valid.
         */
        SPAWN_SERVICE_INVALID,
        /**
         * Service file not found in system-services directory.
         */
        SPAWN_SERVICE_NOT_FOUND,
        /**
         * Permissions are incorrect on the setuid helper.
         */
        SPAWN_PERMISSIONS_INVALID,
        /**
         * Service file invalid (Name, User or Exec missing).
         */
        SPAWN_FILE_INVALID,
        /**
         * Tried to get a UNIX process ID and it wasn't available.
         */
        SPAWN_NO_MEMORY,
        /**
         * Tried to get a UNIX process ID and it wasn't available.
         */
        UNIX_PROCESS_ID_UNKNOWN,
        /**
         * A type signature is not valid.
         */
        INVALID_SIGNATURE,
        /**
         * A file contains invalid syntax or is otherwise broken.
         */
        INVALID_FILE_CONTENT,
        /**
         * Asked for SELinux security context and it wasn't available.
         */
        SELINUX_SECURITY_CONTEXT_UNKNOWN,
        /**
         * Asked for ADT audit data and it wasn't available.
         */
        ADT_AUDIT_DATA_UNKNOWN,
        /**
         * There's already an object with the requested object path.
         */
        OBJECT_PATH_IN_USE,
        /**
         * Object you invoked a method on isn't known. Since 2.42
         */
        UNKNOWN_OBJECT,
        /**
         * Interface you invoked a method on isn't known by the object. Since 2.42
         */
        UNKNOWN_INTERFACE,
        /**
         * Property you tried to access isn't known by the object. Since 2.42
         */
        UNKNOWN_PROPERTY,
        /**
         * Property you tried to set is read-only. Since 2.42
         */
        PROPERTY_READ_ONLY,
    }
    /**
     * Enumeration used to describe the byte order of a D-Bus message.
     */
    enum DBusMessageByteOrder {
        /**
         * The byte order is big endian.
         */
        BIG_ENDIAN,
        /**
         * The byte order is little endian.
         */
        LITTLE_ENDIAN,
    }
    /**
     * Header fields used in #GDBusMessage.
     */
    enum DBusMessageHeaderField {
        /**
         * Not a valid header field.
         */
        INVALID,
        /**
         * The object path.
         */
        PATH,
        /**
         * The interface name.
         */
        INTERFACE,
        /**
         * The method or signal name.
         */
        MEMBER,
        /**
         * The name of the error that occurred.
         */
        ERROR_NAME,
        /**
         * The serial number the message is a reply to.
         */
        REPLY_SERIAL,
        /**
         * The name the message is intended for.
         */
        DESTINATION,
        /**
         * Unique name of the sender of the message (filled in by the bus).
         */
        SENDER,
        /**
         * The signature of the message body.
         */
        SIGNATURE,
        /**
         * The number of UNIX file descriptors that accompany the message.
         */
        NUM_UNIX_FDS,
    }
    /**
     * Message types used in #GDBusMessage.
     */
    enum DBusMessageType {
        /**
         * Message is of invalid type.
         */
        INVALID,
        /**
         * Method call.
         */
        METHOD_CALL,
        /**
         * Method reply.
         */
        METHOD_RETURN,
        /**
         * Error reply.
         */
        ERROR,
        /**
         * Signal emission.
         */
        SIGNAL,
    }
    /**
     * #GDataStreamByteOrder is used to ensure proper endianness of streaming data sources
     * across various machine architectures.
     */
    enum DataStreamByteOrder {
        /**
         * Selects Big Endian byte order.
         */
        BIG_ENDIAN,
        /**
         * Selects Little Endian byte order.
         */
        LITTLE_ENDIAN,
        /**
         * Selects endianness based on host machine's architecture.
         */
        HOST_ENDIAN,
    }
    /**
     * #GDataStreamNewlineType is used when checking for or setting the line endings for a given file.
     */
    enum DataStreamNewlineType {
        /**
         * Selects "LF" line endings, common on most modern UNIX platforms.
         */
        LF,
        /**
         * Selects "CR" line endings.
         */
        CR,
        /**
         * Selects "CR, LF" line ending, common on Microsoft Windows.
         */
        CR_LF,
        /**
         * Automatically try to handle any line ending type.
         */
        ANY,
    }
    /**
     * Enumeration describing how a drive can be started/stopped.
     */
    enum DriveStartStopType {
        /**
         * Unknown or drive doesn't support
         *    start/stop.
         */
        UNKNOWN,
        /**
         * The stop method will physically
         *    shut down the drive and e.g. power down the port the drive is
         *    attached to.
         */
        SHUTDOWN,
        /**
         * The start/stop methods are used
         *    for connecting/disconnect to the drive over the network.
         */
        NETWORK,
        /**
         * The start/stop methods will
         *    assemble/disassemble a virtual drive from several physical
         *    drives.
         */
        MULTIDISK,
        /**
         * The start/stop methods will
         *    unlock/lock the disk (for example using the ATA <quote>SECURITY
         *    UNLOCK DEVICE</quote> command)
         */
        PASSWORD,
    }
    /**
     * GEmblemOrigin is used to add information about the origin of the emblem
     * to #GEmblem.
     */
    enum EmblemOrigin {
        /**
         * Emblem of unknown origin
         */
        UNKNOWN,
        /**
         * Emblem adds device-specific information
         */
        DEVICE,
        /**
         * Emblem depicts live metadata, such as "readonly"
         */
        LIVEMETADATA,
        /**
         * Emblem comes from a user-defined tag, e.g. set by nautilus (in the future)
         */
        TAG,
    }
    /**
     * Used by g_file_set_attributes_from_info() when setting file attributes.
     */
    enum FileAttributeStatus {
        /**
         * Attribute value is unset (empty).
         */
        UNSET,
        /**
         * Attribute value is set.
         */
        SET,
        /**
         * Indicates an error in setting the value.
         */
        ERROR_SETTING,
    }
    /**
     * The data types for file attributes.
     */
    enum FileAttributeType {
        /**
         * indicates an invalid or uninitialized type.
         */
        INVALID,
        /**
         * a null terminated UTF8 string.
         */
        STRING,
        /**
         * a zero terminated string of non-zero bytes.
         */
        BYTE_STRING,
        /**
         * a boolean value.
         */
        BOOLEAN,
        /**
         * an unsigned 4-byte/32-bit integer.
         */
        UINT32,
        /**
         * a signed 4-byte/32-bit integer.
         */
        INT32,
        /**
         * an unsigned 8-byte/64-bit integer.
         */
        UINT64,
        /**
         * a signed 8-byte/64-bit integer.
         */
        INT64,
        /**
         * a #GObject.
         */
        OBJECT,
        /**
         * a %NULL terminated char **. Since 2.22
         */
        STRINGV,
    }
    /**
     * Specifies what type of event a monitor event is.
     */
    enum FileMonitorEvent {
        /**
         * a file changed.
         */
        CHANGED,
        /**
         * a hint that this was probably the last change in a set of changes.
         */
        CHANGES_DONE_HINT,
        /**
         * a file was deleted.
         */
        DELETED,
        /**
         * a file was created.
         */
        CREATED,
        /**
         * a file attribute was changed.
         */
        ATTRIBUTE_CHANGED,
        /**
         * the file location will soon be unmounted.
         */
        PRE_UNMOUNT,
        /**
         * the file location was unmounted.
         */
        UNMOUNTED,
        /**
         * the file was moved -- only sent if the
         *   (deprecated) %G_FILE_MONITOR_SEND_MOVED flag is set
         */
        MOVED,
        /**
         * the file was renamed within the
         *   current directory -- only sent if the %G_FILE_MONITOR_WATCH_MOVES
         *   flag is set.  Since: 2.46.
         */
        RENAMED,
        /**
         * the file was moved into the
         *   monitored directory from another location -- only sent if the
         *   %G_FILE_MONITOR_WATCH_MOVES flag is set.  Since: 2.46.
         */
        MOVED_IN,
        /**
         * the file was moved out of the
         *   monitored directory to another location -- only sent if the
         *   %G_FILE_MONITOR_WATCH_MOVES flag is set.  Since: 2.46
         */
        MOVED_OUT,
    }
    /**
     * Indicates the file's on-disk type.
     *
     * On Windows systems a file will never have %G_FILE_TYPE_SYMBOLIC_LINK type;
     * use #GFileInfo and %G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK to determine
     * whether a file is a symlink or not. This is due to the fact that NTFS does
     * not have a single filesystem object type for symbolic links - it has
     * files that symlink to files, and directories that symlink to directories.
     * #GFileType enumeration cannot precisely represent this important distinction,
     * which is why all Windows symlinks will continue to be reported as
     * %G_FILE_TYPE_REGULAR or %G_FILE_TYPE_DIRECTORY.
     */
    enum FileType {
        /**
         * File's type is unknown.
         */
        UNKNOWN,
        /**
         * File handle represents a regular file.
         */
        REGULAR,
        /**
         * File handle represents a directory.
         */
        DIRECTORY,
        /**
         * File handle represents a symbolic link
         *    (Unix systems).
         */
        SYMBOLIC_LINK,
        /**
         * File is a "special" file, such as a socket, fifo,
         *    block device, or character device.
         */
        SPECIAL,
        /**
         * File is a shortcut (Windows systems).
         */
        SHORTCUT,
        /**
         * File is a mountable location.
         */
        MOUNTABLE,
    }
    /**
     * Indicates a hint from the file system whether files should be
     * previewed in a file manager. Returned as the value of the key
     * %G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW.
     */
    enum FilesystemPreviewType {
        /**
         * Only preview files if user has explicitly requested it.
         */
        IF_ALWAYS,
        /**
         * Preview files if user has requested preview of "local" files.
         */
        IF_LOCAL,
        /**
         * Never preview files.
         */
        NEVER,
    }
    /**
     * Error codes returned by GIO functions.
     *
     * Note that this domain may be extended in future GLib releases. In
     * general, new error codes either only apply to new APIs, or else
     * replace %G_IO_ERROR_FAILED in cases that were not explicitly
     * distinguished before. You should therefore avoid writing code like
     *
     * ```c
     * if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_FAILED))
     *   {
     *     // Assume that this is EPRINTERONFIRE
     *     ...
     *   }
     * ```
     *
     * but should instead treat all unrecognized error codes the same as
     * %G_IO_ERROR_FAILED.
     *
     * See also #GPollableReturn for a cheaper way of returning
     * %G_IO_ERROR_WOULD_BLOCK to callers without allocating a #GError.
     */
    enum IOErrorEnum {
        /**
         * Generic error condition for when an operation fails
         *     and no more specific #GIOErrorEnum value is defined.
         */
        FAILED,
        /**
         * File not found.
         */
        NOT_FOUND,
        /**
         * File already exists.
         */
        EXISTS,
        /**
         * File is a directory.
         */
        IS_DIRECTORY,
        /**
         * File is not a directory.
         */
        NOT_DIRECTORY,
        /**
         * File is a directory that isn't empty.
         */
        NOT_EMPTY,
        /**
         * File is not a regular file.
         */
        NOT_REGULAR_FILE,
        /**
         * File is not a symbolic link.
         */
        NOT_SYMBOLIC_LINK,
        /**
         * File cannot be mounted.
         */
        NOT_MOUNTABLE_FILE,
        /**
         * Filename is too many characters.
         */
        FILENAME_TOO_LONG,
        /**
         * Filename is invalid or contains invalid characters.
         */
        INVALID_FILENAME,
        /**
         * File contains too many symbolic links.
         */
        TOO_MANY_LINKS,
        /**
         * No space left on drive.
         */
        NO_SPACE,
        /**
         * Invalid argument.
         */
        INVALID_ARGUMENT,
        /**
         * Permission denied.
         */
        PERMISSION_DENIED,
        /**
         * Operation (or one of its parameters) not supported
         */
        NOT_SUPPORTED,
        /**
         * File isn't mounted.
         */
        NOT_MOUNTED,
        /**
         * File is already mounted.
         */
        ALREADY_MOUNTED,
        /**
         * File was closed.
         */
        CLOSED,
        /**
         * Operation was cancelled. See #GCancellable.
         */
        CANCELLED,
        /**
         * Operations are still pending.
         */
        PENDING,
        /**
         * File is read only.
         */
        READ_ONLY,
        /**
         * Backup couldn't be created.
         */
        CANT_CREATE_BACKUP,
        /**
         * File's Entity Tag was incorrect.
         */
        WRONG_ETAG,
        /**
         * Operation timed out.
         */
        TIMED_OUT,
        /**
         * Operation would be recursive.
         */
        WOULD_RECURSE,
        /**
         * File is busy.
         */
        BUSY,
        /**
         * Operation would block.
         */
        WOULD_BLOCK,
        /**
         * Host couldn't be found (remote operations).
         */
        HOST_NOT_FOUND,
        /**
         * Operation would merge files.
         */
        WOULD_MERGE,
        /**
         * Operation failed and a helper program has
         *     already interacted with the user. Do not display any error dialog.
         */
        FAILED_HANDLED,
        /**
         * The current process has too many files
         *     open and can't open any more. Duplicate descriptors do count toward
         *     this limit. Since 2.20
         */
        TOO_MANY_OPEN_FILES,
        /**
         * The object has not been initialized. Since 2.22
         */
        NOT_INITIALIZED,
        /**
         * The requested address is already in use. Since 2.22
         */
        ADDRESS_IN_USE,
        /**
         * Need more input to finish operation. Since 2.24
         */
        PARTIAL_INPUT,
        /**
         * The input data was invalid. Since 2.24
         */
        INVALID_DATA,
        /**
         * A remote object generated an error that
         *     doesn't correspond to a locally registered #GError error
         *     domain. Use g_dbus_error_get_remote_error() to extract the D-Bus
         *     error name and g_dbus_error_strip_remote_error() to fix up the
         *     message so it matches what was received on the wire. Since 2.26.
         */
        DBUS_ERROR,
        /**
         * Host unreachable. Since 2.26
         */
        HOST_UNREACHABLE,
        /**
         * Network unreachable. Since 2.26
         */
        NETWORK_UNREACHABLE,
        /**
         * Connection refused. Since 2.26
         */
        CONNECTION_REFUSED,
        /**
         * Connection to proxy server failed. Since 2.26
         */
        PROXY_FAILED,
        /**
         * Proxy authentication failed. Since 2.26
         */
        PROXY_AUTH_FAILED,
        /**
         * Proxy server needs authentication. Since 2.26
         */
        PROXY_NEED_AUTH,
        /**
         * Proxy connection is not allowed by ruleset.
         *     Since 2.26
         */
        PROXY_NOT_ALLOWED,
        /**
         * Broken pipe. Since 2.36
         */
        BROKEN_PIPE,
        /**
         * Connection closed by peer. Note that this
         *     is the same code as %G_IO_ERROR_BROKEN_PIPE; before 2.44 some
         *     "connection closed" errors returned %G_IO_ERROR_BROKEN_PIPE, but others
         *     returned %G_IO_ERROR_FAILED. Now they should all return the same
         *     value, which has this more logical name. Since 2.44.
         */
        CONNECTION_CLOSED,
        /**
         * Transport endpoint is not connected. Since 2.44
         */
        NOT_CONNECTED,
        /**
         * Message too large. Since 2.48.
         */
        MESSAGE_TOO_LARGE,
        /**
         * No such device found. Since 2.74
         */
        NO_SUCH_DEVICE,
    }
    /**
     * Flags for use with g_io_module_scope_new().
     */
    enum IOModuleScopeFlags {
        /**
         * No module scan flags
         */
        NONE,
        /**
         * When using this scope to load or
         *     scan modules, automatically block a modules which has the same base
         *     basename as previously loaded module.
         */
        BLOCK_DUPLICATES,
    }
    /**
     * Memory availability warning levels.
     *
     * Note that because new values might be added, it is recommended that applications check
     * #GMemoryMonitorWarningLevel as ranges, for example:
     *
     * ```c
     * if (warning_level > G_MEMORY_MONITOR_WARNING_LEVEL_LOW)
     *   drop_caches ();
     * ```
     *
     */
    enum MemoryMonitorWarningLevel {
        /**
         * Memory on the device is low, processes
         *   should free up unneeded resources (for example, in-memory caches) so they can
         *   be used elsewhere.
         */
        LOW,
        /**
         * Same as `G_MEMORY_MONITOR_WARNING_LEVEL_LOW`
         *   but the device has even less free memory, so processes should try harder to free
         *   up unneeded resources. If your process does not need to stay running, it is a
         *   good time for it to quit.
         */
        MEDIUM,
        /**
         * The system will soon start terminating
         *   processes to reclaim memory, including background processes.
         */
        CRITICAL,
    }
    /**
     * #GMountOperationResult is returned as a result when a request for
     * information is send by the mounting operation.
     */
    enum MountOperationResult {
        /**
         * The request was fulfilled and the
         *     user specified data is now available
         */
        HANDLED,
        /**
         * The user requested the mount operation
         *     to be aborted
         */
        ABORTED,
        /**
         * The request was unhandled (i.e. not
         *     implemented)
         */
        UNHANDLED,
    }
    /**
     * The host's network connectivity state, as reported by #GNetworkMonitor.
     */
    enum NetworkConnectivity {
        /**
         * The host is not configured with a
         *   route to the Internet; it may or may not be connected to a local
         *   network.
         */
        LOCAL,
        /**
         * The host is connected to a network, but
         *   does not appear to be able to reach the full Internet, perhaps
         *   due to upstream network problems.
         */
        LIMITED,
        /**
         * The host is behind a captive portal and
         *   cannot reach the full Internet.
         */
        PORTAL,
        /**
         * The host is connected to a network, and
         *   appears to be able to reach the full Internet.
         */
        FULL,
    }
    /**
     * Priority levels for #GNotifications.
     */
    enum NotificationPriority {
        /**
         * the default priority, to be used for the
         *   majority of notifications (for example email messages, software updates,
         *   completed download/sync operations)
         */
        NORMAL,
        /**
         * for notifications that do not require
         *   immediate attention - typically used for contextual background
         *   information, such as contact birthdays or local weather
         */
        LOW,
        /**
         * for events that require more attention,
         *   usually because responses are time-sensitive (for example chat and SMS
         *   messages or alarms)
         */
        HIGH,
        /**
         * for urgent notifications, or notifications
         *   that require a response in a short space of time (for example phone calls
         *   or emergency warnings)
         */
        URGENT,
    }
    /**
     * #GPasswordSave is used to indicate the lifespan of a saved password.
     *
     * #Gvfs stores passwords in the Gnome keyring when this flag allows it
     * to, and later retrieves it again from there.
     */
    enum PasswordSave {
        /**
         * never save a password.
         */
        NEVER,
        /**
         * save a password for the session.
         */
        FOR_SESSION,
        /**
         * save a password permanently.
         */
        PERMANENTLY,
    }
    /**
     * Return value for various IO operations that signal errors via the
     * return value and not necessarily via a #GError.
     *
     * This enum exists to be able to return errors to callers without having to
     * allocate a #GError. Allocating #GErrors can be quite expensive for
     * regularly happening errors like %G_IO_ERROR_WOULD_BLOCK.
     *
     * In case of %G_POLLABLE_RETURN_FAILED a #GError should be set for the
     * operation to give details about the error that happened.
     */
    enum PollableReturn {
        /**
         * Generic error condition for when an operation fails.
         */
        FAILED,
        /**
         * The operation was successfully finished.
         */
        OK,
        /**
         * The operation would block.
         */
        WOULD_BLOCK,
    }
    /**
     * An error code used with %G_RESOLVER_ERROR in a #GError returned
     * from a #GResolver routine.
     */
    enum ResolverError {
        /**
         * the requested name/address/service was not
         *     found
         */
        NOT_FOUND,
        /**
         * the requested information could not
         *     be looked up due to a network error or similar problem
         */
        TEMPORARY_FAILURE,
        /**
         * unknown error
         */
        INTERNAL,
    }
    /**
     * The type of record that g_resolver_lookup_records() or
     * g_resolver_lookup_records_async() should retrieve. The records are returned
     * as lists of #GVariant tuples. Each record type has different values in
     * the variant tuples returned.
     *
     * %G_RESOLVER_RECORD_SRV records are returned as variants with the signature
     * `(qqqs)`, containing a `guint16` with the priority, a `guint16` with the
     * weight, a `guint16` with the port, and a string of the hostname.
     *
     * %G_RESOLVER_RECORD_MX records are returned as variants with the signature
     * `(qs)`, representing a `guint16` with the preference, and a string containing
     * the mail exchanger hostname.
     *
     * %G_RESOLVER_RECORD_TXT records are returned as variants with the signature
     * `(as)`, representing an array of the strings in the text record. Note: Most TXT
     * records only contain a single string, but
     * [RFC 1035](https://tools.ietf.org/html/rfc1035#section-3.3.14) does allow a
     * record to contain multiple strings. The RFC which defines the interpretation
     * of a specific TXT record will likely require concatenation of multiple
     * strings if they are present, as with
     * [RFC 7208](https://tools.ietf.org/html/rfc7208#section-3.3).
     *
     * %G_RESOLVER_RECORD_SOA records are returned as variants with the signature
     * `(ssuuuuu)`, representing a string containing the primary name server, a
     * string containing the administrator, the serial as a `guint32`, the refresh
     * interval as a `guint32`, the retry interval as a `guint32`, the expire timeout
     * as a `guint32`, and the TTL as a `guint32`.
     *
     * %G_RESOLVER_RECORD_NS records are returned as variants with the signature
     * `(s)`, representing a string of the hostname of the name server.
     */
    enum ResolverRecordType {
        /**
         * look up DNS SRV records for a domain
         */
        SRV,
        /**
         * look up DNS MX records for a domain
         */
        MX,
        /**
         * look up DNS TXT records for a name
         */
        TXT,
        /**
         * look up DNS SOA records for a zone
         */
        SOA,
        /**
         * look up DNS NS records for a domain
         */
        NS,
    }
    /**
     * An error code used with %G_RESOURCE_ERROR in a #GError returned
     * from a #GResource routine.
     */
    enum ResourceError {
        /**
         * no file was found at the requested path
         */
        NOT_FOUND,
        /**
         * unknown error
         */
        INTERNAL,
    }
    /**
     * Describes an event occurring on a #GSocketClient. See the
     * #GSocketClient::event signal for more details.
     *
     * Additional values may be added to this type in the future.
     */
    enum SocketClientEvent {
        /**
         * The client is doing a DNS lookup.
         */
        RESOLVING,
        /**
         * The client has completed a DNS lookup.
         */
        RESOLVED,
        /**
         * The client is connecting to a remote
         *   host (either a proxy or the destination server).
         */
        CONNECTING,
        /**
         * The client has connected to a remote
         *   host.
         */
        CONNECTED,
        /**
         * The client is negotiating
         *   with a proxy to connect to the destination server.
         */
        PROXY_NEGOTIATING,
        /**
         * The client has negotiated
         *   with the proxy server.
         */
        PROXY_NEGOTIATED,
        /**
         * The client is performing a
         *   TLS handshake.
         */
        TLS_HANDSHAKING,
        /**
         * The client has performed a
         *   TLS handshake.
         */
        TLS_HANDSHAKED,
        /**
         * The client is done with a particular
         *   #GSocketConnectable.
         */
        COMPLETE,
    }
    /**
     * The protocol family of a #GSocketAddress. (These values are
     * identical to the system defines %AF_INET, %AF_INET6 and %AF_UNIX,
     * if available.)
     */
    enum SocketFamily {
        /**
         * no address family
         */
        INVALID,
        /**
         * the UNIX domain family
         */
        UNIX,
        /**
         * the IPv4 family
         */
        IPV4,
        /**
         * the IPv6 family
         */
        IPV6,
    }
    /**
     * Describes an event occurring on a #GSocketListener. See the
     * #GSocketListener::event signal for more details.
     *
     * Additional values may be added to this type in the future.
     */
    enum SocketListenerEvent {
        /**
         * The listener is about to bind a socket.
         */
        BINDING,
        /**
         * The listener has bound a socket.
         */
        BOUND,
        /**
         * The listener is about to start
         *    listening on this socket.
         */
        LISTENING,
        /**
         * The listener is now listening on
         *   this socket.
         */
        LISTENED,
    }
    /**
     * A protocol identifier is specified when creating a #GSocket, which is a
     * family/type specific identifier, where 0 means the default protocol for
     * the particular family/type.
     *
     * This enum contains a set of commonly available and used protocols. You
     * can also pass any other identifiers handled by the platform in order to
     * use protocols not listed here.
     */
    enum SocketProtocol {
        /**
         * The protocol type is unknown
         */
        UNKNOWN,
        /**
         * The default protocol for the family/type
         */
        DEFAULT,
        /**
         * TCP over IP
         */
        TCP,
        /**
         * UDP over IP
         */
        UDP,
        /**
         * SCTP over IP
         */
        SCTP,
    }
    /**
     * Flags used when creating a #GSocket. Some protocols may not implement
     * all the socket types.
     */
    enum SocketType {
        /**
         * Type unknown or wrong
         */
        INVALID,
        /**
         * Reliable connection-based byte streams (e.g. TCP).
         */
        STREAM,
        /**
         * Connectionless, unreliable datagram passing.
         *     (e.g. UDP)
         */
        DATAGRAM,
        /**
         * Reliable connection-based passing of datagrams
         *     of fixed maximum length (e.g. SCTP).
         */
        SEQPACKET,
    }
    /**
     * The client authentication mode for a #GTlsServerConnection.
     */
    enum TlsAuthenticationMode {
        /**
         * client authentication not required
         */
        NONE,
        /**
         * client authentication is requested
         */
        REQUESTED,
        /**
         * client authentication is required
         */
        REQUIRED,
    }
    /**
     * Flags for g_tls_interaction_request_certificate(),
     * g_tls_interaction_request_certificate_async(), and
     * g_tls_interaction_invoke_request_certificate().
     */
    enum TlsCertificateRequestFlags {
        /**
         * No flags
         */
        NONE,
    }
    /**
     * An error code used with %G_TLS_CHANNEL_BINDING_ERROR in a #GError to
     * indicate a TLS channel binding retrieval error.
     */
    enum TlsChannelBindingError {
        /**
         * Either entire binding
         *    retrieval facility or specific binding type is not implemented in the
         *    TLS backend.
         */
        NOT_IMPLEMENTED,
        /**
         * The handshake is not yet
         *    complete on the connection which is a strong requirement for any existing
         *    binding type.
         */
        INVALID_STATE,
        /**
         * Handshake is complete but
         *    binding data is not available. That normally indicates the TLS
         *    implementation failed to provide the binding data. For example, some
         *    implementations do not provide a peer certificate for resumed connections.
         */
        NOT_AVAILABLE,
        /**
         * Binding type is not supported
         *    on the current connection. This error could be triggered when requesting
         *    `tls-server-end-point` binding data for a certificate which has no hash
         *    function or uses multiple hash functions.
         */
        NOT_SUPPORTED,
        /**
         * Any other backend error
         *    preventing binding data retrieval.
         */
        GENERAL_ERROR,
    }
    /**
     * The type of TLS channel binding data to retrieve from #GTlsConnection
     * or #GDtlsConnection, as documented by RFC 5929 or RFC 9266. The
     * [`tls-unique-for-telnet`](https://tools.ietf.org/html/rfc5929#section-5)
     * binding type is not currently implemented.
     */
    enum TlsChannelBindingType {
        /**
         * [`tls-unique`](https://tools.ietf.org/html/rfc5929#section-3) binding
         *    type
         */
        UNIQUE,
        /**
         * [`tls-server-end-point`](https://tools.ietf.org/html/rfc5929#section-4)
         *    binding type
         */
        SERVER_END_POINT,
        /**
         * [`tls-exporter`](https://www.rfc-editor.org/rfc/rfc9266.html) binding
         *    type. Since: 2.74
         */
        EXPORTER,
    }
    /**
     * Flags for g_tls_database_lookup_certificate_for_handle(),
     * g_tls_database_lookup_certificate_issuer(),
     * and g_tls_database_lookup_certificates_issued_by().
     */
    enum TlsDatabaseLookupFlags {
        /**
         * No lookup flags
         */
        NONE,
        /**
         * Restrict lookup to certificates that have
         *     a private key.
         */
        KEYPAIR,
    }
    /**
     * An error code used with %G_TLS_ERROR in a #GError returned from a
     * TLS-related routine.
     */
    enum TlsError {
        /**
         * No TLS provider is available
         */
        UNAVAILABLE,
        /**
         * Miscellaneous TLS error
         */
        MISC,
        /**
         * The certificate presented could not
         *   be parsed or failed validation.
         */
        BAD_CERTIFICATE,
        /**
         * The TLS handshake failed because the
         *   peer does not seem to be a TLS server.
         */
        NOT_TLS,
        /**
         * The TLS handshake failed because the
         *   peer's certificate was not acceptable.
         */
        HANDSHAKE,
        /**
         * The TLS handshake failed because
         *   the server requested a client-side certificate, but none was
         *   provided. See g_tls_connection_set_certificate().
         */
        CERTIFICATE_REQUIRED,
        /**
         * The TLS connection was closed without proper
         *   notice, which may indicate an attack. See
         *   g_tls_connection_set_require_close_notify().
         */
        EOF,
        /**
         * The TLS handshake failed
         *   because the client sent the fallback SCSV, indicating a protocol
         *   downgrade attack. Since: 2.60
         */
        INAPPROPRIATE_FALLBACK,
        /**
         * The certificate failed
         *   to load because a password was incorrect. Since: 2.72
         */
        BAD_CERTIFICATE_PASSWORD,
    }
    /**
     * #GTlsInteractionResult is returned by various functions in #GTlsInteraction
     * when finishing an interaction request.
     */
    enum TlsInteractionResult {
        /**
         * The interaction was unhandled (i.e. not
         *     implemented).
         */
        UNHANDLED,
        /**
         * The interaction completed, and resulting data
         *     is available.
         */
        HANDLED,
        /**
         * The interaction has failed, or was cancelled.
         *     and the operation should be aborted.
         */
        FAILED,
    }
    /**
     * The TLS or DTLS protocol version used by a #GTlsConnection or
     * #GDtlsConnection. The integer values of these versions are sequential
     * to ensure newer known protocol versions compare greater than older
     * known versions. Any known DTLS protocol version will compare greater
     * than any SSL or TLS protocol version. The protocol version may be
     * %G_TLS_PROTOCOL_VERSION_UNKNOWN if the TLS backend supports a newer
     * protocol version that GLib does not yet know about. This means that
     * it's possible for an unknown DTLS protocol version to compare less
     * than the TLS protocol versions.
     */
    enum TlsProtocolVersion {
        /**
         * No protocol version or unknown protocol version
         */
        UNKNOWN,
        /**
         * SSL 3.0, which is insecure and should not be used
         */
        SSL_3_0,
        /**
         * TLS 1.0, which is insecure and should not be used
         */
        TLS_1_0,
        /**
         * TLS 1.1, which is insecure and should not be used
         */
        TLS_1_1,
        /**
         * TLS 1.2, defined by [RFC 5246](https://datatracker.ietf.org/doc/html/rfc5246)
         */
        TLS_1_2,
        /**
         * TLS 1.3, defined by [RFC 8446](https://datatracker.ietf.org/doc/html/rfc8446)
         */
        TLS_1_3,
        /**
         * DTLS 1.0, which is insecure and should not be used
         */
        DTLS_1_0,
        /**
         * DTLS 1.2, defined by [RFC 6347](https://datatracker.ietf.org/doc/html/rfc6347)
         */
        DTLS_1_2,
    }
    /**
     * When to allow rehandshaking. See
     * g_tls_connection_set_rehandshake_mode().
     */
    enum TlsRehandshakeMode {
        /**
         * Never allow rehandshaking
         */
        NEVER,
        /**
         * Allow safe rehandshaking only
         */
        SAFELY,
        /**
         * Allow unsafe rehandshaking
         */
        UNSAFELY,
    }
    /**
     * The type of name used by a #GUnixSocketAddress.
     * %G_UNIX_SOCKET_ADDRESS_PATH indicates a traditional unix domain
     * socket bound to a filesystem path. %G_UNIX_SOCKET_ADDRESS_ANONYMOUS
     * indicates a socket not bound to any name (eg, a client-side socket,
     * or a socket created with socketpair()).
     *
     * For abstract sockets, there are two incompatible ways of naming
     * them; the man pages suggest using the entire `struct sockaddr_un`
     * as the name, padding the unused parts of the %sun_path field with
     * zeroes; this corresponds to %G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED.
     * However, many programs instead just use a portion of %sun_path, and
     * pass an appropriate smaller length to bind() or connect(). This is
     * %G_UNIX_SOCKET_ADDRESS_ABSTRACT.
     */
    enum UnixSocketAddressType {
        /**
         * invalid
         */
        INVALID,
        /**
         * anonymous
         */
        ANONYMOUS,
        /**
         * a filesystem path
         */
        PATH,
        /**
         * an abstract name
         */
        ABSTRACT,
        /**
         * an abstract name, 0-padded
         *   to the full length of a unix socket name
         */
        ABSTRACT_PADDED,
    }
    /**
     * Used to select the type of data format to use for #GZlibDecompressor
     * and #GZlibCompressor.
     */
    enum ZlibCompressorFormat {
        /**
         * deflate compression with zlib header
         */
        ZLIB,
        /**
         * gzip file format
         */
        GZIP,
        /**
         * deflate compression with no header
         */
        RAW,
    }
    /**
     * Flags used when creating a #GAppInfo.
     * @bitfield
     */
    enum AppInfoCreateFlags {
        /**
         * No flags.
         */
        NONE,
        /**
         * Application opens in a terminal window.
         */
        NEEDS_TERMINAL,
        /**
         * Application supports URI arguments.
         */
        SUPPORTS_URIS,
        /**
         * Application supports startup notification. Since 2.26
         */
        SUPPORTS_STARTUP_NOTIFICATION,
    }
    /**
     * Flags used to define the behaviour of a #GApplication.
     * @bitfield
     */
    enum ApplicationFlags {
        /**
         * Default. Deprecated in 2.74, use
         *   %G_APPLICATION_DEFAULT_FLAGS instead
         */
        FLAGS_NONE,
        /**
         * Default flags. Since: 2.74
         */
        DEFAULT_FLAGS,
        /**
         * Run as a service. In this mode, registration
         *      fails if the service is already running, and the application
         *      will initially wait up to 10 seconds for an initial activation
         *      message to arrive.
         */
        IS_SERVICE,
        /**
         * Don't try to become the primary instance.
         */
        IS_LAUNCHER,
        /**
         * This application handles opening files (in
         *     the primary instance). Note that this flag only affects the default
         *     implementation of local_command_line(), and has no effect if
         *     %G_APPLICATION_HANDLES_COMMAND_LINE is given.
         *     See g_application_run() for details.
         */
        HANDLES_OPEN,
        /**
         * This application handles command line
         *     arguments (in the primary instance). Note that this flag only affect
         *     the default implementation of local_command_line().
         *     See g_application_run() for details.
         */
        HANDLES_COMMAND_LINE,
        /**
         * Send the environment of the
         *     launching process to the primary instance. Set this flag if your
         *     application is expected to behave differently depending on certain
         *     environment variables. For instance, an editor might be expected
         *     to use the `GIT_COMMITTER_NAME` environment variable
         *     when editing a git commit message. The environment is available
         *     to the #GApplication::command-line signal handler, via
         *     g_application_command_line_getenv().
         */
        SEND_ENVIRONMENT,
        /**
         * Make no attempts to do any of the typical
         *     single-instance application negotiation, even if the application
         *     ID is given.  The application neither attempts to become the
         *     owner of the application ID nor does it check if an existing
         *     owner already exists.  Everything occurs in the local process.
         *     Since: 2.30.
         */
        NON_UNIQUE,
        /**
         * Allow users to override the
         *     application ID from the command line with `--gapplication-app-id`.
         *     Since: 2.48
         */
        CAN_OVERRIDE_APP_ID,
        /**
         * Allow another instance to take over
         *     the bus name. Since: 2.60
         */
        ALLOW_REPLACEMENT,
        /**
         * Take over from another instance. This flag is
         *     usually set by passing `--gapplication-replace` on the commandline.
         *     Since: 2.60
         */
        REPLACE,
    }
    /**
     * #GAskPasswordFlags are used to request specific information from the
     * user, or to notify the user of their choices in an authentication
     * situation.
     * @bitfield
     */
    enum AskPasswordFlags {
        /**
         * operation requires a password.
         */
        NEED_PASSWORD,
        /**
         * operation requires a username.
         */
        NEED_USERNAME,
        /**
         * operation requires a domain.
         */
        NEED_DOMAIN,
        /**
         * operation supports saving settings.
         */
        SAVING_SUPPORTED,
        /**
         * operation supports anonymous users.
         */
        ANONYMOUS_SUPPORTED,
        /**
         * operation takes TCRYPT parameters (Since: 2.58)
         */
        TCRYPT,
    }
    /**
     * Flags used in g_bus_own_name().
     * @bitfield
     */
    enum BusNameOwnerFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * Allow another message bus connection to claim the name.
         */
        ALLOW_REPLACEMENT,
        /**
         * If another message bus connection owns the name and have
         * specified %G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT, then take the name from the other connection.
         */
        REPLACE,
        /**
         * If another message bus connection owns the name, immediately
         * return an error from g_bus_own_name() rather than entering the waiting queue for that name. (Since 2.54)
         */
        DO_NOT_QUEUE,
    }
    /**
     * Flags used in g_bus_watch_name().
     * @bitfield
     */
    enum BusNameWatcherFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * If no-one owns the name when
         * beginning to watch the name, ask the bus to launch an owner for the
         * name.
         */
        AUTO_START,
    }
    /**
     * Flags used when calling a g_converter_convert().
     * @bitfield
     */
    enum ConverterFlags {
        /**
         * No flags.
         */
        NONE,
        /**
         * At end of input data
         */
        INPUT_AT_END,
        /**
         * Flush data
         */
        FLUSH,
    }
    /**
     * Flags used in g_dbus_connection_call() and similar APIs.
     * @bitfield
     */
    enum DBusCallFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * The bus must not launch
         * an owner for the destination name in response to this method
         * invocation.
         */
        NO_AUTO_START,
        /**
         * the caller is prepared to
         * wait for interactive authorization. Since 2.46.
         */
        ALLOW_INTERACTIVE_AUTHORIZATION,
    }
    /**
     * Capabilities negotiated with the remote peer.
     * @bitfield
     */
    enum DBusCapabilityFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * The connection
         * supports exchanging UNIX file descriptors with the remote peer.
         */
        UNIX_FD_PASSING,
    }
    /**
     * Flags used when creating a new #GDBusConnection.
     * @bitfield
     */
    enum DBusConnectionFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * Perform authentication against server.
         */
        AUTHENTICATION_CLIENT,
        /**
         * Perform authentication against client.
         */
        AUTHENTICATION_SERVER,
        /**
         * When
         * authenticating as a server, allow the anonymous authentication
         * method.
         */
        AUTHENTICATION_ALLOW_ANONYMOUS,
        /**
         * Pass this flag if connecting to a peer that is a
         * message bus. This means that the Hello() method will be invoked as part of the connection setup.
         */
        MESSAGE_BUS_CONNECTION,
        /**
         * If set, processing of D-Bus messages is
         * delayed until g_dbus_connection_start_message_processing() is called.
         */
        DELAY_MESSAGE_PROCESSING,
        /**
         * When authenticating
         * as a server, require the UID of the peer to be the same as the UID of the server. (Since: 2.68)
         */
        AUTHENTICATION_REQUIRE_SAME_USER,
        /**
         * When authenticating, try to use
         *  protocols that work across a Linux user namespace boundary, even if this
         *  reduces interoperability with older D-Bus implementations. This currently
         *  affects client-side `EXTERNAL` authentication, for which this flag makes
         *  connections to a server in another user namespace succeed, but causes
         *  a deadlock when connecting to a GDBus server older than 2.73.3. Since: 2.74
         */
        CROSS_NAMESPACE,
    }
    /**
     * Flags describing the behavior of a #GDBusInterfaceSkeleton instance.
     * @bitfield
     */
    enum DBusInterfaceSkeletonFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * Each method invocation is handled in
         *   a thread dedicated to the invocation. This means that the method implementation can use blocking IO
         *   without blocking any other part of the process. It also means that the method implementation must
         *   use locking to access data structures used by other threads.
         */
        HANDLE_METHOD_INVOCATIONS_IN_THREAD,
    }
    /**
     * Message flags used in #GDBusMessage.
     * @bitfield
     */
    enum DBusMessageFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * A reply is not expected.
         */
        NO_REPLY_EXPECTED,
        /**
         * The bus must not launch an
         * owner for the destination name in response to this message.
         */
        NO_AUTO_START,
        /**
         * If set on a method
         * call, this flag means that the caller is prepared to wait for interactive
         * authorization. Since 2.46.
         */
        ALLOW_INTERACTIVE_AUTHORIZATION,
    }
    /**
     * Flags used when constructing a #GDBusObjectManagerClient.
     * @bitfield
     */
    enum DBusObjectManagerClientFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * If not set and the
         *   manager is for a well-known name, then request the bus to launch
         *   an owner for the name if no-one owns the name. This flag can only
         *   be used in managers for well-known names.
         */
        DO_NOT_AUTO_START,
    }
    /**
     * Flags describing the access control of a D-Bus property.
     * @bitfield
     */
    enum DBusPropertyInfoFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * Property is readable.
         */
        READABLE,
        /**
         * Property is writable.
         */
        WRITABLE,
    }
    /**
     * Flags used when constructing an instance of a #GDBusProxy derived class.
     * @bitfield
     */
    enum DBusProxyFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * Don't load properties.
         */
        DO_NOT_LOAD_PROPERTIES,
        /**
         * Don't connect to signals on the remote object.
         */
        DO_NOT_CONNECT_SIGNALS,
        /**
         * If the proxy is for a well-known name,
         * do not ask the bus to launch an owner during proxy initialization or a method call.
         * This flag is only meaningful in proxies for well-known names.
         */
        DO_NOT_AUTO_START,
        /**
         * If set, the property value for any __invalidated property__ will be (asynchronously) retrieved upon receiving the [`PropertiesChanged`](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties) D-Bus signal and the property will not cause emission of the #GDBusProxy::g-properties-changed signal. When the value is received the #GDBusProxy::g-properties-changed signal is emitted for the property along with the retrieved value. Since 2.32.
         */
        GET_INVALIDATED_PROPERTIES,
        /**
         * If the proxy is for a well-known name,
         * do not ask the bus to launch an owner during proxy initialization, but allow it to be
         * autostarted by a method call. This flag is only meaningful in proxies for well-known names,
         * and only if %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START is not also specified.
         */
        DO_NOT_AUTO_START_AT_CONSTRUCTION,
        /**
         * Don't actually send the AddMatch D-Bus
         *    call for this signal subscription. This gives you more control
         *    over which match rules you add (but you must add them manually). (Since: 2.72)
         */
        NO_MATCH_RULE,
    }
    /**
     * Flags used when sending #GDBusMessages on a #GDBusConnection.
     * @bitfield
     */
    enum DBusSendMessageFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * Do not automatically
         * assign a serial number from the #GDBusConnection object when
         * sending a message.
         */
        PRESERVE_SERIAL,
    }
    /**
     * Flags used when creating a #GDBusServer.
     * @bitfield
     */
    enum DBusServerFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * All #GDBusServer::new-connection
         * signals will run in separated dedicated threads (see signal for
         * details).
         */
        RUN_IN_THREAD,
        /**
         * Allow the anonymous
         * authentication method.
         */
        AUTHENTICATION_ALLOW_ANONYMOUS,
        /**
         * Require the UID of the
         * peer to be the same as the UID of the server when authenticating. (Since: 2.68)
         */
        AUTHENTICATION_REQUIRE_SAME_USER,
    }
    /**
     * Flags used when subscribing to signals via g_dbus_connection_signal_subscribe().
     * @bitfield
     */
    enum DBusSignalFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * Don't actually send the AddMatch
         * D-Bus call for this signal subscription.  This gives you more control
         * over which match rules you add (but you must add them manually).
         */
        NO_MATCH_RULE,
        /**
         * Match first arguments that
         * contain a bus or interface name with the given namespace.
         */
        MATCH_ARG0_NAMESPACE,
        /**
         * Match first arguments that
         * contain an object path that is either equivalent to the given path,
         * or one of the paths is a subpath of the other.
         */
        MATCH_ARG0_PATH,
    }
    /**
     * Flags passed to g_dbus_connection_register_subtree().
     * @bitfield
     */
    enum DBusSubtreeFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * Method calls to objects not in the enumerated range
         *                                                       will still be dispatched. This is useful if you want
         *                                                       to dynamically spawn objects in the subtree.
         */
        DISPATCH_TO_UNENUMERATED_NODES,
    }
    /**
     * Flags used when starting a drive.
     * @bitfield
     */
    enum DriveStartFlags {
        /**
         * No flags set.
         */
        NONE,
    }
    /**
     * Flags specifying the behaviour of an attribute.
     * @bitfield
     */
    enum FileAttributeInfoFlags {
        /**
         * no flags set.
         */
        NONE,
        /**
         * copy the attribute values when the file is copied.
         */
        COPY_WITH_FILE,
        /**
         * copy the attribute values when the file is moved.
         */
        COPY_WHEN_MOVED,
    }
    /**
     * Flags used when copying or moving files.
     * @bitfield
     */
    enum FileCopyFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * Overwrite any existing files
         */
        OVERWRITE,
        /**
         * Make a backup of any existing files.
         */
        BACKUP,
        /**
         * Don't follow symlinks.
         */
        NOFOLLOW_SYMLINKS,
        /**
         * Copy all file metadata instead of just default set used for copy (see #GFileInfo).
         */
        ALL_METADATA,
        /**
         * Don't use copy and delete fallback if native move not supported.
         */
        NO_FALLBACK_FOR_MOVE,
        /**
         * Leaves target file with default perms, instead of setting the source file perms.
         */
        TARGET_DEFAULT_PERMS,
    }
    /**
     * Flags used when an operation may create a file.
     * @bitfield
     */
    enum FileCreateFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * Create a file that can only be
         *    accessed by the current user.
         */
        PRIVATE,
        /**
         * Replace the destination
         *    as if it didn't exist before. Don't try to keep any old
         *    permissions, replace instead of following links. This
         *    is generally useful if you're doing a "copy over"
         *    rather than a "save new version of" replace operation.
         *    You can think of it as "unlink destination" before
         *    writing to it, although the implementation may not
         *    be exactly like that. This flag can only be used with
         *    g_file_replace() and its variants, including g_file_replace_contents().
         *    Since 2.20
         */
        REPLACE_DESTINATION,
    }
    /**
     * Flags that can be used with g_file_measure_disk_usage().
     * @bitfield
     */
    enum FileMeasureFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * Report any error encountered
         *   while traversing the directory tree.  Normally errors are only
         *   reported for the toplevel file.
         */
        REPORT_ANY_ERROR,
        /**
         * Tally usage based on apparent file
         *   sizes.  Normally, the block-size is used, if available, as this is a
         *   more accurate representation of disk space used.
         *   Compare with `du --apparent-size`.
         *   Since GLib 2.78. and similarly to `du` since GNU Coreutils 9.2, this will
         *   ignore the sizes of file types other than regular files and links, as the
         *   sizes of other file types are not specified in a standard way.
         */
        APPARENT_SIZE,
        /**
         * Do not cross mount point boundaries.
         *   Compare with `du -x`.
         */
        NO_XDEV,
    }
    /**
     * Flags used to set what a #GFileMonitor will watch for.
     * @bitfield
     */
    enum FileMonitorFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * Watch for mount events.
         */
        WATCH_MOUNTS,
        /**
         * Pair DELETED and CREATED events caused
         *   by file renames (moves) and send a single G_FILE_MONITOR_EVENT_MOVED
         *   event instead (NB: not supported on all backends; the default
         *   behaviour -without specifying this flag- is to send single DELETED
         *   and CREATED events).  Deprecated since 2.46: use
         *   %G_FILE_MONITOR_WATCH_MOVES instead.
         */
        SEND_MOVED,
        /**
         * Watch for changes to the file made
         *   via another hard link. Since 2.36.
         */
        WATCH_HARD_LINKS,
        /**
         * Watch for rename operations on a
         *   monitored directory.  This causes %G_FILE_MONITOR_EVENT_RENAMED,
         *   %G_FILE_MONITOR_EVENT_MOVED_IN and %G_FILE_MONITOR_EVENT_MOVED_OUT
         *   events to be emitted when possible.  Since: 2.46.
         */
        WATCH_MOVES,
    }
    /**
     * Flags used when querying a #GFileInfo.
     * @bitfield
     */
    enum FileQueryInfoFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * Don't follow symlinks.
         */
        NOFOLLOW_SYMLINKS,
    }
    /**
     * GIOStreamSpliceFlags determine how streams should be spliced.
     * @bitfield
     */
    enum IOStreamSpliceFlags {
        /**
         * Do not close either stream.
         */
        NONE,
        /**
         * Close the first stream after
         *     the splice.
         */
        CLOSE_STREAM1,
        /**
         * Close the second stream after
         *     the splice.
         */
        CLOSE_STREAM2,
        /**
         * Wait for both splice operations to finish
         *     before calling the callback.
         */
        WAIT_FOR_BOTH,
    }
    /**
     * Flags used when mounting a mount.
     * @bitfield
     */
    enum MountMountFlags {
        /**
         * No flags set.
         */
        NONE,
    }
    /**
     * Flags used when an unmounting a mount.
     * @bitfield
     */
    enum MountUnmountFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * Unmount even if there are outstanding
         *  file operations on the mount.
         */
        FORCE,
    }
    /**
     * GOutputStreamSpliceFlags determine how streams should be spliced.
     * @bitfield
     */
    enum OutputStreamSpliceFlags {
        /**
         * Do not close either stream.
         */
        NONE,
        /**
         * Close the source stream after
         *     the splice.
         */
        CLOSE_SOURCE,
        /**
         * Close the target stream after
         *     the splice.
         */
        CLOSE_TARGET,
    }
    /**
     * Flags to modify lookup behavior.
     * @bitfield
     */
    enum ResolverNameLookupFlags {
        /**
         * default behavior (same as g_resolver_lookup_by_name())
         */
        DEFAULT,
        /**
         * only resolve ipv4 addresses
         */
        IPV4_ONLY,
        /**
         * only resolve ipv6 addresses
         */
        IPV6_ONLY,
    }
    /**
     * GResourceFlags give information about a particular file inside a resource
     * bundle.
     * @bitfield
     */
    enum ResourceFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * The file is compressed.
         */
        COMPRESSED,
    }
    /**
     * GResourceLookupFlags determine how resource path lookups are handled.
     * @bitfield
     */
    enum ResourceLookupFlags {
        /**
         * No flags set.
         */
        NONE,
    }
    /**
     * Flags used when creating a binding. These flags determine in which
     * direction the binding works. The default is to synchronize in both
     * directions.
     * @bitfield
     */
    enum SettingsBindFlags {
        /**
         * Equivalent to `G_SETTINGS_BIND_GET|G_SETTINGS_BIND_SET`
         */
        DEFAULT,
        /**
         * Update the #GObject property when the setting changes.
         *     It is an error to use this flag if the property is not writable.
         */
        GET,
        /**
         * Update the setting when the #GObject property changes.
         *     It is an error to use this flag if the property is not readable.
         */
        SET,
        /**
         * Do not try to bind a "sensitivity" property to the writability of the setting
         */
        NO_SENSITIVITY,
        /**
         * When set in addition to %G_SETTINGS_BIND_GET, set the #GObject property
         *     value initially from the setting, but do not listen for changes of the setting
         */
        GET_NO_CHANGES,
        /**
         * When passed to g_settings_bind(), uses a pair of mapping functions that invert
         *     the boolean value when mapping between the setting and the property.  The setting and property must both
         *     be booleans.  You cannot pass this flag to g_settings_bind_with_mapping().
         */
        INVERT_BOOLEAN,
    }
    /**
     * Flags used in g_socket_receive_message() and g_socket_send_message().
     * The flags listed in the enum are some commonly available flags, but the
     * values used for them are the same as on the platform, and any other flags
     * are passed in/out as is. So to use a platform specific flag, just include
     * the right system header and pass in the flag.
     * @bitfield
     */
    enum SocketMsgFlags {
        /**
         * No flags.
         */
        NONE,
        /**
         * Request to send/receive out of band data.
         */
        OOB,
        /**
         * Read data from the socket without removing it from
         *     the queue.
         */
        PEEK,
        /**
         * Don't use a gateway to send out the packet,
         *     only send to hosts on directly connected networks.
         */
        DONTROUTE,
    }
    /**
     * Flags to define the behaviour of a #GSubprocess.
     *
     * Note that the default for stdin is to redirect from `/dev/null`.  For
     * stdout and stderr the default are for them to inherit the
     * corresponding descriptor from the calling process.
     *
     * Note that it is a programmer error to mix 'incompatible' flags.  For
     * example, you may not request both %G_SUBPROCESS_FLAGS_STDOUT_PIPE and
     * %G_SUBPROCESS_FLAGS_STDOUT_SILENCE.
     * @bitfield
     */
    enum SubprocessFlags {
        /**
         * No flags.
         */
        NONE,
        /**
         * create a pipe for the stdin of the
         *   spawned process that can be accessed with
         *   g_subprocess_get_stdin_pipe().
         */
        STDIN_PIPE,
        /**
         * stdin is inherited from the
         *   calling process.
         */
        STDIN_INHERIT,
        /**
         * create a pipe for the stdout of the
         *   spawned process that can be accessed with
         *   g_subprocess_get_stdout_pipe().
         */
        STDOUT_PIPE,
        /**
         * silence the stdout of the spawned
         *   process (ie: redirect to `/dev/null`).
         */
        STDOUT_SILENCE,
        /**
         * create a pipe for the stderr of the
         *   spawned process that can be accessed with
         *   g_subprocess_get_stderr_pipe().
         */
        STDERR_PIPE,
        /**
         * silence the stderr of the spawned
         *   process (ie: redirect to `/dev/null`).
         */
        STDERR_SILENCE,
        /**
         * merge the stderr of the spawned
         *   process with whatever the stdout happens to be.  This is a good way
         *   of directing both streams to a common log file, for example.
         */
        STDERR_MERGE,
        /**
         * spawned processes will inherit the
         *   file descriptors of their parent, unless those descriptors have
         *   been explicitly marked as close-on-exec.  This flag has no effect
         *   over the "standard" file descriptors (stdin, stdout, stderr).
         */
        INHERIT_FDS,
        /**
         * if path searching is
         *   needed when spawning the subprocess, use the `PATH` in the launcher
         *   environment. (Since: 2.72)
         */
        SEARCH_PATH_FROM_ENVP,
    }
    /**
     * Flags to define future #GTestDBus behaviour.
     * @bitfield
     */
    enum TestDBusFlags {
        /**
         * No flags.
         */
        NONE,
    }
    /**
     * A set of flags describing TLS certification validation. This can be
     * used to describe why a particular certificate was rejected (for
     * example, in #GTlsConnection::accept-certificate).
     *
     * GLib guarantees that if certificate verification fails, at least one
     * flag will be set, but it does not guarantee that all possible flags
     * will be set. Accordingly, you may not safely decide to ignore any
     * particular type of error. For example, it would be incorrect to mask
     * %G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates,
     * because this could potentially be the only error flag set even if
     * other problems exist with the certificate.
     * @bitfield
     */
    enum TlsCertificateFlags {
        /**
         * No flags set. Since: 2.74
         */
        NO_FLAGS,
        /**
         * The signing certificate authority is
         *   not known.
         */
        UNKNOWN_CA,
        /**
         * The certificate does not match the
         *   expected identity of the site that it was retrieved from.
         */
        BAD_IDENTITY,
        /**
         * The certificate's activation time
         *   is still in the future
         */
        NOT_ACTIVATED,
        /**
         * The certificate has expired
         */
        EXPIRED,
        /**
         * The certificate has been revoked
         *   according to the #GTlsConnection's certificate revocation list.
         */
        REVOKED,
        /**
         * The certificate's algorithm is
         *   considered insecure.
         */
        INSECURE,
        /**
         * Some other error occurred validating
         *   the certificate
         */
        GENERIC_ERROR,
        /**
         * the combination of all of the above
         *   flags
         */
        VALIDATE_ALL,
    }
    /**
     * Flags for g_tls_database_verify_chain().
     * @bitfield
     */
    enum TlsDatabaseVerifyFlags {
        /**
         * No verification flags
         */
        NONE,
    }
    /**
     * Various flags for the password.
     * @bitfield
     */
    enum TlsPasswordFlags {
        /**
         * No flags
         */
        NONE,
        /**
         * The password was wrong, and the user should retry.
         */
        RETRY,
        /**
         * Hint to the user that the password has been
         *    wrong many times, and the user may not have many chances left.
         */
        MANY_TRIES,
        /**
         * Hint to the user that this is the last try to get
         *    this password right.
         */
        FINAL_TRY,
        /**
         * For PKCS #11, the user PIN is required.
         *    Since: 2.70.
         */
        PKCS11_USER,
        /**
         * For PKCS #11, the security officer
         *    PIN is required. Since: 2.70.
         */
        PKCS11_SECURITY_OFFICER,
        /**
         * For PKCS #11, the context-specific
         *    PIN is required. Since: 2.70.
         */
        PKCS11_CONTEXT_SPECIFIC,
    }
    /**
     * The value returned by handlers of the signals generated by
     * the `gdbus-codegen` tool to indicate that a method call has been
     * handled by an implementation. It is equal to %TRUE, but using
     * this macro is sometimes more readable.
     *
     * In code that needs to be backwards-compatible with older GLib,
     * use %TRUE instead, often written like this:
     *
     *
     * ```
     *   g_dbus_method_invocation_return_error (invocation, ...);
     *   return TRUE;    // handled
     * ```
     *
     */
    const DBUS_METHOD_INVOCATION_HANDLED: boolean;
    /**
     * The value returned by handlers of the signals generated by
     * the `gdbus-codegen` tool to indicate that a method call has not been
     * handled by an implementation. It is equal to %FALSE, but using
     * this macro is sometimes more readable.
     *
     * In code that needs to be backwards-compatible with older GLib,
     * use %FALSE instead.
     */
    const DBUS_METHOD_INVOCATION_UNHANDLED: boolean;
    /**
     * Extension point for debug control functionality.
     * See [Extending GIO][extending-gio].
     */
    const DEBUG_CONTROLLER_EXTENSION_POINT_NAME: string | null;
    /**
     * Extension point for default handler to URI association. See
     * [Extending GIO][extending-gio].
     */
    const DESKTOP_APP_INFO_LOOKUP_EXTENSION_POINT_NAME: string | null;
    /**
     * The string used to obtain a Unix device path with g_drive_get_identifier().
     */
    const DRIVE_IDENTIFIER_KIND_UNIX_DEVICE: string | null;
    /**
     * A key in the "access" namespace for checking deletion privileges.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     *
     * This attribute will be %TRUE if the user is able to delete the file.
     */
    const FILE_ATTRIBUTE_ACCESS_CAN_DELETE: string | null;
    /**
     * A key in the "access" namespace for getting execution privileges.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     *
     * This attribute will be %TRUE if the user is able to execute the file.
     */
    const FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE: string | null;
    /**
     * A key in the "access" namespace for getting read privileges.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     *
     * This attribute will be %TRUE if the user is able to read the file.
     */
    const FILE_ATTRIBUTE_ACCESS_CAN_READ: string | null;
    /**
     * A key in the "access" namespace for checking renaming privileges.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     *
     * This attribute will be %TRUE if the user is able to rename the file.
     */
    const FILE_ATTRIBUTE_ACCESS_CAN_RENAME: string | null;
    /**
     * A key in the "access" namespace for checking trashing privileges.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     *
     * This attribute will be %TRUE if the user is able to move the file to
     * the trash.
     */
    const FILE_ATTRIBUTE_ACCESS_CAN_TRASH: string | null;
    /**
     * A key in the "access" namespace for getting write privileges.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     *
     * This attribute will be %TRUE if the user is able to write to the file.
     */
    const FILE_ATTRIBUTE_ACCESS_CAN_WRITE: string | null;
    /**
     * A key in the "dos" namespace for checking if the file's archive flag
     * is set.
     *
     * This attribute is %TRUE if the archive flag is set.
     *
     * This attribute is only available for DOS file systems.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_DOS_IS_ARCHIVE: string | null;
    /**
     * A key in the "dos" namespace for checking if the file is a NTFS mount point
     * (a volume mount or a junction point).
     *
     * This attribute is %TRUE if file is a reparse point of type
     * [IO_REPARSE_TAG_MOUNT_POINT](https://msdn.microsoft.com/en-us/library/dd541667.aspx).
     *
     * This attribute is only available for DOS file systems.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_DOS_IS_MOUNTPOINT: string | null;
    /**
     * A key in the "dos" namespace for checking if the file's backup flag
     * is set.
     *
     * This attribute is %TRUE if the backup flag is set.
     *
     * This attribute is only available for DOS file systems.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_DOS_IS_SYSTEM: string | null;
    /**
     * A key in the "dos" namespace for getting the file NTFS reparse tag.
     *
     * This value is 0 for files that are not reparse points.
     *
     * See the [Reparse Tags](https://msdn.microsoft.com/en-us/library/dd541667.aspx)
     * page for possible reparse tag values.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_DOS_REPARSE_POINT_TAG: string | null;
    /**
     * A key in the "etag" namespace for getting the value of the file's
     * entity tag.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     */
    const FILE_ATTRIBUTE_ETAG_VALUE: string | null;
    /**
     * A key in the "filesystem" namespace for getting the number of bytes
     * of free space left on the file system.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
     */
    const FILE_ATTRIBUTE_FILESYSTEM_FREE: string | null;
    /**
     * A key in the "filesystem" namespace for checking if the file system
     * is read only.
     *
     * Is set to %TRUE if the file system is read only.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_FILESYSTEM_READONLY: string | null;
    /**
     * A key in the "filesystem" namespace for checking if the file system
     * is remote.
     *
     * Is set to %TRUE if the file system is remote.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_FILESYSTEM_REMOTE: string | null;
    /**
     * A key in the "filesystem" namespace for getting the total size (in
     * bytes) of the file system, used in g_file_query_filesystem_info().
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
     */
    const FILE_ATTRIBUTE_FILESYSTEM_SIZE: string | null;
    /**
     * A key in the "filesystem" namespace for getting the file system's type.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     */
    const FILE_ATTRIBUTE_FILESYSTEM_TYPE: string | null;
    /**
     * A key in the "filesystem" namespace for getting the number of bytes
     * used by data on the file system.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
     */
    const FILE_ATTRIBUTE_FILESYSTEM_USED: string | null;
    /**
     * A key in the "filesystem" namespace for hinting a file manager
     * application whether it should preview (e.g. thumbnail) files on the
     * file system.
     *
     * The value for this key contain a #GFilesystemPreviewType.
     */
    const FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW: string | null;
    /**
     * A key in the "gvfs" namespace that gets the name of the current
     * GVFS backend in use.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     */
    const FILE_ATTRIBUTE_GVFS_BACKEND: string | null;
    /**
     * A key in the "id" namespace for getting a file identifier.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     *
     * An example use would be during listing files, to avoid recursive
     * directory scanning.
     */
    const FILE_ATTRIBUTE_ID_FILE: string | null;
    /**
     * A key in the "id" namespace for getting the file system identifier.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     *
     * An example use would be during drag and drop to see if the source
     * and target are on the same filesystem (default to move) or not (default
     * to copy).
     */
    const FILE_ATTRIBUTE_ID_FILESYSTEM: string | null;
    /**
     * A key in the "mountable" namespace for checking if a file (of
     * type G_FILE_TYPE_MOUNTABLE) can be ejected.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT: string | null;
    /**
     * A key in the "mountable" namespace for checking if a file (of
     * type G_FILE_TYPE_MOUNTABLE) is mountable.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT: string | null;
    /**
     * A key in the "mountable" namespace for checking if a file (of
     * type G_FILE_TYPE_MOUNTABLE) can be polled.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL: string | null;
    /**
     * A key in the "mountable" namespace for checking if a file (of
     * type G_FILE_TYPE_MOUNTABLE) can be started.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_MOUNTABLE_CAN_START: string | null;
    /**
     * A key in the "mountable" namespace for checking if a file (of
     * type G_FILE_TYPE_MOUNTABLE) can be started degraded.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED: string | null;
    /**
     * A key in the "mountable" namespace for checking if a file (of
     * type G_FILE_TYPE_MOUNTABLE) can be stopped.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP: string | null;
    /**
     * A key in the "mountable" namespace for checking if a file (of
     * type G_FILE_TYPE_MOUNTABLE)  is unmountable.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT: string | null;
    /**
     * A key in the "mountable" namespace for getting the HAL UDI for the mountable
     * file.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     */
    const FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI: string | null;
    /**
     * A key in the "mountable" namespace for checking if a file (of
     * type G_FILE_TYPE_MOUNTABLE) is automatically polled for media.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC: string | null;
    /**
     * A key in the "mountable" namespace for getting the #GDriveStartStopType.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE: string | null;
    /**
     * A key in the "mountable" namespace for getting the unix device.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE: string | null;
    /**
     * A key in the "mountable" namespace for getting the unix device file.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     */
    const FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE: string | null;
    /**
     * A key in the "owner" namespace for getting the file owner's group.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     */
    const FILE_ATTRIBUTE_OWNER_GROUP: string | null;
    /**
     * A key in the "owner" namespace for getting the user name of the
     * file's owner.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     */
    const FILE_ATTRIBUTE_OWNER_USER: string | null;
    /**
     * A key in the "owner" namespace for getting the real name of the
     * user that owns the file.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     */
    const FILE_ATTRIBUTE_OWNER_USER_REAL: string | null;
    /**
     * A key in the "preview" namespace for getting a #GIcon that can be
     * used to get preview of the file.
     *
     * For example, it may be a low resolution thumbnail without metadata.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_OBJECT.
     *
     * The value for this key should contain a #GIcon.
     */
    const FILE_ATTRIBUTE_PREVIEW_ICON: string | null;
    /**
     * A key in the "recent" namespace for getting time, when the metadata for the
     * file in `recent:///` was last changed.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_INT64.
     */
    const FILE_ATTRIBUTE_RECENT_MODIFIED: string | null;
    /**
     * A key in the "selinux" namespace for getting the file's SELinux
     * context.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     *
     * Note that this attribute is only available if GLib has been built
     * with SELinux support.
     */
    const FILE_ATTRIBUTE_SELINUX_CONTEXT: string | null;
    /**
     * A key in the "standard" namespace for getting the amount of disk space
     * that is consumed by the file (in bytes).
     *
     * This will generally be larger than the file size (due to block size
     * overhead) but can occasionally be smaller (for example, for sparse files).
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
     */
    const FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE: string | null;
    /**
     * A key in the "standard" namespace for getting the content type of the file.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     *
     * The value for this key should contain a valid content type.
     */
    const FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE: string | null;
    /**
     * A key in the "standard" namespace for getting the copy name of the file.
     *
     * The copy name is an optional version of the name. If available it's always
     * in UTF8, and corresponds directly to the original filename (only transcoded to
     * UTF8). This is useful if you want to copy the file to another filesystem that
     * might have a different encoding. If the filename is not a valid string in the
     * encoding selected for the filesystem it is in then the copy name will not be set.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     */
    const FILE_ATTRIBUTE_STANDARD_COPY_NAME: string | null;
    /**
     * A key in the "standard" namespace for getting the description of the file.
     *
     * The description is a utf8 string that describes the file, generally containing
     * the filename, but can also contain further information. Example descriptions
     * could be "filename (on hostname)" for a remote file or "filename (in trash)"
     * for a file in the trash. This is useful for instance as the window title
     * when displaying a directory or for a bookmarks menu.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     */
    const FILE_ATTRIBUTE_STANDARD_DESCRIPTION: string | null;
    /**
     * A key in the "standard" namespace for getting the display name of the file.
     *
     * A display name is guaranteed to be in UTF-8 and can thus be displayed in
     * the UI. It is guaranteed to be set on every file.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     */
    const FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME: string | null;
    /**
     * A key in the "standard" namespace for edit name of the file.
     *
     * An edit name is similar to the display name, but it is meant to be
     * used when you want to rename the file in the UI. The display name
     * might contain information you don't want in the new filename (such as
     * "(invalid unicode)" if the filename was in an invalid encoding).
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     */
    const FILE_ATTRIBUTE_STANDARD_EDIT_NAME: string | null;
    /**
     * A key in the "standard" namespace for getting the fast content type.
     *
     * The fast content type isn't as reliable as the regular one, as it
     * only uses the filename to guess it, but it is faster to calculate than the
     * regular content type.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     */
    const FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE: string | null;
    /**
     * A key in the "standard" namespace for getting the icon for the file.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_OBJECT.
     *
     * The value for this key should contain a #GIcon.
     */
    const FILE_ATTRIBUTE_STANDARD_ICON: string | null;
    /**
     * A key in the "standard" namespace for checking if a file is a backup file.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_STANDARD_IS_BACKUP: string | null;
    /**
     * A key in the "standard" namespace for checking if a file is hidden.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_STANDARD_IS_HIDDEN: string | null;
    /**
     * A key in the "standard" namespace for checking if the file is a symlink.
     * Typically the actual type is something else, if we followed the symlink
     * to get the type.
     *
     * On Windows NTFS mountpoints are considered to be symlinks as well.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_STANDARD_IS_SYMLINK: string | null;
    /**
     * A key in the "standard" namespace for checking if a file is virtual.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL: string | null;
    /**
     * A key in the "standard" namespace for checking if a file is
     * volatile. This is meant for opaque, non-POSIX-like backends to
     * indicate that the URI is not persistent. Applications should look
     * at %G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET for the persistent URI.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_STANDARD_IS_VOLATILE: string | null;
    /**
     * A key in the "standard" namespace for getting the name of the file.
     *
     * The name is the on-disk filename which may not be in any known encoding,
     * and can thus not be generally displayed as is. It is guaranteed to be set on
     * every file.
     *
     * Use %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME if you need to display the
     * name in a user interface.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
     */
    const FILE_ATTRIBUTE_STANDARD_NAME: string | null;
    /**
     * A key in the "standard" namespace for getting the file's size (in bytes).
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
     */
    const FILE_ATTRIBUTE_STANDARD_SIZE: string | null;
    /**
     * A key in the "standard" namespace for setting the sort order of a file.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_INT32.
     *
     * An example use would be in file managers, which would use this key
     * to set the order files are displayed. Files with smaller sort order
     * should be sorted first, and files without sort order as if sort order
     * was zero.
     */
    const FILE_ATTRIBUTE_STANDARD_SORT_ORDER: string | null;
    /**
     * A key in the "standard" namespace for getting the symbolic icon for the file.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_OBJECT.
     *
     * The value for this key should contain a #GIcon.
     */
    const FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON: string | null;
    /**
     * A key in the "standard" namespace for getting the symlink target, if the file
     * is a symlink.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
     */
    const FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET: string | null;
    /**
     * A key in the "standard" namespace for getting the target URI for the file, in
     * the case of %G_FILE_TYPE_SHORTCUT or %G_FILE_TYPE_MOUNTABLE files.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     */
    const FILE_ATTRIBUTE_STANDARD_TARGET_URI: string | null;
    /**
     * A key in the "standard" namespace for storing file types.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
     *
     * The value for this key should contain a #GFileType.
     */
    const FILE_ATTRIBUTE_STANDARD_TYPE: string | null;
    /**
     * A key in the "thumbnail" namespace for checking if thumbnailing failed.
     *
     * This attribute is %TRUE if thumbnailing failed.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_THUMBNAILING_FAILED: string | null;
    /**
     * A key in the "thumbnail" namespace for checking if thumbnailing failed
     * for the large image.
     *
     * This attribute is %TRUE if thumbnailing failed.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_THUMBNAILING_FAILED_LARGE: string | null;
    /**
     * A key in the "thumbnail" namespace for checking if thumbnailing failed
     * for the normal image.
     *
     * This attribute is %TRUE if thumbnailing failed.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_THUMBNAILING_FAILED_NORMAL: string | null;
    /**
     * A key in the "thumbnail" namespace for checking if thumbnailing failed
     * for the x-large image.
     *
     * This attribute is %TRUE if thumbnailing failed.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_THUMBNAILING_FAILED_XLARGE: string | null;
    /**
     * A key in the "thumbnail" namespace for checking if thumbnailing failed
     * for the xx-large image.
     *
     * This attribute is %TRUE if thumbnailing failed.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_THUMBNAILING_FAILED_XXLARGE: string | null;
    /**
     * A key in the "thumbnail" namespace for checking whether the thumbnail is outdated.
     *
     * This attribute is %TRUE if the thumbnail is up-to-date with the file it represents,
     * and %FALSE if the file has been modified since the thumbnail was generated.
     *
     * If %G_FILE_ATTRIBUTE_THUMBNAILING_FAILED is %TRUE and this attribute is %FALSE,
     * it indicates that thumbnailing may be attempted again and may succeed.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_THUMBNAIL_IS_VALID: string | null;
    /**
     * A key in the "thumbnail" namespace for checking whether the large
     * thumbnail is outdated.
     *
     * This attribute is %TRUE if the large thumbnail is up-to-date with the file
     * it represents, and %FALSE if the file has been modified since the thumbnail
     * was generated.
     *
     * If %G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_LARGE is %TRUE and this attribute
     * is %FALSE, it indicates that thumbnailing may be attempted again and may
     * succeed.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_LARGE: string | null;
    /**
     * A key in the "thumbnail" namespace for checking whether the normal
     * thumbnail is outdated.
     *
     * This attribute is %TRUE if the normal thumbnail is up-to-date with the file
     * it represents, and %FALSE if the file has been modified since the thumbnail
     * was generated.
     *
     * If %G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_NORMAL is %TRUE and this attribute
     * is %FALSE, it indicates that thumbnailing may be attempted again and may
     * succeed.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_NORMAL: string | null;
    /**
     * A key in the "thumbnail" namespace for checking whether the x-large
     * thumbnail is outdated.
     *
     * This attribute is %TRUE if the x-large thumbnail is up-to-date with the file
     * it represents, and %FALSE if the file has been modified since the thumbnail
     * was generated.
     *
     * If %G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_XLARGE is %TRUE and this attribute
     * is %FALSE, it indicates that thumbnailing may be attempted again and may
     * succeed.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_XLARGE: string | null;
    /**
     * A key in the "thumbnail" namespace for checking whether the xx-large
     * thumbnail is outdated.
     *
     * This attribute is %TRUE if the x-large thumbnail is up-to-date with the file
     * it represents, and %FALSE if the file has been modified since the thumbnail
     * was generated.
     *
     * If %G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_XXLARGE is %TRUE and this attribute
     * is %FALSE, it indicates that thumbnailing may be attempted again and may
     * succeed.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_XXLARGE: string | null;
    /**
     * A key in the "thumbnail" namespace for getting the path to the thumbnail
     * image with the biggest size available.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
     */
    const FILE_ATTRIBUTE_THUMBNAIL_PATH: string | null;
    /**
     * A key in the "thumbnail" namespace for getting the path to the large
     * thumbnail image.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
     */
    const FILE_ATTRIBUTE_THUMBNAIL_PATH_LARGE: string | null;
    /**
     * A key in the "thumbnail" namespace for getting the path to the normal
     * thumbnail image.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
     */
    const FILE_ATTRIBUTE_THUMBNAIL_PATH_NORMAL: string | null;
    /**
     * A key in the "thumbnail" namespace for getting the path to the x-large
     * thumbnail image.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
     */
    const FILE_ATTRIBUTE_THUMBNAIL_PATH_XLARGE: string | null;
    /**
     * A key in the "thumbnail" namespace for getting the path to the xx-large
     * thumbnail image.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
     */
    const FILE_ATTRIBUTE_THUMBNAIL_PATH_XXLARGE: string | null;
    /**
     * A key in the "time" namespace for getting the time the file was last
     * accessed.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64, and
     * contains the time since the file was last accessed, in seconds since the
     * UNIX epoch.
     */
    const FILE_ATTRIBUTE_TIME_ACCESS: string | null;
    /**
     * A key in the "time" namespace for getting the nanoseconds of the time
     * the file was last accessed. This should be used in conjunction with
     * #G_FILE_ATTRIBUTE_TIME_ACCESS. Corresponding #GFileAttributeType is
     * %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_TIME_ACCESS_NSEC: string | null;
    /**
     * A key in the "time" namespace for getting the microseconds of the time
     * the file was last accessed.
     *
     * This should be used in conjunction with %G_FILE_ATTRIBUTE_TIME_ACCESS.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_TIME_ACCESS_USEC: string | null;
    /**
     * A key in the "time" namespace for getting the time the file was last
     * changed.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64,
     * and contains the time since the file was last changed, in seconds since
     * the UNIX epoch.
     *
     * This corresponds to the traditional UNIX ctime.
     */
    const FILE_ATTRIBUTE_TIME_CHANGED: string | null;
    /**
     * A key in the "time" namespace for getting the nanoseconds of the time
     * the file was last changed. This should be used in conjunction with
     * #G_FILE_ATTRIBUTE_TIME_CHANGED. Corresponding #GFileAttributeType is
     * %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_TIME_CHANGED_NSEC: string | null;
    /**
     * A key in the "time" namespace for getting the microseconds of the time
     * the file was last changed.
     *
     * This should be used in conjunction with %G_FILE_ATTRIBUTE_TIME_CHANGED.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_TIME_CHANGED_USEC: string | null;
    /**
     * A key in the "time" namespace for getting the time the file was created.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64,
     * and contains the time since the file was created, in seconds since the UNIX
     * epoch.
     *
     * This may correspond to Linux `stx_btime`, FreeBSD `st_birthtim`, NetBSD
     * `st_birthtime` or NTFS `ctime`.
     */
    const FILE_ATTRIBUTE_TIME_CREATED: string | null;
    /**
     * A key in the "time" namespace for getting the nanoseconds of the time
     * the file was created. This should be used in conjunction with
     * #G_FILE_ATTRIBUTE_TIME_CREATED. Corresponding #GFileAttributeType is
     * %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_TIME_CREATED_NSEC: string | null;
    /**
     * A key in the "time" namespace for getting the microseconds of the time
     * the file was created.
     *
     * This should be used in conjunction with %G_FILE_ATTRIBUTE_TIME_CREATED.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_TIME_CREATED_USEC: string | null;
    /**
     * A key in the "time" namespace for getting the time the file was last
     * modified.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64, and
     * contains the time since the file was modified, in seconds since the UNIX
     * epoch.
     */
    const FILE_ATTRIBUTE_TIME_MODIFIED: string | null;
    /**
     * A key in the "time" namespace for getting the nanoseconds of the time
     * the file was last modified. This should be used in conjunction with
     * #G_FILE_ATTRIBUTE_TIME_MODIFIED. Corresponding #GFileAttributeType is
     * %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_TIME_MODIFIED_NSEC: string | null;
    /**
     * A key in the "time" namespace for getting the microseconds of the time
     * the file was last modified.
     *
     * This should be used in conjunction with %G_FILE_ATTRIBUTE_TIME_MODIFIED.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_TIME_MODIFIED_USEC: string | null;
    /**
     * A key in the "trash" namespace for getting the deletion date and time
     * of a file inside the `trash:///` folder.
     *
     * The format of the returned string is `YYYY-MM-DDThh:mm:ss`.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     */
    const FILE_ATTRIBUTE_TRASH_DELETION_DATE: string | null;
    /**
     * A key in the "trash" namespace for getting the number of (toplevel) items
     * that are present in the `trash:///` folder.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_TRASH_ITEM_COUNT: string | null;
    /**
     * A key in the "trash" namespace for getting the original path of a file
     * inside the `trash:///` folder before it was trashed.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
     */
    const FILE_ATTRIBUTE_TRASH_ORIG_PATH: string | null;
    /**
     * A key in the "unix" namespace for getting the number of blocks allocated
     * for the file.
     *
     * This attribute is only available for UNIX file systems.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
     */
    const FILE_ATTRIBUTE_UNIX_BLOCKS: string | null;
    /**
     * A key in the "unix" namespace for getting the block size for the file
     * system.
     *
     * This attribute is only available for UNIX file systems.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_UNIX_BLOCK_SIZE: string | null;
    /**
     * A key in the "unix" namespace for getting the device id of the device the
     * file is located on (see stat() documentation).
     *
     * This attribute is only available for UNIX file systems.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_UNIX_DEVICE: string | null;
    /**
     * A key in the "unix" namespace for getting the group ID for the file.
     *
     * This attribute is only available for UNIX file systems.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_UNIX_GID: string | null;
    /**
     * A key in the "unix" namespace for getting the inode of the file.
     *
     * This attribute is only available for UNIX file systems.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
     */
    const FILE_ATTRIBUTE_UNIX_INODE: string | null;
    /**
     * A key in the "unix" namespace for checking if the file represents a
     * UNIX mount point.
     *
     * This attribute is %TRUE if the file is a UNIX mount point.
     *
     * Since 2.58, `/` is considered to be a mount point.
     *
     * This attribute is only available for UNIX file systems.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT: string | null;
    /**
     * A key in the "unix" namespace for getting the mode of the file
     * (e.g. whether the file is a regular file, symlink, etc).
     *
     * See the documentation for `lstat()`: this attribute is equivalent to
     * the `st_mode` member of `struct stat`, and includes both the file type
     * and permissions.
     *
     * This attribute is only available for UNIX file systems.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_UNIX_MODE: string | null;
    /**
     * A key in the "unix" namespace for getting the number of hard links
     * for a file.
     *
     * See the documentation for `lstat()`.
     *
     * This attribute is only available for UNIX file systems.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_UNIX_NLINK: string | null;
    /**
     * A key in the "unix" namespace for getting the device ID for the file
     * (if it is a special file).
     *
     * See the documentation for `lstat()`.
     *
     * This attribute is only available for UNIX file systems.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_UNIX_RDEV: string | null;
    /**
     * A key in the "unix" namespace for getting the user ID for the file.
     *
     * This attribute is only available for UNIX file systems.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_UNIX_UID: string | null;
    /**
     * Extension point for memory usage monitoring functionality.
     * See [Extending GIO][extending-gio].
     */
    const MEMORY_MONITOR_EXTENSION_POINT_NAME: string | null;
    /**
     * The menu item attribute which holds the action name of the item.  Action
     * names are namespaced with an identifier for the action group in which the
     * action resides. For example, "win." for window-specific actions and "app."
     * for application-wide actions.
     *
     * See also g_menu_model_get_item_attribute() and g_menu_item_set_attribute().
     */
    const MENU_ATTRIBUTE_ACTION: string | null;
    /**
     * The menu item attribute that holds the namespace for all action names in
     * menus that are linked from this item.
     */
    const MENU_ATTRIBUTE_ACTION_NAMESPACE: string | null;
    /**
     * The menu item attribute which holds the icon of the item.
     *
     * The icon is stored in the format returned by g_icon_serialize().
     *
     * This attribute is intended only to represent 'noun' icons such as
     * favicons for a webpage, or application icons.  It should not be used
     * for 'verbs' (ie: stock icons).
     */
    const MENU_ATTRIBUTE_ICON: string | null;
    /**
     * The menu item attribute which holds the label of the item.
     */
    const MENU_ATTRIBUTE_LABEL: string | null;
    /**
     * The menu item attribute which holds the target with which the item's action
     * will be activated.
     *
     * See also g_menu_item_set_action_and_target()
     */
    const MENU_ATTRIBUTE_TARGET: string | null;
    /**
     * The maximum number of entries in a menu section supported by
     * g_dbus_connection_export_menu_model().
     *
     * The exact value of the limit may change in future GLib versions.
     */
    const MENU_EXPORTER_MAX_SECTION_SIZE: number;
    /**
     * The name of the link that associates a menu item with a section.  The linked
     * menu will usually be shown in place of the menu item, using the item's label
     * as a header.
     *
     * See also g_menu_item_set_link().
     */
    const MENU_LINK_SECTION: string | null;
    /**
     * The name of the link that associates a menu item with a submenu.
     *
     * See also g_menu_item_set_link().
     */
    const MENU_LINK_SUBMENU: string | null;
    const NATIVE_VOLUME_MONITOR_EXTENSION_POINT_NAME: string | null;
    /**
     * Extension point for network status monitoring functionality.
     * See [Extending GIO][extending-gio].
     */
    const NETWORK_MONITOR_EXTENSION_POINT_NAME: string | null;
    /**
     * Extension point for power profile usage monitoring functionality.
     * See [Extending GIO][extending-gio].
     */
    const POWER_PROFILE_MONITOR_EXTENSION_POINT_NAME: string | null;
    /**
     * Extension point for proxy functionality.
     * See [Extending GIO][extending-gio].
     */
    const PROXY_EXTENSION_POINT_NAME: string | null;
    /**
     * Extension point for proxy resolving functionality.
     * See [Extending GIO][extending-gio].
     */
    const PROXY_RESOLVER_EXTENSION_POINT_NAME: string | null;
    /**
     * Extension point for #GSettingsBackend functionality.
     */
    const SETTINGS_BACKEND_EXTENSION_POINT_NAME: string | null;
    /**
     * Extension point for TLS functionality via #GTlsBackend.
     * See [Extending GIO][extending-gio].
     */
    const TLS_BACKEND_EXTENSION_POINT_NAME: string | null;
    /**
     * The purpose used to verify the client certificate in a TLS connection.
     * Used by TLS servers.
     */
    const TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT: string | null;
    /**
     * The purpose used to verify the server certificate in a TLS connection. This
     * is the most common purpose in use. Used by TLS clients.
     */
    const TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER: string | null;
    /**
     * Extension point for #GVfs functionality.
     * See [Extending GIO][extending-gio].
     */
    const VFS_EXTENSION_POINT_NAME: string | null;
    /**
     * The string used to obtain the volume class with g_volume_get_identifier().
     *
     * Known volume classes include `device`, `network`, and `loop`. Other
     * classes may be added in the future.
     *
     * This is intended to be used by applications to classify #GVolume
     * instances into different sections - for example a file manager or
     * file chooser can use this information to show `network` volumes under
     * a "Network" heading and `device` volumes under a "Devices" heading.
     */
    const VOLUME_IDENTIFIER_KIND_CLASS: string | null;
    /**
     * The string used to obtain a Hal UDI with g_volume_get_identifier().
     */
    const VOLUME_IDENTIFIER_KIND_HAL_UDI: string | null;
    /**
     * The string used to obtain a filesystem label with g_volume_get_identifier().
     */
    const VOLUME_IDENTIFIER_KIND_LABEL: string | null;
    /**
     * The string used to obtain a NFS mount with g_volume_get_identifier().
     */
    const VOLUME_IDENTIFIER_KIND_NFS_MOUNT: string | null;
    /**
     * The string used to obtain a Unix device path with g_volume_get_identifier().
     */
    const VOLUME_IDENTIFIER_KIND_UNIX_DEVICE: string | null;
    /**
     * The string used to obtain a UUID with g_volume_get_identifier().
     */
    const VOLUME_IDENTIFIER_KIND_UUID: string | null;
    /**
     * Extension point for volume monitor functionality.
     * See [Extending GIO][extending-gio].
     */
    const VOLUME_MONITOR_EXTENSION_POINT_NAME: string | null;
    /**
     * Checks if `action_name` is valid.
     *
     * `action_name` is valid if it consists only of alphanumeric characters,
     * plus '-' and '.'.  The empty string is not a valid action name.
     *
     * It is an error to call this function with a non-utf8 `action_name`.
     * `action_name` must not be %NULL.
     * @param action_name a potential action name
     * @returns %TRUE if @action_name is valid
     */
    function action_name_is_valid(action_name: string | null): boolean;
    /**
     * Parses a detailed action name into its separate name and target
     * components.
     *
     * Detailed action names can have three formats.
     *
     * The first format is used to represent an action name with no target
     * value and consists of just an action name containing no whitespace
     * nor the characters `:`, `(` or `)`.  For example: `app.action`.
     *
     * The second format is used to represent an action with a target value
     * that is a non-empty string consisting only of alphanumerics, plus `-`
     * and `.`.  In that case, the action name and target value are
     * separated by a double colon (`::`).  For example:
     * `app.action::target`.
     *
     * The third format is used to represent an action with any type of
     * target value, including strings.  The target value follows the action
     * name, surrounded in parens.  For example: `app.action(42)`.  The
     * target value is parsed using g_variant_parse().  If a tuple-typed
     * value is desired, it must be specified in the same way, resulting in
     * two sets of parens, for example: `app.action((1,2,3))`.  A string
     * target can be specified this way as well: `app.action('target')`.
     * For strings, this third format must be used if target value is
     * empty or contains characters other than alphanumerics, `-` and `.`.
     *
     * If this function returns %TRUE, a non-%NULL value is guaranteed to be returned
     * in `action_name` (if a pointer is passed in). A %NULL value may still be
     * returned in `target_value,` as the `detailed_name` may not contain a target.
     *
     * If returned, the #GVariant in `target_value` is guaranteed to not be floating.
     * @param detailed_name a detailed action name
     * @returns %TRUE if successful, else %FALSE with @error set
     */
    function action_parse_detailed_name(
        detailed_name: string | null
    ): [
        /* returnType */ boolean,
        /* action_name */ string | null,
        /* target_value */ GLib.Variant | null
    ];
    /**
     * Formats a detailed action name from `action_name` and `target_value`.
     *
     * It is an error to call this function with an invalid action name.
     *
     * This function is the opposite of g_action_parse_detailed_name().
     * It will produce a string that can be parsed back to the `action_name`
     * and `target_value` by that function.
     *
     * See that function for the types of strings that will be printed by
     * this function.
     * @param action_name a valid action name
     * @param target_value a #GVariant target value, or %NULL
     * @returns a detailed format string
     */
    function action_print_detailed_name(
        action_name: string | null,
        target_value: GLib.Variant | null
    ): string | null;
    /**
     * Creates a new #GAppInfo from the given information.
     *
     * Note that for `commandline,` the quoting rules of the Exec key of the
     * [freedesktop.org Desktop Entry Specification](http://freedesktop.org/Standards/desktop-entry-spec)
     * are applied. For example, if the `commandline` contains
     * percent-encoded URIs, the percent-character must be doubled in order to prevent it from
     * being swallowed by Exec key unquoting. See the specification for exact quoting rules.
     * @param commandline the commandline to use
     * @param application_name the application name, or %NULL to use `commandline`
     * @param flags flags that can specify details of the created #GAppInfo
     * @returns new #GAppInfo for given command.
     */
    function app_info_create_from_commandline(
        commandline: string,
        application_name: string | null,
        flags: AppInfoCreateFlags
    ): AppInfo;
    /**
     * Gets a list of all of the applications currently registered
     * on this system.
     *
     * For desktop files, this includes applications that have
     * `NoDisplay=true` set or are excluded from display by means
     * of `OnlyShowIn` or `NotShowIn`. See g_app_info_should_show().
     * The returned list does not include applications which have
     * the `Hidden` key set.
     * @returns a newly allocated #GList of references to #GAppInfos.
     */
    function app_info_get_all(): AppInfo[];
    /**
     * Gets a list of all #GAppInfos for a given content type,
     * including the recommended and fallback #GAppInfos. See
     * g_app_info_get_recommended_for_type() and
     * g_app_info_get_fallback_for_type().
     * @param content_type the content type to find a #GAppInfo for
     * @returns #GList of #GAppInfos     for given @content_type or %NULL on error.
     */
    function app_info_get_all_for_type(content_type: string | null): AppInfo[];
    /**
     * Gets the default #GAppInfo for a given content type.
     * @param content_type the content type to find a #GAppInfo for
     * @param must_support_uris if %TRUE, the #GAppInfo is expected to     support URIs
     * @returns #GAppInfo for given @content_type or     %NULL on error.
     */
    function app_info_get_default_for_type(
        content_type: string | null,
        must_support_uris: boolean
    ): AppInfo | null;
    /**
     * Asynchronously gets the default #GAppInfo for a given content type.
     * @param content_type the content type to find a #GAppInfo for
     * @param must_support_uris if %TRUE, the #GAppInfo is expected to     support URIs
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call when the request is done
     */
    function app_info_get_default_for_type_async<Z = unknown>(
        content_type: string | null,
        must_support_uris: boolean,
        cancellable: Cancellable | null,
        callback: AsyncReadyCallback<Z> | null
    ): void;

    // Overloads of app_info_get_default_for_type_async

    /**
     * Promisified version of {@link app_info_get_default_for_type_async}
     *
     * Asynchronously gets the default #GAppInfo for a given content type.
     * @param content_type the content type to find a #GAppInfo for
     * @param must_support_uris if %TRUE, the #GAppInfo is expected to     support URIs
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @returns A Promise of: #GAppInfo for given @content_type or     %NULL on error.
     */
    function app_info_get_default_for_type_async<Z = unknown>(
        content_type: string | null,
        must_support_uris: boolean,
        cancellable: Cancellable | null
    ): globalThis.Promise<AppInfo>;
    /**
     * Finishes a default #GAppInfo lookup started by
     * g_app_info_get_default_for_type_async().
     *
     * If no #GAppInfo is found, then `error` will be set to %G_IO_ERROR_NOT_FOUND.
     * @param result a #GAsyncResult
     * @returns #GAppInfo for given @content_type or     %NULL on error.
     */
    function app_info_get_default_for_type_finish(result: AsyncResult): AppInfo;
    /**
     * Gets the default application for handling URIs with
     * the given URI scheme. A URI scheme is the initial part
     * of the URI, up to but not including the ':', e.g. "http",
     * "ftp" or "sip".
     * @param uri_scheme a string containing a URI scheme.
     * @returns #GAppInfo for given @uri_scheme or     %NULL on error.
     */
    function app_info_get_default_for_uri_scheme(
        uri_scheme: string | null
    ): AppInfo | null;
    /**
     * Asynchronously gets the default application for handling URIs with
     * the given URI scheme. A URI scheme is the initial part
     * of the URI, up to but not including the ':', e.g. "http",
     * "ftp" or "sip".
     * @param uri_scheme a string containing a URI scheme.
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call when the request is done
     */
    function app_info_get_default_for_uri_scheme_async<Z = unknown>(
        uri_scheme: string | null,
        cancellable: Cancellable | null,
        callback: AsyncReadyCallback<Z> | null
    ): void;

    // Overloads of app_info_get_default_for_uri_scheme_async

    /**
     * Promisified version of {@link app_info_get_default_for_uri_scheme_async}
     *
     * Asynchronously gets the default application for handling URIs with
     * the given URI scheme. A URI scheme is the initial part
     * of the URI, up to but not including the ':', e.g. "http",
     * "ftp" or "sip".
     * @param uri_scheme a string containing a URI scheme.
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @returns A Promise of: #GAppInfo for given @uri_scheme or     %NULL on error.
     */
    function app_info_get_default_for_uri_scheme_async<Z = unknown>(
        uri_scheme: string | null,
        cancellable: Cancellable | null
    ): globalThis.Promise<AppInfo>;
    /**
     * Finishes a default #GAppInfo lookup started by
     * g_app_info_get_default_for_uri_scheme_async().
     *
     * If no #GAppInfo is found, then `error` will be set to %G_IO_ERROR_NOT_FOUND.
     * @param result a #GAsyncResult
     * @returns #GAppInfo for given @uri_scheme or     %NULL on error.
     */
    function app_info_get_default_for_uri_scheme_finish(
        result: AsyncResult
    ): AppInfo;
    /**
     * Gets a list of fallback #GAppInfos for a given content type, i.e.
     * those applications which claim to support the given content type
     * by MIME type subclassing and not directly.
     * @param content_type the content type to find a #GAppInfo for
     * @returns #GList of #GAppInfos     for given @content_type or %NULL on error.
     */
    function app_info_get_fallback_for_type(
        content_type: string | null
    ): AppInfo[];
    /**
     * Gets a list of recommended #GAppInfos for a given content type, i.e.
     * those applications which claim to support the given content type exactly,
     * and not by MIME type subclassing.
     * Note that the first application of the list is the last used one, i.e.
     * the last one for which g_app_info_set_as_last_used_for_type() has been
     * called.
     * @param content_type the content type to find a #GAppInfo for
     * @returns #GList of #GAppInfos     for given @content_type or %NULL on error.
     */
    function app_info_get_recommended_for_type(
        content_type: string | null
    ): AppInfo[];
    /**
     * Utility function that launches the default application
     * registered to handle the specified uri. Synchronous I/O
     * is done on the uri to detect the type of the file if
     * required.
     *
     * The D-Busactivated applications don't have to be started if your application
     * terminates too soon after this function. To prevent this, use
     * g_app_info_launch_default_for_uri_async() instead.
     * @param uri the uri to show
     * @param context an optional #GAppLaunchContext
     * @returns %TRUE on success, %FALSE on error.
     */
    function app_info_launch_default_for_uri(
        uri: string | null,
        context: AppLaunchContext | null
    ): boolean;
    /**
     * Async version of g_app_info_launch_default_for_uri().
     *
     * This version is useful if you are interested in receiving
     * error information in the case where the application is
     * sandboxed and the portal may present an application chooser
     * dialog to the user.
     *
     * This is also useful if you want to be sure that the D-Busactivated
     * applications are really started before termination and if you are interested
     * in receiving error information from their activation.
     * @param uri the uri to show
     * @param context an optional #GAppLaunchContext
     * @param cancellable a #GCancellable
     * @param callback a #GAsyncReadyCallback to call when the request is done
     */
    function app_info_launch_default_for_uri_async<Z = unknown>(
        uri: string | null,
        context: AppLaunchContext | null,
        cancellable: Cancellable | null,
        callback: AsyncReadyCallback<Z> | null
    ): void;

    // Overloads of app_info_launch_default_for_uri_async

    /**
     * Promisified version of {@link app_info_launch_default_for_uri_async}
     *
     * Async version of g_app_info_launch_default_for_uri().
     *
     * This version is useful if you are interested in receiving
     * error information in the case where the application is
     * sandboxed and the portal may present an application chooser
     * dialog to the user.
     *
     * This is also useful if you want to be sure that the D-Busactivated
     * applications are really started before termination and if you are interested
     * in receiving error information from their activation.
     * @param uri the uri to show
     * @param context an optional #GAppLaunchContext
     * @param cancellable a #GCancellable
     * @returns A Promise of: %TRUE if the launch was successful, %FALSE if @error is set
     */
    function app_info_launch_default_for_uri_async<Z = unknown>(
        uri: string | null,
        context: AppLaunchContext | null,
        cancellable: Cancellable | null
    ): globalThis.Promise<boolean>;
    /**
     * Finishes an asynchronous launch-default-for-uri operation.
     * @param result a #GAsyncResult
     * @returns %TRUE if the launch was successful, %FALSE if @error is set
     */
    function app_info_launch_default_for_uri_finish(
        result: AsyncResult
    ): boolean;
    /**
     * Removes all changes to the type associations done by
     * g_app_info_set_as_default_for_type(),
     * g_app_info_set_as_default_for_extension(),
     * g_app_info_add_supports_type() or
     * g_app_info_remove_supports_type().
     * @param content_type a content type
     */
    function app_info_reset_type_associations(
        content_type: string | null
    ): void;
    /**
     * Helper function for constructing #GAsyncInitable object. This is
     * similar to g_object_newv() but also initializes the object asynchronously.
     *
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_new_finish() to get the new object and check
     * for any errors.
     * @param object_type a #GType supporting #GAsyncInitable.
     * @param n_parameters the number of parameters in `parameters`
     * @param parameters the parameters to use to construct the object
     * @param io_priority the [I/O priority][io-priority] of the operation
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback to call when the initialization is     finished
     */
    function async_initable_newv_async<Z = unknown>(
        object_type: GObject.GType,
        n_parameters: number,
        parameters: GObject.Parameter,
        io_priority: number,
        cancellable: Cancellable | null,
        callback: AsyncReadyCallback<Z> | null
    ): void;
    /**
     * Asynchronously connects to the message bus specified by `bus_type`.
     *
     * When the operation is finished, `callback` will be invoked. You can
     * then call g_bus_get_finish() to get the result of the operation.
     *
     * This is an asynchronous failable function. See g_bus_get_sync() for
     * the synchronous version.
     * @param bus_type a #GBusType
     * @param cancellable a #GCancellable or %NULL
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied
     */
    function bus_get<Z = unknown>(
        bus_type: BusType,
        cancellable: Cancellable | null,
        callback: AsyncReadyCallback<Z> | null
    ): void;
    /**
     * Finishes an operation started with g_bus_get().
     *
     * The returned object is a singleton, that is, shared with other
     * callers of g_bus_get() and g_bus_get_sync() for `bus_type`. In the
     * event that you need a private message bus connection, use
     * g_dbus_address_get_for_bus_sync() and
     * g_dbus_connection_new_for_address() with
     * G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT and
     * G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION flags.
     *
     * Note that the returned #GDBusConnection object will (usually) have
     * the #GDBusConnection:exit-on-close property set to %TRUE.
     * @param res a #GAsyncResult obtained from the #GAsyncReadyCallback passed     to g_bus_get()
     * @returns a #GDBusConnection or %NULL if @error is set.     Free with g_object_unref().
     */
    function bus_get_finish(res: AsyncResult): DBusConnection;
    /**
     * Synchronously connects to the message bus specified by `bus_type`.
     * Note that the returned object may shared with other callers,
     * e.g. if two separate parts of a process calls this function with
     * the same `bus_type,` they will share the same object.
     *
     * This is a synchronous failable function. See g_bus_get() and
     * g_bus_get_finish() for the asynchronous version.
     *
     * The returned object is a singleton, that is, shared with other
     * callers of g_bus_get() and g_bus_get_sync() for `bus_type`. In the
     * event that you need a private message bus connection, use
     * g_dbus_address_get_for_bus_sync() and
     * g_dbus_connection_new_for_address() with
     * G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT and
     * G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION flags.
     *
     * Note that the returned #GDBusConnection object will (usually) have
     * the #GDBusConnection:exit-on-close property set to %TRUE.
     * @param bus_type a #GBusType
     * @param cancellable a #GCancellable or %NULL
     * @returns a #GDBusConnection or %NULL if @error is set.     Free with g_object_unref().
     */
    function bus_get_sync(
        bus_type: BusType,
        cancellable: Cancellable | null
    ): DBusConnection;
    /**
     * Version of g_bus_own_name_on_connection() using closures instead of
     * callbacks for easier binding in other languages.
     * @param connection a #GDBusConnection
     * @param name the well-known name to own
     * @param flags a set of flags from the #GBusNameOwnerFlags enumeration
     * @param name_acquired_closure #GClosure to invoke when `name` is     acquired or %NULL
     * @param name_lost_closure #GClosure to invoke when `name` is lost     or %NULL
     * @returns an identifier (never 0) that can be used with     g_bus_unown_name() to stop owning the name.
     */
    function bus_own_name_on_connection(
        connection: DBusConnection,
        name: string | null,
        flags: BusNameOwnerFlags,
        name_acquired_closure: GObject.TClosure | null,
        name_lost_closure: GObject.TClosure | null
    ): number;
    /**
     * Version of g_bus_own_name() using closures instead of callbacks for
     * easier binding in other languages.
     * @param bus_type the type of bus to own a name on
     * @param name the well-known name to own
     * @param flags a set of flags from the #GBusNameOwnerFlags enumeration
     * @param bus_acquired_closure #GClosure to invoke when connected to     the bus of type `bus_type` or %NULL
     * @param name_acquired_closure #GClosure to invoke when `name` is     acquired or %NULL
     * @param name_lost_closure #GClosure to invoke when `name` is lost or     %NULL
     * @returns an identifier (never 0) that can be used with     g_bus_unown_name() to stop owning the name.
     */
    function bus_own_name(
        bus_type: BusType,
        name: string | null,
        flags: BusNameOwnerFlags,
        bus_acquired_closure: GObject.TClosure | null,
        name_acquired_closure: GObject.TClosure | null,
        name_lost_closure: GObject.TClosure | null
    ): number;
    /**
     * Stops owning a name.
     *
     * Note that there may still be D-Bus traffic to process (relating to owning
     * and unowning the name) in the current thread-default #GMainContext after
     * this function has returned. You should continue to iterate the #GMainContext
     * until the #GDestroyNotify function passed to g_bus_own_name() is called, in
     * order to avoid memory leaks through callbacks queued on the #GMainContext
     * after its stopped being iterated.
     * @param owner_id an identifier obtained from g_bus_own_name()
     */
    function bus_unown_name(owner_id: number): void;
    /**
     * Stops watching a name.
     *
     * Note that there may still be D-Bus traffic to process (relating to watching
     * and unwatching the name) in the current thread-default #GMainContext after
     * this function has returned. You should continue to iterate the #GMainContext
     * until the #GDestroyNotify function passed to g_bus_watch_name() is called, in
     * order to avoid memory leaks through callbacks queued on the #GMainContext
     * after its stopped being iterated.
     * @param watcher_id An identifier obtained from g_bus_watch_name()
     */
    function bus_unwatch_name(watcher_id: number): void;
    /**
     * Version of g_bus_watch_name_on_connection() using closures instead of callbacks for
     * easier binding in other languages.
     * @param connection A #GDBusConnection.
     * @param name The name (well-known or unique) to watch.
     * @param flags Flags from the #GBusNameWatcherFlags enumeration.
     * @param name_appeared_closure #GClosure to invoke when `name` is known to exist or %NULL.
     * @param name_vanished_closure #GClosure to invoke when `name` is known to not exist or %NULL.
     * @returns An identifier (never 0) that can be used with g_bus_unwatch_name() to stop watching the name.
     */
    function bus_watch_name_on_connection(
        connection: DBusConnection,
        name: string | null,
        flags: BusNameWatcherFlags,
        name_appeared_closure: GObject.TClosure | null,
        name_vanished_closure: GObject.TClosure | null
    ): number;
    /**
     * Version of g_bus_watch_name() using closures instead of callbacks for
     * easier binding in other languages.
     * @param bus_type The type of bus to watch a name on.
     * @param name The name (well-known or unique) to watch.
     * @param flags Flags from the #GBusNameWatcherFlags enumeration.
     * @param name_appeared_closure #GClosure to invoke when `name` is known to exist or %NULL.
     * @param name_vanished_closure #GClosure to invoke when `name` is known to not exist or %NULL.
     * @returns An identifier (never 0) that can be used with g_bus_unwatch_name() to stop watching the name.
     */
    function bus_watch_name(
        bus_type: BusType,
        name: string | null,
        flags: BusNameWatcherFlags,
        name_appeared_closure: GObject.TClosure | null,
        name_vanished_closure: GObject.TClosure | null
    ): number;
    /**
     * Checks if a content type can be executable. Note that for instance
     * things like text files can be executables (i.e. scripts and batch files).
     * @param type a content type string
     * @returns %TRUE if the file type corresponds to a type that     can be executable, %FALSE otherwise.
     */
    function content_type_can_be_executable(type: string | null): boolean;
    /**
     * Compares two content types for equality.
     * @param type1 a content type string
     * @param type2 a content type string
     * @returns %TRUE if the two strings are identical or equivalent,     %FALSE otherwise.
     */
    function content_type_equals(
        type1: string | null,
        type2: string | null
    ): boolean;
    /**
     * Tries to find a content type based on the mime type name.
     * @param mime_type a mime type string
     * @returns Newly allocated string with content type or     %NULL. Free with g_free()
     */
    function content_type_from_mime_type(
        mime_type: string | null
    ): string | null;
    /**
     * Gets the human readable description of the content type.
     * @param type a content type string
     * @returns a short description of the content type @type. Free the     returned string with g_free()
     */
    function content_type_get_description(type: string | null): string | null;
    /**
     * Gets the generic icon name for a content type.
     *
     * See the
     * [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
     * specification for more on the generic icon name.
     * @param type a content type string
     * @returns the registered generic icon name for the given @type,     or %NULL if unknown. Free with g_free()
     */
    function content_type_get_generic_icon_name(
        type: string | null
    ): string | null;
    /**
     * Gets the icon for a content type.
     * @param type a content type string
     * @returns #GIcon corresponding to the content type. Free the returned     object with g_object_unref()
     */
    function content_type_get_icon(type: string | null): Icon;
    /**
     * Get the list of directories which MIME data is loaded from. See
     * g_content_type_set_mime_dirs() for details.
     * @returns %NULL-terminated list of    directories to load MIME data from, including any `mime/` subdirectory,    and with the first directory to try listed first
     */
    function content_type_get_mime_dirs(): string[];
    /**
     * Gets the mime type for the content type, if one is registered.
     * @param type a content type string
     * @returns the registered mime type for the     given @type, or %NULL if unknown; free with g_free().
     */
    function content_type_get_mime_type(type: string | null): string | null;
    /**
     * Gets the symbolic icon for a content type.
     * @param type a content type string
     * @returns symbolic #GIcon corresponding to the content type.     Free the returned object with g_object_unref()
     */
    function content_type_get_symbolic_icon(type: string | null): Icon;
    /**
     * Guesses the content type based on example data. If the function is
     * uncertain, `result_uncertain` will be set to %TRUE. Either `filename`
     * or `data` may be %NULL, in which case the guess will be based solely
     * on the other argument.
     * @param filename a path, or %NULL
     * @param data a stream of data, or %NULL
     * @returns a string indicating a guessed content type for the     given data. Free with g_free()
     */
    function content_type_guess(
        filename: string | null,
        data: Uint8Array | null
    ): [/* returnType */ string | null, /* result_uncertain */ boolean];
    /**
     * Tries to guess the type of the tree with root `root,` by
     * looking at the files it contains. The result is an array
     * of content types, with the best guess coming first.
     *
     * The types returned all have the form x-content/foo, e.g.
     * x-content/audio-cdda (for audio CDs) or x-content/image-dcf
     * (for a camera memory card). See the
     * [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
     * specification for more on x-content types.
     *
     * This function is useful in the implementation of
     * g_mount_guess_content_type().
     * @param root the root of the tree to guess a type for
     * @returns an %NULL-terminated     array of zero or more content types. Free with g_strfreev()
     */
    function content_type_guess_for_tree(root: File): string[];
    /**
     * Determines if `type` is a subset of `supertype`.
     * @param type a content type string
     * @param supertype a content type string
     * @returns %TRUE if @type is a kind of @supertype,     %FALSE otherwise.
     */
    function content_type_is_a(
        type: string | null,
        supertype: string | null
    ): boolean;
    /**
     * Determines if `type` is a subset of `mime_type`.
     * Convenience wrapper around g_content_type_is_a().
     * @param type a content type string
     * @param mime_type a mime type string
     * @returns %TRUE if @type is a kind of @mime_type,     %FALSE otherwise.
     */
    function content_type_is_mime_type(
        type: string | null,
        mime_type: string | null
    ): boolean;
    /**
     * Checks if the content type is the generic "unknown" type.
     * On UNIX this is the "application/octet-stream" mimetype,
     * while on win32 it is "*" and on OSX it is a dynamic type
     * or octet-stream.
     * @param type a content type string
     * @returns %TRUE if the type is the unknown type.
     */
    function content_type_is_unknown(type: string | null): boolean;
    /**
     * Set the list of directories used by GIO to load the MIME database.
     * If `dirs` is %NULL, the directories used are the default:
     *
     *  - the `mime` subdirectory of the directory in `$XDG_DATA_HOME`
     *  - the `mime` subdirectory of every directory in `$XDG_DATA_DIRS`
     *
     * This function is intended to be used when writing tests that depend on
     * information stored in the MIME database, in order to control the data.
     *
     * Typically, in case your tests use %G_TEST_OPTION_ISOLATE_DIRS, but they
     * depend on the systems MIME database, you should call this function
     * with `dirs` set to %NULL before calling g_test_init(), for instance:
     *
     *
     * ```c
     *   // Load MIME data from the system
     *   g_content_type_set_mime_dirs (NULL);
     *   // Isolate the environment
     *   g_test_init (&argc, &argv, G_TEST_OPTION_ISOLATE_DIRS, NULL);
     *
     *   
     *
     *   return g_test_run ();
     * ```
     *
     * @param dirs %NULL-terminated list of    directories to load MIME data from, including any `mime/` subdirectory,    and with the first directory to try listed first
     */
    function content_type_set_mime_dirs(dirs: string[] | null): void;
    /**
     * Gets a list of strings containing all the registered content types
     * known to the system. The list and its data should be freed using
     * `g_list_free_full (list, g_free)`.
     * @returns list of the registered     content types
     */
    function content_types_get_registered(): string[];
    /**
     * Escape `string` so it can appear in a D-Bus address as the value
     * part of a key-value pair.
     *
     * For instance, if `string` is `/run/bus-for-:0`,
     * this function would return `/run/bus-for-%3A0`,
     * which could be used in a D-Bus address like
     * `unix:nonce-tcp:host=127.0.0.1,port=42,noncefile=/run/bus-for-%3A0`.
     * @param string an unescaped string to be included in a D-Bus address     as the value in a key-value pair
     * @returns a copy of @string with all     non-optionally-escaped bytes escaped
     */
    function dbus_address_escape_value(string: string | null): string | null;
    /**
     * Synchronously looks up the D-Bus address for the well-known message
     * bus instance specified by `bus_type`. This may involve using various
     * platform specific mechanisms.
     *
     * The returned address will be in the
     * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
     * @param bus_type a #GBusType
     * @param cancellable a #GCancellable or %NULL
     * @returns a valid D-Bus address string for @bus_type or     %NULL if @error is set
     */
    function dbus_address_get_for_bus_sync(
        bus_type: BusType,
        cancellable: Cancellable | null
    ): string | null;
    /**
     * Asynchronously connects to an endpoint specified by `address` and
     * sets up the connection so it is in a state to run the client-side
     * of the D-Bus authentication conversation. `address` must be in the
     * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
     *
     * When the operation is finished, `callback` will be invoked. You can
     * then call g_dbus_address_get_stream_finish() to get the result of
     * the operation.
     *
     * This is an asynchronous failable function. See
     * g_dbus_address_get_stream_sync() for the synchronous version.
     * @param address A valid D-Bus address.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    function dbus_address_get_stream<Z = unknown>(
        address: string | null,
        cancellable: Cancellable | null,
        callback: AsyncReadyCallback<Z> | null
    ): void;
    /**
     * Finishes an operation started with g_dbus_address_get_stream().
     *
     * A server is not required to set a GUID, so `out_guid` may be set to %NULL
     * even on success.
     * @param res A #GAsyncResult obtained from the GAsyncReadyCallback passed to g_dbus_address_get_stream().
     * @returns A #GIOStream or %NULL if @error is set.
     */
    function dbus_address_get_stream_finish(
        res: AsyncResult
    ): [/* returnType */ IOStream, /* out_guid */ string | null];
    /**
     * Synchronously connects to an endpoint specified by `address` and
     * sets up the connection so it is in a state to run the client-side
     * of the D-Bus authentication conversation. `address` must be in the
     * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
     *
     * A server is not required to set a GUID, so `out_guid` may be set to %NULL
     * even on success.
     *
     * This is a synchronous failable function. See
     * g_dbus_address_get_stream() for the asynchronous version.
     * @param address A valid D-Bus address.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GIOStream or %NULL if @error is set.
     */
    function dbus_address_get_stream_sync(
        address: string | null,
        cancellable: Cancellable | null
    ): [/* returnType */ IOStream, /* out_guid */ string | null];
    /**
     * Looks up the value of an annotation.
     *
     * The cost of this function is O(n) in number of annotations.
     * @param annotations A %NULL-terminated array of annotations or %NULL.
     * @param name The name of the annotation to look up.
     * @returns The value or %NULL if not found. Do not free, it is owned by @annotations.
     */
    function dbus_annotation_info_lookup(
        annotations: DBusAnnotationInfo[] | null,
        name: string | null
    ): string | null;
    /**
     * Creates a D-Bus error name to use for `error`. If `error` matches
     * a registered error (cf. g_dbus_error_register_error()), the corresponding
     * D-Bus error name will be returned.
     *
     * Otherwise the a name of the form
     * `org.gtk.GDBus.UnmappedGError.Quark._ESCAPED_QUARK_NAME.Code_ERROR_CODE`
     * will be used. This allows other GDBus applications to map the error
     * on the wire back to a #GError using g_dbus_error_new_for_dbus_error().
     *
     * This function is typically only used in object mappings to put a
     * #GError on the wire. Regular applications should not use it.
     * @param error A #GError.
     * @returns A D-Bus error name (never %NULL).     Free with g_free().
     */
    function dbus_error_encode_gerror(error: GLib.Error): string | null;
    /**
     * Gets the D-Bus error name used for `error,` if any.
     *
     * This function is guaranteed to return a D-Bus error name for all
     * #GErrors returned from functions handling remote method calls
     * (e.g. g_dbus_connection_call_finish()) unless
     * g_dbus_error_strip_remote_error() has been used on `error`.
     * @param error a #GError
     * @returns an allocated string or %NULL if the     D-Bus error name could not be found. Free with g_free().
     */
    function dbus_error_get_remote_error(error: GLib.Error): string | null;
    /**
     * Checks if `error` represents an error received via D-Bus from a remote peer. If so,
     * use g_dbus_error_get_remote_error() to get the name of the error.
     * @param error A #GError.
     * @returns %TRUE if @error represents an error from a remote peer, %FALSE otherwise.
     */
    function dbus_error_is_remote_error(error: GLib.Error): boolean;
    /**
     * Creates a #GError based on the contents of `dbus_error_name` and
     * `dbus_error_message`.
     *
     * Errors registered with g_dbus_error_register_error() will be looked
     * up using `dbus_error_name` and if a match is found, the error domain
     * and code is used. Applications can use g_dbus_error_get_remote_error()
     * to recover `dbus_error_name`.
     *
     * If a match against a registered error is not found and the D-Bus
     * error name is in a form as returned by g_dbus_error_encode_gerror()
     * the error domain and code encoded in the name is used to
     * create the #GError. Also, `dbus_error_name` is added to the error message
     * such that it can be recovered with g_dbus_error_get_remote_error().
     *
     * Otherwise, a #GError with the error code %G_IO_ERROR_DBUS_ERROR
     * in the %G_IO_ERROR error domain is returned. Also, `dbus_error_name` is
     * added to the error message such that it can be recovered with
     * g_dbus_error_get_remote_error().
     *
     * In all three cases, `dbus_error_name` can always be recovered from the
     * returned #GError using the g_dbus_error_get_remote_error() function
     * (unless g_dbus_error_strip_remote_error() hasn't been used on the returned error).
     *
     * This function is typically only used in object mappings to prepare
     * #GError instances for applications. Regular applications should not use
     * it.
     * @param dbus_error_name D-Bus error name.
     * @param dbus_error_message D-Bus error message.
     * @returns An allocated #GError. Free with g_error_free().
     */
    function dbus_error_new_for_dbus_error(
        dbus_error_name: string | null,
        dbus_error_message: string | null
    ): GLib.Error;
    function dbus_error_quark(): GLib.Quark;
    /**
     * Creates an association to map between `dbus_error_name` and
     * #GErrors specified by `error_domain` and `error_code`.
     *
     * This is typically done in the routine that returns the #GQuark for
     * an error domain.
     * @param error_domain A #GQuark for an error domain.
     * @param error_code An error code.
     * @param dbus_error_name A D-Bus error name.
     * @returns %TRUE if the association was created, %FALSE if it already exists.
     */
    function dbus_error_register_error(
        error_domain: GLib.Quark,
        error_code: number,
        dbus_error_name: string | null
    ): boolean;
    /**
     * Helper function for associating a #GError error domain with D-Bus error names.
     *
     * While `quark_volatile` has a `volatile` qualifier, this is a historical
     * artifact and the argument passed to it should not be `volatile`.
     * @param error_domain_quark_name The error domain name.
     * @param quark_volatile A pointer where to store the #GQuark.
     * @param entries A pointer to `num_entries` #GDBusErrorEntry struct items.
     */
    function dbus_error_register_error_domain(
        error_domain_quark_name: string | null,
        quark_volatile: number,
        entries: DBusErrorEntry[]
    ): void;
    /**
     * Looks for extra information in the error message used to recover
     * the D-Bus error name and strips it if found. If stripped, the
     * message field in `error` will correspond exactly to what was
     * received on the wire.
     *
     * This is typically used when presenting errors to the end user.
     * @param error A #GError.
     * @returns %TRUE if information was stripped, %FALSE otherwise.
     */
    function dbus_error_strip_remote_error(error: GLib.Error): boolean;
    /**
     * Destroys an association previously set up with g_dbus_error_register_error().
     * @param error_domain A #GQuark for an error domain.
     * @param error_code An error code.
     * @param dbus_error_name A D-Bus error name.
     * @returns %TRUE if the association was destroyed, %FALSE if it wasn't found.
     */
    function dbus_error_unregister_error(
        error_domain: GLib.Quark,
        error_code: number,
        dbus_error_name: string | null
    ): boolean;
    /**
     * This is a language binding friendly version of g_dbus_escape_object_path_bytestring().
     * @param s the string to escape
     * @returns an escaped version of @s. Free with g_free().
     */
    function dbus_escape_object_path(s: string | null): string | null;
    /**
     * Escapes `bytes` for use in a D-Bus object path component.
     * `bytes` is an array of zero or more nonzero bytes in an
     * unspecified encoding, followed by a single zero byte.
     *
     * The escaping method consists of replacing all non-alphanumeric
     * characters (see g_ascii_isalnum()) with their hexadecimal value
     * preceded by an underscore (`_`). For example:
     * `foo.bar.baz` will become `foo_2ebar_2ebaz`.
     *
     * This method is appropriate to use when the input is nearly
     * a valid object path component but is not when your input
     * is far from being a valid object path component.
     * Other escaping algorithms are also valid to use with
     * D-Bus object paths.
     *
     * This can be reversed with g_dbus_unescape_object_path().
     * @param bytes the string of bytes to escape
     * @returns an escaped version of @bytes. Free with g_free().
     */
    function dbus_escape_object_path_bytestring(
        bytes: Uint8Array
    ): string | null;
    /**
     * Generate a D-Bus GUID that can be used with
     * e.g. g_dbus_connection_new().
     *
     * See the
     * [D-Bus specification](https://dbus.freedesktop.org/doc/dbus-specification.html#uuids)
     * regarding what strings are valid D-Bus GUIDs. The specification refers to
     * these as UUIDs whereas GLib (for historical reasons) refers to them as
     * GUIDs. The terms are interchangeable.
     *
     * Note that D-Bus GUIDs do not follow
     * [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122).
     * @returns A valid D-Bus GUID. Free with g_free().
     */
    function dbus_generate_guid(): string | null;
    /**
     * Converts a #GValue to a #GVariant of the type indicated by the `type`
     * parameter.
     *
     * The conversion is using the following rules:
     *
     * - `G_TYPE_STRING`: 's', 'o', 'g' or 'ay'
     * - `G_TYPE_STRV`: 'as', 'ao' or 'aay'
     * - `G_TYPE_BOOLEAN`: 'b'
     * - `G_TYPE_UCHAR`: 'y'
     * - `G_TYPE_INT`: 'i', 'n'
     * - `G_TYPE_UINT`: 'u', 'q'
     * - `G_TYPE_INT64`: 'x'
     * - `G_TYPE_UINT64`: 't'
     * - `G_TYPE_DOUBLE`: 'd'
     * - `G_TYPE_VARIANT`: Any #GVariantType
     *
     * This can fail if e.g. `gvalue` is of type %G_TYPE_STRING and `type`
     * is 'i', i.e. %G_VARIANT_TYPE_INT32. It will also fail for any #GType
     * (including e.g. %G_TYPE_OBJECT and %G_TYPE_BOXED derived-types) not
     * in the table above.
     *
     * Note that if `gvalue` is of type %G_TYPE_VARIANT and its value is
     * %NULL, the empty #GVariant instance (never %NULL) for `type` is
     * returned (e.g. 0 for scalar types, the empty string for string types,
     * '/' for object path types, the empty array for any array type and so on).
     *
     * See the g_dbus_gvariant_to_gvalue() function for how to convert a
     * #GVariant to a #GValue.
     * @param gvalue A #GValue to convert to a #GVariant
     * @param type A #GVariantType
     * @returns A #GVariant (never floating) of     #GVariantType @type holding the data from @gvalue or an empty #GVariant     in case of failure. Free with g_variant_unref().
     */
    function dbus_gvalue_to_gvariant(
        gvalue: any,
        type: GLib.VariantType
    ): GLib.Variant;
    /**
     * Converts a #GVariant to a #GValue. If `value` is floating, it is consumed.
     *
     * The rules specified in the g_dbus_gvalue_to_gvariant() function are
     * used - this function is essentially its reverse form. So, a #GVariant
     * containing any basic or string array type will be converted to a #GValue
     * containing a basic value or string array. Any other #GVariant (handle,
     * variant, tuple, dict entry) will be converted to a #GValue containing that
     * #GVariant.
     *
     * The conversion never fails - a valid #GValue is always returned in
     * `out_gvalue`.
     * @param value A #GVariant.
     */
    function dbus_gvariant_to_gvalue(value: GLib.Variant): /* out_gvalue */ any;
    /**
     * Checks if `string` is a
     * [D-Bus address](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
     *
     * This doesn't check if `string` is actually supported by #GDBusServer
     * or #GDBusConnection - use g_dbus_is_supported_address() to do more
     * checks.
     * @param string A string.
     * @returns %TRUE if @string is a valid D-Bus address, %FALSE otherwise.
     */
    function dbus_is_address(string: string | null): boolean;
    /**
     * Check whether `string` is a valid D-Bus error name.
     *
     * This function returns the same result as g_dbus_is_interface_name(),
     * because D-Bus error names are defined to have exactly the
     * same syntax as interface names.
     * @param string The string to check.
     * @returns %TRUE if valid, %FALSE otherwise.
     */
    function dbus_is_error_name(string: string | null): boolean;
    /**
     * Checks if `string` is a D-Bus GUID.
     *
     * See the documentation for g_dbus_generate_guid() for more information about
     * the format of a GUID.
     * @param string The string to check.
     * @returns %TRUE if @string is a GUID, %FALSE otherwise.
     */
    function dbus_is_guid(string: string | null): boolean;
    /**
     * Checks if `string` is a valid D-Bus interface name.
     * @param string The string to check.
     * @returns %TRUE if valid, %FALSE otherwise.
     */
    function dbus_is_interface_name(string: string | null): boolean;
    /**
     * Checks if `string` is a valid D-Bus member (e.g. signal or method) name.
     * @param string The string to check.
     * @returns %TRUE if valid, %FALSE otherwise.
     */
    function dbus_is_member_name(string: string | null): boolean;
    /**
     * Checks if `string` is a valid D-Bus bus name (either unique or well-known).
     * @param string The string to check.
     * @returns %TRUE if valid, %FALSE otherwise.
     */
    function dbus_is_name(string: string | null): boolean;
    /**
     * Like g_dbus_is_address() but also checks if the library supports the
     * transports in `string` and that key/value pairs for each transport
     * are valid. See the specification of the
     * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
     * @param string A string.
     * @returns %TRUE if @string is a valid D-Bus address that is supported by this library, %FALSE if @error is set.
     */
    function dbus_is_supported_address(string: string | null): boolean;
    /**
     * Checks if `string` is a valid D-Bus unique bus name.
     * @param string The string to check.
     * @returns %TRUE if valid, %FALSE otherwise.
     */
    function dbus_is_unique_name(string: string | null): boolean;
    /**
     * Unescapes an string that was previously escaped with
     * g_dbus_escape_object_path(). If the string is in a format that could
     * not have been returned by g_dbus_escape_object_path(), this function
     * returns %NULL.
     *
     * Encoding alphanumeric characters which do not need to be
     * encoded is not allowed (e.g `_63` is not valid, the string
     * should contain `c` instead).
     * @param s the string to unescape
     * @returns an   unescaped version of @s, or %NULL if @s is not a string returned   from g_dbus_escape_object_path(). Free with g_free().
     */
    function dbus_unescape_object_path(s: string | null): Uint8Array | null;
    /**
     * Creates a new #GDtlsClientConnection wrapping `base_socket` which is
     * assumed to communicate with the server identified by `server_identity`.
     * @param base_socket the #GDatagramBased to wrap
     * @param server_identity the expected identity of the server
     * @returns the new   #GDtlsClientConnection, or %NULL on error
     */
    function dtls_client_connection_new(
        base_socket: DatagramBased,
        server_identity: SocketConnectable | null
    ): DtlsClientConnection;
    /**
     * Creates a new #GDtlsServerConnection wrapping `base_socket`.
     * @param base_socket the #GDatagramBased to wrap
     * @param certificate the default server certificate, or %NULL
     * @returns the new   #GDtlsServerConnection, or %NULL on error
     */
    function dtls_server_connection_new(
        base_socket: DatagramBased,
        certificate: TlsCertificate | null
    ): DtlsServerConnection;
    /**
     * Constructs a #GFile from a vector of elements using the correct
     * separator for filenames.
     *
     * Using this function is equivalent to calling g_build_filenamev(),
     * followed by g_file_new_for_path() on the result.
     * @param args %NULL-terminated   array of strings containing the path elements.
     * @returns a new #GFile
     */
    function file_new_build_filenamev(args: string[]): File;
    /**
     * Creates a #GFile with the given argument from the command line.
     * The value of `arg` can be either a URI, an absolute path or a
     * relative path resolved relative to the current working directory.
     * This operation never fails, but the returned object might not
     * support any I/O operation if `arg` points to a malformed path.
     *
     * Note that on Windows, this function expects its argument to be in
     * UTF-8 -- not the system code page.  This means that you
     * should not use this function with string from argv as it is passed
     * to main().  g_win32_get_command_line() will return a UTF-8 version of
     * the commandline.  #GApplication also uses UTF-8 but
     * g_application_command_line_create_file_for_arg() may be more useful
     * for you there.  It is also always possible to use this function with
     * #GOptionContext arguments of type %G_OPTION_ARG_FILENAME.
     * @param arg a command line string
     * @returns a new #GFile.   Free the returned object with g_object_unref().
     */
    function file_new_for_commandline_arg(arg: string): File;
    /**
     * Creates a #GFile with the given argument from the command line.
     *
     * This function is similar to g_file_new_for_commandline_arg() except
     * that it allows for passing the current working directory as an
     * argument instead of using the current working directory of the
     * process.
     *
     * This is useful if the commandline argument was given in a context
     * other than the invocation of the current process.
     *
     * See also g_application_command_line_create_file_for_arg().
     * @param arg a command line string
     * @param cwd the current working directory of the commandline
     * @returns a new #GFile
     */
    function file_new_for_commandline_arg_and_cwd(
        arg: string,
        cwd: string
    ): File;
    /**
     * Constructs a #GFile for a given path. This operation never
     * fails, but the returned object might not support any I/O
     * operation if `path` is malformed.
     * @param path a string containing a relative or absolute path.   The string must be encoded in the glib filename encoding.
     * @returns a new #GFile for the given @path.   Free the returned object with g_object_unref().
     */
    function file_new_for_path(path: string): File;
    /**
     * Constructs a #GFile for a given URI. This operation never
     * fails, but the returned object might not support any I/O
     * operation if `uri` is malformed or if the uri type is
     * not supported.
     * @param uri a UTF-8 string containing a URI
     * @returns a new #GFile for the given @uri.   Free the returned object with g_object_unref().
     */
    function file_new_for_uri(uri: string | null): File;
    /**
     * Opens a file in the preferred directory for temporary files (as
     * returned by g_get_tmp_dir()) and returns a #GFile and
     * #GFileIOStream pointing to it.
     *
     * `tmpl` should be a string in the GLib file name encoding
     * containing a sequence of six 'X' characters, and containing no
     * directory components. If it is %NULL, a default template is used.
     *
     * Unlike the other #GFile constructors, this will return %NULL if
     * a temporary file could not be created.
     * @param tmpl Template for the file   name, as in g_file_open_tmp(), or %NULL for a default template
     * @returns a new #GFile.   Free the returned object with g_object_unref().
     */
    function file_new_tmp(
        tmpl: string | null
    ): [/* returnType */ File, /* iostream */ FileIOStream];
    /**
     * Asynchronously opens a file in the preferred directory for temporary files
     *  (as returned by g_get_tmp_dir()) as g_file_new_tmp().
     *
     * `tmpl` should be a string in the GLib file name encoding
     * containing a sequence of six 'X' characters, and containing no
     * directory components. If it is %NULL, a default template is used.
     * @param tmpl Template for the file   name, as in g_file_open_tmp(), or %NULL for a default template
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call when the request is done
     */
    function file_new_tmp_async<Z = unknown>(
        tmpl: string | null,
        io_priority: number,
        cancellable: Cancellable | null,
        callback: AsyncReadyCallback<Z> | null
    ): void;

    // Overloads of file_new_tmp_async

    /**
     * Promisified version of {@link file_new_tmp_async}
     *
     * Asynchronously opens a file in the preferred directory for temporary files
     *  (as returned by g_get_tmp_dir()) as g_file_new_tmp().
     *
     * `tmpl` should be a string in the GLib file name encoding
     * containing a sequence of six 'X' characters, and containing no
     * directory components. If it is %NULL, a default template is used.
     * @param tmpl Template for the file   name, as in g_file_open_tmp(), or %NULL for a default template
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @returns A Promise of: a new #GFile.   Free the returned object with g_object_unref().
     */
    function file_new_tmp_async<Z = unknown>(
        tmpl: string | null,
        io_priority: number,
        cancellable: Cancellable | null
    ): globalThis.Promise</* iostream */ FileIOStream>;
    /**
     * Asynchronously creates a directory in the preferred directory for
     * temporary files (as returned by g_get_tmp_dir()) as g_dir_make_tmp().
     *
     * `tmpl` should be a string in the GLib file name encoding
     * containing a sequence of six 'X' characters, and containing no
     * directory components. If it is %NULL, a default template is used.
     * @param tmpl Template for the file   name, as in g_dir_make_tmp(), or %NULL for a default template
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call when the request is done
     */
    function file_new_tmp_dir_async<Z = unknown>(
        tmpl: string | null,
        io_priority: number,
        cancellable: Cancellable | null,
        callback: AsyncReadyCallback<Z> | null
    ): void;

    // Overloads of file_new_tmp_dir_async

    /**
     * Promisified version of {@link file_new_tmp_dir_async}
     *
     * Asynchronously creates a directory in the preferred directory for
     * temporary files (as returned by g_get_tmp_dir()) as g_dir_make_tmp().
     *
     * `tmpl` should be a string in the GLib file name encoding
     * containing a sequence of six 'X' characters, and containing no
     * directory components. If it is %NULL, a default template is used.
     * @param tmpl Template for the file   name, as in g_dir_make_tmp(), or %NULL for a default template
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @returns A Promise of: a new #GFile.   Free the returned object with g_object_unref().
     */
    function file_new_tmp_dir_async<Z = unknown>(
        tmpl: string | null,
        io_priority: number,
        cancellable: Cancellable | null
    ): globalThis.Promise<File>;
    /**
     * Finishes a temporary directory creation started by
     * g_file_new_tmp_dir_async().
     * @param result a #GAsyncResult
     * @returns a new #GFile.   Free the returned object with g_object_unref().
     */
    function file_new_tmp_dir_finish(result: AsyncResult): File;
    /**
     * Finishes a temporary file creation started by g_file_new_tmp_async().
     * @param result a #GAsyncResult
     * @returns a new #GFile.   Free the returned object with g_object_unref().
     */
    function file_new_tmp_finish(
        result: AsyncResult
    ): [/* returnType */ File, /* iostream */ FileIOStream];
    /**
     * Constructs a #GFile with the given `parse_name` (i.e. something
     * given by g_file_get_parse_name()). This operation never fails,
     * but the returned object might not support any I/O operation if
     * the `parse_name` cannot be parsed.
     * @param parse_name a file name or path to be parsed
     * @returns a new #GFile.
     */
    function file_parse_name(parse_name: string | null): File;
    /**
     * Deserializes a #GIcon previously serialized using g_icon_serialize().
     * @param value a #GVariant created with g_icon_serialize()
     * @returns a #GIcon, or %NULL when deserialization fails.
     */
    function icon_deserialize(value: GLib.Variant): Icon | null;
    /**
     * Generate a #GIcon instance from `str`. This function can fail if
     * `str` is not valid - see g_icon_to_string() for discussion.
     *
     * If your application or library provides one or more #GIcon
     * implementations you need to ensure that each #GType is registered
     * with the type system prior to calling g_icon_new_for_string().
     * @param str A string obtained via g_icon_to_string().
     * @returns An object implementing the #GIcon          interface or %NULL if @error is set.
     */
    function icon_new_for_string(str: string | null): Icon;
    /**
     * Helper function for constructing #GInitable object. This is
     * similar to g_object_newv() but also initializes the object
     * and returns %NULL, setting an error on failure.
     * @param object_type a #GType supporting #GInitable.
     * @param parameters the parameters to use to construct the object
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns a newly allocated      #GObject, or %NULL on error
     */
    function initable_newv(
        object_type: GObject.GType,
        parameters: GObject.Parameter[],
        cancellable: Cancellable | null
    ): GObject.Object;
    /**
     * Converts errno.h error codes into GIO error codes. The fallback
     * value %G_IO_ERROR_FAILED is returned for error codes not currently
     * handled (but note that future GLib releases may return a more
     * specific value instead).
     *
     * As %errno is global and may be modified by intermediate function
     * calls, you should save its value as soon as the call which sets it
     * @param err_no Error number as defined in errno.h.
     * @returns #GIOErrorEnum value for the given errno.h error number.
     */
    function io_error_from_errno(err_no: number): IOErrorEnum;
    /**
     * Converts #GFileError error codes into GIO error codes.
     * @param file_error a #GFileError.
     * @returns #GIOErrorEnum value for the given #GFileError error value.
     */
    function io_error_from_file_error(file_error: GLib.FileError): IOErrorEnum;
    /**
     * Gets the GIO Error Quark.
     * @returns a #GQuark.
     */
    function io_error_quark(): GLib.Quark;
    /**
     * Registers `type` as extension for the extension point with name
     * `extension_point_name`.
     *
     * If `type` has already been registered as an extension for this
     * extension point, the existing #GIOExtension object is returned.
     * @param extension_point_name the name of the extension point
     * @param type the #GType to register as extension
     * @param extension_name the name for the extension
     * @param priority the priority for the extension
     * @returns a #GIOExtension object for #GType
     */
    function io_extension_point_implement(
        extension_point_name: string | null,
        type: GObject.GType,
        extension_name: string | null,
        priority: number
    ): IOExtension;
    /**
     * Looks up an existing extension point.
     * @param name the name of the extension point
     * @returns the #GIOExtensionPoint, or %NULL if there    is no registered extension point with the given name.
     */
    function io_extension_point_lookup(name: string | null): IOExtensionPoint;
    /**
     * Registers an extension point.
     * @param name The name of the extension point
     * @returns the new #GIOExtensionPoint. This object is    owned by GIO and should not be freed.
     */
    function io_extension_point_register(name: string | null): IOExtensionPoint;
    /**
     * Loads all the modules in the specified directory.
     *
     * If don't require all modules to be initialized (and thus registering
     * all gtypes) then you can use g_io_modules_scan_all_in_directory()
     * which allows delayed/lazy loading of modules.
     * @param dirname pathname for a directory containing modules     to load.
     * @returns a list of #GIOModules loaded      from the directory,      All the modules are loaded into memory, if you want to      unload them (enabling on-demand loading) you must call      g_type_module_unuse() on all the modules. Free the list      with g_list_free().
     */
    function io_modules_load_all_in_directory(dirname: string): IOModule[];
    /**
     * Loads all the modules in the specified directory.
     *
     * If don't require all modules to be initialized (and thus registering
     * all gtypes) then you can use g_io_modules_scan_all_in_directory()
     * which allows delayed/lazy loading of modules.
     * @param dirname pathname for a directory containing modules     to load.
     * @param scope a scope to use when scanning the modules.
     * @returns a list of #GIOModules loaded      from the directory,      All the modules are loaded into memory, if you want to      unload them (enabling on-demand loading) you must call      g_type_module_unuse() on all the modules. Free the list      with g_list_free().
     */
    function io_modules_load_all_in_directory_with_scope(
        dirname: string,
        scope: IOModuleScope
    ): IOModule[];
    /**
     * Scans all the modules in the specified directory, ensuring that
     * any extension point implemented by a module is registered.
     *
     * This may not actually load and initialize all the types in each
     * module, some modules may be lazily loaded and initialized when
     * an extension point it implements is used with e.g.
     * g_io_extension_point_get_extensions() or
     * g_io_extension_point_get_extension_by_name().
     *
     * If you need to guarantee that all types are loaded in all the modules,
     * use g_io_modules_load_all_in_directory().
     * @param dirname pathname for a directory containing modules     to scan.
     */
    function io_modules_scan_all_in_directory(dirname: string): void;
    /**
     * Scans all the modules in the specified directory, ensuring that
     * any extension point implemented by a module is registered.
     *
     * This may not actually load and initialize all the types in each
     * module, some modules may be lazily loaded and initialized when
     * an extension point it implements is used with e.g.
     * g_io_extension_point_get_extensions() or
     * g_io_extension_point_get_extension_by_name().
     *
     * If you need to guarantee that all types are loaded in all the modules,
     * use g_io_modules_load_all_in_directory().
     * @param dirname pathname for a directory containing modules     to scan.
     * @param scope a scope to use when scanning the modules
     */
    function io_modules_scan_all_in_directory_with_scope(
        dirname: string,
        scope: IOModuleScope
    ): void;
    /**
     * Cancels all cancellable I/O jobs.
     *
     * A job is cancellable if a #GCancellable was passed into
     * g_io_scheduler_push_job().
     */
    function io_scheduler_cancel_all_jobs(): void;
    /**
     * Schedules the I/O job to run in another thread.
     *
     * `notify` will be called on `user_data` after `job_func` has returned,
     * regardless whether the job was cancelled or has run to completion.
     *
     * If `cancellable` is not %NULL, it can be used to cancel the I/O job
     * by calling g_cancellable_cancel() or by calling
     * g_io_scheduler_cancel_all_jobs().
     * @param job_func a #GIOSchedulerJobFunc.
     * @param io_priority the [I/O priority][io-priority] of the request.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     */
    function io_scheduler_push_job(
        job_func: IOSchedulerJobFunc,
        io_priority: number,
        cancellable: Cancellable | null
    ): void;
    /**
     * Creates a keyfile-backed #GSettingsBackend.
     *
     * The filename of the keyfile to use is given by `filename`.
     *
     * All settings read to or written from the backend must fall under the
     * path given in `root_path` (which must start and end with a slash and
     * not contain two consecutive slashes).  `root_path` may be "/".
     *
     * If `root_group` is non-%NULL then it specifies the name of the keyfile
     * group used for keys that are written directly below `root_path`.  For
     * example, if `root_path` is "/apps/example/" and `root_group` is
     * "toplevel", then settings the key "/apps/example/enabled" to a value
     * of %TRUE will cause the following to appear in the keyfile:
     *
     *
     * ```
     *   [toplevel]
     *   enabled=true
     * ```
     *
     *
     * If `root_group` is %NULL then it is not permitted to store keys
     * directly below the `root_path`.
     *
     * For keys not stored directly below `root_path` (ie: in a sub-path),
     * the name of the subpath (with the final slash stripped) is used as
     * the name of the keyfile group.  To continue the example, if
     * "/apps/example/profiles/default/font-size" were set to
     * 12 then the following would appear in the keyfile:
     *
     *
     * ```
     *   [profiles/default]
     *   font-size=12
     * ```
     *
     *
     * The backend will refuse writes (and return writability as being
     * %FALSE) for keys outside of `root_path` and, in the event that
     * `root_group` is %NULL, also for keys directly under `root_path`.
     * Writes will also be refused if the backend detects that it has the
     * inability to rewrite the keyfile (ie: the containing directory is not
     * writable).
     *
     * There is no checking done for your key namespace clashing with the
     * syntax of the key file format.  For example, if you have '[' or ']'
     * characters in your path names or '=' in your key names you may be in
     * trouble.
     *
     * The backend reads default values from a keyfile called `defaults` in
     * the directory specified by the #GKeyfileSettingsBackend:defaults-dir property,
     * and a list of locked keys from a text file with the name `locks` in
     * the same location.
     * @param filename the filename of the keyfile
     * @param root_path the path under which all settings keys appear
     * @param root_group the group name corresponding to              `root_path,` or %NULL
     * @returns a keyfile-backed #GSettingsBackend
     */
    function keyfile_settings_backend_new(
        filename: string | null,
        root_path: string | null,
        root_group: string | null
    ): SettingsBackend;
    /**
     * Gets a reference to the default #GMemoryMonitor for the system.
     * @returns a new reference to the default #GMemoryMonitor
     */
    function memory_monitor_dup_default(): MemoryMonitor;
    /**
     * Creates a memory-backed #GSettingsBackend.
     *
     * This backend allows changes to settings, but does not write them
     * to any backing storage, so the next time you run your application,
     * the memory backend will start out with the default values again.
     * @returns a newly created #GSettingsBackend
     */
    function memory_settings_backend_new(): SettingsBackend;
    /**
     * Gets the default #GNetworkMonitor for the system.
     * @returns a #GNetworkMonitor, which will be     a dummy object if no network monitor is available
     */
    function network_monitor_get_default(): NetworkMonitor;
    /**
     * Initializes the platform networking libraries (eg, on Windows, this
     * calls WSAStartup()). GLib will call this itself if it is needed, so
     * you only need to call it if you directly call system networking
     * functions (without calling any GLib networking functions first).
     */
    function networking_init(): void;
    /**
     * Creates a readonly #GSettingsBackend.
     *
     * This backend does not allow changes to settings, so all settings
     * will always have their default values.
     * @returns a newly created #GSettingsBackend
     */
    function null_settings_backend_new(): SettingsBackend;
    /**
     * Utility method for #GPollableInputStream and #GPollableOutputStream
     * implementations. Creates a new #GSource that expects a callback of
     * type #GPollableSourceFunc. The new source does not actually do
     * anything on its own; use g_source_add_child_source() to add other
     * sources to it to cause it to trigger.
     * @param pollable_stream the stream associated with the new source
     * @returns the new #GSource.
     */
    function pollable_source_new(pollable_stream: GObject.Object): GLib.Source;
    /**
     * Utility method for #GPollableInputStream and #GPollableOutputStream
     * implementations. Creates a new #GSource, as with
     * g_pollable_source_new(), but also attaching `child_source` (with a
     * dummy callback), and `cancellable,` if they are non-%NULL.
     * @param pollable_stream the stream associated with the   new source
     * @param child_source optional child source to attach
     * @param cancellable optional #GCancellable to attach
     * @returns the new #GSource.
     */
    function pollable_source_new_full(
        pollable_stream: GObject.Object,
        child_source: GLib.Source | null,
        cancellable: Cancellable | null
    ): GLib.Source;
    /**
     * Tries to read from `stream,` as with g_input_stream_read() (if
     * `blocking` is %TRUE) or g_pollable_input_stream_read_nonblocking()
     * (if `blocking` is %FALSE). This can be used to more easily share
     * code between blocking and non-blocking implementations of a method.
     *
     * If `blocking` is %FALSE, then `stream` must be a
     * #GPollableInputStream for which g_pollable_input_stream_can_poll()
     * returns %TRUE, or else the behavior is undefined. If `blocking` is
     * %TRUE, then `stream` does not need to be a #GPollableInputStream.
     * @param stream a #GInputStream
     * @param buffer a buffer to   read data into
     * @param blocking whether to do blocking I/O
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns the number of bytes read, or -1 on error.
     */
    function pollable_stream_read(
        stream: InputStream,
        buffer: Uint8Array,
        blocking: boolean,
        cancellable: Cancellable | null
    ): number;
    /**
     * Tries to write to `stream,` as with g_output_stream_write() (if
     * `blocking` is %TRUE) or g_pollable_output_stream_write_nonblocking()
     * (if `blocking` is %FALSE). This can be used to more easily share
     * code between blocking and non-blocking implementations of a method.
     *
     * If `blocking` is %FALSE, then `stream` must be a
     * #GPollableOutputStream for which
     * g_pollable_output_stream_can_poll() returns %TRUE or else the
     * behavior is undefined. If `blocking` is %TRUE, then `stream` does not
     * need to be a #GPollableOutputStream.
     * @param stream a #GOutputStream.
     * @param buffer the buffer   containing the data to write.
     * @param blocking whether to do blocking I/O
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns the number of bytes written, or -1 on error.
     */
    function pollable_stream_write(
        stream: OutputStream,
        buffer: Uint8Array,
        blocking: boolean,
        cancellable: Cancellable | null
    ): number;
    /**
     * Tries to write `count` bytes to `stream,` as with
     * g_output_stream_write_all(), but using g_pollable_stream_write()
     * rather than g_output_stream_write().
     *
     * On a successful write of `count` bytes, %TRUE is returned, and
     * `bytes_written` is set to `count`.
     *
     * If there is an error during the operation (including
     * %G_IO_ERROR_WOULD_BLOCK in the non-blocking case), %FALSE is
     * returned and `error` is set to indicate the error status,
     * `bytes_written` is updated to contain the number of bytes written
     * into the stream before the error occurred.
     *
     * As with g_pollable_stream_write(), if `blocking` is %FALSE, then
     * `stream` must be a #GPollableOutputStream for which
     * g_pollable_output_stream_can_poll() returns %TRUE or else the
     * behavior is undefined. If `blocking` is %TRUE, then `stream` does not
     * need to be a #GPollableOutputStream.
     * @param stream a #GOutputStream.
     * @param buffer the buffer   containing the data to write.
     * @param blocking whether to do blocking I/O
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns %TRUE on success, %FALSE if there was an error
     */
    function pollable_stream_write_all(
        stream: OutputStream,
        buffer: Uint8Array,
        blocking: boolean,
        cancellable: Cancellable | null
    ): [/* returnType */ boolean, /* bytes_written */ number];
    /**
     * Gets a reference to the default #GPowerProfileMonitor for the system.
     * @returns a new reference to the default #GPowerProfileMonitor
     */
    function power_profile_monitor_dup_default(): PowerProfileMonitor;
    /**
     * Find the `gio-proxy` extension point for a proxy implementation that supports
     * the specified protocol.
     * @param protocol the proxy protocol name (e.g. http, socks, etc)
     * @returns return a #GProxy or NULL if protocol               is not supported.
     */
    function proxy_get_default_for_protocol(
        protocol: string | null
    ): Proxy | null;
    /**
     * Gets the default #GProxyResolver for the system.
     * @returns the default #GProxyResolver, which     will be a dummy object if no proxy resolver is available
     */
    function proxy_resolver_get_default(): ProxyResolver;
    /**
     * Gets the #GResolver Error Quark.
     * @returns a #GQuark.
     */
    function resolver_error_quark(): GLib.Quark;
    /**
     * Gets the #GResource Error Quark.
     * @returns a #GQuark
     */
    function resource_error_quark(): GLib.Quark;
    /**
     * Loads a binary resource bundle and creates a #GResource representation of it, allowing
     * you to query it for data.
     *
     * If you want to use this resource in the global resource namespace you need
     * to register it with g_resources_register().
     *
     * If `filename` is empty or the data in it is corrupt,
     * %G_RESOURCE_ERROR_INTERNAL will be returned. If `filename` doesnt exist, or
     * there is an error in reading it, an error from g_mapped_file_new() will be
     * returned.
     * @param filename the path of a filename to load, in the GLib filename encoding
     * @returns a new #GResource, or %NULL on error
     */
    function resource_load(filename: string): Resource;
    /**
     * Returns all the names of children at the specified `path` in the set of
     * globally registered resources.
     * The return result is a %NULL terminated list of strings which should
     * be released with g_strfreev().
     *
     * `lookup_flags` controls the behaviour of the lookup.
     * @param path A pathname inside the resource
     * @param lookup_flags A #GResourceLookupFlags
     * @returns an array of constant strings
     */
    function resources_enumerate_children(
        path: string | null,
        lookup_flags: ResourceLookupFlags
    ): string[];
    /**
     * Looks for a file at the specified `path` in the set of
     * globally registered resources and if found returns information about it.
     *
     * `lookup_flags` controls the behaviour of the lookup.
     * @param path A pathname inside the resource
     * @param lookup_flags A #GResourceLookupFlags
     * @returns %TRUE if the file was found. %FALSE if there were errors
     */
    function resources_get_info(
        path: string | null,
        lookup_flags: ResourceLookupFlags
    ): [/* returnType */ boolean, /* size */ number, /* flags */ number];
    /**
     * Looks for a file at the specified `path` in the set of
     * globally registered resources and returns a #GBytes that
     * lets you directly access the data in memory.
     *
     * The data is always followed by a zero byte, so you
     * can safely use the data as a C string. However, that byte
     * is not included in the size of the GBytes.
     *
     * For uncompressed resource files this is a pointer directly into
     * the resource bundle, which is typically in some readonly data section
     * in the program binary. For compressed files we allocate memory on
     * the heap and automatically uncompress the data.
     *
     * `lookup_flags` controls the behaviour of the lookup.
     * @param path A pathname inside the resource
     * @param lookup_flags A #GResourceLookupFlags
     * @returns #GBytes or %NULL on error.     Free the returned object with g_bytes_unref()
     */
    function resources_lookup_data(
        path: string | null,
        lookup_flags: ResourceLookupFlags
    ): GLib.Bytes;
    /**
     * Looks for a file at the specified `path` in the set of
     * globally registered resources and returns a #GInputStream
     * that lets you read the data.
     *
     * `lookup_flags` controls the behaviour of the lookup.
     * @param path A pathname inside the resource
     * @param lookup_flags A #GResourceLookupFlags
     * @returns #GInputStream or %NULL on error.     Free the returned object with g_object_unref()
     */
    function resources_open_stream(
        path: string | null,
        lookup_flags: ResourceLookupFlags
    ): InputStream;
    /**
     * Registers the resource with the process-global set of resources.
     * Once a resource is registered the files in it can be accessed
     * with the global resource lookup functions like g_resources_lookup_data().
     * @param resource A #GResource
     */
    function resources_register(resource: Resource): void;
    /**
     * Unregisters the resource from the process-global set of resources.
     * @param resource A #GResource
     */
    function resources_unregister(resource: Resource): void;
    /**
     * Gets the default system schema source.
     *
     * This function is not required for normal uses of #GSettings but it
     * may be useful to authors of plugin management systems or to those who
     * want to introspect the content of schemas.
     *
     * If no schemas are installed, %NULL will be returned.
     *
     * The returned source may actually consist of multiple schema sources
     * from different directories, depending on which directories were given
     * in `XDG_DATA_DIRS` and `GSETTINGS_SCHEMA_DIR`. For this reason, all
     * lookups performed against the default source should probably be done
     * recursively.
     * @returns the default schema source
     */
    function settings_schema_source_get_default(): SettingsSchemaSource | null;
    /**
     * Reports an error in an idle function. Similar to
     * g_simple_async_report_error_in_idle(), but takes a #GError rather
     * than building a new one.
     * @param object a #GObject, or %NULL
     * @param callback a #GAsyncReadyCallback.
     * @param error the #GError to report
     */
    function simple_async_report_gerror_in_idle<Z = unknown>(
        object: GObject.Object | null,
        callback: AsyncReadyCallback<Z> | null,
        error: GLib.Error
    ): void;
    /**
     * Gets the default #GTlsBackend for the system.
     * @returns a #GTlsBackend, which will be a     dummy object if no TLS backend is available
     */
    function tls_backend_get_default(): TlsBackend;
    /**
     * Gets the TLS channel binding error quark.
     * @returns a #GQuark.
     */
    function tls_channel_binding_error_quark(): GLib.Quark;
    /**
     * Creates a new #GTlsClientConnection wrapping `base_io_stream` (which
     * must have pollable input and output streams) which is assumed to
     * communicate with the server identified by `server_identity`.
     *
     * See the documentation for #GTlsConnection:base-io-stream for restrictions
     * on when application code can run operations on the `base_io_stream` after
     * this function has returned.
     * @param base_io_stream the #GIOStream to wrap
     * @param server_identity the expected identity of the server
     * @returns the new #GTlsClientConnection, or %NULL on error
     */
    function tls_client_connection_new(
        base_io_stream: IOStream,
        server_identity: SocketConnectable | null
    ): TlsClientConnection;
    /**
     * Gets the TLS error quark.
     * @returns a #GQuark.
     */
    function tls_error_quark(): GLib.Quark;
    /**
     * Creates a new #GTlsFileDatabase which uses anchor certificate authorities
     * in `anchors` to verify certificate chains.
     *
     * The certificates in `anchors` must be PEM encoded.
     * @param anchors filename of anchor certificate authorities.
     * @returns the new #GTlsFileDatabase, or %NULL on error
     */
    function tls_file_database_new(anchors: string): TlsFileDatabase;
    /**
     * Creates a new #GTlsServerConnection wrapping `base_io_stream` (which
     * must have pollable input and output streams).
     *
     * See the documentation for #GTlsConnection:base-io-stream for restrictions
     * on when application code can run operations on the `base_io_stream` after
     * this function has returned.
     * @param base_io_stream the #GIOStream to wrap
     * @param certificate the default server certificate, or %NULL
     * @returns the new #GTlsServerConnection, or %NULL on error
     */
    function tls_server_connection_new(
        base_io_stream: IOStream,
        certificate: TlsCertificate | null
    ): TlsServerConnection;
    /**
     * Determines if `mount_path` is considered an implementation of the
     * OS. This is primarily used for hiding mountable and mounted volumes
     * that only are used in the OS and has little to no relevance to the
     * casual user.
     * @param mount_path a mount path, e.g. `/media/disk` or `/usr`
     * @returns %TRUE if @mount_path is considered an implementation detail     of the OS.
     */
    function unix_is_mount_path_system_internal(mount_path: string): boolean;
    /**
     * Determines if `device_path` is considered a block device path which is only
     * used in implementation of the OS. This is primarily used for hiding
     * mounted volumes that are intended as APIs for programs to read, and system
     * administrators at a shell; rather than something that should, for example,
     * appear in a GUI. For example, the Linux `/proc` filesystem.
     *
     * The list of device paths considered system ones may change over time.
     * @param device_path a device path, e.g. `/dev/loop0` or `nfsd`
     * @returns %TRUE if @device_path is considered an implementation detail of    the OS.
     */
    function unix_is_system_device_path(device_path: string | null): boolean;
    /**
     * Determines if `fs_type` is considered a type of file system which is only
     * used in implementation of the OS. This is primarily used for hiding
     * mounted volumes that are intended as APIs for programs to read, and system
     * administrators at a shell; rather than something that should, for example,
     * appear in a GUI. For example, the Linux `/proc` filesystem.
     *
     * The list of file system types considered system ones may change over time.
     * @param fs_type a file system type, e.g. `procfs` or `tmpfs`
     * @returns %TRUE if @fs_type is considered an implementation detail of the OS.
     */
    function unix_is_system_fs_type(fs_type: string | null): boolean;
    /**
     * Gets a #GUnixMountEntry for a given mount path. If `time_read`
     * is set, it will be filled with a unix timestamp for checking
     * if the mounts have changed since with g_unix_mounts_changed_since().
     *
     * If more mounts have the same mount path, the last matching mount
     * is returned.
     *
     * This will return %NULL if there is no mount point at `mount_path`.
     * @param mount_path path for a possible unix mount.
     * @returns a #GUnixMountEntry.
     */
    function unix_mount_at(
        mount_path: string
    ): [/* returnType */ UnixMountEntry | null, /* time_read */ number];
    /**
     * Compares two unix mounts.
     * @param mount1 first #GUnixMountEntry to compare.
     * @param mount2 second #GUnixMountEntry to compare.
     * @returns 1, 0 or -1 if @mount1 is greater than, equal to, or less than @mount2, respectively.
     */
    function unix_mount_compare(
        mount1: UnixMountEntry,
        mount2: UnixMountEntry
    ): number;
    /**
     * Makes a copy of `mount_entry`.
     * @param mount_entry a #GUnixMountEntry.
     * @returns a new #GUnixMountEntry
     */
    function unix_mount_copy(mount_entry: UnixMountEntry): UnixMountEntry;
    /**
     * Gets a #GUnixMountEntry for a given file path. If `time_read`
     * is set, it will be filled with a unix timestamp for checking
     * if the mounts have changed since with g_unix_mounts_changed_since().
     *
     * If more mounts have the same mount path, the last matching mount
     * is returned.
     *
     * This will return %NULL if looking up the mount entry fails, if
     * `file_path` doesnt exist or there is an I/O error.
     * @param file_path file path on some unix mount.
     * @returns a #GUnixMountEntry.
     */
    function unix_mount_for(
        file_path: string
    ): [/* returnType */ UnixMountEntry | null, /* time_read */ number];
    /**
     * Frees a unix mount.
     * @param mount_entry a #GUnixMountEntry.
     */
    function unix_mount_free(mount_entry: UnixMountEntry): void;
    /**
     * Gets the device path for a unix mount.
     * @param mount_entry a #GUnixMount.
     * @returns a string containing the device path.
     */
    function unix_mount_get_device_path(mount_entry: UnixMountEntry): string;
    /**
     * Gets the filesystem type for the unix mount.
     * @param mount_entry a #GUnixMount.
     * @returns a string containing the file system type.
     */
    function unix_mount_get_fs_type(mount_entry: UnixMountEntry): string | null;
    /**
     * Gets the mount path for a unix mount.
     * @param mount_entry input #GUnixMountEntry to get the mount path for.
     * @returns the mount path for @mount_entry.
     */
    function unix_mount_get_mount_path(mount_entry: UnixMountEntry): string;
    /**
     * Gets a comma-separated list of mount options for the unix mount. For example,
     * `rw,relatime,seclabel,data=ordered`.
     *
     * This is similar to g_unix_mount_point_get_options(), but it takes
     * a #GUnixMountEntry as an argument.
     * @param mount_entry a #GUnixMountEntry.
     * @returns a string containing the options, or %NULL if not available.
     */
    function unix_mount_get_options(mount_entry: UnixMountEntry): string | null;
    /**
     * Gets the root of the mount within the filesystem. This is useful e.g. for
     * mounts created by bind operation, or btrfs subvolumes.
     *
     * For example, the root path is equal to "/" for mount created by
     * "mount /dev/sda1 /mnt/foo" and "/bar" for
     * "mount --bind /mnt/foo/bar /mnt/bar".
     * @param mount_entry a #GUnixMountEntry.
     * @returns a string containing the root, or %NULL if not supported.
     */
    function unix_mount_get_root_path(
        mount_entry: UnixMountEntry
    ): string | null;
    /**
     * Guesses whether a Unix mount can be ejected.
     * @param mount_entry a #GUnixMountEntry
     * @returns %TRUE if @mount_entry is deemed to be ejectable.
     */
    function unix_mount_guess_can_eject(mount_entry: UnixMountEntry): boolean;
    /**
     * Guesses the icon of a Unix mount.
     * @param mount_entry a #GUnixMountEntry
     * @returns a #GIcon
     */
    function unix_mount_guess_icon(mount_entry: UnixMountEntry): Icon;
    /**
     * Guesses the name of a Unix mount.
     * The result is a translated string.
     * @param mount_entry a #GUnixMountEntry
     * @returns A newly allocated string that must     be freed with g_free()
     */
    function unix_mount_guess_name(mount_entry: UnixMountEntry): string | null;
    /**
     * Guesses whether a Unix mount should be displayed in the UI.
     * @param mount_entry a #GUnixMountEntry
     * @returns %TRUE if @mount_entry is deemed to be displayable.
     */
    function unix_mount_guess_should_display(
        mount_entry: UnixMountEntry
    ): boolean;
    /**
     * Guesses the symbolic icon of a Unix mount.
     * @param mount_entry a #GUnixMountEntry
     * @returns a #GIcon
     */
    function unix_mount_guess_symbolic_icon(mount_entry: UnixMountEntry): Icon;
    /**
     * Checks if a unix mount is mounted read only.
     * @param mount_entry a #GUnixMount.
     * @returns %TRUE if @mount_entry is read only.
     */
    function unix_mount_is_readonly(mount_entry: UnixMountEntry): boolean;
    /**
     * Checks if a Unix mount is a system mount. This is the Boolean OR of
     * g_unix_is_system_fs_type(), g_unix_is_system_device_path() and
     * g_unix_is_mount_path_system_internal() on `mount_entry`s properties.
     *
     * The definition of what a system mount entry is may change over time as new
     * file system types and device paths are ignored.
     * @param mount_entry a #GUnixMount.
     * @returns %TRUE if the unix mount is for a system path.
     */
    function unix_mount_is_system_internal(
        mount_entry: UnixMountEntry
    ): boolean;
    /**
     * Gets a #GUnixMountPoint for a given mount path. If `time_read` is set, it
     * will be filled with a unix timestamp for checking if the mount points have
     * changed since with g_unix_mount_points_changed_since().
     *
     * If more mount points have the same mount path, the last matching mount point
     * is returned.
     * @param mount_path path for a possible unix mount point.
     * @returns a #GUnixMountPoint, or %NULL if no match is found.
     */
    function unix_mount_point_at(
        mount_path: string
    ): [/* returnType */ UnixMountPoint | null, /* time_read */ number];
    /**
     * Checks if the unix mount points have changed since a given unix time.
     * @param time guint64 to contain a timestamp.
     * @returns %TRUE if the mount points have changed since @time.
     */
    function unix_mount_points_changed_since(time: number): boolean;
    /**
     * Gets a #GList of #GUnixMountPoint containing the unix mount points.
     * If `time_read` is set, it will be filled with the mount timestamp,
     * allowing for checking if the mounts have changed with
     * g_unix_mount_points_changed_since().
     * @returns      a #GList of the UNIX mountpoints.
     */
    function unix_mount_points_get(): [
        /* returnType */ UnixMountPoint[],
        /* time_read */ number
    ];
    /**
     * Checks if the unix mounts have changed since a given unix time.
     * @param time guint64 to contain a timestamp.
     * @returns %TRUE if the mounts have changed since @time.
     */
    function unix_mounts_changed_since(time: number): boolean;
    /**
     * Gets a #GList of #GUnixMountEntry containing the unix mounts.
     * If `time_read` is set, it will be filled with the mount
     * timestamp, allowing for checking if the mounts have changed
     * with g_unix_mounts_changed_since().
     * @returns      a #GList of the UNIX mounts.
     */
    function unix_mounts_get(): [
        /* returnType */ UnixMountEntry[],
        /* time_read */ number
    ];
    /**
     * Type definition for a function that will be called back when an asynchronous
     * operation within GIO has been completed. #GAsyncReadyCallback
     * callbacks from #GTask are guaranteed to be invoked in a later
     * iteration of the
     * [thread-default main context][g-main-context-push-thread-default]
     * where the #GTask was created. All other users of
     * #GAsyncReadyCallback must likewise call it asynchronously in a
     * later iteration of the main context.
     *
     * The asynchronous operation is guaranteed to have held a reference to
     * `source_object` from the time when the `*_async()` function was called, until
     * after this callback returns.
     * @callback
     * @param source_object the object the asynchronous operation was started with.
     * @param res a #GAsyncResult.
     * @param data user data passed to the callback.
     */
    interface AsyncReadyCallback<T = GObject.Object> {
        (source_object: T, res: AsyncResult, data: any | null): void;
    }
    /**
     * Invoked when a connection to a message bus has been obtained.
     * @callback
     * @param connection The #GDBusConnection to a message bus.
     * @param name The name that is requested to be owned.
     */
    interface BusAcquiredCallback {
        (connection: DBusConnection, name: string | null): void;
    }
    /**
     * Invoked when the name is acquired.
     * @callback
     * @param connection The #GDBusConnection on which to acquired the name.
     * @param name The name being owned.
     */
    interface BusNameAcquiredCallback {
        (connection: DBusConnection, name: string | null): void;
    }
    /**
     * Invoked when the name being watched is known to have to have an owner.
     * @callback
     * @param connection The #GDBusConnection the name is being watched on.
     * @param name The name being watched.
     * @param name_owner Unique name of the owner of the name being watched.
     */
    interface BusNameAppearedCallback {
        (
            connection: DBusConnection,
            name: string | null,
            name_owner: string | null
        ): void;
    }
    /**
     * Invoked when the name is lost or `connection` has been closed.
     * @callback
     * @param connection The #GDBusConnection on which to acquire the name or %NULL if the connection was disconnected.
     * @param name The name being owned.
     */
    interface BusNameLostCallback {
        (connection: DBusConnection, name: string | null): void;
    }
    /**
     * Invoked when the name being watched is known not to have to have an owner.
     *
     * This is also invoked when the #GDBusConnection on which the watch was
     * established has been closed.  In that case, `connection` will be
     * %NULL.
     * @callback
     * @param connection The #GDBusConnection the name is being watched on, or     %NULL.
     * @param name The name being watched.
     */
    interface BusNameVanishedCallback {
        (connection: DBusConnection, name: string | null): void;
    }
    /**
     * This is the function type of the callback used for the #GSource
     * returned by g_cancellable_source_new().
     * @callback
     * @param cancellable the #GCancellable
     * @param data data passed in by the user.
     * @returns it should return %FALSE if the source should be removed.
     */
    interface CancellableSourceFunc {
        (cancellable: Cancellable | null, data: any | null): boolean;
    }
    /**
     * The type of the `get_property` function in #GDBusInterfaceVTable.
     * @callback
     * @param connection A #GDBusConnection.
     * @param sender The unique bus name of the remote caller.
     * @param object_path The object path that the method was invoked on.
     * @param interface_name The D-Bus interface name for the property.
     * @param property_name The name of the property to get the value of.
     * @param error Return location for error.
     * @returns A #GVariant with the value for @property_name or %NULL if     @error is set. If the returned #GVariant is floating, it is     consumed - otherwise its reference count is decreased by one.
     */
    interface DBusInterfaceGetPropertyFunc {
        (
            connection: DBusConnection,
            sender: string | null,
            object_path: string | null,
            interface_name: string | null,
            property_name: string | null,
            error: GLib.Error
        ): GLib.Variant;
    }
    /**
     * The type of the `method_call` function in #GDBusInterfaceVTable.
     * @callback
     * @param connection A #GDBusConnection.
     * @param sender The unique bus name of the remote caller.
     * @param object_path The object path that the method was invoked on.
     * @param interface_name The D-Bus interface name the method was invoked on.
     * @param method_name The name of the method that was invoked.
     * @param parameters A #GVariant tuple with parameters.
     * @param invocation A #GDBusMethodInvocation object that must be used to return a value or error.
     */
    interface DBusInterfaceMethodCallFunc {
        (
            connection: DBusConnection,
            sender: string | null,
            object_path: string | null,
            interface_name: string | null,
            method_name: string | null,
            parameters: GLib.Variant,
            invocation: DBusMethodInvocation
        ): void;
    }
    /**
     * The type of the `set_property` function in #GDBusInterfaceVTable.
     * @callback
     * @param connection A #GDBusConnection.
     * @param sender The unique bus name of the remote caller.
     * @param object_path The object path that the method was invoked on.
     * @param interface_name The D-Bus interface name for the property.
     * @param property_name The name of the property to get the value of.
     * @param value The value to set the property to.
     * @param error Return location for error.
     * @returns %TRUE if the property was set to @value, %FALSE if @error is set.
     */
    interface DBusInterfaceSetPropertyFunc {
        (
            connection: DBusConnection,
            sender: string | null,
            object_path: string | null,
            interface_name: string | null,
            property_name: string | null,
            value: GLib.Variant,
            error: GLib.Error
        ): boolean;
    }
    /**
     * Signature for function used in g_dbus_connection_add_filter().
     *
     * A filter function is passed a #GDBusMessage and expected to return
     * a #GDBusMessage too. Passive filter functions that don't modify the
     * message can simply return the `message` object:
     *
     * ```
     * static GDBusMessage *
     * passive_filter (GDBusConnection *connection
     *                 GDBusMessage    *message,
     *                 gboolean         incoming,
     *                 gpointer         user_data)
     * {
     *   // inspect `message`
     *   return message;
     * }
     * ```
     *
     * Filter functions that wants to drop a message can simply return %NULL:
     *
     * ```
     * static GDBusMessage *
     * drop_filter (GDBusConnection *connection
     *              GDBusMessage    *message,
     *              gboolean         incoming,
     *              gpointer         user_data)
     * {
     *   if (should_drop_message)
     *     {
     *       g_object_unref (message);
     *       message = NULL;
     *     }
     *   return message;
     * }
     * ```
     *
     * Finally, a filter function may modify a message by copying it:
     *
     * ```
     * static GDBusMessage *
     * modifying_filter (GDBusConnection *connection
     *                   GDBusMessage    *message,
     *                   gboolean         incoming,
     *                   gpointer         user_data)
     * {
     *   GDBusMessage *copy;
     *   GError *error;
     *
     *   error = NULL;
     *   copy = g_dbus_message_copy (message, &error);
     *   // handle `error` being set
     *   g_object_unref (message);
     *
     *   // modify `copy`
     *
     *   return copy;
     * }
     * ```
     *
     * If the returned #GDBusMessage is different from `message` and cannot
     * be sent on `connection` (it could use features, such as file
     * descriptors, not compatible with `connection)`, then a warning is
     * logged to standard error. Applications can
     * check this ahead of time using g_dbus_message_to_blob() passing a
     * #GDBusCapabilityFlags value obtained from `connection`.
     * @callback
     * @param connection A #GDBusConnection.
     * @param message A locked #GDBusMessage that the filter function takes ownership of.
     * @param incoming %TRUE if it is a message received from the other peer, %FALSE if it is a message to be sent to the other peer.
     * @returns A #GDBusMessage that will be freed with g_object_unref() or %NULL to drop the message. Passive filter functions can simply return the passed @message object.
     */
    interface DBusMessageFilterFunction {
        (
            connection: DBusConnection,
            message: DBusMessage,
            incoming: boolean
        ): DBusMessage | null;
    }
    /**
     * Function signature for a function used to determine the #GType to
     * use for an interface proxy (if `interface_name` is not %NULL) or
     * object proxy (if `interface_name` is %NULL).
     *
     * This function is called in the
     * [thread-default main loop][g-main-context-push-thread-default]
     * that `manager` was constructed in.
     * @callback
     * @param manager A #GDBusObjectManagerClient.
     * @param object_path The object path of the remote object.
     * @param interface_name The interface name of the remote object or %NULL if a #GDBusObjectProxy #GType is requested.
     * @param data data passed in by the user.
     * @returns A #GType to use for the remote object. The returned type   must be a #GDBusProxy or #GDBusObjectProxy -derived   type.
     */
    interface DBusProxyTypeFunc {
        (
            manager: DBusObjectManagerClient,
            object_path: string | null,
            interface_name: string | null,
            data: any | null
        ): GObject.GType;
    }
    /**
     * Signature for callback function used in g_dbus_connection_signal_subscribe().
     * @callback
     * @param connection A #GDBusConnection.
     * @param sender_name The unique bus name of the sender of the signal,    or %NULL on a peer-to-peer D-Bus connection.
     * @param object_path The object path that the signal was emitted on.
     * @param interface_name The name of the interface.
     * @param signal_name The name of the signal.
     * @param parameters A #GVariant tuple with parameters for the signal.
     */
    interface DBusSignalCallback {
        (
            connection: DBusConnection,
            sender_name: string | null,
            object_path: string | null,
            interface_name: string | null,
            signal_name: string | null,
            parameters: GLib.Variant
        ): void;
    }
    /**
     * The type of the `dispatch` function in #GDBusSubtreeVTable.
     *
     * Subtrees are flat.  `node,` if non-%NULL, is always exactly one
     * segment of the object path (ie: it never contains a slash).
     * @callback
     * @param connection A #GDBusConnection.
     * @param sender The unique bus name of the remote caller.
     * @param object_path The object path that was registered with g_dbus_connection_register_subtree().
     * @param interface_name The D-Bus interface name that the method call or property access is for.
     * @param node A node that is a child of `object_path` (relative to `object_path)` or %NULL for the root of the subtree.
     * @param out_user_data Return location for user data to pass to functions in the returned #GDBusInterfaceVTable.
     * @returns A #GDBusInterfaceVTable or %NULL if you don't want to handle the methods.
     */
    interface DBusSubtreeDispatchFunc {
        (
            connection: DBusConnection,
            sender: string | null,
            object_path: string | null,
            interface_name: string | null,
            node: string | null,
            out_user_data: any
        ): DBusInterfaceVTable | null;
    }
    /**
     * The type of the `enumerate` function in #GDBusSubtreeVTable.
     *
     * This function is called when generating introspection data and also
     * when preparing to dispatch incoming messages in the event that the
     * %G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES flag is not
     * specified (ie: to verify that the object path is valid).
     *
     * Hierarchies are not supported; the items that you return should not
     * contain the `/` character.
     *
     * The return value will be freed with g_strfreev().
     * @callback
     * @param connection A #GDBusConnection.
     * @param sender The unique bus name of the remote caller.
     * @param object_path The object path that was registered with g_dbus_connection_register_subtree().
     * @returns A newly allocated array of strings for node names that are children of @object_path.
     */
    interface DBusSubtreeEnumerateFunc {
        (
            connection: DBusConnection,
            sender: string | null,
            object_path: string | null
        ): string[];
    }
    /**
     * The type of the `introspect` function in #GDBusSubtreeVTable.
     *
     * Subtrees are flat.  `node,` if non-%NULL, is always exactly one
     * segment of the object path (ie: it never contains a slash).
     *
     * This function should return %NULL to indicate that there is no object
     * at this node.
     *
     * If this function returns non-%NULL, the return value is expected to
     * be a %NULL-terminated array of pointers to #GDBusInterfaceInfo
     * structures describing the interfaces implemented by `node`.  This
     * array will have g_dbus_interface_info_unref() called on each item
     * before being freed with g_free().
     *
     * The difference between returning %NULL and an array containing zero
     * items is that the standard DBus interfaces will returned to the
     * remote introspector in the empty array case, but not in the %NULL
     * case.
     * @callback
     * @param connection A #GDBusConnection.
     * @param sender The unique bus name of the remote caller.
     * @param object_path The object path that was registered with g_dbus_connection_register_subtree().
     * @param node A node that is a child of `object_path` (relative to `object_path)` or %NULL for the root of the subtree.
     * @returns A %NULL-terminated array of pointers to #GDBusInterfaceInfo, or %NULL.
     */
    interface DBusSubtreeIntrospectFunc {
        (
            connection: DBusConnection,
            sender: string | null,
            object_path: string | null,
            node: string | null
        ): DBusInterfaceInfo[] | null;
    }
    /**
     * This is the function type of the callback used for the #GSource
     * returned by g_datagram_based_create_source().
     * @callback
     * @param datagram_based the #GDatagramBased
     * @param condition the current condition at the source fired
     * @param data data passed in by the user
     * @returns %G_SOURCE_REMOVE if the source should be removed,   %G_SOURCE_CONTINUE otherwise
     */
    interface DatagramBasedSourceFunc {
        (
            datagram_based: DatagramBased,
            condition: GLib.IOCondition,
            data: any | null
        ): boolean;
    }
    /**
     * During invocation, g_desktop_app_info_launch_uris_as_manager() may
     * create one or more child processes.  This callback is invoked once
     * for each, providing the process ID.
     * @callback
     * @param appinfo a #GDesktopAppInfo
     * @param pid Process identifier
     */
    interface DesktopAppLaunchCallback {
        (appinfo: DesktopAppInfo, pid: GLib.Pid): void;
    }
    /**
     * This callback type is used by g_file_measure_disk_usage() to make
     * periodic progress reports when measuring the amount of disk spaced
     * used by a directory.
     *
     * These calls are made on a best-effort basis and not all types of
     * #GFile will support them.  At the minimum, however, one call will
     * always be made immediately.
     *
     * In the case that there is no support, `reporting` will be set to
     * %FALSE (and the other values undefined) and no further calls will be
     * made.  Otherwise, the `reporting` will be %TRUE and the other values
     * all-zeros during the first (immediate) call.  In this way, you can
     * know which type of progress UI to show without a delay.
     *
     * For g_file_measure_disk_usage() the callback is made directly.  For
     * g_file_measure_disk_usage_async() the callback is made via the
     * default main context of the calling thread (ie: the same way that the
     * final async result would be reported).
     *
     * `current_size` is in the same units as requested by the operation (see
     * %G_FILE_MEASURE_APPARENT_SIZE).
     *
     * The frequency of the updates is implementation defined, but is
     * ideally about once every 200ms.
     *
     * The last progress callback may or may not be equal to the final
     * result.  Always check the async result to get the final value.
     * @callback
     * @param reporting %TRUE if more reports will come
     * @param current_size the current cumulative size measurement
     * @param num_dirs the number of directories visited so far
     * @param num_files the number of non-directory files encountered
     * @param data the data passed to the original request for this callback
     */
    interface FileMeasureProgressCallback {
        (
            reporting: boolean,
            current_size: number,
            num_dirs: number,
            num_files: number,
            data: any | null
        ): void;
    }
    /**
     * When doing file operations that may take a while, such as moving
     * a file or copying a file, a progress callback is used to pass how
     * far along that operation is to the application.
     * @callback
     * @param current_num_bytes the current number of bytes in the operation.
     * @param total_num_bytes the total number of bytes in the operation.
     * @param data user data passed to the callback.
     */
    interface FileProgressCallback {
        (
            current_num_bytes: number,
            total_num_bytes: number,
            data: any | null
        ): void;
    }
    /**
     * When loading the partial contents of a file with g_file_load_partial_contents_async(),
     * it may become necessary to determine if any more data from the file should be loaded.
     * A #GFileReadMoreCallback function facilitates this by returning %TRUE if more data
     * should be read, or %FALSE otherwise.
     * @callback
     * @param file_contents the data as currently read.
     * @param file_size the size of the data currently read.
     * @param callback_data data passed to the callback.
     * @returns %TRUE if more data should be read back. %FALSE otherwise.
     */
    interface FileReadMoreCallback {
        (
            file_contents: string | null,
            file_size: number,
            callback_data: any | null
        ): boolean;
    }
    /**
     * I/O Job function.
     *
     * Long-running jobs should periodically check the `cancellable`
     * to see if they have been cancelled.
     * @callback
     * @param job a #GIOSchedulerJob.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param data data passed to the callback function
     * @returns %TRUE if this function should be called again to    complete the job, %FALSE if the job is complete (or cancelled)
     */
    interface IOSchedulerJobFunc {
        (
            job: IOSchedulerJob,
            cancellable: Cancellable | null,
            data: any | null
        ): boolean;
    }
    /**
     * This is the function type of the callback used for the #GSource
     * returned by g_pollable_input_stream_create_source() and
     * g_pollable_output_stream_create_source().
     * @callback
     * @param pollable_stream the #GPollableInputStream or #GPollableOutputStream
     * @param data data passed in by the user.
     * @returns it should return %FALSE if the source should be removed.
     */
    interface PollableSourceFunc {
        (pollable_stream: GObject.Object, data: any | null): boolean;
    }
    /**
     * Changes the size of the memory block pointed to by `data` to
     * `size` bytes.
     *
     * The function should have the same semantics as realloc().
     * @callback
     * @param data memory block to reallocate
     * @param size size to reallocate `data` to
     * @returns a pointer to the reallocated memory
     */
    interface ReallocFunc {
        (data: any | null, size: number): any | null;
    }
    /**
     * The type for the function that is used to convert from #GSettings to
     * an object property. The `value` is already initialized to hold values
     * of the appropriate type.
     * @callback
     * @param value return location for the property value
     * @param variant the #GVariant
     * @returns %TRUE if the conversion succeeded, %FALSE in case of an error
     */
    interface SettingsBindGetMapping {
        (value: any, variant: GLib.Variant): boolean;
    }
    /**
     * The type for the function that is used to convert an object property
     * value to a #GVariant for storing it in #GSettings.
     * @callback
     * @param value a #GValue containing the property value to map
     * @param expected_type the #GVariantType to create
     * @returns a new #GVariant holding the data from @value,     or %NULL in case of an error
     */
    interface SettingsBindSetMapping {
        (value: any, expected_type: GLib.VariantType): GLib.Variant;
    }
    /**
     * The type of the function that is used to convert from a value stored
     * in a #GSettings to a value that is useful to the application.
     *
     * If the value is successfully mapped, the result should be stored at
     * `result` and %TRUE returned.  If mapping fails (for example, if `value`
     * is not in the right format) then %FALSE should be returned.
     *
     * If `value` is %NULL then it means that the mapping function is being
     * given a "last chance" to successfully return a valid value.  %TRUE
     * must be returned in this case.
     * @callback
     * @param value the #GVariant to map, or %NULL
     * @returns %TRUE if the conversion succeeded, %FALSE in case of an error
     */
    interface SettingsGetMapping {
        (value: GLib.Variant): boolean;
    }
    /**
     * Simple thread function that runs an asynchronous operation and
     * checks for cancellation.
     * @callback
     * @param res a #GSimpleAsyncResult.
     * @param object a #GObject.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     */
    interface SimpleAsyncThreadFunc {
        (
            res: SimpleAsyncResult,
            object: GObject.Object,
            cancellable: Cancellable | null
        ): void;
    }
    /**
     * This is the function type of the callback used for the #GSource
     * returned by g_socket_create_source().
     * @callback
     * @param socket the #GSocket
     * @param condition the current condition at the source fired.
     * @param data data passed in by the user.
     * @returns it should return %FALSE if the source should be removed.
     */
    interface SocketSourceFunc {
        (
            socket: Socket,
            condition: GLib.IOCondition,
            data: any | null
        ): boolean;
    }
    /**
     * The prototype for a task function to be run in a thread via
     * g_task_run_in_thread() or g_task_run_in_thread_sync().
     *
     * If the return-on-cancel flag is set on `task,` and `cancellable` gets
     * cancelled, then the #GTask will be completed immediately (as though
     * g_task_return_error_if_cancelled() had been called), without
     * waiting for the task function to complete. However, the task
     * function will continue running in its thread in the background. The
     * function therefore needs to be careful about how it uses
     * externally-visible state in this case. See
     * g_task_set_return_on_cancel() for more details.
     *
     * Other than in that case, `task` will be completed when the
     * #GTaskThreadFunc returns, not when it calls a
     * `g_task_return_` function.
     * @callback
     * @param task the #GTask
     * @param source_object `task'`s source object
     * @param task_data `task'`s task data
     * @param cancellable `task'`s #GCancellable, or %NULL
     */
    interface TaskThreadFunc {
        (
            task: Task,
            source_object: GObject.Object,
            task_data: any | null,
            cancellable: Cancellable | null
        ): void;
    }
    /**
     * This function type is used by g_vfs_register_uri_scheme() to make it
     * possible for a client to associate an URI scheme to a different #GFile
     * implementation.
     *
     * The client should return a reference to the new file that has been
     * created for `uri,` or %NULL to continue with the default implementation.
     * @callback
     * @param vfs a #GVfs
     * @param identifier the identifier to look up a #GFile for. This can either     be an URI or a parse name as returned by g_file_get_parse_name()
     * @returns a #GFile for @identifier.
     */
    interface VfsFileLookupFunc {
        (vfs: Vfs, identifier: string | null): File;
    }
    namespace Action {
        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface Action {
        // Own properties of Gio-2.0.Gio.Action

        /**
         * If `action` is currently enabled.
         *
         * If the action is disabled then calls to g_action_activate() and
         * g_action_change_state() have no effect.
         */
        readonly enabled: boolean;
        /**
         * The name of the action.  This is mostly meaningful for identifying
         * the action once it has been added to a #GActionGroup. It is immutable.
         */
        readonly name: string | null;
        /**
         * The type of the parameter that must be given when activating the
         * action. This is immutable, and may be %NULL if no parameter is needed when
         * activating the action.
         */
        readonly parameter_type: GLib.VariantType;
        /**
         * The state of the action, or %NULL if the action is stateless.
         */
        readonly state: GLib.Variant;
        /**
         * The #GVariantType of the state that the action has, or %NULL if the
         * action is stateless. This is immutable.
         */
        readonly state_type: GLib.VariantType;

        // Owm methods of Gio-2.0.Gio.Action

        /**
         * Activates the action.
         *
         * `parameter` must be the correct type of parameter for the action (ie:
         * the parameter type given at construction time).  If the parameter
         * type was %NULL then `parameter` must also be %NULL.
         *
         * If the `parameter` GVariant is floating, it is consumed.
         * @param parameter the parameter to the activation
         */
        activate(parameter: GLib.Variant | null): void;
        /**
         * Request for the state of `action` to be changed to `value`.
         *
         * The action must be stateful and `value` must be of the correct type.
         * See g_action_get_state_type().
         *
         * This call merely requests a change.  The action may refuse to change
         * its state or may change its state to something other than `value`.
         * See g_action_get_state_hint().
         *
         * If the `value` GVariant is floating, it is consumed.
         * @param value the new state
         */
        change_state(value: GLib.Variant): void;
        /**
         * Checks if `action` is currently enabled.
         *
         * An action must be enabled in order to be activated or in order to
         * have its state changed from outside callers.
         * @returns whether the action is enabled
         */
        get_enabled(): boolean;
        /**
         * Queries the name of `action`.
         * @returns the name of the action
         */
        get_name(): string | null;
        /**
         * Queries the type of the parameter that must be given when activating
         * `action`.
         *
         * When activating the action using g_action_activate(), the #GVariant
         * given to that function must be of the type returned by this function.
         *
         * In the case that this function returns %NULL, you must not give any
         * #GVariant, but %NULL instead.
         * @returns the parameter type
         */
        get_parameter_type(): GLib.VariantType | null;
        /**
         * Queries the current state of `action`.
         *
         * If the action is not stateful then %NULL will be returned.  If the
         * action is stateful then the type of the return value is the type
         * given by g_action_get_state_type().
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         * @returns the current state of the action
         */
        get_state(): GLib.Variant | null;
        /**
         * Requests a hint about the valid range of values for the state of
         * `action`.
         *
         * If %NULL is returned it either means that the action is not stateful
         * or that there is no hint about the valid range of values for the
         * state of the action.
         *
         * If a #GVariant array is returned then each item in the array is a
         * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
         * returned then the tuple specifies the inclusive lower and upper bound
         * of valid values for the state.
         *
         * In any case, the information is merely a hint.  It may be possible to
         * have a state value outside of the hinted range and setting a value
         * within the range may fail.
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         * @returns the state range hint
         */
        get_state_hint(): GLib.Variant | null;
        /**
         * Queries the type of the state of `action`.
         *
         * If the action is stateful (e.g. created with
         * g_simple_action_new_stateful()) then this function returns the
         * #GVariantType of the state.  This is the type of the initial value
         * given as the state. All calls to g_action_change_state() must give a
         * #GVariant of this type and g_action_get_state() will return a
         * #GVariant of the same type.
         *
         * If the action is not stateful (e.g. created with g_simple_action_new())
         * then this function will return %NULL. In that case, g_action_get_state()
         * will return %NULL and you must not call g_action_change_state().
         * @returns the state type, if the action is stateful
         */
        get_state_type(): GLib.VariantType | null;

        // Own virtual methods of Gio-2.0.Gio.Action

        /**
         * Activates the action.
         *
         * `parameter` must be the correct type of parameter for the action (ie:
         * the parameter type given at construction time).  If the parameter
         * type was %NULL then `parameter` must also be %NULL.
         *
         * If the `parameter` GVariant is floating, it is consumed.
         * @virtual
         * @param parameter the parameter to the activation
         */
        vfunc_activate(parameter: GLib.Variant | null): void;
        /**
         * Request for the state of `action` to be changed to `value`.
         *
         * The action must be stateful and `value` must be of the correct type.
         * See g_action_get_state_type().
         *
         * This call merely requests a change.  The action may refuse to change
         * its state or may change its state to something other than `value`.
         * See g_action_get_state_hint().
         *
         * If the `value` GVariant is floating, it is consumed.
         * @virtual
         * @param value the new state
         */
        vfunc_change_state(value: GLib.Variant): void;
        /**
         * Checks if `action` is currently enabled.
         *
         * An action must be enabled in order to be activated or in order to
         * have its state changed from outside callers.
         * @virtual
         * @returns whether the action is enabled
         */
        vfunc_get_enabled(): boolean;
        /**
         * Queries the name of `action`.
         * @virtual
         * @returns the name of the action
         */
        vfunc_get_name(): string | null;
        /**
         * Queries the type of the parameter that must be given when activating
         * `action`.
         *
         * When activating the action using g_action_activate(), the #GVariant
         * given to that function must be of the type returned by this function.
         *
         * In the case that this function returns %NULL, you must not give any
         * #GVariant, but %NULL instead.
         * @virtual
         * @returns the parameter type
         */
        vfunc_get_parameter_type(): GLib.VariantType | null;
        /**
         * Queries the current state of `action`.
         *
         * If the action is not stateful then %NULL will be returned.  If the
         * action is stateful then the type of the return value is the type
         * given by g_action_get_state_type().
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         * @virtual
         * @returns the current state of the action
         */
        vfunc_get_state(): GLib.Variant | null;
        /**
         * Requests a hint about the valid range of values for the state of
         * `action`.
         *
         * If %NULL is returned it either means that the action is not stateful
         * or that there is no hint about the valid range of values for the
         * state of the action.
         *
         * If a #GVariant array is returned then each item in the array is a
         * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
         * returned then the tuple specifies the inclusive lower and upper bound
         * of valid values for the state.
         *
         * In any case, the information is merely a hint.  It may be possible to
         * have a state value outside of the hinted range and setting a value
         * within the range may fail.
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         * @virtual
         * @returns the state range hint
         */
        vfunc_get_state_hint(): GLib.Variant | null;
        /**
         * Queries the type of the state of `action`.
         *
         * If the action is stateful (e.g. created with
         * g_simple_action_new_stateful()) then this function returns the
         * #GVariantType of the state.  This is the type of the initial value
         * given as the state. All calls to g_action_change_state() must give a
         * #GVariant of this type and g_action_get_state() will return a
         * #GVariant of the same type.
         *
         * If the action is not stateful (e.g. created with g_simple_action_new())
         * then this function will return %NULL. In that case, g_action_get_state()
         * will return %NULL and you must not call g_action_change_state().
         * @virtual
         * @returns the state type, if the action is stateful
         */
        vfunc_get_state_type(): GLib.VariantType | null;

        // Class property signals of Gio-2.0.Gio.Action

        connect(
            sigName: 'notify::enabled',
            callback: ($obj: Action, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::enabled',
            callback: ($obj: Action, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::enabled', ...args: any[]): void;
        connect(
            sigName: 'notify::name',
            callback: ($obj: Action, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::name',
            callback: ($obj: Action, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::name', ...args: any[]): void;
        connect(
            sigName: 'notify::parameter-type',
            callback: ($obj: Action, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::parameter-type',
            callback: ($obj: Action, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::parameter-type', ...args: any[]): void;
        connect(
            sigName: 'notify::state',
            callback: ($obj: Action, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::state',
            callback: ($obj: Action, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::state', ...args: any[]): void;
        connect(
            sigName: 'notify::state-type',
            callback: ($obj: Action, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::state-type',
            callback: ($obj: Action, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::state-type', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GAction represents a single named action.
     *
     * The main interface to an action is that it can be activated with
     * g_action_activate().  This results in the 'activate' signal being
     * emitted.  An activation has a #GVariant parameter (which may be
     * %NULL).  The correct type for the parameter is determined by a static
     * parameter type (which is given at construction time).
     *
     * An action may optionally have a state, in which case the state may be
     * set with g_action_change_state().  This call takes a #GVariant.  The
     * correct type for the state is determined by a static state type
     * (which is given at construction time).
     *
     * The state may have a hint associated with it, specifying its valid
     * range.
     *
     * #GAction is merely the interface to the concept of an action, as
     * described above.  Various implementations of actions exist, including
     * #GSimpleAction.
     *
     * In all cases, the implementing class is responsible for storing the
     * name of the action, the parameter type, the enabled state, the
     * optional state type and the state and emitting the appropriate
     * signals when these change.  The implementor is responsible for filtering
     * calls to g_action_activate() and g_action_change_state() for type
     * safety and for the state being enabled.
     *
     * Probably the only useful thing to do with a #GAction is to put it
     * inside of a #GSimpleActionGroup.
     * @interface
     */
    class Action extends GObject.Object {
        // Own properties of Gio-2.0.Gio.Action

        static name: string;
        static $gtype: GObject.GType<Action>;

        // Constructors of Gio-2.0.Gio.Action

        constructor(config?: Action.ConstructorProperties);
        _init(config?: Action.ConstructorProperties): void;
        /**
         * Checks if `action_name` is valid.
         *
         * `action_name` is valid if it consists only of alphanumeric characters,
         * plus '-' and '.'.  The empty string is not a valid action name.
         *
         * It is an error to call this function with a non-utf8 `action_name`.
         * `action_name` must not be %NULL.
         * @param action_name a potential action name
         * @returns %TRUE if @action_name is valid
         */
        static name_is_valid(action_name: string | null): boolean;
        /**
         * Parses a detailed action name into its separate name and target
         * components.
         *
         * Detailed action names can have three formats.
         *
         * The first format is used to represent an action name with no target
         * value and consists of just an action name containing no whitespace
         * nor the characters `:`, `(` or `)`.  For example: `app.action`.
         *
         * The second format is used to represent an action with a target value
         * that is a non-empty string consisting only of alphanumerics, plus `-`
         * and `.`.  In that case, the action name and target value are
         * separated by a double colon (`::`).  For example:
         * `app.action::target`.
         *
         * The third format is used to represent an action with any type of
         * target value, including strings.  The target value follows the action
         * name, surrounded in parens.  For example: `app.action(42)`.  The
         * target value is parsed using g_variant_parse().  If a tuple-typed
         * value is desired, it must be specified in the same way, resulting in
         * two sets of parens, for example: `app.action((1,2,3))`.  A string
         * target can be specified this way as well: `app.action('target')`.
         * For strings, this third format must be used if target value is
         * empty or contains characters other than alphanumerics, `-` and `.`.
         *
         * If this function returns %TRUE, a non-%NULL value is guaranteed to be returned
         * in `action_name` (if a pointer is passed in). A %NULL value may still be
         * returned in `target_value,` as the `detailed_name` may not contain a target.
         *
         * If returned, the #GVariant in `target_value` is guaranteed to not be floating.
         * @param detailed_name a detailed action name
         * @returns %TRUE if successful, else %FALSE with @error set
         */
        static parse_detailed_name(
            detailed_name: string | null
        ): [
            /* returnType */ boolean,
            /* action_name */ string | null,
            /* target_value */ GLib.Variant | null
        ];
        /**
         * Formats a detailed action name from `action_name` and `target_value`.
         *
         * It is an error to call this function with an invalid action name.
         *
         * This function is the opposite of g_action_parse_detailed_name().
         * It will produce a string that can be parsed back to the `action_name`
         * and `target_value` by that function.
         *
         * See that function for the types of strings that will be printed by
         * this function.
         * @param action_name a valid action name
         * @param target_value a #GVariant target value, or %NULL
         * @returns a detailed format string
         */
        static print_detailed_name(
            action_name: string | null,
            target_value: GLib.Variant | null
        ): string | null;
    }

    namespace ActionGroup {
        // Signal callback interfaces

        /**
         * Signal callback interface for `action-added`
         */
        interface ActionAddedSignalCallback {
            ($obj: ActionGroup, action_name: string | null): void;
        }

        /**
         * Signal callback interface for `action-enabled-changed`
         */
        interface ActionEnabledChangedSignalCallback {
            (
                $obj: ActionGroup,
                action_name: string | null,
                enabled: boolean
            ): void;
        }

        /**
         * Signal callback interface for `action-removed`
         */
        interface ActionRemovedSignalCallback {
            ($obj: ActionGroup, action_name: string | null): void;
        }

        /**
         * Signal callback interface for `action-state-changed`
         */
        interface ActionStateChangedSignalCallback {
            (
                $obj: ActionGroup,
                action_name: string | null,
                value: GLib.Variant
            ): void;
        }

        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface ActionGroup {
        // Owm methods of Gio-2.0.Gio.ActionGroup

        /**
         * Emits the #GActionGroup::action-added signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         */
        action_added(action_name: string | null): void;
        /**
         * Emits the #GActionGroup::action-enabled-changed signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         * @param enabled whether or not the action is now enabled
         */
        action_enabled_changed(
            action_name: string | null,
            enabled: boolean
        ): void;
        /**
         * Emits the #GActionGroup::action-removed signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         */
        action_removed(action_name: string | null): void;
        /**
         * Emits the #GActionGroup::action-state-changed signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         * @param state the new state of the named action
         */
        action_state_changed(
            action_name: string | null,
            state: GLib.Variant
        ): void;
        /**
         * Activate the named action within `action_group`.
         *
         * If the action is expecting a parameter, then the correct type of
         * parameter must be given as `parameter`.  If the action is expecting no
         * parameters then `parameter` must be %NULL.  See
         * g_action_group_get_action_parameter_type().
         *
         * If the #GActionGroup implementation supports asynchronous remote
         * activation over D-Bus, this call may return before the relevant
         * D-Bus traffic has been sent, or any replies have been received. In
         * order to block on such asynchronous activation calls,
         * g_dbus_connection_flush() should be called prior to the code, which
         * depends on the result of the action activation. Without flushing
         * the D-Bus connection, there is no guarantee that the action would
         * have been activated.
         *
         * The following code which runs in a remote app instance, shows an
         * example of a "quit" action being activated on the primary app
         * instance over D-Bus. Here g_dbus_connection_flush() is called
         * before `exit()`. Without g_dbus_connection_flush(), the "quit" action
         * may fail to be activated on the primary instance.
         *
         *
         * ```c
         * // call "quit" action on primary instance
         * g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
         *
         * // make sure the action is activated now
         * g_dbus_connection_flush (...);
         *
         * g_debug ("application has been terminated. exiting.");
         *
         * exit (0);
         * ```
         *
         * @param action_name the name of the action to activate
         * @param parameter parameters to the activation
         */
        activate_action(
            action_name: string | null,
            parameter: GLib.Variant | null
        ): void;
        /**
         * Request for the state of the named action within `action_group` to be
         * changed to `value`.
         *
         * The action must be stateful and `value` must be of the correct type.
         * See g_action_group_get_action_state_type().
         *
         * This call merely requests a change.  The action may refuse to change
         * its state or may change its state to something other than `value`.
         * See g_action_group_get_action_state_hint().
         *
         * If the `value` GVariant is floating, it is consumed.
         * @param action_name the name of the action to request the change on
         * @param value the new state
         */
        change_action_state(
            action_name: string | null,
            value: GLib.Variant
        ): void;
        /**
         * Checks if the named action within `action_group` is currently enabled.
         *
         * An action must be enabled in order to be activated or in order to
         * have its state changed from outside callers.
         * @param action_name the name of the action to query
         * @returns whether or not the action is currently enabled
         */
        get_action_enabled(action_name: string | null): boolean;
        /**
         * Queries the type of the parameter that must be given when activating
         * the named action within `action_group`.
         *
         * When activating the action using g_action_group_activate_action(),
         * the #GVariant given to that function must be of the type returned
         * by this function.
         *
         * In the case that this function returns %NULL, you must not give any
         * #GVariant, but %NULL instead.
         *
         * The parameter type of a particular action will never change but it is
         * possible for an action to be removed and for a new action to be added
         * with the same name but a different parameter type.
         * @param action_name the name of the action to query
         * @returns the parameter type
         */
        get_action_parameter_type(
            action_name: string | null
        ): GLib.VariantType | null;
        /**
         * Queries the current state of the named action within `action_group`.
         *
         * If the action is not stateful then %NULL will be returned.  If the
         * action is stateful then the type of the return value is the type
         * given by g_action_group_get_action_state_type().
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         * @param action_name the name of the action to query
         * @returns the current state of the action
         */
        get_action_state(action_name: string | null): GLib.Variant | null;
        /**
         * Requests a hint about the valid range of values for the state of the
         * named action within `action_group`.
         *
         * If %NULL is returned it either means that the action is not stateful
         * or that there is no hint about the valid range of values for the
         * state of the action.
         *
         * If a #GVariant array is returned then each item in the array is a
         * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
         * returned then the tuple specifies the inclusive lower and upper bound
         * of valid values for the state.
         *
         * In any case, the information is merely a hint.  It may be possible to
         * have a state value outside of the hinted range and setting a value
         * within the range may fail.
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         * @param action_name the name of the action to query
         * @returns the state range hint
         */
        get_action_state_hint(action_name: string | null): GLib.Variant | null;
        /**
         * Queries the type of the state of the named action within
         * `action_group`.
         *
         * If the action is stateful then this function returns the
         * #GVariantType of the state.  All calls to
         * g_action_group_change_action_state() must give a #GVariant of this
         * type and g_action_group_get_action_state() will return a #GVariant
         * of the same type.
         *
         * If the action is not stateful then this function will return %NULL.
         * In that case, g_action_group_get_action_state() will return %NULL
         * and you must not call g_action_group_change_action_state().
         *
         * The state type of a particular action will never change but it is
         * possible for an action to be removed and for a new action to be added
         * with the same name but a different state type.
         * @param action_name the name of the action to query
         * @returns the state type, if the action is stateful
         */
        get_action_state_type(
            action_name: string | null
        ): GLib.VariantType | null;
        /**
         * Checks if the named action exists within `action_group`.
         * @param action_name the name of the action to check for
         * @returns whether the named action exists
         */
        has_action(action_name: string | null): boolean;
        /**
         * Lists the actions contained within `action_group`.
         *
         * The caller is responsible for freeing the list with g_strfreev() when
         * it is no longer required.
         * @returns a %NULL-terminated array of the names of the actions in the group
         */
        list_actions(): string[];
        /**
         * Queries all aspects of the named action within an `action_group`.
         *
         * This function acquires the information available from
         * g_action_group_has_action(), g_action_group_get_action_enabled(),
         * g_action_group_get_action_parameter_type(),
         * g_action_group_get_action_state_type(),
         * g_action_group_get_action_state_hint() and
         * g_action_group_get_action_state() with a single function call.
         *
         * This provides two main benefits.
         *
         * The first is the improvement in efficiency that comes with not having
         * to perform repeated lookups of the action in order to discover
         * different things about it.  The second is that implementing
         * #GActionGroup can now be done by only overriding this one virtual
         * function.
         *
         * The interface provides a default implementation of this function that
         * calls the individual functions, as required, to fetch the
         * information.  The interface also provides default implementations of
         * those functions that call this function.  All implementations,
         * therefore, must override either this function or all of the others.
         *
         * If the action exists, %TRUE is returned and any of the requested
         * fields (as indicated by having a non-%NULL reference passed in) are
         * filled.  If the action doesn't exist, %FALSE is returned and the
         * fields may or may not have been modified.
         * @param action_name the name of an action in the group
         * @returns %TRUE if the action exists, else %FALSE
         */
        query_action(
            action_name: string | null
        ): [
            /* returnType */ boolean,
            /* enabled */ boolean,
            /* parameter_type */ GLib.VariantType,
            /* state_type */ GLib.VariantType,
            /* state_hint */ GLib.Variant,
            /* state */ GLib.Variant
        ];

        // Own virtual methods of Gio-2.0.Gio.ActionGroup

        /**
         * Emits the #GActionGroup::action-added signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @virtual
         * @param action_name the name of an action in the group
         */
        vfunc_action_added(action_name: string | null): void;
        /**
         * Emits the #GActionGroup::action-enabled-changed signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @virtual
         * @param action_name the name of an action in the group
         * @param enabled whether or not the action is now enabled
         */
        vfunc_action_enabled_changed(
            action_name: string | null,
            enabled: boolean
        ): void;
        /**
         * Emits the #GActionGroup::action-removed signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @virtual
         * @param action_name the name of an action in the group
         */
        vfunc_action_removed(action_name: string | null): void;
        /**
         * Emits the #GActionGroup::action-state-changed signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @virtual
         * @param action_name the name of an action in the group
         * @param state the new state of the named action
         */
        vfunc_action_state_changed(
            action_name: string | null,
            state: GLib.Variant
        ): void;
        /**
         * Activate the named action within `action_group`.
         *
         * If the action is expecting a parameter, then the correct type of
         * parameter must be given as `parameter`.  If the action is expecting no
         * parameters then `parameter` must be %NULL.  See
         * g_action_group_get_action_parameter_type().
         *
         * If the #GActionGroup implementation supports asynchronous remote
         * activation over D-Bus, this call may return before the relevant
         * D-Bus traffic has been sent, or any replies have been received. In
         * order to block on such asynchronous activation calls,
         * g_dbus_connection_flush() should be called prior to the code, which
         * depends on the result of the action activation. Without flushing
         * the D-Bus connection, there is no guarantee that the action would
         * have been activated.
         *
         * The following code which runs in a remote app instance, shows an
         * example of a "quit" action being activated on the primary app
         * instance over D-Bus. Here g_dbus_connection_flush() is called
         * before `exit()`. Without g_dbus_connection_flush(), the "quit" action
         * may fail to be activated on the primary instance.
         *
         *
         * ```c
         * // call "quit" action on primary instance
         * g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
         *
         * // make sure the action is activated now
         * g_dbus_connection_flush (...);
         *
         * g_debug ("application has been terminated. exiting.");
         *
         * exit (0);
         * ```
         *
         * @virtual
         * @param action_name the name of the action to activate
         * @param parameter parameters to the activation
         */
        vfunc_activate_action(
            action_name: string | null,
            parameter: GLib.Variant | null
        ): void;
        /**
         * Request for the state of the named action within `action_group` to be
         * changed to `value`.
         *
         * The action must be stateful and `value` must be of the correct type.
         * See g_action_group_get_action_state_type().
         *
         * This call merely requests a change.  The action may refuse to change
         * its state or may change its state to something other than `value`.
         * See g_action_group_get_action_state_hint().
         *
         * If the `value` GVariant is floating, it is consumed.
         * @virtual
         * @param action_name the name of the action to request the change on
         * @param value the new state
         */
        vfunc_change_action_state(
            action_name: string | null,
            value: GLib.Variant
        ): void;
        /**
         * Checks if the named action within `action_group` is currently enabled.
         *
         * An action must be enabled in order to be activated or in order to
         * have its state changed from outside callers.
         * @virtual
         * @param action_name the name of the action to query
         * @returns whether or not the action is currently enabled
         */
        vfunc_get_action_enabled(action_name: string | null): boolean;
        /**
         * Queries the type of the parameter that must be given when activating
         * the named action within `action_group`.
         *
         * When activating the action using g_action_group_activate_action(),
         * the #GVariant given to that function must be of the type returned
         * by this function.
         *
         * In the case that this function returns %NULL, you must not give any
         * #GVariant, but %NULL instead.
         *
         * The parameter type of a particular action will never change but it is
         * possible for an action to be removed and for a new action to be added
         * with the same name but a different parameter type.
         * @virtual
         * @param action_name the name of the action to query
         * @returns the parameter type
         */
        vfunc_get_action_parameter_type(
            action_name: string | null
        ): GLib.VariantType | null;
        /**
         * Queries the current state of the named action within `action_group`.
         *
         * If the action is not stateful then %NULL will be returned.  If the
         * action is stateful then the type of the return value is the type
         * given by g_action_group_get_action_state_type().
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         * @virtual
         * @param action_name the name of the action to query
         * @returns the current state of the action
         */
        vfunc_get_action_state(action_name: string | null): GLib.Variant | null;
        /**
         * Requests a hint about the valid range of values for the state of the
         * named action within `action_group`.
         *
         * If %NULL is returned it either means that the action is not stateful
         * or that there is no hint about the valid range of values for the
         * state of the action.
         *
         * If a #GVariant array is returned then each item in the array is a
         * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
         * returned then the tuple specifies the inclusive lower and upper bound
         * of valid values for the state.
         *
         * In any case, the information is merely a hint.  It may be possible to
         * have a state value outside of the hinted range and setting a value
         * within the range may fail.
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         * @virtual
         * @param action_name the name of the action to query
         * @returns the state range hint
         */
        vfunc_get_action_state_hint(
            action_name: string | null
        ): GLib.Variant | null;
        /**
         * Queries the type of the state of the named action within
         * `action_group`.
         *
         * If the action is stateful then this function returns the
         * #GVariantType of the state.  All calls to
         * g_action_group_change_action_state() must give a #GVariant of this
         * type and g_action_group_get_action_state() will return a #GVariant
         * of the same type.
         *
         * If the action is not stateful then this function will return %NULL.
         * In that case, g_action_group_get_action_state() will return %NULL
         * and you must not call g_action_group_change_action_state().
         *
         * The state type of a particular action will never change but it is
         * possible for an action to be removed and for a new action to be added
         * with the same name but a different state type.
         * @virtual
         * @param action_name the name of the action to query
         * @returns the state type, if the action is stateful
         */
        vfunc_get_action_state_type(
            action_name: string | null
        ): GLib.VariantType | null;
        /**
         * Checks if the named action exists within `action_group`.
         * @virtual
         * @param action_name the name of the action to check for
         * @returns whether the named action exists
         */
        vfunc_has_action(action_name: string | null): boolean;
        /**
         * Lists the actions contained within `action_group`.
         *
         * The caller is responsible for freeing the list with g_strfreev() when
         * it is no longer required.
         * @virtual
         * @returns a %NULL-terminated array of the names of the actions in the group
         */
        vfunc_list_actions(): string[];
        /**
         * Queries all aspects of the named action within an `action_group`.
         *
         * This function acquires the information available from
         * g_action_group_has_action(), g_action_group_get_action_enabled(),
         * g_action_group_get_action_parameter_type(),
         * g_action_group_get_action_state_type(),
         * g_action_group_get_action_state_hint() and
         * g_action_group_get_action_state() with a single function call.
         *
         * This provides two main benefits.
         *
         * The first is the improvement in efficiency that comes with not having
         * to perform repeated lookups of the action in order to discover
         * different things about it.  The second is that implementing
         * #GActionGroup can now be done by only overriding this one virtual
         * function.
         *
         * The interface provides a default implementation of this function that
         * calls the individual functions, as required, to fetch the
         * information.  The interface also provides default implementations of
         * those functions that call this function.  All implementations,
         * therefore, must override either this function or all of the others.
         *
         * If the action exists, %TRUE is returned and any of the requested
         * fields (as indicated by having a non-%NULL reference passed in) are
         * filled.  If the action doesn't exist, %FALSE is returned and the
         * fields may or may not have been modified.
         * @virtual
         * @param action_name the name of an action in the group
         * @returns %TRUE if the action exists, else %FALSE
         */
        vfunc_query_action(
            action_name: string | null
        ): [
            /* returnType */ boolean,
            /* enabled */ boolean,
            /* parameter_type */ GLib.VariantType,
            /* state_type */ GLib.VariantType,
            /* state_hint */ GLib.Variant,
            /* state */ GLib.Variant
        ];

        // Own signals of Gio-2.0.Gio.ActionGroup

        connect(
            sigName: 'action-added',
            callback: ActionGroup.ActionAddedSignalCallback
        ): number;
        connect_after(
            sigName: 'action-added',
            callback: ActionGroup.ActionAddedSignalCallback
        ): number;
        emit(
            sigName: 'action-added',
            action_name: string | null,
            ...args: any[]
        ): void;
        connect(
            sigName: 'action-enabled-changed',
            callback: ActionGroup.ActionEnabledChangedSignalCallback
        ): number;
        connect_after(
            sigName: 'action-enabled-changed',
            callback: ActionGroup.ActionEnabledChangedSignalCallback
        ): number;
        emit(
            sigName: 'action-enabled-changed',
            action_name: string | null,
            enabled: boolean,
            ...args: any[]
        ): void;
        connect(
            sigName: 'action-removed',
            callback: ActionGroup.ActionRemovedSignalCallback
        ): number;
        connect_after(
            sigName: 'action-removed',
            callback: ActionGroup.ActionRemovedSignalCallback
        ): number;
        emit(
            sigName: 'action-removed',
            action_name: string | null,
            ...args: any[]
        ): void;
        connect(
            sigName: 'action-state-changed',
            callback: ActionGroup.ActionStateChangedSignalCallback
        ): number;
        connect_after(
            sigName: 'action-state-changed',
            callback: ActionGroup.ActionStateChangedSignalCallback
        ): number;
        emit(
            sigName: 'action-state-changed',
            action_name: string | null,
            value: GLib.Variant,
            ...args: any[]
        ): void;

        // Class property signals of Gio-2.0.Gio.ActionGroup

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GActionGroup represents a group of actions. Actions can be used to
     * expose functionality in a structured way, either from one part of a
     * program to another, or to the outside world. Action groups are often
     * used together with a #GMenuModel that provides additional
     * representation data for displaying the actions to the user, e.g. in
     * a menu.
     *
     * The main way to interact with the actions in a GActionGroup is to
     * activate them with g_action_group_activate_action(). Activating an
     * action may require a #GVariant parameter. The required type of the
     * parameter can be inquired with g_action_group_get_action_parameter_type().
     * Actions may be disabled, see g_action_group_get_action_enabled().
     * Activating a disabled action has no effect.
     *
     * Actions may optionally have a state in the form of a #GVariant. The
     * current state of an action can be inquired with
     * g_action_group_get_action_state(). Activating a stateful action may
     * change its state, but it is also possible to set the state by calling
     * g_action_group_change_action_state().
     *
     * As typical example, consider a text editing application which has an
     * option to change the current font to 'bold'. A good way to represent
     * this would be a stateful action, with a boolean state. Activating the
     * action would toggle the state.
     *
     * Each action in the group has a unique name (which is a string).  All
     * method calls, except g_action_group_list_actions() take the name of
     * an action as an argument.
     *
     * The #GActionGroup API is meant to be the 'public' API to the action
     * group.  The calls here are exactly the interaction that 'external
     * forces' (eg: UI, incoming D-Bus messages, etc.) are supposed to have
     * with actions.  'Internal' APIs (ie: ones meant only to be accessed by
     * the action group implementation) are found on subclasses.  This is
     * why you will find - for example - g_action_group_get_action_enabled()
     * but not an equivalent set() call.
     *
     * Signals are emitted on the action group in response to state changes
     * on individual actions.
     *
     * Implementations of #GActionGroup should provide implementations for
     * the virtual functions g_action_group_list_actions() and
     * g_action_group_query_action().  The other virtual functions should
     * not be implemented - their "wrappers" are actually implemented with
     * calls to g_action_group_query_action().
     * @interface
     */
    class ActionGroup extends GObject.Object {
        // Own properties of Gio-2.0.Gio.ActionGroup

        static name: string;
        static $gtype: GObject.GType<ActionGroup>;

        // Constructors of Gio-2.0.Gio.ActionGroup

        constructor(config?: ActionGroup.ConstructorProperties);
        _init(config?: ActionGroup.ConstructorProperties): void;
    }

    namespace ActionMap {
        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface ActionMap {
        // Owm methods of Gio-2.0.Gio.ActionMap

        /**
         * Adds an action to the `action_map`.
         *
         * If the action map already contains an action with the same name
         * as `action` then the old action is dropped from the action map.
         *
         * The action map takes its own reference on `action`.
         * @param action a #GAction
         */
        add_action(action: Action): void;
        /**
         * A convenience function for creating multiple #GSimpleAction instances
         * and adding them to a #GActionMap.
         *
         * Each action is constructed as per one #GActionEntry.
         *
         *
         * ```c
         * static void
         * activate_quit (GSimpleAction *simple,
         *                GVariant      *parameter,
         *                gpointer       user_data)
         * {
         *   exit (0);
         * }
         *
         * static void
         * activate_print_string (GSimpleAction *simple,
         *                        GVariant      *parameter,
         *                        gpointer       user_data)
         * {
         *   g_print ("%s\n", g_variant_get_string (parameter, NULL));
         * }
         *
         * static GActionGroup *
         * create_action_group (void)
         * {
         *   const GActionEntry entries[] = {
         *     { "quit",         activate_quit              },
         *     { "print-string", activate_print_string, "s" }
         *   };
         *   GSimpleActionGroup *group;
         *
         *   group = g_simple_action_group_new ();
         *   g_action_map_add_action_entries (G_ACTION_MAP (group), entries, G_N_ELEMENTS (entries), NULL);
         *
         *   return G_ACTION_GROUP (group);
         * }
         * ```
         *
         * @param entries a pointer to           the first item in an array of #GActionEntry structs
         * @param user_data the user data for signal connections
         */
        add_action_entries(entries: ActionEntry[], user_data: any | null): void;
        /**
         * Looks up the action with the name `action_name` in `action_map`.
         *
         * If no such action exists, returns %NULL.
         * @param action_name the name of an action
         * @returns a #GAction, or %NULL
         */
        lookup_action(action_name: string | null): Action | null;
        /**
         * Removes the named action from the action map.
         *
         * If no action of this name is in the map then nothing happens.
         * @param action_name the name of the action
         */
        remove_action(action_name: string | null): void;
        /**
         * Remove actions from a #GActionMap. This is meant as the reverse of
         * g_action_map_add_action_entries().
         *
         *
         *
         * ```c
         * static const GActionEntry entries[] = {
         *     { "quit",         activate_quit              },
         *     { "print-string", activate_print_string, "s" }
         * };
         *
         * void
         * add_actions (GActionMap *map)
         * {
         *   g_action_map_add_action_entries (map, entries, G_N_ELEMENTS (entries), NULL);
         * }
         *
         * void
         * remove_actions (GActionMap *map)
         * {
         *   g_action_map_remove_action_entries (map, entries, G_N_ELEMENTS (entries));
         * }
         * ```
         *
         * @param entries a pointer to           the first item in an array of #GActionEntry structs
         */
        remove_action_entries(entries: ActionEntry[]): void;

        // Own virtual methods of Gio-2.0.Gio.ActionMap

        /**
         * Adds an action to the `action_map`.
         *
         * If the action map already contains an action with the same name
         * as `action` then the old action is dropped from the action map.
         *
         * The action map takes its own reference on `action`.
         * @virtual
         * @param action a #GAction
         */
        vfunc_add_action(action: Action): void;
        /**
         * Looks up the action with the name `action_name` in `action_map`.
         *
         * If no such action exists, returns %NULL.
         * @virtual
         * @param action_name the name of an action
         * @returns a #GAction, or %NULL
         */
        vfunc_lookup_action(action_name: string | null): Action | null;
        /**
         * Removes the named action from the action map.
         *
         * If no action of this name is in the map then nothing happens.
         * @virtual
         * @param action_name the name of the action
         */
        vfunc_remove_action(action_name: string | null): void;

        // Class property signals of Gio-2.0.Gio.ActionMap

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * The GActionMap interface is implemented by #GActionGroup
     * implementations that operate by containing a number of
     * named #GAction instances, such as #GSimpleActionGroup.
     *
     * One useful application of this interface is to map the
     * names of actions from various action groups to unique,
     * prefixed names (e.g. by prepending "app." or "win.").
     * This is the motivation for the 'Map' part of the interface
     * name.
     * @interface
     */
    class ActionMap extends GObject.Object {
        // Own properties of Gio-2.0.Gio.ActionMap

        static name: string;
        static $gtype: GObject.GType<ActionMap>;

        // Constructors of Gio-2.0.Gio.ActionMap

        constructor(config?: ActionMap.ConstructorProperties);
        _init(config?: ActionMap.ConstructorProperties): void;
    }

    namespace AppInfo {
        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface AppInfo {
        // Owm methods of Gio-2.0.Gio.AppInfo

        /**
         * Adds a content type to the application information to indicate the
         * application is capable of opening files with the given content type.
         * @param content_type a string.
         * @returns %TRUE on success, %FALSE on error.
         */
        add_supports_type(content_type: string | null): boolean;
        /**
         * Obtains the information whether the #GAppInfo can be deleted.
         * See g_app_info_delete().
         * @returns %TRUE if @appinfo can be deleted
         */
        can_delete(): boolean;
        /**
         * Checks if a supported content type can be removed from an application.
         * @returns %TRUE if it is possible to remove supported     content types from a given @appinfo, %FALSE if not.
         */
        can_remove_supports_type(): boolean;
        /**
         * Tries to delete a #GAppInfo.
         *
         * On some platforms, there may be a difference between user-defined
         * #GAppInfos which can be deleted, and system-wide ones which cannot.
         * See g_app_info_can_delete().
         * @returns %TRUE if @appinfo has been deleted
         */
        delete(): boolean;
        /**
         * Creates a duplicate of a #GAppInfo.
         * @returns a duplicate of @appinfo.
         */
        dup(): AppInfo;
        /**
         * Checks if two #GAppInfos are equal.
         *
         * Note that the check *may not* compare each individual
         * field, and only does an identity check. In case detecting changes in the
         * contents is needed, program code must additionally compare relevant fields.
         * @param appinfo2 the second #GAppInfo.
         * @returns %TRUE if @appinfo1 is equal to @appinfo2. %FALSE otherwise.
         */
        equal(appinfo2: AppInfo): boolean;
        /**
         * Gets the commandline with which the application will be
         * started.
         * @returns a string containing the @appinfo's commandline,     or %NULL if this information is not available
         */
        get_commandline(): string | null;
        /**
         * Gets a human-readable description of an installed application.
         * @returns a string containing a description of the application @appinfo, or %NULL if none.
         */
        get_description(): string | null;
        /**
         * Gets the display name of the application. The display name is often more
         * descriptive to the user than the name itself.
         * @returns the display name of the application for @appinfo, or the name if no display name is available.
         */
        get_display_name(): string | null;
        /**
         * Gets the executable's name for the installed application.
         *
         * This is intended to be used for debugging or labelling what program is going
         * to be run. To launch the executable, use g_app_info_launch() and related
         * functions, rather than spawning the return value from this function.
         * @returns a string containing the @appinfo's application binaries name
         */
        get_executable(): string;
        /**
         * Gets the icon for the application.
         * @returns the default #GIcon for @appinfo or %NULL if there is no default icon.
         */
        get_icon(): Icon | null;
        /**
         * Gets the ID of an application. An id is a string that
         * identifies the application. The exact format of the id is
         * platform dependent. For instance, on Unix this is the
         * desktop file id from the xdg menu specification.
         *
         * Note that the returned ID may be %NULL, depending on how
         * the `appinfo` has been constructed.
         * @returns a string containing the application's ID.
         */
        get_id(): string | null;
        /**
         * Gets the installed name of the application.
         * @returns the name of the application for @appinfo.
         */
        get_name(): string | null;
        /**
         * Retrieves the list of content types that `app_info` claims to support.
         * If this information is not provided by the environment, this function
         * will return %NULL.
         * This function does not take in consideration associations added with
         * g_app_info_add_supports_type(), but only those exported directly by
         * the application.
         * @returns     a list of content types.
         */
        get_supported_types(): string[];
        /**
         * Launches the application. Passes `files` to the launched application
         * as arguments, using the optional `context` to get information
         * about the details of the launcher (like what screen it is on).
         * On error, `error` will be set accordingly.
         *
         * To launch the application without arguments pass a %NULL `files` list.
         *
         * Note that even if the launch is successful the application launched
         * can fail to start if it runs into problems during startup. There is
         * no way to detect this.
         *
         * Some URIs can be changed when passed through a GFile (for instance
         * unsupported URIs with strange formats like mailto:), so if you have
         * a textual URI you want to pass in as argument, consider using
         * g_app_info_launch_uris() instead.
         *
         * The launched application inherits the environment of the launching
         * process, but it can be modified with g_app_launch_context_setenv()
         * and g_app_launch_context_unsetenv().
         *
         * On UNIX, this function sets the `GIO_LAUNCHED_DESKTOP_FILE`
         * environment variable with the path of the launched desktop file and
         * `GIO_LAUNCHED_DESKTOP_FILE_PID` to the process id of the launched
         * process. This can be used to ignore `GIO_LAUNCHED_DESKTOP_FILE`,
         * should it be inherited by further processes. The `DISPLAY`,
         * `XDG_ACTIVATION_TOKEN` and `DESKTOP_STARTUP_ID` environment
         * variables are also set, based on information provided in `context`.
         * @param files a #GList of #GFile objects
         * @param context a #GAppLaunchContext or %NULL
         * @returns %TRUE on successful launch, %FALSE otherwise.
         */
        launch(files: File[] | null, context: AppLaunchContext | null): boolean;
        /**
         * Launches the application. This passes the `uris` to the launched application
         * as arguments, using the optional `context` to get information
         * about the details of the launcher (like what screen it is on).
         * On error, `error` will be set accordingly. If the application only supports
         * one URI per invocation as part of their command-line, multiple instances
         * of the application will be spawned.
         *
         * To launch the application without arguments pass a %NULL `uris` list.
         *
         * Note that even if the launch is successful the application launched
         * can fail to start if it runs into problems during startup. There is
         * no way to detect this.
         * @param uris a #GList containing URIs to launch.
         * @param context a #GAppLaunchContext or %NULL
         * @returns %TRUE on successful launch, %FALSE otherwise.
         */
        launch_uris(
            uris: string[] | null,
            context: AppLaunchContext | null
        ): boolean;
        /**
         * Async version of g_app_info_launch_uris().
         *
         * The `callback` is invoked immediately after the application launch, but it
         * waits for activation in case of D-Busactivated applications and also provides
         * extended error information for sandboxed applications, see notes for
         * g_app_info_launch_default_for_uri_async().
         * @param uris a #GList containing URIs to launch.
         * @param context a #GAppLaunchContext or %NULL
         * @param cancellable a #GCancellable
         * @param callback a #GAsyncReadyCallback to call when the request is done
         */
        launch_uris_async(
            uris: string[] | null,
            context: AppLaunchContext | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of launch_uris_async

        /**
         * Promisified version of {@link launch_uris_async}
         *
         * Async version of g_app_info_launch_uris().
         *
         * The `callback` is invoked immediately after the application launch, but it
         * waits for activation in case of D-Busactivated applications and also provides
         * extended error information for sandboxed applications, see notes for
         * g_app_info_launch_default_for_uri_async().
         * @param uris a #GList containing URIs to launch.
         * @param context a #GAppLaunchContext or %NULL
         * @param cancellable a #GCancellable
         * @returns A Promise of: %TRUE on successful launch, %FALSE otherwise.
         */
        launch_uris_async(
            uris: string[] | null,
            context: AppLaunchContext | null,
            cancellable: Cancellable | null
        ): globalThis.Promise<boolean>;
        /**
         * Finishes a g_app_info_launch_uris_async() operation.
         * @param result a #GAsyncResult
         * @returns %TRUE on successful launch, %FALSE otherwise.
         */
        launch_uris_finish(result: AsyncResult): boolean;
        /**
         * Removes a supported type from an application, if possible.
         * @param content_type a string.
         * @returns %TRUE on success, %FALSE on error.
         */
        remove_supports_type(content_type: string | null): boolean;
        /**
         * Sets the application as the default handler for the given file extension.
         * @param extension a string containing the file extension     (without the dot).
         * @returns %TRUE on success, %FALSE on error.
         */
        set_as_default_for_extension(extension: string): boolean;
        /**
         * Sets the application as the default handler for a given type.
         * @param content_type the content type.
         * @returns %TRUE on success, %FALSE on error.
         */
        set_as_default_for_type(content_type: string | null): boolean;
        /**
         * Sets the application as the last used application for a given type.
         * This will make the application appear as first in the list returned
         * by g_app_info_get_recommended_for_type(), regardless of the default
         * application for that content type.
         * @param content_type the content type.
         * @returns %TRUE on success, %FALSE on error.
         */
        set_as_last_used_for_type(content_type: string | null): boolean;
        /**
         * Checks if the application info should be shown in menus that
         * list available applications.
         * @returns %TRUE if the @appinfo should be shown, %FALSE otherwise.
         */
        should_show(): boolean;
        /**
         * Checks if the application accepts files as arguments.
         * @returns %TRUE if the @appinfo supports files.
         */
        supports_files(): boolean;
        /**
         * Checks if the application supports reading files and directories from URIs.
         * @returns %TRUE if the @appinfo supports URIs.
         */
        supports_uris(): boolean;

        // Own virtual methods of Gio-2.0.Gio.AppInfo

        /**
         * Adds a content type to the application information to indicate the
         * application is capable of opening files with the given content type.
         * @virtual
         * @param content_type a string.
         * @returns %TRUE on success, %FALSE on error.
         */
        vfunc_add_supports_type(content_type: string | null): boolean;
        /**
         * Obtains the information whether the #GAppInfo can be deleted.
         * See g_app_info_delete().
         * @virtual
         * @returns %TRUE if @appinfo can be deleted
         */
        vfunc_can_delete(): boolean;
        /**
         * Checks if a supported content type can be removed from an application.
         * @virtual
         * @returns %TRUE if it is possible to remove supported     content types from a given @appinfo, %FALSE if not.
         */
        vfunc_can_remove_supports_type(): boolean;
        /**
         * Tries to delete a #GAppInfo.
         *
         * On some platforms, there may be a difference between user-defined
         * #GAppInfos which can be deleted, and system-wide ones which cannot.
         * See g_app_info_can_delete().
         * @virtual
         * @returns %TRUE if @appinfo has been deleted
         */
        vfunc_do_delete(): boolean;
        /**
         * Creates a duplicate of a #GAppInfo.
         * @virtual
         * @returns a duplicate of @appinfo.
         */
        vfunc_dup(): AppInfo;
        /**
         * Checks if two #GAppInfos are equal.
         *
         * Note that the check *may not* compare each individual
         * field, and only does an identity check. In case detecting changes in the
         * contents is needed, program code must additionally compare relevant fields.
         * @virtual
         * @param appinfo2 the second #GAppInfo.
         * @returns %TRUE if @appinfo1 is equal to @appinfo2. %FALSE otherwise.
         */
        vfunc_equal(appinfo2: AppInfo): boolean;
        /**
         * Gets the commandline with which the application will be
         * started.
         * @virtual
         * @returns a string containing the @appinfo's commandline,     or %NULL if this information is not available
         */
        vfunc_get_commandline(): string | null;
        /**
         * Gets a human-readable description of an installed application.
         * @virtual
         * @returns a string containing a description of the application @appinfo, or %NULL if none.
         */
        vfunc_get_description(): string | null;
        /**
         * Gets the display name of the application. The display name is often more
         * descriptive to the user than the name itself.
         * @virtual
         * @returns the display name of the application for @appinfo, or the name if no display name is available.
         */
        vfunc_get_display_name(): string | null;
        /**
         * Gets the executable's name for the installed application.
         *
         * This is intended to be used for debugging or labelling what program is going
         * to be run. To launch the executable, use g_app_info_launch() and related
         * functions, rather than spawning the return value from this function.
         * @virtual
         * @returns a string containing the @appinfo's application binaries name
         */
        vfunc_get_executable(): string;
        /**
         * Gets the icon for the application.
         * @virtual
         * @returns the default #GIcon for @appinfo or %NULL if there is no default icon.
         */
        vfunc_get_icon(): Icon | null;
        /**
         * Gets the ID of an application. An id is a string that
         * identifies the application. The exact format of the id is
         * platform dependent. For instance, on Unix this is the
         * desktop file id from the xdg menu specification.
         *
         * Note that the returned ID may be %NULL, depending on how
         * the `appinfo` has been constructed.
         * @virtual
         * @returns a string containing the application's ID.
         */
        vfunc_get_id(): string | null;
        /**
         * Gets the installed name of the application.
         * @virtual
         * @returns the name of the application for @appinfo.
         */
        vfunc_get_name(): string | null;
        /**
         * Retrieves the list of content types that `app_info` claims to support.
         * If this information is not provided by the environment, this function
         * will return %NULL.
         * This function does not take in consideration associations added with
         * g_app_info_add_supports_type(), but only those exported directly by
         * the application.
         * @virtual
         * @returns     a list of content types.
         */
        vfunc_get_supported_types(): string[];
        /**
         * Launches the application. Passes `files` to the launched application
         * as arguments, using the optional `context` to get information
         * about the details of the launcher (like what screen it is on).
         * On error, `error` will be set accordingly.
         *
         * To launch the application without arguments pass a %NULL `files` list.
         *
         * Note that even if the launch is successful the application launched
         * can fail to start if it runs into problems during startup. There is
         * no way to detect this.
         *
         * Some URIs can be changed when passed through a GFile (for instance
         * unsupported URIs with strange formats like mailto:), so if you have
         * a textual URI you want to pass in as argument, consider using
         * g_app_info_launch_uris() instead.
         *
         * The launched application inherits the environment of the launching
         * process, but it can be modified with g_app_launch_context_setenv()
         * and g_app_launch_context_unsetenv().
         *
         * On UNIX, this function sets the `GIO_LAUNCHED_DESKTOP_FILE`
         * environment variable with the path of the launched desktop file and
         * `GIO_LAUNCHED_DESKTOP_FILE_PID` to the process id of the launched
         * process. This can be used to ignore `GIO_LAUNCHED_DESKTOP_FILE`,
         * should it be inherited by further processes. The `DISPLAY`,
         * `XDG_ACTIVATION_TOKEN` and `DESKTOP_STARTUP_ID` environment
         * variables are also set, based on information provided in `context`.
         * @virtual
         * @param files a #GList of #GFile objects
         * @param context a #GAppLaunchContext or %NULL
         * @returns %TRUE on successful launch, %FALSE otherwise.
         */
        vfunc_launch(
            files: File[] | null,
            context: AppLaunchContext | null
        ): boolean;
        /**
         * Launches the application. This passes the `uris` to the launched application
         * as arguments, using the optional `context` to get information
         * about the details of the launcher (like what screen it is on).
         * On error, `error` will be set accordingly. If the application only supports
         * one URI per invocation as part of their command-line, multiple instances
         * of the application will be spawned.
         *
         * To launch the application without arguments pass a %NULL `uris` list.
         *
         * Note that even if the launch is successful the application launched
         * can fail to start if it runs into problems during startup. There is
         * no way to detect this.
         * @virtual
         * @param uris a #GList containing URIs to launch.
         * @param context a #GAppLaunchContext or %NULL
         * @returns %TRUE on successful launch, %FALSE otherwise.
         */
        vfunc_launch_uris(
            uris: string[] | null,
            context: AppLaunchContext | null
        ): boolean;
        /**
         * Async version of g_app_info_launch_uris().
         *
         * The `callback` is invoked immediately after the application launch, but it
         * waits for activation in case of D-Busactivated applications and also provides
         * extended error information for sandboxed applications, see notes for
         * g_app_info_launch_default_for_uri_async().
         * @virtual
         * @param uris a #GList containing URIs to launch.
         * @param context a #GAppLaunchContext or %NULL
         * @param cancellable a #GCancellable
         * @param callback a #GAsyncReadyCallback to call when the request is done
         */
        vfunc_launch_uris_async(
            uris: string[] | null,
            context: AppLaunchContext | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes a g_app_info_launch_uris_async() operation.
         * @virtual
         * @param result a #GAsyncResult
         * @returns %TRUE on successful launch, %FALSE otherwise.
         */
        vfunc_launch_uris_finish(result: AsyncResult): boolean;
        /**
         * Removes a supported type from an application, if possible.
         * @virtual
         * @param content_type a string.
         * @returns %TRUE on success, %FALSE on error.
         */
        vfunc_remove_supports_type(content_type: string | null): boolean;
        /**
         * Sets the application as the default handler for the given file extension.
         * @virtual
         * @param extension a string containing the file extension     (without the dot).
         * @returns %TRUE on success, %FALSE on error.
         */
        vfunc_set_as_default_for_extension(extension: string): boolean;
        /**
         * Sets the application as the default handler for a given type.
         * @virtual
         * @param content_type the content type.
         * @returns %TRUE on success, %FALSE on error.
         */
        vfunc_set_as_default_for_type(content_type: string | null): boolean;
        /**
         * Sets the application as the last used application for a given type.
         * This will make the application appear as first in the list returned
         * by g_app_info_get_recommended_for_type(), regardless of the default
         * application for that content type.
         * @virtual
         * @param content_type the content type.
         * @returns %TRUE on success, %FALSE on error.
         */
        vfunc_set_as_last_used_for_type(content_type: string | null): boolean;
        /**
         * Checks if the application info should be shown in menus that
         * list available applications.
         * @virtual
         * @returns %TRUE if the @appinfo should be shown, %FALSE otherwise.
         */
        vfunc_should_show(): boolean;
        /**
         * Checks if the application accepts files as arguments.
         * @virtual
         * @returns %TRUE if the @appinfo supports files.
         */
        vfunc_supports_files(): boolean;
        /**
         * Checks if the application supports reading files and directories from URIs.
         * @virtual
         * @returns %TRUE if the @appinfo supports URIs.
         */
        vfunc_supports_uris(): boolean;

        // Class property signals of Gio-2.0.Gio.AppInfo

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GAppInfo and #GAppLaunchContext are used for describing and launching
     * applications installed on the system.
     *
     * As of GLib 2.20, URIs will always be converted to POSIX paths
     * (using g_file_get_path()) when using g_app_info_launch() even if
     * the application requested an URI and not a POSIX path. For example
     * for a desktop-file based application with Exec key `totem
     * %U` and a single URI, `sftp://foo/file.avi`, then
     * `/home/user/.gvfs/sftp on foo/file.avi` will be passed. This will
     * only work if a set of suitable GIO extensions (such as gvfs 2.26
     * compiled with FUSE support), is available and operational; if this
     * is not the case, the URI will be passed unmodified to the application.
     * Some URIs, such as `mailto:`, of course cannot be mapped to a POSIX
     * path (in gvfs there's no FUSE mount for it); such URIs will be
     * passed unmodified to the application.
     *
     * Specifically for gvfs 2.26 and later, the POSIX URI will be mapped
     * back to the GIO URI in the #GFile constructors (since gvfs
     * implements the #GVfs extension point). As such, if the application
     * needs to examine the URI, it needs to use g_file_get_uri() or
     * similar on #GFile. In other words, an application cannot assume
     * that the URI passed to e.g. g_file_new_for_commandline_arg() is
     * equal to the result of g_file_get_uri(). The following snippet
     * illustrates this:
     *
     *
     * ```
     * GFile *f;
     * char *uri;
     *
     * file = g_file_new_for_commandline_arg (uri_from_commandline);
     *
     * uri = g_file_get_uri (file);
     * strcmp (uri, uri_from_commandline) == 0;
     * g_free (uri);
     *
     * if (g_file_has_uri_scheme (file, "cdda"))
     *   {
     *     // do something special with uri
     *   }
     * g_object_unref (file);
     * ```
     *
     *
     * This code will work when both `cdda://sr0/Track 1.wav` and
     * `/home/user/.gvfs/cdda on sr0/Track 1.wav` is passed to the
     * application. It should be noted that it's generally not safe
     * for applications to rely on the format of a particular URIs.
     * Different launcher applications (e.g. file managers) may have
     * different ideas of what a given URI means.
     * @interface
     */
    class AppInfo extends GObject.Object {
        // Own properties of Gio-2.0.Gio.AppInfo

        static name: string;
        static $gtype: GObject.GType<AppInfo>;

        // Constructors of Gio-2.0.Gio.AppInfo

        constructor(config?: AppInfo.ConstructorProperties);
        _init(config?: AppInfo.ConstructorProperties): void;
        /**
         * Creates a new #GAppInfo from the given information.
         *
         * Note that for `commandline,` the quoting rules of the Exec key of the
         * [freedesktop.org Desktop Entry Specification](http://freedesktop.org/Standards/desktop-entry-spec)
         * are applied. For example, if the `commandline` contains
         * percent-encoded URIs, the percent-character must be doubled in order to prevent it from
         * being swallowed by Exec key unquoting. See the specification for exact quoting rules.
         * @param commandline the commandline to use
         * @param application_name the application name, or %NULL to use `commandline`
         * @param flags flags that can specify details of the created #GAppInfo
         * @returns new #GAppInfo for given command.
         */
        static create_from_commandline(
            commandline: string,
            application_name: string | null,
            flags: AppInfoCreateFlags
        ): AppInfo;
        /**
         * Gets a list of all of the applications currently registered
         * on this system.
         *
         * For desktop files, this includes applications that have
         * `NoDisplay=true` set or are excluded from display by means
         * of `OnlyShowIn` or `NotShowIn`. See g_app_info_should_show().
         * The returned list does not include applications which have
         * the `Hidden` key set.
         * @returns a newly allocated #GList of references to #GAppInfos.
         */
        static get_all(): AppInfo[];
        /**
         * Gets a list of all #GAppInfos for a given content type,
         * including the recommended and fallback #GAppInfos. See
         * g_app_info_get_recommended_for_type() and
         * g_app_info_get_fallback_for_type().
         * @param content_type the content type to find a #GAppInfo for
         * @returns #GList of #GAppInfos     for given @content_type or %NULL on error.
         */
        static get_all_for_type(content_type: string | null): AppInfo[];
        /**
         * Gets the default #GAppInfo for a given content type.
         * @param content_type the content type to find a #GAppInfo for
         * @param must_support_uris if %TRUE, the #GAppInfo is expected to     support URIs
         * @returns #GAppInfo for given @content_type or     %NULL on error.
         */
        static get_default_for_type(
            content_type: string | null,
            must_support_uris: boolean
        ): AppInfo | null;
        /**
         * Asynchronously gets the default #GAppInfo for a given content type.
         * @param content_type the content type to find a #GAppInfo for
         * @param must_support_uris if %TRUE, the #GAppInfo is expected to     support URIs
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call when the request is done
         */
        static get_default_for_type_async(
            content_type: string | null,
            must_support_uris: boolean,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<AppInfo> | null
        ): void;
        /**
         * Finishes a default #GAppInfo lookup started by
         * g_app_info_get_default_for_type_async().
         *
         * If no #GAppInfo is found, then `error` will be set to %G_IO_ERROR_NOT_FOUND.
         * @param result a #GAsyncResult
         * @returns #GAppInfo for given @content_type or     %NULL on error.
         */
        static get_default_for_type_finish(result: AsyncResult): AppInfo;
        /**
         * Gets the default application for handling URIs with
         * the given URI scheme. A URI scheme is the initial part
         * of the URI, up to but not including the ':', e.g. "http",
         * "ftp" or "sip".
         * @param uri_scheme a string containing a URI scheme.
         * @returns #GAppInfo for given @uri_scheme or     %NULL on error.
         */
        static get_default_for_uri_scheme(
            uri_scheme: string | null
        ): AppInfo | null;
        /**
         * Asynchronously gets the default application for handling URIs with
         * the given URI scheme. A URI scheme is the initial part
         * of the URI, up to but not including the ':', e.g. "http",
         * "ftp" or "sip".
         * @param uri_scheme a string containing a URI scheme.
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call when the request is done
         */
        static get_default_for_uri_scheme_async(
            uri_scheme: string | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<AppInfo> | null
        ): void;
        /**
         * Finishes a default #GAppInfo lookup started by
         * g_app_info_get_default_for_uri_scheme_async().
         *
         * If no #GAppInfo is found, then `error` will be set to %G_IO_ERROR_NOT_FOUND.
         * @param result a #GAsyncResult
         * @returns #GAppInfo for given @uri_scheme or     %NULL on error.
         */
        static get_default_for_uri_scheme_finish(result: AsyncResult): AppInfo;
        /**
         * Gets a list of fallback #GAppInfos for a given content type, i.e.
         * those applications which claim to support the given content type
         * by MIME type subclassing and not directly.
         * @param content_type the content type to find a #GAppInfo for
         * @returns #GList of #GAppInfos     for given @content_type or %NULL on error.
         */
        static get_fallback_for_type(content_type: string | null): AppInfo[];
        /**
         * Gets a list of recommended #GAppInfos for a given content type, i.e.
         * those applications which claim to support the given content type exactly,
         * and not by MIME type subclassing.
         * Note that the first application of the list is the last used one, i.e.
         * the last one for which g_app_info_set_as_last_used_for_type() has been
         * called.
         * @param content_type the content type to find a #GAppInfo for
         * @returns #GList of #GAppInfos     for given @content_type or %NULL on error.
         */
        static get_recommended_for_type(content_type: string | null): AppInfo[];
        /**
         * Utility function that launches the default application
         * registered to handle the specified uri. Synchronous I/O
         * is done on the uri to detect the type of the file if
         * required.
         *
         * The D-Busactivated applications don't have to be started if your application
         * terminates too soon after this function. To prevent this, use
         * g_app_info_launch_default_for_uri_async() instead.
         * @param uri the uri to show
         * @param context an optional #GAppLaunchContext
         * @returns %TRUE on success, %FALSE on error.
         */
        static launch_default_for_uri(
            uri: string | null,
            context: AppLaunchContext | null
        ): boolean;
        /**
         * Async version of g_app_info_launch_default_for_uri().
         *
         * This version is useful if you are interested in receiving
         * error information in the case where the application is
         * sandboxed and the portal may present an application chooser
         * dialog to the user.
         *
         * This is also useful if you want to be sure that the D-Busactivated
         * applications are really started before termination and if you are interested
         * in receiving error information from their activation.
         * @param uri the uri to show
         * @param context an optional #GAppLaunchContext
         * @param cancellable a #GCancellable
         * @param callback a #GAsyncReadyCallback to call when the request is done
         */
        static launch_default_for_uri_async(
            uri: string | null,
            context: AppLaunchContext | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<AppInfo> | null
        ): void;
        /**
         * Finishes an asynchronous launch-default-for-uri operation.
         * @param result a #GAsyncResult
         * @returns %TRUE if the launch was successful, %FALSE if @error is set
         */
        static launch_default_for_uri_finish(result: AsyncResult): boolean;
        /**
         * Removes all changes to the type associations done by
         * g_app_info_set_as_default_for_type(),
         * g_app_info_set_as_default_for_extension(),
         * g_app_info_add_supports_type() or
         * g_app_info_remove_supports_type().
         * @param content_type a content type
         */
        static reset_type_associations(content_type: string | null): void;
    }

    namespace AsyncInitable {
        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface AsyncInitable {
        // Owm methods of Gio-2.0.Gio.AsyncInitable

        /**
         * Starts asynchronous initialization of the object implementing the
         * interface. This must be done before any real use of the object after
         * initial construction. If the object also implements #GInitable you can
         * optionally call g_initable_init() instead.
         *
         * This method is intended for language bindings. If writing in C,
         * g_async_initable_new_async() should typically be used instead.
         *
         * When the initialization is finished, `callback` will be called. You can
         * then call g_async_initable_init_finish() to get the result of the
         * initialization.
         *
         * Implementations may also support cancellation. If `cancellable` is not
         * %NULL, then initialization can be cancelled by triggering the cancellable
         * object from another thread. If the operation was cancelled, the error
         * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
         * the object doesn't support cancellable initialization, the error
         * %G_IO_ERROR_NOT_SUPPORTED will be returned.
         *
         * As with #GInitable, if the object is not initialized, or initialization
         * returns with an error, then all operations on the object except
         * g_object_ref() and g_object_unref() are considered to be invalid, and
         * have undefined behaviour. They will often fail with g_critical() or
         * g_warning(), but this must not be relied on.
         *
         * Callers should not assume that a class which implements #GAsyncInitable can
         * be initialized multiple times; for more information, see g_initable_init().
         * If a class explicitly supports being initialized multiple times,
         * implementation requires yielding all subsequent calls to init_async() on the
         * results of the first call.
         *
         * For classes that also support the #GInitable interface, the default
         * implementation of this method will run the g_initable_init() function
         * in a thread, so if you want to support asynchronous initialization via
         * threads, just implement the #GAsyncInitable interface without overriding
         * any interface methods.
         * @param io_priority the [I/O priority][io-priority] of the operation
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied
         */
        init_async(
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of init_async

        /**
         * Promisified version of {@link init_async}
         *
         * Starts asynchronous initialization of the object implementing the
         * interface. This must be done before any real use of the object after
         * initial construction. If the object also implements #GInitable you can
         * optionally call g_initable_init() instead.
         *
         * This method is intended for language bindings. If writing in C,
         * g_async_initable_new_async() should typically be used instead.
         *
         * When the initialization is finished, `callback` will be called. You can
         * then call g_async_initable_init_finish() to get the result of the
         * initialization.
         *
         * Implementations may also support cancellation. If `cancellable` is not
         * %NULL, then initialization can be cancelled by triggering the cancellable
         * object from another thread. If the operation was cancelled, the error
         * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
         * the object doesn't support cancellable initialization, the error
         * %G_IO_ERROR_NOT_SUPPORTED will be returned.
         *
         * As with #GInitable, if the object is not initialized, or initialization
         * returns with an error, then all operations on the object except
         * g_object_ref() and g_object_unref() are considered to be invalid, and
         * have undefined behaviour. They will often fail with g_critical() or
         * g_warning(), but this must not be relied on.
         *
         * Callers should not assume that a class which implements #GAsyncInitable can
         * be initialized multiple times; for more information, see g_initable_init().
         * If a class explicitly supports being initialized multiple times,
         * implementation requires yielding all subsequent calls to init_async() on the
         * results of the first call.
         *
         * For classes that also support the #GInitable interface, the default
         * implementation of this method will run the g_initable_init() function
         * in a thread, so if you want to support asynchronous initialization via
         * threads, just implement the #GAsyncInitable interface without overriding
         * any interface methods.
         * @param io_priority the [I/O priority][io-priority] of the operation
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns A Promise of: %TRUE if successful. If an error has occurred, this function will return %FALSE and set @error appropriately if present.
         */
        init_async(
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<boolean>;
        /**
         * Finishes asynchronous initialization and returns the result.
         * See g_async_initable_init_async().
         * @param res a #GAsyncResult.
         * @returns %TRUE if successful. If an error has occurred, this function will return %FALSE and set @error appropriately if present.
         */
        init_finish(res: AsyncResult): boolean;
        /**
         * Finishes the async construction for the various g_async_initable_new
         * calls, returning the created object or %NULL on error.
         * @param res the #GAsyncResult from the callback
         * @returns a newly created #GObject,      or %NULL on error. Free with g_object_unref().
         */
        new_finish(res: AsyncResult): GObject.Object;

        // Own virtual methods of Gio-2.0.Gio.AsyncInitable

        /**
         * Starts asynchronous initialization of the object implementing the
         * interface. This must be done before any real use of the object after
         * initial construction. If the object also implements #GInitable you can
         * optionally call g_initable_init() instead.
         *
         * This method is intended for language bindings. If writing in C,
         * g_async_initable_new_async() should typically be used instead.
         *
         * When the initialization is finished, `callback` will be called. You can
         * then call g_async_initable_init_finish() to get the result of the
         * initialization.
         *
         * Implementations may also support cancellation. If `cancellable` is not
         * %NULL, then initialization can be cancelled by triggering the cancellable
         * object from another thread. If the operation was cancelled, the error
         * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
         * the object doesn't support cancellable initialization, the error
         * %G_IO_ERROR_NOT_SUPPORTED will be returned.
         *
         * As with #GInitable, if the object is not initialized, or initialization
         * returns with an error, then all operations on the object except
         * g_object_ref() and g_object_unref() are considered to be invalid, and
         * have undefined behaviour. They will often fail with g_critical() or
         * g_warning(), but this must not be relied on.
         *
         * Callers should not assume that a class which implements #GAsyncInitable can
         * be initialized multiple times; for more information, see g_initable_init().
         * If a class explicitly supports being initialized multiple times,
         * implementation requires yielding all subsequent calls to init_async() on the
         * results of the first call.
         *
         * For classes that also support the #GInitable interface, the default
         * implementation of this method will run the g_initable_init() function
         * in a thread, so if you want to support asynchronous initialization via
         * threads, just implement the #GAsyncInitable interface without overriding
         * any interface methods.
         * @virtual
         * @param io_priority the [I/O priority][io-priority] of the operation
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied
         */
        vfunc_init_async(
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes asynchronous initialization and returns the result.
         * See g_async_initable_init_async().
         * @virtual
         * @param res a #GAsyncResult.
         * @returns %TRUE if successful. If an error has occurred, this function will return %FALSE and set @error appropriately if present.
         */
        vfunc_init_finish(res: AsyncResult): boolean;

        // Class property signals of Gio-2.0.Gio.AsyncInitable

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * This is the asynchronous version of #GInitable; it behaves the same
     * in all ways except that initialization is asynchronous. For more details
     * see the descriptions on #GInitable.
     *
     * A class may implement both the #GInitable and #GAsyncInitable interfaces.
     *
     * Users of objects implementing this are not intended to use the interface
     * method directly; instead it will be used automatically in various ways.
     * For C applications you generally just call g_async_initable_new_async()
     * directly, or indirectly via a foo_thing_new_async() wrapper. This will call
     * g_async_initable_init_async() under the cover, calling back with %NULL and
     * a set %GError on failure.
     *
     * A typical implementation might look something like this:
     *
     *
     * ```c
     * enum {
     *    NOT_INITIALIZED,
     *    INITIALIZING,
     *    INITIALIZED
     * };
     *
     * static void
     * _foo_ready_cb (Foo *self)
     * {
     *   GList *l;
     *
     *   self->priv->state = INITIALIZED;
     *
     *   for (l = self->priv->init_results; l != NULL; l = l->next)
     *     {
     *       GTask *task = l->data;
     *
     *       if (self->priv->success)
     *         g_task_return_boolean (task, TRUE);
     *       else
     *         g_task_return_new_error (task, ...);
     *       g_object_unref (task);
     *     }
     *
     *   g_list_free (self->priv->init_results);
     *   self->priv->init_results = NULL;
     * }
     *
     * static void
     * foo_init_async (GAsyncInitable       *initable,
     *                 int                   io_priority,
     *                 GCancellable         *cancellable,
     *                 GAsyncReadyCallback   callback,
     *                 gpointer              user_data)
     * {
     *   Foo *self = FOO (initable);
     *   GTask *task;
     *
     *   task = g_task_new (initable, cancellable, callback, user_data);
     *   g_task_set_name (task, G_STRFUNC);
     *
     *   switch (self->priv->state)
     *     {
     *       case NOT_INITIALIZED:
     *         _foo_get_ready (self);
     *         self->priv->init_results = g_list_append (self->priv->init_results,
     *                                                   task);
     *         self->priv->state = INITIALIZING;
     *         break;
     *       case INITIALIZING:
     *         self->priv->init_results = g_list_append (self->priv->init_results,
     *                                                   task);
     *         break;
     *       case INITIALIZED:
     *         if (!self->priv->success)
     *           g_task_return_new_error (task, ...);
     *         else
     *           g_task_return_boolean (task, TRUE);
     *         g_object_unref (task);
     *         break;
     *     }
     * }
     *
     * static gboolean
     * foo_init_finish (GAsyncInitable       *initable,
     *                  GAsyncResult         *result,
     *                  GError              **error)
     * {
     *   g_return_val_if_fail (g_task_is_valid (result, initable), FALSE);
     *
     *   return g_task_propagate_boolean (G_TASK (result), error);
     * }
     *
     * static void
     * foo_async_initable_iface_init (gpointer g_iface,
     *                                gpointer data)
     * {
     *   GAsyncInitableIface *iface = g_iface;
     *
     *   iface->init_async = foo_init_async;
     *   iface->init_finish = foo_init_finish;
     * }
     * ```
     *
     * @interface
     */
    class AsyncInitable extends GObject.Object {
        // Own properties of Gio-2.0.Gio.AsyncInitable

        static name: string;
        static $gtype: GObject.GType<AsyncInitable>;

        // Constructors of Gio-2.0.Gio.AsyncInitable

        constructor(config?: AsyncInitable.ConstructorProperties);
        _init(config?: AsyncInitable.ConstructorProperties): void;
        /**
         * Helper function for constructing #GAsyncInitable object. This is
         * similar to g_object_newv() but also initializes the object asynchronously.
         *
         * When the initialization is finished, `callback` will be called. You can
         * then call g_async_initable_new_finish() to get the new object and check
         * for any errors.
         * @param object_type a #GType supporting #GAsyncInitable.
         * @param n_parameters the number of parameters in `parameters`
         * @param parameters the parameters to use to construct the object
         * @param io_priority the [I/O priority][io-priority] of the operation
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback to call when the initialization is     finished
         */
        static newv_async(
            object_type: GObject.GType,
            n_parameters: number,
            parameters: GObject.Parameter,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<AsyncInitable> | null
        ): void;
    }

    namespace AsyncResult {
        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface AsyncResult {
        // Owm methods of Gio-2.0.Gio.AsyncResult

        /**
         * Gets the source object from a #GAsyncResult.
         * @returns a new reference to the source    object for the @res, or %NULL if there is none.
         */
        get_source_object(): GObject.Object | null;
        /**
         * Gets the user data from a #GAsyncResult.
         * @returns the user data for @res.
         */
        get_user_data(): any | null;
        /**
         * Checks if `res` has the given `source_tag` (generally a function
         * pointer indicating the function `res` was created by).
         * @param source_tag an application-defined tag
         * @returns %TRUE if @res has the indicated @source_tag, %FALSE if   not.
         */
        is_tagged(source_tag: any | null): boolean;
        /**
         * If `res` is a #GSimpleAsyncResult, this is equivalent to
         * g_simple_async_result_propagate_error(). Otherwise it returns
         * %FALSE.
         *
         * This can be used for legacy error handling in async *_finish()
         * wrapper functions that traditionally handled #GSimpleAsyncResult
         * error returns themselves rather than calling into the virtual method.
         * This should not be used in new code; #GAsyncResult errors that are
         * set by virtual methods should also be extracted by virtual methods,
         * to enable subclasses to chain up correctly.
         * @returns %TRUE if @error is has been filled in with an error from   @res, %FALSE if not.
         */
        legacy_propagate_error(): boolean;

        // Own virtual methods of Gio-2.0.Gio.AsyncResult

        /**
         * Gets the source object from a #GAsyncResult.
         * @virtual
         * @returns a new reference to the source    object for the @res, or %NULL if there is none.
         */
        vfunc_get_source_object(): GObject.Object | null;
        /**
         * Gets the user data from a #GAsyncResult.
         * @virtual
         * @returns the user data for @res.
         */
        vfunc_get_user_data(): any | null;
        /**
         * Checks if `res` has the given `source_tag` (generally a function
         * pointer indicating the function `res` was created by).
         * @virtual
         * @param source_tag an application-defined tag
         * @returns %TRUE if @res has the indicated @source_tag, %FALSE if   not.
         */
        vfunc_is_tagged(source_tag: any | null): boolean;

        // Class property signals of Gio-2.0.Gio.AsyncResult

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * Provides a base class for implementing asynchronous function results.
     *
     * Asynchronous operations are broken up into two separate operations
     * which are chained together by a #GAsyncReadyCallback. To begin
     * an asynchronous operation, provide a #GAsyncReadyCallback to the
     * asynchronous function. This callback will be triggered when the
     * operation has completed, and must be run in a later iteration of
     * the [thread-default main context][g-main-context-push-thread-default]
     * from where the operation was initiated. It will be passed a
     * #GAsyncResult instance filled with the details of the operation's
     * success or failure, the object the asynchronous function was
     * started for and any error codes returned. The asynchronous callback
     * function is then expected to call the corresponding "_finish()"
     * function, passing the object the function was called for, the
     * #GAsyncResult instance, and (optionally) an `error` to grab any
     * error conditions that may have occurred.
     *
     * The "_finish()" function for an operation takes the generic result
     * (of type #GAsyncResult) and returns the specific result that the
     * operation in question yields (e.g. a #GFileEnumerator for a
     * "enumerate children" operation). If the result or error status of the
     * operation is not needed, there is no need to call the "_finish()"
     * function; GIO will take care of cleaning up the result and error
     * information after the #GAsyncReadyCallback returns. You can pass
     * %NULL for the #GAsyncReadyCallback if you don't need to take any
     * action at all after the operation completes. Applications may also
     * take a reference to the #GAsyncResult and call "_finish()" later;
     * however, the "_finish()" function may be called at most once.
     *
     * Example of a typical asynchronous operation flow:
     *
     * ```c
     * void _theoretical_frobnitz_async (Theoretical         *t,
     *                                   GCancellable        *c,
     *                                   GAsyncReadyCallback  cb,
     *                                   gpointer             u);
     *
     * gboolean _theoretical_frobnitz_finish (Theoretical   *t,
     *                                        GAsyncResult  *res,
     *                                        GError       **e);
     *
     * static void
     * frobnitz_result_func (GObject      *source_object,
     * 		 GAsyncResult *res,
     * 		 gpointer      user_data)
     * {
     *   gboolean success = FALSE;
     *
     *   success = _theoretical_frobnitz_finish (source_object, res, NULL);
     *
     *   if (success)
     *     g_printf ("Hurray!\n");
     *   else
     *     g_printf ("Uh oh!\n");
     *
     *   ...
     *
     * }
     *
     * int main (int argc, void *argv[])
     * {
     *    ...
     *
     *    _theoretical_frobnitz_async (theoretical_data,
     *                                 NULL,
     *                                 frobnitz_result_func,
     *                                 NULL);
     *
     *    ...
     * }
     * ```
     *
     *
     * The callback for an asynchronous operation is called only once, and is
     * always called, even in the case of a cancelled operation. On cancellation
     * the result is a %G_IO_ERROR_CANCELLED error.
     *
     * ## I/O Priority # {#io-priority}
     *
     * Many I/O-related asynchronous operations have a priority parameter,
     * which is used in certain cases to determine the order in which
     * operations are executed. They are not used to determine system-wide
     * I/O scheduling. Priorities are integers, with lower numbers indicating
     * higher priority. It is recommended to choose priorities between
     * %G_PRIORITY_LOW and %G_PRIORITY_HIGH, with %G_PRIORITY_DEFAULT
     * as a default.
     * @interface
     */
    class AsyncResult extends GObject.Object {
        // Own properties of Gio-2.0.Gio.AsyncResult

        static name: string;
        static $gtype: GObject.GType<AsyncResult>;

        // Constructors of Gio-2.0.Gio.AsyncResult

        constructor(config?: AsyncResult.ConstructorProperties);
        _init(config?: AsyncResult.ConstructorProperties): void;
    }

    namespace Converter {
        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface Converter {
        // Owm methods of Gio-2.0.Gio.Converter

        /**
         * This is the main operation used when converting data. It is to be called
         * multiple times in a loop, and each time it will do some work, i.e.
         * producing some output (in `outbuf)` or consuming some input (from `inbuf)` or
         * both. If its not possible to do any work an error is returned.
         *
         * Note that a single call may not consume all input (or any input at all).
         * Also a call may produce output even if given no input, due to state stored
         * in the converter producing output.
         *
         * If any data was either produced or consumed, and then an error happens, then
         * only the successful conversion is reported and the error is returned on the
         * next call.
         *
         * A full conversion loop involves calling this method repeatedly, each time
         * giving it new input and space output space. When there is no more input
         * data after the data in `inbuf,` the flag %G_CONVERTER_INPUT_AT_END must be set.
         * The loop will be (unless some error happens) returning %G_CONVERTER_CONVERTED
         * each time until all data is consumed and all output is produced, then
         * %G_CONVERTER_FINISHED is returned instead. Note, that %G_CONVERTER_FINISHED
         * may be returned even if %G_CONVERTER_INPUT_AT_END is not set, for instance
         * in a decompression converter where the end of data is detectable from the
         * data (and there might even be other data after the end of the compressed data).
         *
         * When some data has successfully been converted `bytes_read` and is set to
         * the number of bytes read from `inbuf,` and `bytes_written` is set to indicate
         * how many bytes was written to `outbuf`. If there are more data to output
         * or consume (i.e. unless the %G_CONVERTER_INPUT_AT_END is specified) then
         * %G_CONVERTER_CONVERTED is returned, and if no more data is to be output
         * then %G_CONVERTER_FINISHED is returned.
         *
         * On error %G_CONVERTER_ERROR is returned and `error` is set accordingly.
         * Some errors need special handling:
         *
         * %G_IO_ERROR_NO_SPACE is returned if there is not enough space
         * to write the resulting converted data, the application should
         * call the function again with a larger `outbuf` to continue.
         *
         * %G_IO_ERROR_PARTIAL_INPUT is returned if there is not enough
         * input to fully determine what the conversion should produce,
         * and the %G_CONVERTER_INPUT_AT_END flag is not set. This happens for
         * example with an incomplete multibyte sequence when converting text,
         * or when a regexp matches up to the end of the input (and may match
         * further input). It may also happen when `inbuf_size` is zero and
         * there is no more data to produce.
         *
         * When this happens the application should read more input and then
         * call the function again. If further input shows that there is no
         * more data call the function again with the same data but with
         * the %G_CONVERTER_INPUT_AT_END flag set. This may cause the conversion
         * to finish as e.g. in the regexp match case (or, to fail again with
         * %G_IO_ERROR_PARTIAL_INPUT in e.g. a charset conversion where the
         * input is actually partial).
         *
         * After g_converter_convert() has returned %G_CONVERTER_FINISHED the
         * converter object is in an invalid state where its not allowed
         * to call g_converter_convert() anymore. At this time you can only
         * free the object or call g_converter_reset() to reset it to the
         * initial state.
         *
         * If the flag %G_CONVERTER_FLUSH is set then conversion is modified
         * to try to write out all internal state to the output. The application
         * has to call the function multiple times with the flag set, and when
         * the available input has been consumed and all internal state has
         * been produced then %G_CONVERTER_FLUSHED (or %G_CONVERTER_FINISHED if
         * really at the end) is returned instead of %G_CONVERTER_CONVERTED.
         * This is somewhat similar to what happens at the end of the input stream,
         * but done in the middle of the data.
         *
         * This has different meanings for different conversions. For instance
         * in a compression converter it would mean that we flush all the
         * compression state into output such that if you uncompress the
         * compressed data you get back all the input data. Doing this may
         * make the final file larger due to padding though. Another example
         * is a regexp conversion, where if you at the end of the flushed data
         * have a match, but there is also a potential longer match. In the
         * non-flushed case we would ask for more input, but when flushing we
         * treat this as the end of input and do the match.
         *
         * Flushing is not always possible (like if a charset converter flushes
         * at a partial multibyte sequence). Converters are supposed to try
         * to produce as much output as possible and then return an error
         * (typically %G_IO_ERROR_PARTIAL_INPUT).
         * @param inbuf the buffer         containing the data to convert.
         * @param outbuf a    buffer to write converted data in.
         * @param flags a #GConverterFlags controlling the conversion details
         * @returns a #GConverterResult, %G_CONVERTER_ERROR on error.
         */
        convert(
            inbuf: Uint8Array,
            outbuf: Uint8Array,
            flags: ConverterFlags
        ): [
            /* returnType */ ConverterResult,
            /* bytes_read */ number,
            /* bytes_written */ number
        ];
        /**
         * Resets all internal state in the converter, making it behave
         * as if it was just created. If the converter has any internal
         * state that would produce output then that output is lost.
         */
        reset(): void;

        // Own virtual methods of Gio-2.0.Gio.Converter

        /**
         * This is the main operation used when converting data. It is to be called
         * multiple times in a loop, and each time it will do some work, i.e.
         * producing some output (in `outbuf)` or consuming some input (from `inbuf)` or
         * both. If its not possible to do any work an error is returned.
         *
         * Note that a single call may not consume all input (or any input at all).
         * Also a call may produce output even if given no input, due to state stored
         * in the converter producing output.
         *
         * If any data was either produced or consumed, and then an error happens, then
         * only the successful conversion is reported and the error is returned on the
         * next call.
         *
         * A full conversion loop involves calling this method repeatedly, each time
         * giving it new input and space output space. When there is no more input
         * data after the data in `inbuf,` the flag %G_CONVERTER_INPUT_AT_END must be set.
         * The loop will be (unless some error happens) returning %G_CONVERTER_CONVERTED
         * each time until all data is consumed and all output is produced, then
         * %G_CONVERTER_FINISHED is returned instead. Note, that %G_CONVERTER_FINISHED
         * may be returned even if %G_CONVERTER_INPUT_AT_END is not set, for instance
         * in a decompression converter where the end of data is detectable from the
         * data (and there might even be other data after the end of the compressed data).
         *
         * When some data has successfully been converted `bytes_read` and is set to
         * the number of bytes read from `inbuf,` and `bytes_written` is set to indicate
         * how many bytes was written to `outbuf`. If there are more data to output
         * or consume (i.e. unless the %G_CONVERTER_INPUT_AT_END is specified) then
         * %G_CONVERTER_CONVERTED is returned, and if no more data is to be output
         * then %G_CONVERTER_FINISHED is returned.
         *
         * On error %G_CONVERTER_ERROR is returned and `error` is set accordingly.
         * Some errors need special handling:
         *
         * %G_IO_ERROR_NO_SPACE is returned if there is not enough space
         * to write the resulting converted data, the application should
         * call the function again with a larger `outbuf` to continue.
         *
         * %G_IO_ERROR_PARTIAL_INPUT is returned if there is not enough
         * input to fully determine what the conversion should produce,
         * and the %G_CONVERTER_INPUT_AT_END flag is not set. This happens for
         * example with an incomplete multibyte sequence when converting text,
         * or when a regexp matches up to the end of the input (and may match
         * further input). It may also happen when `inbuf_size` is zero and
         * there is no more data to produce.
         *
         * When this happens the application should read more input and then
         * call the function again. If further input shows that there is no
         * more data call the function again with the same data but with
         * the %G_CONVERTER_INPUT_AT_END flag set. This may cause the conversion
         * to finish as e.g. in the regexp match case (or, to fail again with
         * %G_IO_ERROR_PARTIAL_INPUT in e.g. a charset conversion where the
         * input is actually partial).
         *
         * After g_converter_convert() has returned %G_CONVERTER_FINISHED the
         * converter object is in an invalid state where its not allowed
         * to call g_converter_convert() anymore. At this time you can only
         * free the object or call g_converter_reset() to reset it to the
         * initial state.
         *
         * If the flag %G_CONVERTER_FLUSH is set then conversion is modified
         * to try to write out all internal state to the output. The application
         * has to call the function multiple times with the flag set, and when
         * the available input has been consumed and all internal state has
         * been produced then %G_CONVERTER_FLUSHED (or %G_CONVERTER_FINISHED if
         * really at the end) is returned instead of %G_CONVERTER_CONVERTED.
         * This is somewhat similar to what happens at the end of the input stream,
         * but done in the middle of the data.
         *
         * This has different meanings for different conversions. For instance
         * in a compression converter it would mean that we flush all the
         * compression state into output such that if you uncompress the
         * compressed data you get back all the input data. Doing this may
         * make the final file larger due to padding though. Another example
         * is a regexp conversion, where if you at the end of the flushed data
         * have a match, but there is also a potential longer match. In the
         * non-flushed case we would ask for more input, but when flushing we
         * treat this as the end of input and do the match.
         *
         * Flushing is not always possible (like if a charset converter flushes
         * at a partial multibyte sequence). Converters are supposed to try
         * to produce as much output as possible and then return an error
         * (typically %G_IO_ERROR_PARTIAL_INPUT).
         * @virtual
         * @param inbuf the buffer         containing the data to convert.
         * @param outbuf a    buffer to write converted data in.
         * @param flags a #GConverterFlags controlling the conversion details
         * @returns a #GConverterResult, %G_CONVERTER_ERROR on error.
         */
        vfunc_convert(
            inbuf: Uint8Array | null,
            outbuf: Uint8Array,
            flags: ConverterFlags
        ): [
            /* returnType */ ConverterResult,
            /* bytes_read */ number,
            /* bytes_written */ number
        ];
        /**
         * Resets all internal state in the converter, making it behave
         * as if it was just created. If the converter has any internal
         * state that would produce output then that output is lost.
         * @virtual
         */
        vfunc_reset(): void;

        // Class property signals of Gio-2.0.Gio.Converter

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GConverter is implemented by objects that convert
     * binary data in various ways. The conversion can be
     * stateful and may fail at any place.
     *
     * Some example conversions are: character set conversion,
     * compression, decompression and regular expression
     * replace.
     * @interface
     */
    class Converter extends GObject.Object {
        // Own properties of Gio-2.0.Gio.Converter

        static name: string;
        static $gtype: GObject.GType<Converter>;

        // Constructors of Gio-2.0.Gio.Converter

        constructor(config?: Converter.ConstructorProperties);
        _init(config?: Converter.ConstructorProperties): void;
    }

    namespace DBusInterface {
        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface DBusInterface {
        // Owm methods of Gio-2.0.Gio.DBusInterface

        /**
         * Gets the #GDBusObject that `interface_` belongs to, if any.
         * @returns A #GDBusObject or %NULL. The returned reference should be freed with g_object_unref().
         */
        get_object(): DBusObject | null;
        /**
         * Gets D-Bus introspection information for the D-Bus interface
         * implemented by `interface_`.
         * @returns A #GDBusInterfaceInfo. Do not free.
         */
        get_info(): DBusInterfaceInfo;
        /**
         * Sets the #GDBusObject for `interface_` to `object`.
         *
         * Note that `interface_` will hold a weak reference to `object`.
         * @param object A #GDBusObject or %NULL.
         */
        set_object(object: DBusObject | null): void;

        // Own virtual methods of Gio-2.0.Gio.DBusInterface

        /**
         * Gets the #GDBusObject that `interface_` belongs to, if any.
         * @virtual
         * @returns A #GDBusObject or %NULL. The returned reference should be freed with g_object_unref().
         */
        vfunc_dup_object(): DBusObject | null;
        /**
         * Gets D-Bus introspection information for the D-Bus interface
         * implemented by `interface_`.
         * @virtual
         * @returns A #GDBusInterfaceInfo. Do not free.
         */
        vfunc_get_info(): DBusInterfaceInfo;
        /**
         * Sets the #GDBusObject for `interface_` to `object`.
         *
         * Note that `interface_` will hold a weak reference to `object`.
         * @virtual
         * @param object A #GDBusObject or %NULL.
         */
        vfunc_set_object(object: DBusObject | null): void;

        // Class property signals of Gio-2.0.Gio.DBusInterface

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * The #GDBusInterface type is the base type for D-Bus interfaces both
     * on the service side (see #GDBusInterfaceSkeleton) and client side
     * (see #GDBusProxy).
     * @interface
     */
    class DBusInterface extends GObject.Object {
        // Own properties of Gio-2.0.Gio.DBusInterface

        static name: string;
        static $gtype: GObject.GType<DBusInterface>;

        // Constructors of Gio-2.0.Gio.DBusInterface

        constructor(config?: DBusInterface.ConstructorProperties);
        _init(config?: DBusInterface.ConstructorProperties): void;
    }

    namespace DBusObject {
        // Signal callback interfaces

        /**
         * Signal callback interface for `interface-added`
         */
        interface InterfaceAddedSignalCallback {
            ($obj: DBusObject, interface: DBusInterface): void;
        }

        /**
         * Signal callback interface for `interface-removed`
         */
        interface InterfaceRemovedSignalCallback {
            ($obj: DBusObject, interface: DBusInterface): void;
        }

        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface DBusObject {
        // Owm methods of Gio-2.0.Gio.DBusObject

        /**
         * Gets the D-Bus interface with name `interface_name` associated with
         * `object,` if any.
         * @param interface_name A D-Bus interface name.
         * @returns %NULL if not found, otherwise a   #GDBusInterface that must be freed with g_object_unref().
         */
        get_interface(interface_name: string | null): DBusInterface | null;
        /**
         * Gets the D-Bus interfaces associated with `object`.
         * @returns A list of #GDBusInterface instances.   The returned list must be freed by g_list_free() after each element has been freed   with g_object_unref().
         */
        get_interfaces(): DBusInterface[];
        /**
         * Gets the object path for `object`.
         * @returns A string owned by @object. Do not free.
         */
        get_object_path(): string | null;

        // Own virtual methods of Gio-2.0.Gio.DBusObject

        /**
         * Gets the D-Bus interface with name `interface_name` associated with
         * `object,` if any.
         * @virtual
         * @param interface_name A D-Bus interface name.
         * @returns %NULL if not found, otherwise a   #GDBusInterface that must be freed with g_object_unref().
         */
        vfunc_get_interface(
            interface_name: string | null
        ): DBusInterface | null;
        /**
         * Gets the D-Bus interfaces associated with `object`.
         * @virtual
         * @returns A list of #GDBusInterface instances.   The returned list must be freed by g_list_free() after each element has been freed   with g_object_unref().
         */
        vfunc_get_interfaces(): DBusInterface[];
        /**
         * Gets the object path for `object`.
         * @virtual
         * @returns A string owned by @object. Do not free.
         */
        vfunc_get_object_path(): string | null;
        vfunc_interface_added(interface_: DBusInterface): void;
        vfunc_interface_removed(interface_: DBusInterface): void;

        // Own signals of Gio-2.0.Gio.DBusObject

        connect(
            sigName: 'interface-added',
            callback: DBusObject.InterfaceAddedSignalCallback
        ): number;
        connect_after(
            sigName: 'interface-added',
            callback: DBusObject.InterfaceAddedSignalCallback
        ): number;
        emit(
            sigName: 'interface-added',
            interface: DBusInterface,
            ...args: any[]
        ): void;
        connect(
            sigName: 'interface-removed',
            callback: DBusObject.InterfaceRemovedSignalCallback
        ): number;
        connect_after(
            sigName: 'interface-removed',
            callback: DBusObject.InterfaceRemovedSignalCallback
        ): number;
        emit(
            sigName: 'interface-removed',
            interface: DBusInterface,
            ...args: any[]
        ): void;

        // Class property signals of Gio-2.0.Gio.DBusObject

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * The #GDBusObject type is the base type for D-Bus objects on both
     * the service side (see #GDBusObjectSkeleton) and the client side
     * (see #GDBusObjectProxy). It is essentially just a container of
     * interfaces.
     * @interface
     */
    class DBusObject extends GObject.Object {
        // Own properties of Gio-2.0.Gio.DBusObject

        static name: string;
        static $gtype: GObject.GType<DBusObject>;

        // Constructors of Gio-2.0.Gio.DBusObject

        constructor(config?: DBusObject.ConstructorProperties);
        _init(config?: DBusObject.ConstructorProperties): void;
    }

    namespace DBusObjectManager {
        // Signal callback interfaces

        /**
         * Signal callback interface for `interface-added`
         */
        interface InterfaceAddedSignalCallback {
            (
                $obj: DBusObjectManager,
                object: DBusObject,
                interface: DBusInterface
            ): void;
        }

        /**
         * Signal callback interface for `interface-removed`
         */
        interface InterfaceRemovedSignalCallback {
            (
                $obj: DBusObjectManager,
                object: DBusObject,
                interface: DBusInterface
            ): void;
        }

        /**
         * Signal callback interface for `object-added`
         */
        interface ObjectAddedSignalCallback {
            ($obj: DBusObjectManager, object: DBusObject): void;
        }

        /**
         * Signal callback interface for `object-removed`
         */
        interface ObjectRemovedSignalCallback {
            ($obj: DBusObjectManager, object: DBusObject): void;
        }

        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface DBusObjectManager {
        // Owm methods of Gio-2.0.Gio.DBusObjectManager

        /**
         * Gets the interface proxy for `interface_name` at `object_path,` if
         * any.
         * @param object_path Object path to look up.
         * @param interface_name D-Bus interface name to look up.
         * @returns A #GDBusInterface instance or %NULL. Free   with g_object_unref().
         */
        get_interface(
            object_path: string | null,
            interface_name: string | null
        ): DBusInterface | null;
        /**
         * Gets the #GDBusObject at `object_path,` if any.
         * @param object_path Object path to look up.
         * @returns A #GDBusObject or %NULL. Free with   g_object_unref().
         */
        get_object(object_path: string | null): DBusObject | null;
        /**
         * Gets the object path that `manager` is for.
         * @returns A string owned by @manager. Do not free.
         */
        get_object_path(): string | null;
        /**
         * Gets all #GDBusObject objects known to `manager`.
         * @returns A list of   #GDBusObject objects. The returned list should be freed with   g_list_free() after each element has been freed with   g_object_unref().
         */
        get_objects(): DBusObject[];

        // Own virtual methods of Gio-2.0.Gio.DBusObjectManager

        /**
         * Gets the interface proxy for `interface_name` at `object_path,` if
         * any.
         * @virtual
         * @param object_path Object path to look up.
         * @param interface_name D-Bus interface name to look up.
         * @returns A #GDBusInterface instance or %NULL. Free   with g_object_unref().
         */
        vfunc_get_interface(
            object_path: string | null,
            interface_name: string | null
        ): DBusInterface | null;
        /**
         * Gets the #GDBusObject at `object_path,` if any.
         * @virtual
         * @param object_path Object path to look up.
         * @returns A #GDBusObject or %NULL. Free with   g_object_unref().
         */
        vfunc_get_object(object_path: string | null): DBusObject | null;
        /**
         * Gets the object path that `manager` is for.
         * @virtual
         * @returns A string owned by @manager. Do not free.
         */
        vfunc_get_object_path(): string | null;
        /**
         * Gets all #GDBusObject objects known to `manager`.
         * @virtual
         * @returns A list of   #GDBusObject objects. The returned list should be freed with   g_list_free() after each element has been freed with   g_object_unref().
         */
        vfunc_get_objects(): DBusObject[];
        vfunc_interface_added(
            object: DBusObject,
            interface_: DBusInterface
        ): void;
        vfunc_interface_removed(
            object: DBusObject,
            interface_: DBusInterface
        ): void;
        vfunc_object_added(object: DBusObject): void;
        vfunc_object_removed(object: DBusObject): void;

        // Own signals of Gio-2.0.Gio.DBusObjectManager

        connect(
            sigName: 'interface-added',
            callback: DBusObjectManager.InterfaceAddedSignalCallback
        ): number;
        connect_after(
            sigName: 'interface-added',
            callback: DBusObjectManager.InterfaceAddedSignalCallback
        ): number;
        emit(
            sigName: 'interface-added',
            object: DBusObject,
            interface: DBusInterface,
            ...args: any[]
        ): void;
        connect(
            sigName: 'interface-removed',
            callback: DBusObjectManager.InterfaceRemovedSignalCallback
        ): number;
        connect_after(
            sigName: 'interface-removed',
            callback: DBusObjectManager.InterfaceRemovedSignalCallback
        ): number;
        emit(
            sigName: 'interface-removed',
            object: DBusObject,
            interface: DBusInterface,
            ...args: any[]
        ): void;
        connect(
            sigName: 'object-added',
            callback: DBusObjectManager.ObjectAddedSignalCallback
        ): number;
        connect_after(
            sigName: 'object-added',
            callback: DBusObjectManager.ObjectAddedSignalCallback
        ): number;
        emit(sigName: 'object-added', object: DBusObject, ...args: any[]): void;
        connect(
            sigName: 'object-removed',
            callback: DBusObjectManager.ObjectRemovedSignalCallback
        ): number;
        connect_after(
            sigName: 'object-removed',
            callback: DBusObjectManager.ObjectRemovedSignalCallback
        ): number;
        emit(
            sigName: 'object-removed',
            object: DBusObject,
            ...args: any[]
        ): void;

        // Class property signals of Gio-2.0.Gio.DBusObjectManager

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * The #GDBusObjectManager type is the base type for service- and
     * client-side implementations of the standardized
     * [org.freedesktop.DBus.ObjectManager](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
     * interface.
     *
     * See #GDBusObjectManagerClient for the client-side implementation
     * and #GDBusObjectManagerServer for the service-side implementation.
     * @interface
     */
    class DBusObjectManager extends GObject.Object {
        // Own properties of Gio-2.0.Gio.DBusObjectManager

        static name: string;
        static $gtype: GObject.GType<DBusObjectManager>;

        // Constructors of Gio-2.0.Gio.DBusObjectManager

        constructor(config?: DBusObjectManager.ConstructorProperties);
        _init(config?: DBusObjectManager.ConstructorProperties): void;
    }

    namespace DatagramBased {
        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface DatagramBased {
        // Owm methods of Gio-2.0.Gio.DatagramBased

        /**
         * Checks on the readiness of `datagram_based` to perform operations. The
         * operations specified in `condition` are checked for and masked against the
         * currently-satisfied conditions on `datagram_based`. The result is returned.
         *
         * %G_IO_IN will be set in the return value if data is available to read with
         * g_datagram_based_receive_messages(), or if the connection is closed remotely
         * (EOS); and if the datagram_based has not been closed locally using some
         * implementation-specific method (such as g_socket_close() or
         * g_socket_shutdown() with `shutdown_read` set, if its a #GSocket).
         *
         * If the connection is shut down or closed (by calling g_socket_close() or
         * g_socket_shutdown() with `shutdown_read` set, if its a #GSocket, for
         * example), all calls to this function will return %G_IO_ERROR_CLOSED.
         *
         * %G_IO_OUT will be set if it is expected that at least one byte can be sent
         * using g_datagram_based_send_messages() without blocking. It will not be set
         * if the datagram_based has been closed locally.
         *
         * %G_IO_HUP will be set if the connection has been closed locally.
         *
         * %G_IO_ERR will be set if there was an asynchronous error in transmitting data
         * previously enqueued using g_datagram_based_send_messages().
         *
         * Note that on Windows, it is possible for an operation to return
         * %G_IO_ERROR_WOULD_BLOCK even immediately after
         * g_datagram_based_condition_check() has claimed that the #GDatagramBased is
         * ready for writing. Rather than calling g_datagram_based_condition_check() and
         * then writing to the #GDatagramBased if it succeeds, it is generally better to
         * simply try writing right away, and try again later if the initial attempt
         * returns %G_IO_ERROR_WOULD_BLOCK.
         *
         * It is meaningless to specify %G_IO_ERR or %G_IO_HUP in `condition;` these
         * conditions will always be set in the output if they are true. Apart from
         * these flags, the output is guaranteed to be masked by `condition`.
         *
         * This call never blocks.
         * @param condition a #GIOCondition mask to check
         * @returns the #GIOCondition mask of the current state
         */
        condition_check(condition: GLib.IOCondition): GLib.IOCondition;
        /**
         * Waits for up to `timeout` microseconds for condition to become true on
         * `datagram_based`. If the condition is met, %TRUE is returned.
         *
         * If `cancellable` is cancelled before the condition is met, or if `timeout` is
         * reached before the condition is met, then %FALSE is returned and `error` is
         * set appropriately (%G_IO_ERROR_CANCELLED or %G_IO_ERROR_TIMED_OUT).
         * @param condition a #GIOCondition mask to wait for
         * @param timeout the maximum time (in microseconds) to wait, 0 to not block, or -1   to block indefinitely
         * @param cancellable a #GCancellable
         * @returns %TRUE if the condition was met, %FALSE otherwise
         */
        condition_wait(
            condition: GLib.IOCondition,
            timeout: number,
            cancellable: Cancellable | null
        ): boolean;
        /**
         * Creates a #GSource that can be attached to a #GMainContext to monitor for
         * the availability of the specified `condition` on the #GDatagramBased. The
         * #GSource keeps a reference to the `datagram_based`.
         *
         * The callback on the source is of the #GDatagramBasedSourceFunc type.
         *
         * It is meaningless to specify %G_IO_ERR or %G_IO_HUP in `condition;` these
         * conditions will always be reported in the callback if they are true.
         *
         * If non-%NULL, `cancellable` can be used to cancel the source, which will
         * cause the source to trigger, reporting the current condition (which is
         * likely 0 unless cancellation happened at the same time as a condition
         * change). You can check for this in the callback using
         * g_cancellable_is_cancelled().
         * @param condition a #GIOCondition mask to monitor
         * @param cancellable a #GCancellable
         * @returns a newly allocated #GSource
         */
        create_source(
            condition: GLib.IOCondition,
            cancellable: Cancellable | null
        ): GLib.Source;
        /**
         * Receive one or more data messages from `datagram_based` in one go.
         *
         * `messages` must point to an array of #GInputMessage structs and
         * `num_messages` must be the length of this array. Each #GInputMessage
         * contains a pointer to an array of #GInputVector structs describing the
         * buffers that the data received in each message will be written to.
         *
         * `flags` modify how all messages are received. The commonly available
         * arguments for this are available in the #GSocketMsgFlags enum, but the
         * values there are the same as the system values, and the flags
         * are passed in as-is, so you can pass in system-specific flags too. These
         * flags affect the overall receive operation. Flags affecting individual
         * messages are returned in #GInputMessage.flags.
         *
         * The other members of #GInputMessage are treated as described in its
         * documentation.
         *
         * If `timeout` is negative the call will block until `num_messages` have been
         * received, the connection is closed remotely (EOS), `cancellable` is cancelled,
         * or an error occurs.
         *
         * If `timeout` is 0 the call will return up to `num_messages` without blocking,
         * or %G_IO_ERROR_WOULD_BLOCK if no messages are queued in the operating system
         * to be received.
         *
         * If `timeout` is positive the call will block on the same conditions as if
         * `timeout` were negative. If the timeout is reached
         * before any messages are received, %G_IO_ERROR_TIMED_OUT is returned,
         * otherwise it will return the number of messages received before timing out.
         * (Note: This is effectively the behaviour of `MSG_WAITFORONE` with
         * recvmmsg().)
         *
         * To be notified when messages are available, wait for the %G_IO_IN condition.
         * Note though that you may still receive %G_IO_ERROR_WOULD_BLOCK from
         * g_datagram_based_receive_messages() even if you were previously notified of a
         * %G_IO_IN condition.
         *
         * If the remote peer closes the connection, any messages queued in the
         * underlying receive buffer will be returned, and subsequent calls to
         * g_datagram_based_receive_messages() will return 0 (with no error set).
         *
         * If the connection is shut down or closed (by calling g_socket_close() or
         * g_socket_shutdown() with `shutdown_read` set, if its a #GSocket, for
         * example), all calls to this function will return %G_IO_ERROR_CLOSED.
         *
         * On error -1 is returned and `error` is set accordingly. An error will only
         * be returned if zero messages could be received; otherwise the number of
         * messages successfully received before the error will be returned. If
         * `cancellable` is cancelled, %G_IO_ERROR_CANCELLED is returned as with any
         * other error.
         * @param messages an array of #GInputMessage structs
         * @param flags an int containing #GSocketMsgFlags flags for the overall operation
         * @param timeout the maximum time (in microseconds) to wait, 0 to not block, or -1   to block indefinitely
         * @param cancellable a %GCancellable
         * @returns number of messages received, or -1 on error. Note that the number     of messages received may be smaller than @num_messages if @timeout is     zero or positive, if the peer closed the connection, or if @num_messages     was larger than `UIO_MAXIOV` (1024), in which case the caller may re-try     to receive the remaining messages.
         */
        receive_messages(
            messages: InputMessage[],
            flags: number,
            timeout: number,
            cancellable: Cancellable | null
        ): number;
        /**
         * Send one or more data messages from `datagram_based` in one go.
         *
         * `messages` must point to an array of #GOutputMessage structs and
         * `num_messages` must be the length of this array. Each #GOutputMessage
         * contains an address to send the data to, and a pointer to an array of
         * #GOutputVector structs to describe the buffers that the data to be sent
         * for each message will be gathered from.
         *
         * `flags` modify how the message is sent. The commonly available arguments
         * for this are available in the #GSocketMsgFlags enum, but the
         * values there are the same as the system values, and the flags
         * are passed in as-is, so you can pass in system-specific flags too.
         *
         * The other members of #GOutputMessage are treated as described in its
         * documentation.
         *
         * If `timeout` is negative the call will block until `num_messages` have been
         * sent, `cancellable` is cancelled, or an error occurs.
         *
         * If `timeout` is 0 the call will send up to `num_messages` without blocking,
         * or will return %G_IO_ERROR_WOULD_BLOCK if there is no space to send messages.
         *
         * If `timeout` is positive the call will block on the same conditions as if
         * `timeout` were negative. If the timeout is reached before any messages are
         * sent, %G_IO_ERROR_TIMED_OUT is returned, otherwise it will return the number
         * of messages sent before timing out.
         *
         * To be notified when messages can be sent, wait for the %G_IO_OUT condition.
         * Note though that you may still receive %G_IO_ERROR_WOULD_BLOCK from
         * g_datagram_based_send_messages() even if you were previously notified of a
         * %G_IO_OUT condition. (On Windows in particular, this is very common due to
         * the way the underlying APIs work.)
         *
         * If the connection is shut down or closed (by calling g_socket_close() or
         * g_socket_shutdown() with `shutdown_write` set, if its a #GSocket, for
         * example), all calls to this function will return %G_IO_ERROR_CLOSED.
         *
         * On error -1 is returned and `error` is set accordingly. An error will only
         * be returned if zero messages could be sent; otherwise the number of messages
         * successfully sent before the error will be returned. If `cancellable` is
         * cancelled, %G_IO_ERROR_CANCELLED is returned as with any other error.
         * @param messages an array of #GOutputMessage structs
         * @param flags an int containing #GSocketMsgFlags flags
         * @param timeout the maximum time (in microseconds) to wait, 0 to not block, or -1   to block indefinitely
         * @param cancellable a %GCancellable
         * @returns number of messages sent, or -1 on error. Note that the number of     messages sent may be smaller than @num_messages if @timeout is zero     or positive, or if @num_messages was larger than `UIO_MAXIOV` (1024), in     which case the caller may re-try to send the remaining messages.
         */
        send_messages(
            messages: OutputMessage[],
            flags: number,
            timeout: number,
            cancellable: Cancellable | null
        ): number;

        // Own virtual methods of Gio-2.0.Gio.DatagramBased

        /**
         * Checks on the readiness of `datagram_based` to perform operations. The
         * operations specified in `condition` are checked for and masked against the
         * currently-satisfied conditions on `datagram_based`. The result is returned.
         *
         * %G_IO_IN will be set in the return value if data is available to read with
         * g_datagram_based_receive_messages(), or if the connection is closed remotely
         * (EOS); and if the datagram_based has not been closed locally using some
         * implementation-specific method (such as g_socket_close() or
         * g_socket_shutdown() with `shutdown_read` set, if its a #GSocket).
         *
         * If the connection is shut down or closed (by calling g_socket_close() or
         * g_socket_shutdown() with `shutdown_read` set, if its a #GSocket, for
         * example), all calls to this function will return %G_IO_ERROR_CLOSED.
         *
         * %G_IO_OUT will be set if it is expected that at least one byte can be sent
         * using g_datagram_based_send_messages() without blocking. It will not be set
         * if the datagram_based has been closed locally.
         *
         * %G_IO_HUP will be set if the connection has been closed locally.
         *
         * %G_IO_ERR will be set if there was an asynchronous error in transmitting data
         * previously enqueued using g_datagram_based_send_messages().
         *
         * Note that on Windows, it is possible for an operation to return
         * %G_IO_ERROR_WOULD_BLOCK even immediately after
         * g_datagram_based_condition_check() has claimed that the #GDatagramBased is
         * ready for writing. Rather than calling g_datagram_based_condition_check() and
         * then writing to the #GDatagramBased if it succeeds, it is generally better to
         * simply try writing right away, and try again later if the initial attempt
         * returns %G_IO_ERROR_WOULD_BLOCK.
         *
         * It is meaningless to specify %G_IO_ERR or %G_IO_HUP in `condition;` these
         * conditions will always be set in the output if they are true. Apart from
         * these flags, the output is guaranteed to be masked by `condition`.
         *
         * This call never blocks.
         * @virtual
         * @param condition a #GIOCondition mask to check
         * @returns the #GIOCondition mask of the current state
         */
        vfunc_condition_check(condition: GLib.IOCondition): GLib.IOCondition;
        /**
         * Waits for up to `timeout` microseconds for condition to become true on
         * `datagram_based`. If the condition is met, %TRUE is returned.
         *
         * If `cancellable` is cancelled before the condition is met, or if `timeout` is
         * reached before the condition is met, then %FALSE is returned and `error` is
         * set appropriately (%G_IO_ERROR_CANCELLED or %G_IO_ERROR_TIMED_OUT).
         * @virtual
         * @param condition a #GIOCondition mask to wait for
         * @param timeout the maximum time (in microseconds) to wait, 0 to not block, or -1   to block indefinitely
         * @param cancellable a #GCancellable
         * @returns %TRUE if the condition was met, %FALSE otherwise
         */
        vfunc_condition_wait(
            condition: GLib.IOCondition,
            timeout: number,
            cancellable: Cancellable | null
        ): boolean;
        /**
         * Creates a #GSource that can be attached to a #GMainContext to monitor for
         * the availability of the specified `condition` on the #GDatagramBased. The
         * #GSource keeps a reference to the `datagram_based`.
         *
         * The callback on the source is of the #GDatagramBasedSourceFunc type.
         *
         * It is meaningless to specify %G_IO_ERR or %G_IO_HUP in `condition;` these
         * conditions will always be reported in the callback if they are true.
         *
         * If non-%NULL, `cancellable` can be used to cancel the source, which will
         * cause the source to trigger, reporting the current condition (which is
         * likely 0 unless cancellation happened at the same time as a condition
         * change). You can check for this in the callback using
         * g_cancellable_is_cancelled().
         * @virtual
         * @param condition a #GIOCondition mask to monitor
         * @param cancellable a #GCancellable
         * @returns a newly allocated #GSource
         */
        vfunc_create_source(
            condition: GLib.IOCondition,
            cancellable: Cancellable | null
        ): GLib.Source;
        /**
         * Receive one or more data messages from `datagram_based` in one go.
         *
         * `messages` must point to an array of #GInputMessage structs and
         * `num_messages` must be the length of this array. Each #GInputMessage
         * contains a pointer to an array of #GInputVector structs describing the
         * buffers that the data received in each message will be written to.
         *
         * `flags` modify how all messages are received. The commonly available
         * arguments for this are available in the #GSocketMsgFlags enum, but the
         * values there are the same as the system values, and the flags
         * are passed in as-is, so you can pass in system-specific flags too. These
         * flags affect the overall receive operation. Flags affecting individual
         * messages are returned in #GInputMessage.flags.
         *
         * The other members of #GInputMessage are treated as described in its
         * documentation.
         *
         * If `timeout` is negative the call will block until `num_messages` have been
         * received, the connection is closed remotely (EOS), `cancellable` is cancelled,
         * or an error occurs.
         *
         * If `timeout` is 0 the call will return up to `num_messages` without blocking,
         * or %G_IO_ERROR_WOULD_BLOCK if no messages are queued in the operating system
         * to be received.
         *
         * If `timeout` is positive the call will block on the same conditions as if
         * `timeout` were negative. If the timeout is reached
         * before any messages are received, %G_IO_ERROR_TIMED_OUT is returned,
         * otherwise it will return the number of messages received before timing out.
         * (Note: This is effectively the behaviour of `MSG_WAITFORONE` with
         * recvmmsg().)
         *
         * To be notified when messages are available, wait for the %G_IO_IN condition.
         * Note though that you may still receive %G_IO_ERROR_WOULD_BLOCK from
         * g_datagram_based_receive_messages() even if you were previously notified of a
         * %G_IO_IN condition.
         *
         * If the remote peer closes the connection, any messages queued in the
         * underlying receive buffer will be returned, and subsequent calls to
         * g_datagram_based_receive_messages() will return 0 (with no error set).
         *
         * If the connection is shut down or closed (by calling g_socket_close() or
         * g_socket_shutdown() with `shutdown_read` set, if its a #GSocket, for
         * example), all calls to this function will return %G_IO_ERROR_CLOSED.
         *
         * On error -1 is returned and `error` is set accordingly. An error will only
         * be returned if zero messages could be received; otherwise the number of
         * messages successfully received before the error will be returned. If
         * `cancellable` is cancelled, %G_IO_ERROR_CANCELLED is returned as with any
         * other error.
         * @virtual
         * @param messages an array of #GInputMessage structs
         * @param flags an int containing #GSocketMsgFlags flags for the overall operation
         * @param timeout the maximum time (in microseconds) to wait, 0 to not block, or -1   to block indefinitely
         * @param cancellable a %GCancellable
         * @returns number of messages received, or -1 on error. Note that the number     of messages received may be smaller than @num_messages if @timeout is     zero or positive, if the peer closed the connection, or if @num_messages     was larger than `UIO_MAXIOV` (1024), in which case the caller may re-try     to receive the remaining messages.
         */
        vfunc_receive_messages(
            messages: InputMessage[],
            flags: number,
            timeout: number,
            cancellable: Cancellable | null
        ): number;
        /**
         * Send one or more data messages from `datagram_based` in one go.
         *
         * `messages` must point to an array of #GOutputMessage structs and
         * `num_messages` must be the length of this array. Each #GOutputMessage
         * contains an address to send the data to, and a pointer to an array of
         * #GOutputVector structs to describe the buffers that the data to be sent
         * for each message will be gathered from.
         *
         * `flags` modify how the message is sent. The commonly available arguments
         * for this are available in the #GSocketMsgFlags enum, but the
         * values there are the same as the system values, and the flags
         * are passed in as-is, so you can pass in system-specific flags too.
         *
         * The other members of #GOutputMessage are treated as described in its
         * documentation.
         *
         * If `timeout` is negative the call will block until `num_messages` have been
         * sent, `cancellable` is cancelled, or an error occurs.
         *
         * If `timeout` is 0 the call will send up to `num_messages` without blocking,
         * or will return %G_IO_ERROR_WOULD_BLOCK if there is no space to send messages.
         *
         * If `timeout` is positive the call will block on the same conditions as if
         * `timeout` were negative. If the timeout is reached before any messages are
         * sent, %G_IO_ERROR_TIMED_OUT is returned, otherwise it will return the number
         * of messages sent before timing out.
         *
         * To be notified when messages can be sent, wait for the %G_IO_OUT condition.
         * Note though that you may still receive %G_IO_ERROR_WOULD_BLOCK from
         * g_datagram_based_send_messages() even if you were previously notified of a
         * %G_IO_OUT condition. (On Windows in particular, this is very common due to
         * the way the underlying APIs work.)
         *
         * If the connection is shut down or closed (by calling g_socket_close() or
         * g_socket_shutdown() with `shutdown_write` set, if its a #GSocket, for
         * example), all calls to this function will return %G_IO_ERROR_CLOSED.
         *
         * On error -1 is returned and `error` is set accordingly. An error will only
         * be returned if zero messages could be sent; otherwise the number of messages
         * successfully sent before the error will be returned. If `cancellable` is
         * cancelled, %G_IO_ERROR_CANCELLED is returned as with any other error.
         * @virtual
         * @param messages an array of #GOutputMessage structs
         * @param flags an int containing #GSocketMsgFlags flags
         * @param timeout the maximum time (in microseconds) to wait, 0 to not block, or -1   to block indefinitely
         * @param cancellable a %GCancellable
         * @returns number of messages sent, or -1 on error. Note that the number of     messages sent may be smaller than @num_messages if @timeout is zero     or positive, or if @num_messages was larger than `UIO_MAXIOV` (1024), in     which case the caller may re-try to send the remaining messages.
         */
        vfunc_send_messages(
            messages: OutputMessage[],
            flags: number,
            timeout: number,
            cancellable: Cancellable | null
        ): number;

        // Class property signals of Gio-2.0.Gio.DatagramBased

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * A #GDatagramBased is a networking interface for representing datagram-based
     * communications. It is a more or less direct mapping of the core parts of the
     * BSD socket API in a portable GObject interface. It is implemented by
     * #GSocket, which wraps the UNIX socket API on UNIX and winsock2 on Windows.
     *
     * #GDatagramBased is entirely platform independent, and is intended to be used
     * alongside higher-level networking APIs such as #GIOStream.
     *
     * It uses vectored scatter/gather I/O by default, allowing for many messages
     * to be sent or received in a single call. Where possible, implementations of
     * the interface should take advantage of vectored I/O to minimise processing
     * or system calls. For example, #GSocket uses recvmmsg() and sendmmsg() where
     * possible. Callers should take advantage of scatter/gather I/O (the use of
     * multiple buffers per message) to avoid unnecessary copying of data to
     * assemble or disassemble a message.
     *
     * Each #GDatagramBased operation has a timeout parameter which may be negative
     * for blocking behaviour, zero for non-blocking behaviour, or positive for
     * timeout behaviour. A blocking operation blocks until finished or there is an
     * error. A non-blocking operation will return immediately with a
     * %G_IO_ERROR_WOULD_BLOCK error if it cannot make progress. A timeout operation
     * will block until the operation is complete or the timeout expires; if the
     * timeout expires it will return what progress it made, or
     * %G_IO_ERROR_TIMED_OUT if no progress was made. To know when a call would
     * successfully run you can call g_datagram_based_condition_check() or
     * g_datagram_based_condition_wait(). You can also use
     * g_datagram_based_create_source() and attach it to a #GMainContext to get
     * callbacks when I/O is possible.
     *
     * When running a non-blocking operation applications should always be able to
     * handle getting a %G_IO_ERROR_WOULD_BLOCK error even when some other function
     * said that I/O was possible. This can easily happen in case of a race
     * condition in the application, but it can also happen for other reasons. For
     * instance, on Windows a socket is always seen as writable until a write
     * returns %G_IO_ERROR_WOULD_BLOCK.
     *
     * As with #GSocket, #GDatagramBaseds can be either connection oriented (for
     * example, SCTP) or connectionless (for example, UDP). #GDatagramBaseds must be
     * datagram-based, not stream-based. The interface does not cover connection
     * establishment  use methods on the underlying type to establish a connection
     * before sending and receiving data through the #GDatagramBased API. For
     * connectionless socket types the target/source address is specified or
     * received in each I/O operation.
     *
     * Like most other APIs in GLib, #GDatagramBased is not inherently thread safe.
     * To use a #GDatagramBased concurrently from multiple threads, you must
     * implement your own locking.
     * @interface
     */
    class DatagramBased extends GObject.Object {
        // Own properties of Gio-2.0.Gio.DatagramBased

        static name: string;
        static $gtype: GObject.GType<DatagramBased>;

        // Constructors of Gio-2.0.Gio.DatagramBased

        constructor(config?: DatagramBased.ConstructorProperties);
        _init(config?: DatagramBased.ConstructorProperties): void;
    }

    namespace DebugController {
        // Constructor properties interface

        interface ConstructorProperties
            extends Initable.ConstructorProperties,
                GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.DebugController

            /**
             * %TRUE if debug output should be exposed (for example by forwarding it to
             * the journal), %FALSE otherwise.
             */
            debug_enabled?: boolean | null;
        }
    }

    interface DebugController extends Initable {
        // Own properties of Gio-2.0.Gio.DebugController

        /**
         * %TRUE if debug output should be exposed (for example by forwarding it to
         * the journal), %FALSE otherwise.
         */
        debug_enabled: boolean;

        // Owm methods of Gio-2.0.Gio.DebugController

        /**
         * Get the value of #GDebugController:debug-enabled.
         * @returns %TRUE if debug output should be exposed, %FALSE otherwise
         */
        get_debug_enabled(): boolean;
        /**
         * Set the value of #GDebugController:debug-enabled.
         * @param debug_enabled %TRUE if debug output should be exposed, %FALSE otherwise
         */
        set_debug_enabled(debug_enabled: boolean): void;

        // Class property signals of Gio-2.0.Gio.DebugController

        connect(
            sigName: 'notify::debug-enabled',
            callback: ($obj: DebugController, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::debug-enabled',
            callback: ($obj: DebugController, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::debug-enabled', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GDebugController is an interface to expose control of debugging features and
     * debug output.
     *
     * It is implemented on Linux using #GDebugControllerDBus, which exposes a D-Bus
     * interface to allow authenticated peers to control debug features in this
     * process.
     *
     * Whether debug output is enabled is exposed as
     * #GDebugController:debug-enabled. This controls g_log_set_debug_enabled() by
     * default. Application code may connect to the #GObject::notify signal for it
     * to control other parts of its debug infrastructure as necessary.
     *
     * If your application or service is using the default GLib log writer function,
     * creating one of the built-in implementations of #GDebugController should be
     * all thats needed to dynamically enable or disable debug output.
     * @interface
     */
    class DebugController extends GObject.Object {
        // Own properties of Gio-2.0.Gio.DebugController

        static name: string;
        static $gtype: GObject.GType<DebugController>;

        // Constructors of Gio-2.0.Gio.DebugController

        constructor(config?: DebugController.ConstructorProperties);
        _init(config?: DebugController.ConstructorProperties): void;
    }

    namespace DesktopAppInfoLookup {
        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface DesktopAppInfoLookup {
        // Owm methods of Gio-2.0.Gio.DesktopAppInfoLookup

        /**
         * Gets the default application for launching applications
         * using this URI scheme for a particular #GDesktopAppInfoLookup
         * implementation.
         *
         * The #GDesktopAppInfoLookup interface and this function is used
         * to implement g_app_info_get_default_for_uri_scheme() backends
         * in a GIO module. There is no reason for applications to use it
         * directly. Applications should use g_app_info_get_default_for_uri_scheme().
         * @param uri_scheme a string containing a URI scheme.
         * @returns #GAppInfo for given @uri_scheme or    %NULL on error.
         */
        get_default_for_uri_scheme(uri_scheme: string | null): AppInfo | null;

        // Own virtual methods of Gio-2.0.Gio.DesktopAppInfoLookup

        /**
         * Gets the default application for launching applications
         * using this URI scheme for a particular #GDesktopAppInfoLookup
         * implementation.
         *
         * The #GDesktopAppInfoLookup interface and this function is used
         * to implement g_app_info_get_default_for_uri_scheme() backends
         * in a GIO module. There is no reason for applications to use it
         * directly. Applications should use g_app_info_get_default_for_uri_scheme().
         * @virtual
         * @param uri_scheme a string containing a URI scheme.
         * @returns #GAppInfo for given @uri_scheme or    %NULL on error.
         */
        vfunc_get_default_for_uri_scheme(
            uri_scheme: string | null
        ): AppInfo | null;

        // Class property signals of Gio-2.0.Gio.DesktopAppInfoLookup

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GDesktopAppInfoLookup is an opaque data structure and can only be accessed
     * using the following functions.
     * @interface
     */
    class DesktopAppInfoLookup extends GObject.Object {
        // Own properties of Gio-2.0.Gio.DesktopAppInfoLookup

        static name: string;
        static $gtype: GObject.GType<DesktopAppInfoLookup>;

        // Constructors of Gio-2.0.Gio.DesktopAppInfoLookup

        constructor(config?: DesktopAppInfoLookup.ConstructorProperties);
        _init(config?: DesktopAppInfoLookup.ConstructorProperties): void;
    }

    namespace Drive {
        // Signal callback interfaces

        /**
         * Signal callback interface for `changed`
         */
        interface ChangedSignalCallback {
            ($obj: Drive): void;
        }

        /**
         * Signal callback interface for `disconnected`
         */
        interface DisconnectedSignalCallback {
            ($obj: Drive): void;
        }

        /**
         * Signal callback interface for `eject-button`
         */
        interface EjectButtonSignalCallback {
            ($obj: Drive): void;
        }

        /**
         * Signal callback interface for `stop-button`
         */
        interface StopButtonSignalCallback {
            ($obj: Drive): void;
        }

        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface Drive {
        // Owm methods of Gio-2.0.Gio.Drive

        /**
         * Checks if a drive can be ejected.
         * @returns %TRUE if the @drive can be ejected, %FALSE otherwise.
         */
        can_eject(): boolean;
        /**
         * Checks if a drive can be polled for media changes.
         * @returns %TRUE if the @drive can be polled for media changes,     %FALSE otherwise.
         */
        can_poll_for_media(): boolean;
        /**
         * Checks if a drive can be started.
         * @returns %TRUE if the @drive can be started, %FALSE otherwise.
         */
        can_start(): boolean;
        /**
         * Checks if a drive can be started degraded.
         * @returns %TRUE if the @drive can be started degraded, %FALSE otherwise.
         */
        can_start_degraded(): boolean;
        /**
         * Checks if a drive can be stopped.
         * @returns %TRUE if the @drive can be stopped, %FALSE otherwise.
         */
        can_stop(): boolean;
        /**
         * Asynchronously ejects a drive.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_drive_eject_finish() to obtain the
         * result of the operation.
         * @param flags flags affecting the unmount if required for eject
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        eject(
            flags: MountUnmountFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes ejecting a drive.
         * @param result a #GAsyncResult.
         * @returns %TRUE if the drive has been ejected successfully,     %FALSE otherwise.
         */
        eject_finish(result: AsyncResult): boolean;
        /**
         * Ejects a drive. This is an asynchronous operation, and is
         * finished by calling g_drive_eject_with_operation_finish() with the `drive`
         * and #GAsyncResult data returned in the `callback`.
         * @param flags flags affecting the unmount if required for eject
         * @param mount_operation a #GMountOperation or %NULL to avoid     user interaction.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        eject_with_operation(
            flags: MountUnmountFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes ejecting a drive. If any errors occurred during the operation,
         * `error` will be set to contain the errors and %FALSE will be returned.
         * @param result a #GAsyncResult.
         * @returns %TRUE if the drive was successfully ejected. %FALSE otherwise.
         */
        eject_with_operation_finish(result: AsyncResult): boolean;
        /**
         * Gets the kinds of identifiers that `drive` has.
         * Use g_drive_get_identifier() to obtain the identifiers
         * themselves.
         * @returns a %NULL-terminated     array of strings containing kinds of identifiers. Use g_strfreev()     to free.
         */
        enumerate_identifiers(): string[];
        /**
         * Gets the icon for `drive`.
         * @returns #GIcon for the @drive.    Free the returned object with g_object_unref().
         */
        get_icon(): Icon;
        /**
         * Gets the identifier of the given kind for `drive`. The only
         * identifier currently available is
         * %G_DRIVE_IDENTIFIER_KIND_UNIX_DEVICE.
         * @param kind the kind of identifier to return
         * @returns a newly allocated string containing the     requested identifier, or %NULL if the #GDrive     doesn't have this kind of identifier.
         */
        get_identifier(kind: string | null): string | null;
        /**
         * Gets the name of `drive`.
         * @returns a string containing @drive's name. The returned     string should be freed when no longer needed.
         */
        get_name(): string | null;
        /**
         * Gets the sort key for `drive,` if any.
         * @returns Sorting key for @drive or %NULL if no such key is available.
         */
        get_sort_key(): string | null;
        /**
         * Gets a hint about how a drive can be started/stopped.
         * @returns A value from the #GDriveStartStopType enumeration.
         */
        get_start_stop_type(): DriveStartStopType;
        /**
         * Gets the icon for `drive`.
         * @returns symbolic #GIcon for the @drive.    Free the returned object with g_object_unref().
         */
        get_symbolic_icon(): Icon;
        /**
         * Get a list of mountable volumes for `drive`.
         *
         * The returned list should be freed with g_list_free(), after
         * its elements have been unreffed with g_object_unref().
         * @returns #GList containing any #GVolume objects on the given @drive.
         */
        get_volumes(): Volume[];
        /**
         * Checks if the `drive` has media. Note that the OS may not be polling
         * the drive for media changes; see g_drive_is_media_check_automatic()
         * for more details.
         * @returns %TRUE if @drive has media, %FALSE otherwise.
         */
        has_media(): boolean;
        /**
         * Check if `drive` has any mountable volumes.
         * @returns %TRUE if the @drive contains volumes, %FALSE otherwise.
         */
        has_volumes(): boolean;
        /**
         * Checks if `drive` is capable of automatically detecting media changes.
         * @returns %TRUE if the @drive is capable of automatically detecting     media changes, %FALSE otherwise.
         */
        is_media_check_automatic(): boolean;
        /**
         * Checks if the `drive` supports removable media.
         * @returns %TRUE if @drive supports removable media, %FALSE otherwise.
         */
        is_media_removable(): boolean;
        /**
         * Checks if the #GDrive and/or its media is considered removable by the user.
         * See g_drive_is_media_removable().
         * @returns %TRUE if @drive and/or its media is considered removable, %FALSE otherwise.
         */
        is_removable(): boolean;
        /**
         * Asynchronously polls `drive` to see if media has been inserted or removed.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_drive_poll_for_media_finish() to obtain the
         * result of the operation.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        poll_for_media(
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes an operation started with g_drive_poll_for_media() on a drive.
         * @param result a #GAsyncResult.
         * @returns %TRUE if the drive has been poll_for_mediaed successfully,     %FALSE otherwise.
         */
        poll_for_media_finish(result: AsyncResult): boolean;
        /**
         * Asynchronously starts a drive.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_drive_start_finish() to obtain the
         * result of the operation.
         * @param flags flags affecting the start operation.
         * @param mount_operation a #GMountOperation or %NULL to avoid     user interaction.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        start(
            flags: DriveStartFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes starting a drive.
         * @param result a #GAsyncResult.
         * @returns %TRUE if the drive has been started successfully,     %FALSE otherwise.
         */
        start_finish(result: AsyncResult): boolean;
        /**
         * Asynchronously stops a drive.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_drive_stop_finish() to obtain the
         * result of the operation.
         * @param flags flags affecting the unmount if required for stopping.
         * @param mount_operation a #GMountOperation or %NULL to avoid     user interaction.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        stop(
            flags: MountUnmountFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes stopping a drive.
         * @param result a #GAsyncResult.
         * @returns %TRUE if the drive has been stopped successfully,     %FALSE otherwise.
         */
        stop_finish(result: AsyncResult): boolean;

        // Own virtual methods of Gio-2.0.Gio.Drive

        /**
         * Checks if a drive can be ejected.
         * @virtual
         * @returns %TRUE if the @drive can be ejected, %FALSE otherwise.
         */
        vfunc_can_eject(): boolean;
        /**
         * Checks if a drive can be polled for media changes.
         * @virtual
         * @returns %TRUE if the @drive can be polled for media changes,     %FALSE otherwise.
         */
        vfunc_can_poll_for_media(): boolean;
        /**
         * Checks if a drive can be started.
         * @virtual
         * @returns %TRUE if the @drive can be started, %FALSE otherwise.
         */
        vfunc_can_start(): boolean;
        /**
         * Checks if a drive can be started degraded.
         * @virtual
         * @returns %TRUE if the @drive can be started degraded, %FALSE otherwise.
         */
        vfunc_can_start_degraded(): boolean;
        /**
         * Checks if a drive can be stopped.
         * @virtual
         * @returns %TRUE if the @drive can be stopped, %FALSE otherwise.
         */
        vfunc_can_stop(): boolean;
        vfunc_changed(): void;
        vfunc_disconnected(): void;
        /**
         * Asynchronously ejects a drive.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_drive_eject_finish() to obtain the
         * result of the operation.
         * @virtual
         * @param flags flags affecting the unmount if required for eject
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        vfunc_eject(
            flags: MountUnmountFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        vfunc_eject_button(): void;
        /**
         * Finishes ejecting a drive.
         * @virtual
         * @param result a #GAsyncResult.
         * @returns %TRUE if the drive has been ejected successfully,     %FALSE otherwise.
         */
        vfunc_eject_finish(result: AsyncResult): boolean;
        /**
         * Ejects a drive. This is an asynchronous operation, and is
         * finished by calling g_drive_eject_with_operation_finish() with the `drive`
         * and #GAsyncResult data returned in the `callback`.
         * @virtual
         * @param flags flags affecting the unmount if required for eject
         * @param mount_operation a #GMountOperation or %NULL to avoid     user interaction.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        vfunc_eject_with_operation(
            flags: MountUnmountFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes ejecting a drive. If any errors occurred during the operation,
         * `error` will be set to contain the errors and %FALSE will be returned.
         * @virtual
         * @param result a #GAsyncResult.
         * @returns %TRUE if the drive was successfully ejected. %FALSE otherwise.
         */
        vfunc_eject_with_operation_finish(result: AsyncResult): boolean;
        /**
         * Gets the kinds of identifiers that `drive` has.
         * Use g_drive_get_identifier() to obtain the identifiers
         * themselves.
         * @virtual
         * @returns a %NULL-terminated     array of strings containing kinds of identifiers. Use g_strfreev()     to free.
         */
        vfunc_enumerate_identifiers(): string[];
        /**
         * Gets the icon for `drive`.
         * @virtual
         * @returns #GIcon for the @drive.    Free the returned object with g_object_unref().
         */
        vfunc_get_icon(): Icon;
        /**
         * Gets the identifier of the given kind for `drive`. The only
         * identifier currently available is
         * %G_DRIVE_IDENTIFIER_KIND_UNIX_DEVICE.
         * @virtual
         * @param kind the kind of identifier to return
         * @returns a newly allocated string containing the     requested identifier, or %NULL if the #GDrive     doesn't have this kind of identifier.
         */
        vfunc_get_identifier(kind: string | null): string | null;
        /**
         * Gets the name of `drive`.
         * @virtual
         * @returns a string containing @drive's name. The returned     string should be freed when no longer needed.
         */
        vfunc_get_name(): string | null;
        /**
         * Gets the sort key for `drive,` if any.
         * @virtual
         * @returns Sorting key for @drive or %NULL if no such key is available.
         */
        vfunc_get_sort_key(): string | null;
        /**
         * Gets a hint about how a drive can be started/stopped.
         * @virtual
         * @returns A value from the #GDriveStartStopType enumeration.
         */
        vfunc_get_start_stop_type(): DriveStartStopType;
        /**
         * Gets the icon for `drive`.
         * @virtual
         * @returns symbolic #GIcon for the @drive.    Free the returned object with g_object_unref().
         */
        vfunc_get_symbolic_icon(): Icon;
        /**
         * Get a list of mountable volumes for `drive`.
         *
         * The returned list should be freed with g_list_free(), after
         * its elements have been unreffed with g_object_unref().
         * @virtual
         * @returns #GList containing any #GVolume objects on the given @drive.
         */
        vfunc_get_volumes(): Volume[];
        /**
         * Checks if the `drive` has media. Note that the OS may not be polling
         * the drive for media changes; see g_drive_is_media_check_automatic()
         * for more details.
         * @virtual
         * @returns %TRUE if @drive has media, %FALSE otherwise.
         */
        vfunc_has_media(): boolean;
        /**
         * Check if `drive` has any mountable volumes.
         * @virtual
         * @returns %TRUE if the @drive contains volumes, %FALSE otherwise.
         */
        vfunc_has_volumes(): boolean;
        /**
         * Checks if `drive` is capable of automatically detecting media changes.
         * @virtual
         * @returns %TRUE if the @drive is capable of automatically detecting     media changes, %FALSE otherwise.
         */
        vfunc_is_media_check_automatic(): boolean;
        /**
         * Checks if the `drive` supports removable media.
         * @virtual
         * @returns %TRUE if @drive supports removable media, %FALSE otherwise.
         */
        vfunc_is_media_removable(): boolean;
        /**
         * Checks if the #GDrive and/or its media is considered removable by the user.
         * See g_drive_is_media_removable().
         * @virtual
         * @returns %TRUE if @drive and/or its media is considered removable, %FALSE otherwise.
         */
        vfunc_is_removable(): boolean;
        /**
         * Asynchronously polls `drive` to see if media has been inserted or removed.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_drive_poll_for_media_finish() to obtain the
         * result of the operation.
         * @virtual
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        vfunc_poll_for_media(
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes an operation started with g_drive_poll_for_media() on a drive.
         * @virtual
         * @param result a #GAsyncResult.
         * @returns %TRUE if the drive has been poll_for_mediaed successfully,     %FALSE otherwise.
         */
        vfunc_poll_for_media_finish(result: AsyncResult): boolean;
        /**
         * Asynchronously starts a drive.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_drive_start_finish() to obtain the
         * result of the operation.
         * @virtual
         * @param flags flags affecting the start operation.
         * @param mount_operation a #GMountOperation or %NULL to avoid     user interaction.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        vfunc_start(
            flags: DriveStartFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes starting a drive.
         * @virtual
         * @param result a #GAsyncResult.
         * @returns %TRUE if the drive has been started successfully,     %FALSE otherwise.
         */
        vfunc_start_finish(result: AsyncResult): boolean;
        /**
         * Asynchronously stops a drive.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_drive_stop_finish() to obtain the
         * result of the operation.
         * @virtual
         * @param flags flags affecting the unmount if required for stopping.
         * @param mount_operation a #GMountOperation or %NULL to avoid     user interaction.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        vfunc_stop(
            flags: MountUnmountFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        vfunc_stop_button(): void;
        /**
         * Finishes stopping a drive.
         * @virtual
         * @param result a #GAsyncResult.
         * @returns %TRUE if the drive has been stopped successfully,     %FALSE otherwise.
         */
        vfunc_stop_finish(result: AsyncResult): boolean;

        // Own signals of Gio-2.0.Gio.Drive

        connect(
            sigName: 'changed',
            callback: Drive.ChangedSignalCallback
        ): number;
        connect_after(
            sigName: 'changed',
            callback: Drive.ChangedSignalCallback
        ): number;
        emit(sigName: 'changed', ...args: any[]): void;
        connect(
            sigName: 'disconnected',
            callback: Drive.DisconnectedSignalCallback
        ): number;
        connect_after(
            sigName: 'disconnected',
            callback: Drive.DisconnectedSignalCallback
        ): number;
        emit(sigName: 'disconnected', ...args: any[]): void;
        connect(
            sigName: 'eject-button',
            callback: Drive.EjectButtonSignalCallback
        ): number;
        connect_after(
            sigName: 'eject-button',
            callback: Drive.EjectButtonSignalCallback
        ): number;
        emit(sigName: 'eject-button', ...args: any[]): void;
        connect(
            sigName: 'stop-button',
            callback: Drive.StopButtonSignalCallback
        ): number;
        connect_after(
            sigName: 'stop-button',
            callback: Drive.StopButtonSignalCallback
        ): number;
        emit(sigName: 'stop-button', ...args: any[]): void;

        // Class property signals of Gio-2.0.Gio.Drive

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GDrive - this represent a piece of hardware connected to the machine.
     * It's generally only created for removable hardware or hardware with
     * removable media.
     *
     * #GDrive is a container class for #GVolume objects that stem from
     * the same piece of media. As such, #GDrive abstracts a drive with
     * (or without) removable media and provides operations for querying
     * whether media is available, determining whether media change is
     * automatically detected and ejecting the media.
     *
     * If the #GDrive reports that media isn't automatically detected, one
     * can poll for media; typically one should not do this periodically
     * as a poll for media operation is potentially expensive and may
     * spin up the drive creating noise.
     *
     * #GDrive supports starting and stopping drives with authentication
     * support for the former. This can be used to support a diverse set
     * of use cases including connecting/disconnecting iSCSI devices,
     * powering down external disk enclosures and starting/stopping
     * multi-disk devices such as RAID devices. Note that the actual
     * semantics and side-effects of starting/stopping a #GDrive may vary
     * according to implementation. To choose the correct verbs in e.g. a
     * file manager, use g_drive_get_start_stop_type().
     *
     * For porting from GnomeVFS note that there is no equivalent of
     * #GDrive in that API.
     * @interface
     */
    class Drive extends GObject.Object {
        // Own properties of Gio-2.0.Gio.Drive

        static name: string;
        static $gtype: GObject.GType<Drive>;

        // Constructors of Gio-2.0.Gio.Drive

        constructor(config?: Drive.ConstructorProperties);
        _init(config?: Drive.ConstructorProperties): void;
    }

    namespace DtlsClientConnection {
        // Constructor properties interface

        interface ConstructorProperties
            extends DatagramBased.ConstructorProperties,
                DtlsConnection.ConstructorProperties,
                GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.DtlsClientConnection

            /**
             * A #GSocketConnectable describing the identity of the server that
             * is expected on the other end of the connection.
             *
             * If the %G_TLS_CERTIFICATE_BAD_IDENTITY flag is set in
             * #GDtlsClientConnection:validation-flags, this object will be used
             * to determine the expected identify of the remote end of the
             * connection; if #GDtlsClientConnection:server-identity is not set,
             * or does not match the identity presented by the server, then the
             * %G_TLS_CERTIFICATE_BAD_IDENTITY validation will fail.
             *
             * In addition to its use in verifying the server certificate,
             * this is also used to give a hint to the server about what
             * certificate we expect, which is useful for servers that serve
             * virtual hosts.
             */
            server_identity?: SocketConnectable | null;
            /**
             * What steps to perform when validating a certificate received from
             * a server. Server certificates that fail to validate in any of the
             * ways indicated here will be rejected unless the application
             * overrides the default via #GDtlsConnection::accept-certificate.
             *
             * GLib guarantees that if certificate verification fails, at least one
             * flag will be set, but it does not guarantee that all possible flags
             * will be set. Accordingly, you may not safely decide to ignore any
             * particular type of error. For example, it would be incorrect to mask
             * %G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates,
             * because this could potentially be the only error flag set even if
             * other problems exist with the certificate. Therefore, there is no
             * safe way to use this property. This is not a horrible problem,
             * though, because you should not be attempting to ignore validation
             * errors anyway. If you really must ignore TLS certificate errors,
             * connect to #GDtlsConnection::accept-certificate.
             */
            validation_flags?: TlsCertificateFlags | null;
        }
    }

    interface DtlsClientConnection extends DatagramBased, DtlsConnection {
        // Own properties of Gio-2.0.Gio.DtlsClientConnection

        /**
         * A list of the distinguished names of the Certificate Authorities
         * that the server will accept client certificates signed by. If the
         * server requests a client certificate during the handshake, then
         * this property will be set after the handshake completes.
         *
         * Each item in the list is a #GByteArray which contains the complete
         * subject DN of the certificate authority.
         */
        readonly accepted_cas: any[];
        /**
         * A #GSocketConnectable describing the identity of the server that
         * is expected on the other end of the connection.
         *
         * If the %G_TLS_CERTIFICATE_BAD_IDENTITY flag is set in
         * #GDtlsClientConnection:validation-flags, this object will be used
         * to determine the expected identify of the remote end of the
         * connection; if #GDtlsClientConnection:server-identity is not set,
         * or does not match the identity presented by the server, then the
         * %G_TLS_CERTIFICATE_BAD_IDENTITY validation will fail.
         *
         * In addition to its use in verifying the server certificate,
         * this is also used to give a hint to the server about what
         * certificate we expect, which is useful for servers that serve
         * virtual hosts.
         */
        server_identity: SocketConnectable;
        /**
         * What steps to perform when validating a certificate received from
         * a server. Server certificates that fail to validate in any of the
         * ways indicated here will be rejected unless the application
         * overrides the default via #GDtlsConnection::accept-certificate.
         *
         * GLib guarantees that if certificate verification fails, at least one
         * flag will be set, but it does not guarantee that all possible flags
         * will be set. Accordingly, you may not safely decide to ignore any
         * particular type of error. For example, it would be incorrect to mask
         * %G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates,
         * because this could potentially be the only error flag set even if
         * other problems exist with the certificate. Therefore, there is no
         * safe way to use this property. This is not a horrible problem,
         * though, because you should not be attempting to ignore validation
         * errors anyway. If you really must ignore TLS certificate errors,
         * connect to #GDtlsConnection::accept-certificate.
         */
        validation_flags: TlsCertificateFlags;

        // Owm methods of Gio-2.0.Gio.DtlsClientConnection

        /**
         * Gets the list of distinguished names of the Certificate Authorities
         * that the server will accept certificates from. This will be set
         * during the TLS handshake if the server requests a certificate.
         * Otherwise, it will be %NULL.
         *
         * Each item in the list is a #GByteArray which contains the complete
         * subject DN of the certificate authority.
         * @returns the list of CA DNs. You should unref each element with g_byte_array_unref() and then the free the list with g_list_free().
         */
        get_accepted_cas(): GLib.List[];
        /**
         * Gets `conn'`s expected server identity
         * @returns a #GSocketConnectable describing the expected server identity, or %NULL if the expected identity is not known.
         */
        get_server_identity(): SocketConnectable;
        /**
         * Gets `conn'`s validation flags
         *
         * This function does not work as originally designed and is impossible
         * to use correctly. See #GDtlsClientConnection:validation-flags for more
         * information.
         * @returns the validation flags
         */
        get_validation_flags(): TlsCertificateFlags;
        /**
         * Sets `conn'`s expected server identity, which is used both to tell
         * servers on virtual hosts which certificate to present, and also
         * to let `conn` know what name to look for in the certificate when
         * performing %G_TLS_CERTIFICATE_BAD_IDENTITY validation, if enabled.
         * @param identity a #GSocketConnectable describing the expected server identity
         */
        set_server_identity(identity: SocketConnectable): void;
        /**
         * Sets `conn'`s validation flags, to override the default set of
         * checks performed when validating a server certificate. By default,
         * %G_TLS_CERTIFICATE_VALIDATE_ALL is used.
         *
         * This function does not work as originally designed and is impossible
         * to use correctly. See #GDtlsClientConnection:validation-flags for more
         * information.
         * @param flags the #GTlsCertificateFlags to use
         */
        set_validation_flags(flags: TlsCertificateFlags): void;

        // Class property signals of Gio-2.0.Gio.DtlsClientConnection

        connect(
            sigName: 'notify::accepted-cas',
            callback: (
                $obj: DtlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::accepted-cas',
            callback: (
                $obj: DtlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::accepted-cas', ...args: any[]): void;
        connect(
            sigName: 'notify::server-identity',
            callback: (
                $obj: DtlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::server-identity',
            callback: (
                $obj: DtlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::server-identity', ...args: any[]): void;
        connect(
            sigName: 'notify::validation-flags',
            callback: (
                $obj: DtlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::validation-flags',
            callback: (
                $obj: DtlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::validation-flags', ...args: any[]): void;
        connect(
            sigName: 'notify::advertised-protocols',
            callback: (
                $obj: DtlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::advertised-protocols',
            callback: (
                $obj: DtlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::advertised-protocols', ...args: any[]): void;
        connect(
            sigName: 'notify::base-socket',
            callback: (
                $obj: DtlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::base-socket',
            callback: (
                $obj: DtlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::base-socket', ...args: any[]): void;
        connect(
            sigName: 'notify::certificate',
            callback: (
                $obj: DtlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::certificate',
            callback: (
                $obj: DtlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::certificate', ...args: any[]): void;
        connect(
            sigName: 'notify::ciphersuite-name',
            callback: (
                $obj: DtlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::ciphersuite-name',
            callback: (
                $obj: DtlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::ciphersuite-name', ...args: any[]): void;
        connect(
            sigName: 'notify::database',
            callback: (
                $obj: DtlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::database',
            callback: (
                $obj: DtlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::database', ...args: any[]): void;
        connect(
            sigName: 'notify::interaction',
            callback: (
                $obj: DtlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::interaction',
            callback: (
                $obj: DtlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::interaction', ...args: any[]): void;
        connect(
            sigName: 'notify::negotiated-protocol',
            callback: (
                $obj: DtlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::negotiated-protocol',
            callback: (
                $obj: DtlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::negotiated-protocol', ...args: any[]): void;
        connect(
            sigName: 'notify::peer-certificate',
            callback: (
                $obj: DtlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::peer-certificate',
            callback: (
                $obj: DtlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::peer-certificate', ...args: any[]): void;
        connect(
            sigName: 'notify::peer-certificate-errors',
            callback: (
                $obj: DtlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::peer-certificate-errors',
            callback: (
                $obj: DtlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::peer-certificate-errors', ...args: any[]): void;
        connect(
            sigName: 'notify::protocol-version',
            callback: (
                $obj: DtlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::protocol-version',
            callback: (
                $obj: DtlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::protocol-version', ...args: any[]): void;
        connect(
            sigName: 'notify::rehandshake-mode',
            callback: (
                $obj: DtlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::rehandshake-mode',
            callback: (
                $obj: DtlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::rehandshake-mode', ...args: any[]): void;
        connect(
            sigName: 'notify::require-close-notify',
            callback: (
                $obj: DtlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::require-close-notify',
            callback: (
                $obj: DtlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::require-close-notify', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GDtlsClientConnection is the client-side subclass of
     * #GDtlsConnection, representing a client-side DTLS connection.
     * @interface
     */
    class DtlsClientConnection extends GObject.Object {
        // Own properties of Gio-2.0.Gio.DtlsClientConnection

        static name: string;
        static $gtype: GObject.GType<DtlsClientConnection>;

        // Constructors of Gio-2.0.Gio.DtlsClientConnection

        constructor(config?: DtlsClientConnection.ConstructorProperties);
        _init(config?: DtlsClientConnection.ConstructorProperties): void;
        /**
         * Creates a new #GDtlsClientConnection wrapping `base_socket` which is
         * assumed to communicate with the server identified by `server_identity`.
         * @param base_socket the #GDatagramBased to wrap
         * @param server_identity the expected identity of the server
         * @returns the new   #GDtlsClientConnection, or %NULL on error
         */
        static new(
            base_socket: DatagramBased,
            server_identity: SocketConnectable | null
        ): DtlsClientConnection;
    }

    namespace DtlsConnection {
        // Signal callback interfaces

        /**
         * Signal callback interface for `accept-certificate`
         */
        interface AcceptCertificateSignalCallback {
            (
                $obj: DtlsConnection,
                peer_cert: TlsCertificate,
                errors: TlsCertificateFlags
            ): boolean;
        }

        // Constructor properties interface

        interface ConstructorProperties
            extends DatagramBased.ConstructorProperties,
                GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.DtlsConnection

            /**
             * The list of application-layer protocols that the connection
             * advertises that it is willing to speak. See
             * g_dtls_connection_set_advertised_protocols().
             */
            advertised_protocols?: string[] | null;
            /**
             * The #GDatagramBased that the connection wraps. Note that this may be any
             * implementation of #GDatagramBased, not just a #GSocket.
             */
            base_socket?: DatagramBased | null;
            /**
             * The connection's certificate; see
             * g_dtls_connection_set_certificate().
             */
            certificate?: TlsCertificate | null;
            /**
             * The certificate database to use when verifying this TLS connection.
             * If no certificate database is set, then the default database will be
             * used. See g_tls_backend_get_default_database().
             *
             * When using a non-default database, #GDtlsConnection must fall back to using
             * the #GTlsDatabase to perform certificate verification using
             * g_tls_database_verify_chain(), which means certificate verification will
             * not be able to make use of TLS session context. This may be less secure.
             * For example, if you create your own #GTlsDatabase that just wraps the
             * default #GTlsDatabase, you might expect that you have not changed anything,
             * but this is not true because you may have altered the behavior of
             * #GDtlsConnection by causing it to use g_tls_database_verify_chain(). See the
             * documentation of g_tls_database_verify_chain() for more details on specific
             * security checks that may not be performed. Accordingly, setting a
             * non-default database is discouraged except for specialty applications with
             * unusual security requirements.
             */
            database?: TlsDatabase | null;
            /**
             * A #GTlsInteraction object to be used when the connection or certificate
             * database need to interact with the user. This will be used to prompt the
             * user for passwords where necessary.
             */
            interaction?: TlsInteraction | null;
            /**
             * The rehandshaking mode. See
             * g_dtls_connection_set_rehandshake_mode().
             */
            rehandshake_mode?: TlsRehandshakeMode | null;
            /**
             * Whether or not proper TLS close notification is required.
             * See g_dtls_connection_set_require_close_notify().
             */
            require_close_notify?: boolean | null;
        }
    }

    interface DtlsConnection extends DatagramBased {
        // Own properties of Gio-2.0.Gio.DtlsConnection

        /**
         * The list of application-layer protocols that the connection
         * advertises that it is willing to speak. See
         * g_dtls_connection_set_advertised_protocols().
         */
        advertised_protocols: string[];
        /**
         * The #GDatagramBased that the connection wraps. Note that this may be any
         * implementation of #GDatagramBased, not just a #GSocket.
         */
        readonly base_socket: DatagramBased;
        /**
         * The connection's certificate; see
         * g_dtls_connection_set_certificate().
         */
        certificate: TlsCertificate;
        /**
         * The name of the DTLS ciphersuite in use. See g_dtls_connection_get_ciphersuite_name().
         */
        readonly ciphersuite_name: string | null;
        /**
         * The certificate database to use when verifying this TLS connection.
         * If no certificate database is set, then the default database will be
         * used. See g_tls_backend_get_default_database().
         *
         * When using a non-default database, #GDtlsConnection must fall back to using
         * the #GTlsDatabase to perform certificate verification using
         * g_tls_database_verify_chain(), which means certificate verification will
         * not be able to make use of TLS session context. This may be less secure.
         * For example, if you create your own #GTlsDatabase that just wraps the
         * default #GTlsDatabase, you might expect that you have not changed anything,
         * but this is not true because you may have altered the behavior of
         * #GDtlsConnection by causing it to use g_tls_database_verify_chain(). See the
         * documentation of g_tls_database_verify_chain() for more details on specific
         * security checks that may not be performed. Accordingly, setting a
         * non-default database is discouraged except for specialty applications with
         * unusual security requirements.
         */
        database: TlsDatabase;
        /**
         * A #GTlsInteraction object to be used when the connection or certificate
         * database need to interact with the user. This will be used to prompt the
         * user for passwords where necessary.
         */
        interaction: TlsInteraction;
        /**
         * The application-layer protocol negotiated during the TLS
         * handshake. See g_dtls_connection_get_negotiated_protocol().
         */
        readonly negotiated_protocol: string | null;
        /**
         * The connection's peer's certificate, after the TLS handshake has
         * completed or failed. Note in particular that this is not yet set
         * during the emission of #GDtlsConnection::accept-certificate.
         *
         * (You can watch for a #GObject::notify signal on this property to
         * detect when a handshake has occurred.)
         */
        readonly peer_certificate: TlsCertificate;
        /**
         * The errors noticed while verifying
         * #GDtlsConnection:peer-certificate. Normally this should be 0, but
         * it may not be if #GDtlsClientConnection:validation-flags is not
         * %G_TLS_CERTIFICATE_VALIDATE_ALL, or if
         * #GDtlsConnection::accept-certificate overrode the default
         * behavior.
         *
         * GLib guarantees that if certificate verification fails, at least
         * one error will be set, but it does not guarantee that all possible
         * errors will be set. Accordingly, you may not safely decide to
         * ignore any particular type of error. For example, it would be
         * incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
         * expired certificates, because this could potentially be the only
         * error flag set even if other problems exist with the certificate.
         */
        readonly peer_certificate_errors: TlsCertificateFlags;
        /**
         * The DTLS protocol version in use. See g_dtls_connection_get_protocol_version().
         */
        readonly protocol_version: TlsProtocolVersion;
        /**
         * The rehandshaking mode. See
         * g_dtls_connection_set_rehandshake_mode().
         */
        rehandshake_mode: TlsRehandshakeMode;
        /**
         * Whether or not proper TLS close notification is required.
         * See g_dtls_connection_set_require_close_notify().
         */
        require_close_notify: boolean;

        // Owm methods of Gio-2.0.Gio.DtlsConnection

        /**
         * Close the DTLS connection. This is equivalent to calling
         * g_dtls_connection_shutdown() to shut down both sides of the connection.
         *
         * Closing a #GDtlsConnection waits for all buffered but untransmitted data to
         * be sent before it completes. It then sends a `close_notify` DTLS alert to the
         * peer and may wait for a `close_notify` to be received from the peer. It does
         * not close the underlying #GDtlsConnection:base-socket; that must be closed
         * separately.
         *
         * Once `conn` is closed, all other operations will return %G_IO_ERROR_CLOSED.
         * Closing a #GDtlsConnection multiple times will not return an error.
         *
         * #GDtlsConnections will be automatically closed when the last reference is
         * dropped, but you might want to call this function to make sure resources are
         * released as early as possible.
         *
         * If `cancellable` is cancelled, the #GDtlsConnection may be left
         * partially-closed and any pending untransmitted data may be lost. Call
         * g_dtls_connection_close() again to complete closing the #GDtlsConnection.
         * @param cancellable a #GCancellable, or %NULL
         * @returns %TRUE on success, %FALSE otherwise
         */
        close(cancellable: Cancellable | null): boolean;
        /**
         * Asynchronously close the DTLS connection. See g_dtls_connection_close() for
         * more information.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call when the close operation is complete
         */
        close_async(
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of close_async

        /**
         * Promisified version of {@link close_async}
         *
         * Asynchronously close the DTLS connection. See g_dtls_connection_close() for
         * more information.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable a #GCancellable, or %NULL
         * @returns A Promise of: %TRUE on success, %FALSE on failure, in which case @error will be set
         */
        close_async(
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<boolean>;
        /**
         * Finish an asynchronous TLS close operation. See g_dtls_connection_close()
         * for more information.
         * @param result a #GAsyncResult
         * @returns %TRUE on success, %FALSE on failure, in which case @error will be set
         */
        close_finish(result: AsyncResult): boolean;
        /**
         * Used by #GDtlsConnection implementations to emit the
         * #GDtlsConnection::accept-certificate signal.
         * @param peer_cert the peer's #GTlsCertificate
         * @param errors the problems with `peer_cert`
         * @returns %TRUE if one of the signal handlers has returned     %TRUE to accept @peer_cert
         */
        emit_accept_certificate(
            peer_cert: TlsCertificate,
            errors: TlsCertificateFlags
        ): boolean;
        /**
         * Gets `conn'`s certificate, as set by
         * g_dtls_connection_set_certificate().
         * @returns @conn's certificate, or %NULL
         */
        get_certificate(): TlsCertificate | null;
        /**
         * Query the TLS backend for TLS channel binding data of `type` for `conn`.
         *
         * This call retrieves TLS channel binding data as specified in RFC
         * [5056](https://tools.ietf.org/html/rfc5056), RFC
         * [5929](https://tools.ietf.org/html/rfc5929), and related RFCs.  The
         * binding data is returned in `data`.  The `data` is resized by the callee
         * using #GByteArray buffer management and will be freed when the `data`
         * is destroyed by g_byte_array_unref(). If `data` is %NULL, it will only
         * check whether TLS backend is able to fetch the data (e.g. whether `type`
         * is supported by the TLS backend). It does not guarantee that the data
         * will be available though.  That could happen if TLS connection does not
         * support `type` or the binding data is not available yet due to additional
         * negotiation or input required.
         * @param type #GTlsChannelBindingType type of data to fetch
         * @returns %TRUE on success, %FALSE otherwise
         */
        get_channel_binding_data(
            type: TlsChannelBindingType
        ): [/* returnType */ boolean, /* data */ Uint8Array];
        /**
         * Returns the name of the current DTLS ciphersuite, or %NULL if the
         * connection has not handshaked or has been closed. Beware that the TLS
         * backend may use any of multiple different naming conventions, because
         * OpenSSL and GnuTLS have their own ciphersuite naming conventions that
         * are different from each other and different from the standard, IANA-
         * registered ciphersuite names. The ciphersuite name is intended to be
         * displayed to the user for informative purposes only, and parsing it
         * is not recommended.
         * @returns The name of the current DTLS ciphersuite, or %NULL
         */
        get_ciphersuite_name(): string | null;
        /**
         * Gets the certificate database that `conn` uses to verify
         * peer certificates. See g_dtls_connection_set_database().
         * @returns the certificate database that @conn uses or %NULL
         */
        get_database(): TlsDatabase | null;
        /**
         * Get the object that will be used to interact with the user. It will be used
         * for things like prompting the user for passwords. If %NULL is returned, then
         * no user interaction will occur for this connection.
         * @returns The interaction object.
         */
        get_interaction(): TlsInteraction | null;
        /**
         * Gets the name of the application-layer protocol negotiated during
         * the handshake.
         *
         * If the peer did not use the ALPN extension, or did not advertise a
         * protocol that matched one of `conn'`s protocols, or the TLS backend
         * does not support ALPN, then this will be %NULL. See
         * g_dtls_connection_set_advertised_protocols().
         * @returns the negotiated protocol, or %NULL
         */
        get_negotiated_protocol(): string | null;
        /**
         * Gets `conn'`s peer's certificate after the handshake has completed
         * or failed. (It is not set during the emission of
         * #GDtlsConnection::accept-certificate.)
         * @returns @conn's peer's certificate, or %NULL
         */
        get_peer_certificate(): TlsCertificate | null;
        /**
         * Gets the errors associated with validating `conn'`s peer's
         * certificate, after the handshake has completed or failed. (It is
         * not set during the emission of #GDtlsConnection::accept-certificate.)
         * @returns @conn's peer's certificate errors
         */
        get_peer_certificate_errors(): TlsCertificateFlags;
        /**
         * Returns the current DTLS protocol version, which may be
         * %G_TLS_PROTOCOL_VERSION_UNKNOWN if the connection has not handshaked, or
         * has been closed, or if the TLS backend has implemented a protocol version
         * that is not a recognized #GTlsProtocolVersion.
         * @returns The current DTLS protocol version
         */
        get_protocol_version(): TlsProtocolVersion;
        /**
         * Gets `conn` rehandshaking mode. See
         * g_dtls_connection_set_rehandshake_mode() for details.
         * @returns %G_TLS_REHANDSHAKE_SAFELY
         */
        get_rehandshake_mode(): TlsRehandshakeMode;
        /**
         * Tests whether or not `conn` expects a proper TLS close notification
         * when the connection is closed. See
         * g_dtls_connection_set_require_close_notify() for details.
         * @returns %TRUE if @conn requires a proper TLS close notification.
         */
        get_require_close_notify(): boolean;
        /**
         * Attempts a TLS handshake on `conn`.
         *
         * On the client side, it is never necessary to call this method;
         * although the connection needs to perform a handshake after
         * connecting, #GDtlsConnection will handle this for you automatically
         * when you try to send or receive data on the connection. You can call
         * g_dtls_connection_handshake() manually if you want to know whether
         * the initial handshake succeeded or failed (as opposed to just
         * immediately trying to use `conn` to read or write, in which case,
         * if it fails, it may not be possible to tell if it failed before
         * or after completing the handshake), but beware that servers may reject
         * client authentication after the handshake has completed, so a
         * successful handshake does not indicate the connection will be usable.
         *
         * Likewise, on the server side, although a handshake is necessary at
         * the beginning of the communication, you do not need to call this
         * function explicitly unless you want clearer error reporting.
         *
         * Previously, calling g_dtls_connection_handshake() after the initial
         * handshake would trigger a rehandshake; however, this usage was
         * deprecated in GLib 2.60 because rehandshaking was removed from the
         * TLS protocol in TLS 1.3. Since GLib 2.64, calling this function after
         * the initial handshake will no longer do anything.
         *
         * #GDtlsConnection::accept_certificate may be emitted during the
         * handshake.
         * @param cancellable a #GCancellable, or %NULL
         * @returns success or failure
         */
        handshake(cancellable: Cancellable | null): boolean;
        /**
         * Asynchronously performs a TLS handshake on `conn`. See
         * g_dtls_connection_handshake() for more information.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call when the handshake is complete
         */
        handshake_async(
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of handshake_async

        /**
         * Promisified version of {@link handshake_async}
         *
         * Asynchronously performs a TLS handshake on `conn`. See
         * g_dtls_connection_handshake() for more information.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable a #GCancellable, or %NULL
         * @returns A Promise of: %TRUE on success, %FALSE on failure, in which case @error will be set.
         */
        handshake_async(
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<boolean>;
        /**
         * Finish an asynchronous TLS handshake operation. See
         * g_dtls_connection_handshake() for more information.
         * @param result a #GAsyncResult.
         * @returns %TRUE on success, %FALSE on failure, in which case @error will be set.
         */
        handshake_finish(result: AsyncResult): boolean;
        /**
         * Sets the list of application-layer protocols to advertise that the
         * caller is willing to speak on this connection. The
         * Application-Layer Protocol Negotiation (ALPN) extension will be
         * used to negotiate a compatible protocol with the peer; use
         * g_dtls_connection_get_negotiated_protocol() to find the negotiated
         * protocol after the handshake.  Specifying %NULL for the the value
         * of `protocols` will disable ALPN negotiation.
         *
         * See [IANA TLS ALPN Protocol IDs](https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)
         * for a list of registered protocol IDs.
         * @param protocols a %NULL-terminated   array of ALPN protocol names (eg, "http/1.1", "h2"), or %NULL
         */
        set_advertised_protocols(protocols: string[] | null): void;
        /**
         * This sets the certificate that `conn` will present to its peer
         * during the TLS handshake. For a #GDtlsServerConnection, it is
         * mandatory to set this, and that will normally be done at construct
         * time.
         *
         * For a #GDtlsClientConnection, this is optional. If a handshake fails
         * with %G_TLS_ERROR_CERTIFICATE_REQUIRED, that means that the server
         * requires a certificate, and if you try connecting again, you should
         * call this method first. You can call
         * g_dtls_client_connection_get_accepted_cas() on the failed connection
         * to get a list of Certificate Authorities that the server will
         * accept certificates from.
         *
         * (It is also possible that a server will allow the connection with
         * or without a certificate; in that case, if you don't provide a
         * certificate, you can tell that the server requested one by the fact
         * that g_dtls_client_connection_get_accepted_cas() will return
         * non-%NULL.)
         * @param certificate the certificate to use for `conn`
         */
        set_certificate(certificate: TlsCertificate): void;
        /**
         * Sets the certificate database that is used to verify peer certificates.
         * This is set to the default database by default. See
         * g_tls_backend_get_default_database(). If set to %NULL, then
         * peer certificate validation will always set the
         * %G_TLS_CERTIFICATE_UNKNOWN_CA error (meaning
         * #GDtlsConnection::accept-certificate will always be emitted on
         * client-side connections, unless that bit is not set in
         * #GDtlsClientConnection:validation-flags).
         *
         * There are nonintuitive security implications when using a non-default
         * database. See #GDtlsConnection:database for details.
         * @param database a #GTlsDatabase
         */
        set_database(database: TlsDatabase | null): void;
        /**
         * Set the object that will be used to interact with the user. It will be used
         * for things like prompting the user for passwords.
         *
         * The `interaction` argument will normally be a derived subclass of
         * #GTlsInteraction. %NULL can also be provided if no user interaction
         * should occur for this connection.
         * @param interaction an interaction object, or %NULL
         */
        set_interaction(interaction: TlsInteraction | null): void;
        /**
         * Since GLib 2.64, changing the rehandshake mode is no longer supported
         * and will have no effect. With TLS 1.3, rehandshaking has been removed from
         * the TLS protocol, replaced by separate post-handshake authentication and
         * rekey operations.
         * @param mode the rehandshaking mode
         */
        set_rehandshake_mode(mode: TlsRehandshakeMode): void;
        /**
         * Sets whether or not `conn` expects a proper TLS close notification
         * before the connection is closed. If this is %TRUE (the default),
         * then `conn` will expect to receive a TLS close notification from its
         * peer before the connection is closed, and will return a
         * %G_TLS_ERROR_EOF error if the connection is closed without proper
         * notification (since this may indicate a network error, or
         * man-in-the-middle attack).
         *
         * In some protocols, the application will know whether or not the
         * connection was closed cleanly based on application-level data
         * (because the application-level data includes a length field, or is
         * somehow self-delimiting); in this case, the close notify is
         * redundant and may be omitted. You
         * can use g_dtls_connection_set_require_close_notify() to tell `conn`
         * to allow an "unannounced" connection close, in which case the close
         * will show up as a 0-length read, as in a non-TLS
         * #GDatagramBased, and it is up to the application to check that
         * the data has been fully received.
         *
         * Note that this only affects the behavior when the peer closes the
         * connection; when the application calls g_dtls_connection_close_async() on
         * `conn` itself, this will send a close notification regardless of the
         * setting of this property. If you explicitly want to do an unclean
         * close, you can close `conn'`s #GDtlsConnection:base-socket rather
         * than closing `conn` itself.
         * @param require_close_notify whether or not to require close notification
         */
        set_require_close_notify(require_close_notify: boolean): void;
        /**
         * Shut down part or all of a DTLS connection.
         *
         * If `shutdown_read` is %TRUE then the receiving side of the connection is shut
         * down, and further reading is disallowed. Subsequent calls to
         * g_datagram_based_receive_messages() will return %G_IO_ERROR_CLOSED.
         *
         * If `shutdown_write` is %TRUE then the sending side of the connection is shut
         * down, and further writing is disallowed. Subsequent calls to
         * g_datagram_based_send_messages() will return %G_IO_ERROR_CLOSED.
         *
         * It is allowed for both `shutdown_read` and `shutdown_write` to be TRUE  this
         * is equivalent to calling g_dtls_connection_close().
         *
         * If `cancellable` is cancelled, the #GDtlsConnection may be left
         * partially-closed and any pending untransmitted data may be lost. Call
         * g_dtls_connection_shutdown() again to complete closing the #GDtlsConnection.
         * @param shutdown_read %TRUE to stop reception of incoming datagrams
         * @param shutdown_write %TRUE to stop sending outgoing datagrams
         * @param cancellable a #GCancellable, or %NULL
         * @returns %TRUE on success, %FALSE otherwise
         */
        shutdown(
            shutdown_read: boolean,
            shutdown_write: boolean,
            cancellable: Cancellable | null
        ): boolean;
        /**
         * Asynchronously shut down part or all of the DTLS connection. See
         * g_dtls_connection_shutdown() for more information.
         * @param shutdown_read %TRUE to stop reception of incoming datagrams
         * @param shutdown_write %TRUE to stop sending outgoing datagrams
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call when the shutdown operation is complete
         */
        shutdown_async(
            shutdown_read: boolean,
            shutdown_write: boolean,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of shutdown_async

        /**
         * Promisified version of {@link shutdown_async}
         *
         * Asynchronously shut down part or all of the DTLS connection. See
         * g_dtls_connection_shutdown() for more information.
         * @param shutdown_read %TRUE to stop reception of incoming datagrams
         * @param shutdown_write %TRUE to stop sending outgoing datagrams
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable a #GCancellable, or %NULL
         * @returns A Promise of: %TRUE on success, %FALSE on failure, in which case @error will be set
         */
        shutdown_async(
            shutdown_read: boolean,
            shutdown_write: boolean,
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<boolean>;
        /**
         * Finish an asynchronous TLS shutdown operation. See
         * g_dtls_connection_shutdown() for more information.
         * @param result a #GAsyncResult
         * @returns %TRUE on success, %FALSE on failure, in which case @error will be set
         */
        shutdown_finish(result: AsyncResult): boolean;

        // Own virtual methods of Gio-2.0.Gio.DtlsConnection

        vfunc_accept_certificate(
            peer_cert: TlsCertificate,
            errors: TlsCertificateFlags
        ): boolean;
        vfunc_get_binding_data(
            type: TlsChannelBindingType,
            data: Uint8Array
        ): boolean;
        /**
         * Gets the name of the application-layer protocol negotiated during
         * the handshake.
         *
         * If the peer did not use the ALPN extension, or did not advertise a
         * protocol that matched one of `conn'`s protocols, or the TLS backend
         * does not support ALPN, then this will be %NULL. See
         * g_dtls_connection_set_advertised_protocols().
         * @virtual
         * @returns the negotiated protocol, or %NULL
         */
        vfunc_get_negotiated_protocol(): string | null;
        /**
         * Attempts a TLS handshake on `conn`.
         *
         * On the client side, it is never necessary to call this method;
         * although the connection needs to perform a handshake after
         * connecting, #GDtlsConnection will handle this for you automatically
         * when you try to send or receive data on the connection. You can call
         * g_dtls_connection_handshake() manually if you want to know whether
         * the initial handshake succeeded or failed (as opposed to just
         * immediately trying to use `conn` to read or write, in which case,
         * if it fails, it may not be possible to tell if it failed before
         * or after completing the handshake), but beware that servers may reject
         * client authentication after the handshake has completed, so a
         * successful handshake does not indicate the connection will be usable.
         *
         * Likewise, on the server side, although a handshake is necessary at
         * the beginning of the communication, you do not need to call this
         * function explicitly unless you want clearer error reporting.
         *
         * Previously, calling g_dtls_connection_handshake() after the initial
         * handshake would trigger a rehandshake; however, this usage was
         * deprecated in GLib 2.60 because rehandshaking was removed from the
         * TLS protocol in TLS 1.3. Since GLib 2.64, calling this function after
         * the initial handshake will no longer do anything.
         *
         * #GDtlsConnection::accept_certificate may be emitted during the
         * handshake.
         * @virtual
         * @param cancellable a #GCancellable, or %NULL
         * @returns success or failure
         */
        vfunc_handshake(cancellable: Cancellable | null): boolean;
        /**
         * Asynchronously performs a TLS handshake on `conn`. See
         * g_dtls_connection_handshake() for more information.
         * @virtual
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call when the handshake is complete
         */
        vfunc_handshake_async(
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finish an asynchronous TLS handshake operation. See
         * g_dtls_connection_handshake() for more information.
         * @virtual
         * @param result a #GAsyncResult.
         * @returns %TRUE on success, %FALSE on failure, in which case @error will be set.
         */
        vfunc_handshake_finish(result: AsyncResult): boolean;
        /**
         * Sets the list of application-layer protocols to advertise that the
         * caller is willing to speak on this connection. The
         * Application-Layer Protocol Negotiation (ALPN) extension will be
         * used to negotiate a compatible protocol with the peer; use
         * g_dtls_connection_get_negotiated_protocol() to find the negotiated
         * protocol after the handshake.  Specifying %NULL for the the value
         * of `protocols` will disable ALPN negotiation.
         *
         * See [IANA TLS ALPN Protocol IDs](https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)
         * for a list of registered protocol IDs.
         * @virtual
         * @param protocols a %NULL-terminated   array of ALPN protocol names (eg, "http/1.1", "h2"), or %NULL
         */
        vfunc_set_advertised_protocols(protocols: string[] | null): void;
        /**
         * Shut down part or all of a DTLS connection.
         *
         * If `shutdown_read` is %TRUE then the receiving side of the connection is shut
         * down, and further reading is disallowed. Subsequent calls to
         * g_datagram_based_receive_messages() will return %G_IO_ERROR_CLOSED.
         *
         * If `shutdown_write` is %TRUE then the sending side of the connection is shut
         * down, and further writing is disallowed. Subsequent calls to
         * g_datagram_based_send_messages() will return %G_IO_ERROR_CLOSED.
         *
         * It is allowed for both `shutdown_read` and `shutdown_write` to be TRUE  this
         * is equivalent to calling g_dtls_connection_close().
         *
         * If `cancellable` is cancelled, the #GDtlsConnection may be left
         * partially-closed and any pending untransmitted data may be lost. Call
         * g_dtls_connection_shutdown() again to complete closing the #GDtlsConnection.
         * @virtual
         * @param shutdown_read %TRUE to stop reception of incoming datagrams
         * @param shutdown_write %TRUE to stop sending outgoing datagrams
         * @param cancellable a #GCancellable, or %NULL
         * @returns %TRUE on success, %FALSE otherwise
         */
        vfunc_shutdown(
            shutdown_read: boolean,
            shutdown_write: boolean,
            cancellable: Cancellable | null
        ): boolean;
        /**
         * Asynchronously shut down part or all of the DTLS connection. See
         * g_dtls_connection_shutdown() for more information.
         * @virtual
         * @param shutdown_read %TRUE to stop reception of incoming datagrams
         * @param shutdown_write %TRUE to stop sending outgoing datagrams
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call when the shutdown operation is complete
         */
        vfunc_shutdown_async(
            shutdown_read: boolean,
            shutdown_write: boolean,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finish an asynchronous TLS shutdown operation. See
         * g_dtls_connection_shutdown() for more information.
         * @virtual
         * @param result a #GAsyncResult
         * @returns %TRUE on success, %FALSE on failure, in which case @error will be set
         */
        vfunc_shutdown_finish(result: AsyncResult): boolean;

        // Own signals of Gio-2.0.Gio.DtlsConnection

        connect(
            sigName: 'accept-certificate',
            callback: DtlsConnection.AcceptCertificateSignalCallback
        ): number;
        connect_after(
            sigName: 'accept-certificate',
            callback: DtlsConnection.AcceptCertificateSignalCallback
        ): number;
        emit(
            sigName: 'accept-certificate',
            peer_cert: TlsCertificate,
            errors: TlsCertificateFlags,
            ...args: any[]
        ): void;

        // Class property signals of Gio-2.0.Gio.DtlsConnection

        connect(
            sigName: 'notify::advertised-protocols',
            callback: ($obj: DtlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::advertised-protocols',
            callback: ($obj: DtlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::advertised-protocols', ...args: any[]): void;
        connect(
            sigName: 'notify::base-socket',
            callback: ($obj: DtlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::base-socket',
            callback: ($obj: DtlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::base-socket', ...args: any[]): void;
        connect(
            sigName: 'notify::certificate',
            callback: ($obj: DtlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::certificate',
            callback: ($obj: DtlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::certificate', ...args: any[]): void;
        connect(
            sigName: 'notify::ciphersuite-name',
            callback: ($obj: DtlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::ciphersuite-name',
            callback: ($obj: DtlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::ciphersuite-name', ...args: any[]): void;
        connect(
            sigName: 'notify::database',
            callback: ($obj: DtlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::database',
            callback: ($obj: DtlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::database', ...args: any[]): void;
        connect(
            sigName: 'notify::interaction',
            callback: ($obj: DtlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::interaction',
            callback: ($obj: DtlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::interaction', ...args: any[]): void;
        connect(
            sigName: 'notify::negotiated-protocol',
            callback: ($obj: DtlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::negotiated-protocol',
            callback: ($obj: DtlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::negotiated-protocol', ...args: any[]): void;
        connect(
            sigName: 'notify::peer-certificate',
            callback: ($obj: DtlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::peer-certificate',
            callback: ($obj: DtlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::peer-certificate', ...args: any[]): void;
        connect(
            sigName: 'notify::peer-certificate-errors',
            callback: ($obj: DtlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::peer-certificate-errors',
            callback: ($obj: DtlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::peer-certificate-errors', ...args: any[]): void;
        connect(
            sigName: 'notify::protocol-version',
            callback: ($obj: DtlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::protocol-version',
            callback: ($obj: DtlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::protocol-version', ...args: any[]): void;
        connect(
            sigName: 'notify::rehandshake-mode',
            callback: ($obj: DtlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::rehandshake-mode',
            callback: ($obj: DtlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::rehandshake-mode', ...args: any[]): void;
        connect(
            sigName: 'notify::require-close-notify',
            callback: ($obj: DtlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::require-close-notify',
            callback: ($obj: DtlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::require-close-notify', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GDtlsConnection is the base DTLS connection class type, which wraps
     * a #GDatagramBased and provides DTLS encryption on top of it. Its
     * subclasses, #GDtlsClientConnection and #GDtlsServerConnection,
     * implement client-side and server-side DTLS, respectively.
     *
     * For TLS support, see #GTlsConnection.
     *
     * As DTLS is datagram based, #GDtlsConnection implements #GDatagramBased,
     * presenting a datagram-socket-like API for the encrypted connection. This
     * operates over a base datagram connection, which is also a #GDatagramBased
     * (#GDtlsConnection:base-socket).
     *
     * To close a DTLS connection, use g_dtls_connection_close().
     *
     * Neither #GDtlsServerConnection or #GDtlsClientConnection set the peer address
     * on their base #GDatagramBased if it is a #GSocket  it is up to the caller to
     * do that if they wish. If they do not, and g_socket_close() is called on the
     * base socket, the #GDtlsConnection will not raise a %G_IO_ERROR_NOT_CONNECTED
     * error on further I/O.
     * @interface
     */
    class DtlsConnection extends GObject.Object {
        // Own properties of Gio-2.0.Gio.DtlsConnection

        static name: string;
        static $gtype: GObject.GType<DtlsConnection>;

        // Constructors of Gio-2.0.Gio.DtlsConnection

        constructor(config?: DtlsConnection.ConstructorProperties);
        _init(config?: DtlsConnection.ConstructorProperties): void;
    }

    namespace DtlsServerConnection {
        // Constructor properties interface

        interface ConstructorProperties
            extends DatagramBased.ConstructorProperties,
                DtlsConnection.ConstructorProperties,
                GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.DtlsServerConnection

            /**
             * The #GTlsAuthenticationMode for the server. This can be changed
             * before calling g_dtls_connection_handshake() if you want to
             * rehandshake with a different mode from the initial handshake.
             */
            authentication_mode?: TlsAuthenticationMode | null;
        }
    }

    interface DtlsServerConnection extends DatagramBased, DtlsConnection {
        // Own properties of Gio-2.0.Gio.DtlsServerConnection

        /**
         * The #GTlsAuthenticationMode for the server. This can be changed
         * before calling g_dtls_connection_handshake() if you want to
         * rehandshake with a different mode from the initial handshake.
         */
        authentication_mode: TlsAuthenticationMode;

        // Class property signals of Gio-2.0.Gio.DtlsServerConnection

        connect(
            sigName: 'notify::authentication-mode',
            callback: (
                $obj: DtlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::authentication-mode',
            callback: (
                $obj: DtlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::authentication-mode', ...args: any[]): void;
        connect(
            sigName: 'notify::advertised-protocols',
            callback: (
                $obj: DtlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::advertised-protocols',
            callback: (
                $obj: DtlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::advertised-protocols', ...args: any[]): void;
        connect(
            sigName: 'notify::base-socket',
            callback: (
                $obj: DtlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::base-socket',
            callback: (
                $obj: DtlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::base-socket', ...args: any[]): void;
        connect(
            sigName: 'notify::certificate',
            callback: (
                $obj: DtlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::certificate',
            callback: (
                $obj: DtlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::certificate', ...args: any[]): void;
        connect(
            sigName: 'notify::ciphersuite-name',
            callback: (
                $obj: DtlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::ciphersuite-name',
            callback: (
                $obj: DtlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::ciphersuite-name', ...args: any[]): void;
        connect(
            sigName: 'notify::database',
            callback: (
                $obj: DtlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::database',
            callback: (
                $obj: DtlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::database', ...args: any[]): void;
        connect(
            sigName: 'notify::interaction',
            callback: (
                $obj: DtlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::interaction',
            callback: (
                $obj: DtlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::interaction', ...args: any[]): void;
        connect(
            sigName: 'notify::negotiated-protocol',
            callback: (
                $obj: DtlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::negotiated-protocol',
            callback: (
                $obj: DtlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::negotiated-protocol', ...args: any[]): void;
        connect(
            sigName: 'notify::peer-certificate',
            callback: (
                $obj: DtlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::peer-certificate',
            callback: (
                $obj: DtlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::peer-certificate', ...args: any[]): void;
        connect(
            sigName: 'notify::peer-certificate-errors',
            callback: (
                $obj: DtlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::peer-certificate-errors',
            callback: (
                $obj: DtlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::peer-certificate-errors', ...args: any[]): void;
        connect(
            sigName: 'notify::protocol-version',
            callback: (
                $obj: DtlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::protocol-version',
            callback: (
                $obj: DtlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::protocol-version', ...args: any[]): void;
        connect(
            sigName: 'notify::rehandshake-mode',
            callback: (
                $obj: DtlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::rehandshake-mode',
            callback: (
                $obj: DtlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::rehandshake-mode', ...args: any[]): void;
        connect(
            sigName: 'notify::require-close-notify',
            callback: (
                $obj: DtlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::require-close-notify',
            callback: (
                $obj: DtlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::require-close-notify', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GDtlsServerConnection is the server-side subclass of #GDtlsConnection,
     * representing a server-side DTLS connection.
     * @interface
     */
    class DtlsServerConnection extends GObject.Object {
        // Own properties of Gio-2.0.Gio.DtlsServerConnection

        static name: string;
        static $gtype: GObject.GType<DtlsServerConnection>;

        // Constructors of Gio-2.0.Gio.DtlsServerConnection

        constructor(config?: DtlsServerConnection.ConstructorProperties);
        _init(config?: DtlsServerConnection.ConstructorProperties): void;
        /**
         * Creates a new #GDtlsServerConnection wrapping `base_socket`.
         * @param base_socket the #GDatagramBased to wrap
         * @param certificate the default server certificate, or %NULL
         * @returns the new   #GDtlsServerConnection, or %NULL on error
         */
        static new(
            base_socket: DatagramBased,
            certificate: TlsCertificate | null
        ): DtlsServerConnection;
    }

    namespace File {
        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface File {
        // Owm methods of Gio-2.0.Gio.File

        /**
         * Gets an output stream for appending data to the file.
         * If the file doesn't already exist it is created.
         *
         * By default files created are generally readable by everyone,
         * but if you pass %G_FILE_CREATE_PRIVATE in `flags` the file
         * will be made readable only to the current user, to the level that
         * is supported on the target filesystem.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled
         * by triggering the cancellable object from another thread. If the
         * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
         * returned.
         *
         * Some file systems don't allow all file names, and may return an
         * %G_IO_ERROR_INVALID_FILENAME error. If the file is a directory the
         * %G_IO_ERROR_IS_DIRECTORY error will be returned. Other errors are
         * possible too, and depend on what kind of filesystem the file is on.
         * @param flags a set of #GFileCreateFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFileOutputStream, or %NULL on error.   Free the returned object with g_object_unref().
         */
        append_to(
            flags: FileCreateFlags,
            cancellable: Cancellable | null
        ): FileOutputStream;
        /**
         * Asynchronously opens `file` for appending.
         *
         * For more details, see g_file_append_to() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_append_to_finish() to get the result
         * of the operation.
         * @param flags a set of #GFileCreateFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        append_to_async(
            flags: FileCreateFlags,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of append_to_async

        /**
         * Promisified version of {@link append_to_async}
         *
         * Asynchronously opens `file` for appending.
         *
         * For more details, see g_file_append_to() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_append_to_finish() to get the result
         * of the operation.
         * @param flags a set of #GFileCreateFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns A Promise of: a valid #GFileOutputStream   or %NULL on error.   Free the returned object with g_object_unref().
         */
        append_to_async(
            flags: FileCreateFlags,
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<FileOutputStream>;
        /**
         * Finishes an asynchronous file append operation started with
         * g_file_append_to_async().
         * @param res #GAsyncResult
         * @returns a valid #GFileOutputStream   or %NULL on error.   Free the returned object with g_object_unref().
         */
        append_to_finish(res: AsyncResult): FileOutputStream;
        /**
         * Prepares the file attribute query string for copying to `file`.
         *
         * This function prepares an attribute query string to be
         * passed to g_file_query_info() to get a list of attributes
         * normally copied with the file (see g_file_copy_attributes()
         * for the detailed description). This function is used by the
         * implementation of g_file_copy_attributes() and is useful
         * when one needs to query and set the attributes in two
         * stages (e.g., for recursive move of a directory).
         * @param flags a set of #GFileCopyFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns an attribute query string for g_file_query_info(),   or %NULL if an error occurs.
         */
        build_attribute_list_for_copy(
            flags: FileCopyFlags,
            cancellable: Cancellable | null
        ): string | null;
        /**
         * Copies the file `source` to the location specified by `destination`.
         * Can not handle recursive copies of directories.
         *
         * If the flag %G_FILE_COPY_OVERWRITE is specified an already
         * existing `destination` file is overwritten.
         *
         * If the flag %G_FILE_COPY_NOFOLLOW_SYMLINKS is specified then symlinks
         * will be copied as symlinks, otherwise the target of the
         * `source` symlink will be copied.
         *
         * If the flag %G_FILE_COPY_ALL_METADATA is specified then all the metadata
         * that is possible to copy is copied, not just the default subset (which,
         * for instance, does not include the owner, see #GFileInfo).
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * If `progress_callback` is not %NULL, then the operation can be monitored
         * by setting this to a #GFileProgressCallback function.
         * `progress_callback_data` will be passed to this function. It is guaranteed
         * that this callback will be called after all data has been transferred with
         * the total number of bytes copied during the operation.
         *
         * If the `source` file does not exist, then the %G_IO_ERROR_NOT_FOUND error
         * is returned, independent on the status of the `destination`.
         *
         * If %G_FILE_COPY_OVERWRITE is not specified and the target exists, then
         * the error %G_IO_ERROR_EXISTS is returned.
         *
         * If trying to overwrite a file over a directory, the %G_IO_ERROR_IS_DIRECTORY
         * error is returned. If trying to overwrite a directory with a directory the
         * %G_IO_ERROR_WOULD_MERGE error is returned.
         *
         * If the source is a directory and the target does not exist, or
         * %G_FILE_COPY_OVERWRITE is specified and the target is a file, then the
         * %G_IO_ERROR_WOULD_RECURSE error is returned.
         *
         * If you are interested in copying the #GFile object itself (not the on-disk
         * file), see g_file_dup().
         * @param destination destination #GFile
         * @param flags set of #GFileCopyFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param progress_callback function to callback with   progress information, or %NULL if progress information is not needed
         * @returns %TRUE on success, %FALSE otherwise.
         */
        copy(
            destination: File,
            flags: FileCopyFlags,
            cancellable: Cancellable | null,
            progress_callback: FileProgressCallback | null
        ): boolean;
        /**
         * Copies the file `source` to the location specified by `destination`
         * asynchronously. For details of the behaviour, see g_file_copy().
         *
         * If `progress_callback` is not %NULL, then that function that will be called
         * just like in g_file_copy(). The callback will run in the default main context
         * of the thread calling g_file_copy_async()  the same context as `callback` is
         * run in.
         *
         * When the operation is finished, `callback` will be called. You can then call
         * g_file_copy_finish() to get the result of the operation.
         * @param destination destination #GFile
         * @param flags set of #GFileCopyFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param progress_callback    function to callback with progress information, or %NULL if   progress information is not needed
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        copy_async(
            destination: File,
            flags: FileCopyFlags,
            io_priority: number,
            cancellable: Cancellable | null,
            progress_callback: FileProgressCallback | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of copy_async

        /**
         * Promisified version of {@link copy_async}
         *
         * Copies the file `source` to the location specified by `destination`
         * asynchronously. For details of the behaviour, see g_file_copy().
         *
         * If `progress_callback` is not %NULL, then that function that will be called
         * just like in g_file_copy(). The callback will run in the default main context
         * of the thread calling g_file_copy_async()  the same context as `callback` is
         * run in.
         *
         * When the operation is finished, `callback` will be called. You can then call
         * g_file_copy_finish() to get the result of the operation.
         * @param destination destination #GFile
         * @param flags set of #GFileCopyFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param progress_callback    function to callback with progress information, or %NULL if   progress information is not needed
         * @returns A Promise of: a %TRUE on success, %FALSE on error.
         */
        copy_async(
            destination: File,
            flags: FileCopyFlags,
            io_priority: number,
            cancellable: Cancellable | null,
            progress_callback: FileProgressCallback | null
        ): globalThis.Promise<boolean>;
        /**
         * Copies the file attributes from `source` to `destination`.
         *
         * Normally only a subset of the file attributes are copied,
         * those that are copies in a normal file copy operation
         * (which for instance does not include e.g. owner). However
         * if %G_FILE_COPY_ALL_METADATA is specified in `flags,` then
         * all the metadata that is possible to copy is copied. This
         * is useful when implementing move by copy + delete source.
         * @param destination a #GFile to copy attributes to
         * @param flags a set of #GFileCopyFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns %TRUE if the attributes were copied successfully,   %FALSE otherwise.
         */
        copy_attributes(
            destination: File,
            flags: FileCopyFlags,
            cancellable: Cancellable | null
        ): boolean;
        /**
         * Finishes copying the file started with g_file_copy_async().
         * @param res a #GAsyncResult
         * @returns a %TRUE on success, %FALSE on error.
         */
        copy_finish(res: AsyncResult): boolean;
        /**
         * Creates a new file and returns an output stream for writing to it.
         * The file must not already exist.
         *
         * By default files created are generally readable by everyone,
         * but if you pass %G_FILE_CREATE_PRIVATE in `flags` the file
         * will be made readable only to the current user, to the level
         * that is supported on the target filesystem.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled
         * by triggering the cancellable object from another thread. If the
         * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
         * returned.
         *
         * If a file or directory with this name already exists the
         * %G_IO_ERROR_EXISTS error will be returned. Some file systems don't
         * allow all file names, and may return an %G_IO_ERROR_INVALID_FILENAME
         * error, and if the name is to long %G_IO_ERROR_FILENAME_TOO_LONG will
         * be returned. Other errors are possible too, and depend on what kind
         * of filesystem the file is on.
         * @param flags a set of #GFileCreateFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFileOutputStream for the newly created   file, or %NULL on error.   Free the returned object with g_object_unref().
         */
        create(
            flags: FileCreateFlags,
            cancellable: Cancellable | null
        ): FileOutputStream;
        /**
         * Asynchronously creates a new file and returns an output stream
         * for writing to it. The file must not already exist.
         *
         * For more details, see g_file_create() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_create_finish() to get the result
         * of the operation.
         * @param flags a set of #GFileCreateFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        create_async(
            flags: FileCreateFlags,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of create_async

        /**
         * Promisified version of {@link create_async}
         *
         * Asynchronously creates a new file and returns an output stream
         * for writing to it. The file must not already exist.
         *
         * For more details, see g_file_create() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_create_finish() to get the result
         * of the operation.
         * @param flags a set of #GFileCreateFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns A Promise of: a #GFileOutputStream or %NULL on error.   Free the returned object with g_object_unref().
         */
        create_async(
            flags: FileCreateFlags,
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<FileOutputStream>;
        /**
         * Finishes an asynchronous file create operation started with
         * g_file_create_async().
         * @param res a #GAsyncResult
         * @returns a #GFileOutputStream or %NULL on error.   Free the returned object with g_object_unref().
         */
        create_finish(res: AsyncResult): FileOutputStream;
        /**
         * Creates a new file and returns a stream for reading and
         * writing to it. The file must not already exist.
         *
         * By default files created are generally readable by everyone,
         * but if you pass %G_FILE_CREATE_PRIVATE in `flags` the file
         * will be made readable only to the current user, to the level
         * that is supported on the target filesystem.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled
         * by triggering the cancellable object from another thread. If the
         * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
         * returned.
         *
         * If a file or directory with this name already exists, the
         * %G_IO_ERROR_EXISTS error will be returned. Some file systems don't
         * allow all file names, and may return an %G_IO_ERROR_INVALID_FILENAME
         * error, and if the name is too long, %G_IO_ERROR_FILENAME_TOO_LONG
         * will be returned. Other errors are possible too, and depend on what
         * kind of filesystem the file is on.
         *
         * Note that in many non-local file cases read and write streams are
         * not supported, so make sure you really need to do read and write
         * streaming, rather than just opening for reading or writing.
         * @param flags a set of #GFileCreateFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFileIOStream for the newly created   file, or %NULL on error.   Free the returned object with g_object_unref().
         */
        create_readwrite(
            flags: FileCreateFlags,
            cancellable: Cancellable | null
        ): FileIOStream;
        /**
         * Asynchronously creates a new file and returns a stream
         * for reading and writing to it. The file must not already exist.
         *
         * For more details, see g_file_create_readwrite() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_create_readwrite_finish() to get
         * the result of the operation.
         * @param flags a set of #GFileCreateFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        create_readwrite_async(
            flags: FileCreateFlags,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of create_readwrite_async

        /**
         * Promisified version of {@link create_readwrite_async}
         *
         * Asynchronously creates a new file and returns a stream
         * for reading and writing to it. The file must not already exist.
         *
         * For more details, see g_file_create_readwrite() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_create_readwrite_finish() to get
         * the result of the operation.
         * @param flags a set of #GFileCreateFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns A Promise of: a #GFileIOStream or %NULL on error.   Free the returned object with g_object_unref().
         */
        create_readwrite_async(
            flags: FileCreateFlags,
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<FileIOStream>;
        /**
         * Finishes an asynchronous file create operation started with
         * g_file_create_readwrite_async().
         * @param res a #GAsyncResult
         * @returns a #GFileIOStream or %NULL on error.   Free the returned object with g_object_unref().
         */
        create_readwrite_finish(res: AsyncResult): FileIOStream;
        /**
         * Deletes a file. If the `file` is a directory, it will only be
         * deleted if it is empty. This has the same semantics as g_unlink().
         *
         * If `file` doesnt exist, %G_IO_ERROR_NOT_FOUND will be returned. This allows
         * for deletion to be implemented avoiding
         * [time-of-check to time-of-use races](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use):
         *
         * ```
         * g_autoptr(GError) local_error = NULL;
         * if (!g_file_delete (my_file, my_cancellable, &local_error) &&
         *     !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))
         *   {
         *     // deletion failed for some reason other than the file not existing:
         *     // so report the error
         *     g_warning ("Failed to delete %s: %s",
         *                g_file_peek_path (my_file), local_error->message);
         *   }
         * ```
         *
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns %TRUE if the file was deleted. %FALSE otherwise.
         */
        delete(cancellable: Cancellable | null): boolean;
        /**
         * Asynchronously delete a file. If the `file` is a directory, it will
         * only be deleted if it is empty.  This has the same semantics as
         * g_unlink().
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
         */
        delete_async(
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of delete_async

        /**
         * Promisified version of {@link delete_async}
         *
         * Asynchronously delete a file. If the `file` is a directory, it will
         * only be deleted if it is empty.  This has the same semantics as
         * g_unlink().
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns A Promise of: %TRUE if the file was deleted. %FALSE otherwise.
         */
        delete_async(
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<boolean>;
        /**
         * Finishes deleting a file started with g_file_delete_async().
         * @param result a #GAsyncResult
         * @returns %TRUE if the file was deleted. %FALSE otherwise.
         */
        delete_finish(result: AsyncResult): boolean;
        /**
         * Duplicates a #GFile handle. This operation does not duplicate
         * the actual file or directory represented by the #GFile; see
         * g_file_copy() if attempting to copy a file.
         *
         * g_file_dup() is useful when a second handle is needed to the same underlying
         * file, for use in a separate thread (#GFile is not thread-safe). For use
         * within the same thread, use g_object_ref() to increment the existing objects
         * reference count.
         *
         * This call does no blocking I/O.
         * @returns a new #GFile that is a duplicate   of the given #GFile.
         */
        dup(): File;
        /**
         * Starts an asynchronous eject on a mountable.
         * When this operation has completed, `callback` will be called with
         * `user_user` data, and the operation can be finalized with
         * g_file_eject_mountable_finish().
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param flags flags affecting the operation
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        eject_mountable(
            flags: MountUnmountFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes an asynchronous eject operation started by
         * g_file_eject_mountable().
         * @param result a #GAsyncResult
         * @returns %TRUE if the @file was ejected successfully.   %FALSE otherwise.
         */
        eject_mountable_finish(result: AsyncResult): boolean;
        /**
         * Starts an asynchronous eject on a mountable.
         * When this operation has completed, `callback` will be called with
         * `user_user` data, and the operation can be finalized with
         * g_file_eject_mountable_with_operation_finish().
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param flags flags affecting the operation
         * @param mount_operation a #GMountOperation,   or %NULL to avoid user interaction
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        eject_mountable_with_operation(
            flags: MountUnmountFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes an asynchronous eject operation started by
         * g_file_eject_mountable_with_operation().
         * @param result a #GAsyncResult
         * @returns %TRUE if the @file was ejected successfully.   %FALSE otherwise.
         */
        eject_mountable_with_operation_finish(result: AsyncResult): boolean;
        /**
         * Gets the requested information about the files in a directory.
         * The result is a #GFileEnumerator object that will give out
         * #GFileInfo objects for all the files in the directory.
         *
         * The `attributes` value is a string that specifies the file
         * attributes that should be gathered. It is not an error if
         * it's not possible to read a particular requested attribute
         * from a file - it just won't be set. `attributes` should
         * be a comma-separated list of attributes or attribute wildcards.
         * The wildcard "*" means all attributes, and a wildcard like
         * "standard::*" means all attributes in the standard namespace.
         * An example attribute query be "standard::*,owner::user".
         * The standard attributes are available as defines, like
         * %G_FILE_ATTRIBUTE_STANDARD_NAME. %G_FILE_ATTRIBUTE_STANDARD_NAME should
         * always be specified if you plan to call g_file_enumerator_get_child() or
         * g_file_enumerator_iterate() on the returned enumerator.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled
         * by triggering the cancellable object from another thread. If the
         * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
         * returned.
         *
         * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
         * be returned. If the file is not a directory, the %G_IO_ERROR_NOT_DIRECTORY
         * error will be returned. Other errors are possible too.
         * @param attributes an attribute query string
         * @param flags a set of #GFileQueryInfoFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns A #GFileEnumerator if successful,   %NULL on error. Free the returned object with g_object_unref().
         */
        enumerate_children(
            attributes: string | null,
            flags: FileQueryInfoFlags,
            cancellable: Cancellable | null
        ): FileEnumerator;
        /**
         * Asynchronously gets the requested information about the files
         * in a directory. The result is a #GFileEnumerator object that will
         * give out #GFileInfo objects for all the files in the directory.
         *
         * For more details, see g_file_enumerate_children() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called. You can
         * then call g_file_enumerate_children_finish() to get the result of
         * the operation.
         * @param attributes an attribute query string
         * @param flags a set of #GFileQueryInfoFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        enumerate_children_async(
            attributes: string | null,
            flags: FileQueryInfoFlags,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of enumerate_children_async

        /**
         * Promisified version of {@link enumerate_children_async}
         *
         * Asynchronously gets the requested information about the files
         * in a directory. The result is a #GFileEnumerator object that will
         * give out #GFileInfo objects for all the files in the directory.
         *
         * For more details, see g_file_enumerate_children() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called. You can
         * then call g_file_enumerate_children_finish() to get the result of
         * the operation.
         * @param attributes an attribute query string
         * @param flags a set of #GFileQueryInfoFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns A Promise of: a #GFileEnumerator or %NULL   if an error occurred.   Free the returned object with g_object_unref().
         */
        enumerate_children_async(
            attributes: string | null,
            flags: FileQueryInfoFlags,
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<FileEnumerator>;
        /**
         * Finishes an async enumerate children operation.
         * See g_file_enumerate_children_async().
         * @param res a #GAsyncResult
         * @returns a #GFileEnumerator or %NULL   if an error occurred.   Free the returned object with g_object_unref().
         */
        enumerate_children_finish(res: AsyncResult): FileEnumerator;
        /**
         * Checks if the two given #GFiles refer to the same file.
         *
         * Note that two #GFiles that differ can still refer to the same
         * file on the filesystem due to various forms of filename
         * aliasing.
         *
         * This call does no blocking I/O.
         * @param file2 the second #GFile
         * @returns %TRUE if @file1 and @file2 are equal.
         */
        equal(file2: File): boolean;
        /**
         * Gets a #GMount for the #GFile.
         *
         * #GMount is returned only for user interesting locations, see
         * #GVolumeMonitor. If the #GFileIface for `file` does not have a #mount,
         * `error` will be set to %G_IO_ERROR_NOT_FOUND and %NULL #will be returned.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GMount where the @file is located   or %NULL on error.   Free the returned object with g_object_unref().
         */
        find_enclosing_mount(cancellable: Cancellable | null): Mount;
        /**
         * Asynchronously gets the mount for the file.
         *
         * For more details, see g_file_find_enclosing_mount() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_find_enclosing_mount_finish() to
         * get the result of the operation.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        find_enclosing_mount_async(
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of find_enclosing_mount_async

        /**
         * Promisified version of {@link find_enclosing_mount_async}
         *
         * Asynchronously gets the mount for the file.
         *
         * For more details, see g_file_find_enclosing_mount() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_find_enclosing_mount_finish() to
         * get the result of the operation.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns A Promise of: #GMount for given @file or %NULL on error.   Free the returned object with g_object_unref().
         */
        find_enclosing_mount_async(
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<Mount>;
        /**
         * Finishes an asynchronous find mount request.
         * See g_file_find_enclosing_mount_async().
         * @param res a #GAsyncResult
         * @returns #GMount for given @file or %NULL on error.   Free the returned object with g_object_unref().
         */
        find_enclosing_mount_finish(res: AsyncResult): Mount;
        /**
         * Gets the base name (the last component of the path) for a given #GFile.
         *
         * If called for the top level of a system (such as the filesystem root
         * or a uri like sftp://host/) it will return a single directory separator
         * (and on Windows, possibly a drive letter).
         *
         * The base name is a byte string (not UTF-8). It has no defined encoding
         * or rules other than it may not contain zero bytes.  If you want to use
         * filenames in a user interface you should use the display name that you
         * can get by requesting the %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME
         * attribute with g_file_query_info().
         *
         * This call does no blocking I/O.
         * @returns string containing the #GFile's   base name, or %NULL if given #GFile is invalid. The returned string   should be freed with g_free() when no longer needed.
         */
        get_basename(): string | null;
        /**
         * Gets a child of `file` with basename equal to `name`.
         *
         * Note that the file with that specific name might not exist, but
         * you can still have a #GFile that points to it. You can use this
         * for instance to create that file.
         *
         * This call does no blocking I/O.
         * @param name string containing the child's basename
         * @returns a #GFile to a child specified by @name.   Free the returned object with g_object_unref().
         */
        get_child(name: string): File;
        /**
         * Gets the child of `file` for a given `display_name` (i.e. a UTF-8
         * version of the name). If this function fails, it returns %NULL
         * and `error` will be set. This is very useful when constructing a
         * #GFile for a new file and the user entered the filename in the
         * user interface, for instance when you select a directory and
         * type a filename in the file selector.
         *
         * This call does no blocking I/O.
         * @param display_name string to a possible child
         * @returns a #GFile to the specified child, or   %NULL if the display name couldn't be converted.   Free the returned object with g_object_unref().
         */
        get_child_for_display_name(display_name: string | null): File;
        /**
         * Gets the parent directory for the `file`.
         * If the `file` represents the root directory of the
         * file system, then %NULL will be returned.
         *
         * This call does no blocking I/O.
         * @returns a #GFile structure to the   parent of the given #GFile or %NULL if there is no parent. Free   the returned object with g_object_unref().
         */
        get_parent(): File | null;
        /**
         * Gets the parse name of the `file`.
         * A parse name is a UTF-8 string that describes the
         * file such that one can get the #GFile back using
         * g_file_parse_name().
         *
         * This is generally used to show the #GFile as a nice
         * full-pathname kind of string in a user interface,
         * like in a location entry.
         *
         * For local files with names that can safely be converted
         * to UTF-8 the pathname is used, otherwise the IRI is used
         * (a form of URI that allows UTF-8 characters unescaped).
         *
         * This call does no blocking I/O.
         * @returns a string containing the #GFile's parse name.   The returned string should be freed with g_free()   when no longer needed.
         */
        get_parse_name(): string | null;
        /**
         * Gets the local pathname for #GFile, if one exists. If non-%NULL, this is
         * guaranteed to be an absolute, canonical path. It might contain symlinks.
         *
         * This call does no blocking I/O.
         * @returns string containing the #GFile's path,   or %NULL if no such path exists. The returned string should be freed   with g_free() when no longer needed.
         */
        get_path(): string | null;
        /**
         * Gets the path for `descendant` relative to `parent`.
         *
         * This call does no blocking I/O.
         * @param descendant input #GFile
         * @returns string with the relative path from   @descendant to @parent, or %NULL if @descendant doesn't have @parent as   prefix. The returned string should be freed with g_free() when   no longer needed.
         */
        get_relative_path(descendant: File): string | null;
        /**
         * Gets the URI for the `file`.
         *
         * This call does no blocking I/O.
         * @returns a string containing the #GFile's URI. If the #GFile was constructed   with an invalid URI, an invalid URI is returned.   The returned string should be freed with g_free()   when no longer needed.
         */
        get_uri(): string | null;
        /**
         * Gets the URI scheme for a #GFile.
         * RFC 3986 decodes the scheme as:
         *
         * ```
         * URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
         * ```
         *
         * Common schemes include "file", "http", "ftp", etc.
         *
         * The scheme can be different from the one used to construct the #GFile,
         * in that it might be replaced with one that is logically equivalent to the #GFile.
         *
         * This call does no blocking I/O.
         * @returns a string containing the URI scheme for the given   #GFile or %NULL if the #GFile was constructed with an invalid URI. The   returned string should be freed with g_free() when no longer needed.
         */
        get_uri_scheme(): string | null;
        /**
         * Checks if `file` has a parent, and optionally, if it is `parent`.
         *
         * If `parent` is %NULL then this function returns %TRUE if `file` has any
         * parent at all.  If `parent` is non-%NULL then %TRUE is only returned
         * if `file` is an immediate child of `parent`.
         * @param parent the parent to check for, or %NULL
         * @returns %TRUE if @file is an immediate child of @parent (or any parent in   the case that @parent is %NULL).
         */
        has_parent(parent: File | null): boolean;
        /**
         * Checks whether `file` has the prefix specified by `prefix`.
         *
         * In other words, if the names of initial elements of `file'`s
         * pathname match `prefix`. Only full pathname elements are matched,
         * so a path like /foo is not considered a prefix of /foobar, only
         * of /foo/bar.
         *
         * A #GFile is not a prefix of itself. If you want to check for
         * equality, use g_file_equal().
         *
         * This call does no I/O, as it works purely on names. As such it can
         * sometimes return %FALSE even if `file` is inside a `prefix` (from a
         * filesystem point of view), because the prefix of `file` is an alias
         * of `prefix`.
         * @param prefix input #GFile
         * @returns %TRUE if the @file's parent, grandparent, etc is @prefix,   %FALSE otherwise.
         */
        has_prefix(prefix: File): boolean;
        /**
         * Checks to see if a #GFile has a given URI scheme.
         *
         * This call does no blocking I/O.
         * @param uri_scheme a string containing a URI scheme
         * @returns %TRUE if #GFile's backend supports the   given URI scheme, %FALSE if URI scheme is %NULL,   not supported, or #GFile is invalid.
         */
        has_uri_scheme(uri_scheme: string | null): boolean;
        /**
         * Creates a hash value for a #GFile.
         *
         * This call does no blocking I/O.
         * @returns 0 if @file is not a valid #GFile, otherwise an   integer that can be used as hash value for the #GFile.   This function is intended for easily hashing a #GFile to   add to a #GHashTable or similar data structure.
         */
        hash(): number;
        /**
         * Checks to see if a file is native to the platform.
         *
         * A native file is one expressed in the platform-native filename format,
         * e.g. "C:\Windows" or "/usr/bin/". This does not mean the file is local,
         * as it might be on a locally mounted remote filesystem.
         *
         * On some systems non-native files may be available using the native
         * filesystem via a userspace filesystem (FUSE), in these cases this call
         * will return %FALSE, but g_file_get_path() will still return a native path.
         *
         * This call does no blocking I/O.
         * @returns %TRUE if @file is native
         */
        is_native(): boolean;
        /**
         * Loads the contents of `file` and returns it as #GBytes.
         *
         * If `file` is a resource:// based URI, the resulting bytes will reference the
         * embedded resource instead of a copy. Otherwise, this is equivalent to calling
         * g_file_load_contents() and g_bytes_new_take().
         *
         * For resources, `etag_out` will be set to %NULL.
         *
         * The data contained in the resulting #GBytes is always zero-terminated, but
         * this is not included in the #GBytes length. The resulting #GBytes should be
         * freed with g_bytes_unref() when no longer in use.
         * @param cancellable a #GCancellable or %NULL
         * @returns a #GBytes or %NULL and @error is set
         */
        load_bytes(
            cancellable: Cancellable | null
        ): [/* returnType */ GLib.Bytes, /* etag_out */ string | null];
        /**
         * Asynchronously loads the contents of `file` as #GBytes.
         *
         * If `file` is a resource:// based URI, the resulting bytes will reference the
         * embedded resource instead of a copy. Otherwise, this is equivalent to calling
         * g_file_load_contents_async() and g_bytes_new_take().
         *
         * `callback` should call g_file_load_bytes_finish() to get the result of this
         * asynchronous operation.
         *
         * See g_file_load_bytes() for more information.
         * @param cancellable a #GCancellable or %NULL
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        load_bytes_async(
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of load_bytes_async

        /**
         * Promisified version of {@link load_bytes_async}
         *
         * Asynchronously loads the contents of `file` as #GBytes.
         *
         * If `file` is a resource:// based URI, the resulting bytes will reference the
         * embedded resource instead of a copy. Otherwise, this is equivalent to calling
         * g_file_load_contents_async() and g_bytes_new_take().
         *
         * `callback` should call g_file_load_bytes_finish() to get the result of this
         * asynchronous operation.
         *
         * See g_file_load_bytes() for more information.
         * @param cancellable a #GCancellable or %NULL
         * @returns A Promise of: a #GBytes or %NULL and @error is set
         */
        load_bytes_async(
            cancellable: Cancellable | null
        ): globalThis.Promise</* etag_out */ string | null>;
        /**
         * Completes an asynchronous request to g_file_load_bytes_async().
         *
         * For resources, `etag_out` will be set to %NULL.
         *
         * The data contained in the resulting #GBytes is always zero-terminated, but
         * this is not included in the #GBytes length. The resulting #GBytes should be
         * freed with g_bytes_unref() when no longer in use.
         *
         * See g_file_load_bytes() for more information.
         * @param result a #GAsyncResult provided to the callback
         * @returns a #GBytes or %NULL and @error is set
         */
        load_bytes_finish(
            result: AsyncResult
        ): [/* returnType */ GLib.Bytes, /* etag_out */ string | null];
        /**
         * Loads the content of the file into memory. The data is always
         * zero-terminated, but this is not included in the resultant `length`.
         * The returned `contents` should be freed with g_free() when no longer
         * needed.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @returns %TRUE if the @file's contents were successfully loaded.   %FALSE if there were errors.
         */
        load_contents(
            cancellable: Cancellable | null
        ): [
            /* returnType */ boolean,
            /* contents */ Uint8Array,
            /* etag_out */ string | null
        ];
        /**
         * Starts an asynchronous load of the `file'`s contents.
         *
         * For more details, see g_file_load_contents() which is
         * the synchronous version of this call.
         *
         * When the load operation has completed, `callback` will be called
         * with `user` data. To finish the operation, call
         * g_file_load_contents_finish() with the #GAsyncResult returned by
         * the `callback`.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied
         */
        load_contents_async(
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of load_contents_async

        /**
         * Promisified version of {@link load_contents_async}
         *
         * Starts an asynchronous load of the `file'`s contents.
         *
         * For more details, see g_file_load_contents() which is
         * the synchronous version of this call.
         *
         * When the load operation has completed, `callback` will be called
         * with `user` data. To finish the operation, call
         * g_file_load_contents_finish() with the #GAsyncResult returned by
         * the `callback`.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @returns A Promise of: %TRUE if the load was successful. If %FALSE and @error is   present, it will be set appropriately.
         */
        load_contents_async(
            cancellable: Cancellable | null
        ): globalThis.Promise<
            [/* contents */ Uint8Array, /* etag_out */ string | null]
        >;
        /**
         * Finishes an asynchronous load of the `file'`s contents.
         * The contents are placed in `contents,` and `length` is set to the
         * size of the `contents` string. The `contents` should be freed with
         * g_free() when no longer needed. If `etag_out` is present, it will be
         * set to the new entity tag for the `file`.
         * @param res a #GAsyncResult
         * @returns %TRUE if the load was successful. If %FALSE and @error is   present, it will be set appropriately.
         */
        load_contents_finish(
            res: AsyncResult
        ): [
            /* returnType */ boolean,
            /* contents */ Uint8Array,
            /* etag_out */ string | null
        ];
        /**
         * Finishes an asynchronous partial load operation that was started
         * with g_file_load_partial_contents_async(). The data is always
         * zero-terminated, but this is not included in the resultant `length`.
         * The returned `contents` should be freed with g_free() when no longer
         * needed.
         * @param res a #GAsyncResult
         * @returns %TRUE if the load was successful. If %FALSE and @error is   present, it will be set appropriately.
         */
        load_partial_contents_finish(
            res: AsyncResult
        ): [
            /* returnType */ boolean,
            /* contents */ Uint8Array,
            /* etag_out */ string | null
        ];
        /**
         * Creates a directory. Note that this will only create a child directory
         * of the immediate parent directory of the path or URI given by the #GFile.
         * To recursively create directories, see g_file_make_directory_with_parents().
         * This function will fail if the parent directory does not exist, setting
         * `error` to %G_IO_ERROR_NOT_FOUND. If the file system doesn't support
         * creating directories, this function will fail, setting `error` to
         * %G_IO_ERROR_NOT_SUPPORTED.
         *
         * For a local #GFile the newly created directory will have the default
         * (current) ownership and permissions of the current process.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns %TRUE on successful creation, %FALSE otherwise.
         */
        make_directory(cancellable: Cancellable | null): boolean;
        /**
         * Asynchronously creates a directory.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
         */
        make_directory_async(
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of make_directory_async

        /**
         * Promisified version of {@link make_directory_async}
         *
         * Asynchronously creates a directory.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns A Promise of: %TRUE on successful directory creation, %FALSE otherwise.
         */
        make_directory_async(
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<boolean>;
        /**
         * Finishes an asynchronous directory creation, started with
         * g_file_make_directory_async().
         * @param result a #GAsyncResult
         * @returns %TRUE on successful directory creation, %FALSE otherwise.
         */
        make_directory_finish(result: AsyncResult): boolean;
        /**
         * Creates a directory and any parent directories that may not
         * exist similar to 'mkdir -p'. If the file system does not support
         * creating directories, this function will fail, setting `error` to
         * %G_IO_ERROR_NOT_SUPPORTED. If the directory itself already exists,
         * this function will fail setting `error` to %G_IO_ERROR_EXISTS, unlike
         * the similar g_mkdir_with_parents().
         *
         * For a local #GFile the newly created directories will have the default
         * (current) ownership and permissions of the current process.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns %TRUE if all directories have been successfully created, %FALSE otherwise.
         */
        make_directory_with_parents(cancellable: Cancellable | null): boolean;
        /**
         * Creates a symbolic link named `file` which contains the string
         * `symlink_value`.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param symlink_value a string with the path for the target   of the new symlink
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns %TRUE on the creation of a new symlink, %FALSE otherwise.
         */
        make_symbolic_link(
            symlink_value: string,
            cancellable: Cancellable | null
        ): boolean;
        /**
         * Asynchronously creates a symbolic link named `file` which contains the
         * string `symlink_value`.
         * @param symlink_value a string with the path for the target   of the new symlink
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
         */
        make_symbolic_link_async(
            symlink_value: string,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of make_symbolic_link_async

        /**
         * Promisified version of {@link make_symbolic_link_async}
         *
         * Asynchronously creates a symbolic link named `file` which contains the
         * string `symlink_value`.
         * @param symlink_value a string with the path for the target   of the new symlink
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns A Promise of: %TRUE on successful directory creation, %FALSE otherwise.
         */
        make_symbolic_link_async(
            symlink_value: string,
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<boolean>;
        /**
         * Finishes an asynchronous symbolic link creation, started with
         * g_file_make_symbolic_link_async().
         * @param result a #GAsyncResult
         * @returns %TRUE on successful directory creation, %FALSE otherwise.
         */
        make_symbolic_link_finish(result: AsyncResult): boolean;
        /**
         * Collects the results from an earlier call to
         * g_file_measure_disk_usage_async().  See g_file_measure_disk_usage() for
         * more information.
         * @param result the #GAsyncResult passed to your #GAsyncReadyCallback
         * @returns %TRUE if successful, with the out parameters set.   %FALSE otherwise, with @error set.
         */
        measure_disk_usage_finish(
            result: AsyncResult
        ): [
            /* returnType */ boolean,
            /* disk_usage */ number,
            /* num_dirs */ number,
            /* num_files */ number
        ];
        /**
         * Obtains a file or directory monitor for the given file,
         * depending on the type of the file.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param flags a set of #GFileMonitorFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFileMonitor for the given @file,   or %NULL on error.   Free the returned object with g_object_unref().
         */
        monitor(
            flags: FileMonitorFlags,
            cancellable: Cancellable | null
        ): FileMonitor;
        /**
         * Obtains a directory monitor for the given file.
         * This may fail if directory monitoring is not supported.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * It does not make sense for `flags` to contain
         * %G_FILE_MONITOR_WATCH_HARD_LINKS, since hard links can not be made to
         * directories.  It is not possible to monitor all the files in a
         * directory for changes made via hard links; if you want to do this then
         * you must register individual watches with g_file_monitor().
         * @param flags a set of #GFileMonitorFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFileMonitor for the given @file,   or %NULL on error.   Free the returned object with g_object_unref().
         */
        monitor_directory(
            flags: FileMonitorFlags,
            cancellable: Cancellable | null
        ): FileMonitor;
        /**
         * Obtains a file monitor for the given file. If no file notification
         * mechanism exists, then regular polling of the file is used.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * If `flags` contains %G_FILE_MONITOR_WATCH_HARD_LINKS then the monitor
         * will also attempt to report changes made to the file via another
         * filename (ie, a hard link). Without this flag, you can only rely on
         * changes made through the filename contained in `file` to be
         * reported. Using this flag may result in an increase in resource
         * usage, and may not have any effect depending on the #GFileMonitor
         * backend and/or filesystem type.
         * @param flags a set of #GFileMonitorFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFileMonitor for the given @file,   or %NULL on error.   Free the returned object with g_object_unref().
         */
        monitor_file(
            flags: FileMonitorFlags,
            cancellable: Cancellable | null
        ): FileMonitor;
        /**
         * Starts a `mount_operation,` mounting the volume that contains
         * the file `location`.
         *
         * When this operation has completed, `callback` will be called with
         * `user_user` data, and the operation can be finalized with
         * g_file_mount_enclosing_volume_finish().
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param flags flags affecting the operation
         * @param mount_operation a #GMountOperation   or %NULL to avoid user interaction
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call   when the request is satisfied, or %NULL
         */
        mount_enclosing_volume(
            flags: MountMountFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes a mount operation started by g_file_mount_enclosing_volume().
         * @param result a #GAsyncResult
         * @returns %TRUE if successful. If an error has occurred,   this function will return %FALSE and set @error   appropriately if present.
         */
        mount_enclosing_volume_finish(result: AsyncResult): boolean;
        /**
         * Mounts a file of type G_FILE_TYPE_MOUNTABLE.
         * Using `mount_operation,` you can request callbacks when, for instance,
         * passwords are needed during authentication.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_mount_mountable_finish() to get
         * the result of the operation.
         * @param flags flags affecting the operation
         * @param mount_operation a #GMountOperation,   or %NULL to avoid user interaction
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        mount_mountable(
            flags: MountMountFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes a mount operation. See g_file_mount_mountable() for details.
         *
         * Finish an asynchronous mount operation that was started
         * with g_file_mount_mountable().
         * @param result a #GAsyncResult
         * @returns a #GFile or %NULL on error.   Free the returned object with g_object_unref().
         */
        mount_mountable_finish(result: AsyncResult): File;
        /**
         * Tries to move the file or directory `source` to the location specified
         * by `destination`. If native move operations are supported then this is
         * used, otherwise a copy + delete fallback is used. The native
         * implementation may support moving directories (for instance on moves
         * inside the same filesystem), but the fallback code does not.
         *
         * If the flag %G_FILE_COPY_OVERWRITE is specified an already
         * existing `destination` file is overwritten.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * If `progress_callback` is not %NULL, then the operation can be monitored
         * by setting this to a #GFileProgressCallback function.
         * `progress_callback_data` will be passed to this function. It is
         * guaranteed that this callback will be called after all data has been
         * transferred with the total number of bytes copied during the operation.
         *
         * If the `source` file does not exist, then the %G_IO_ERROR_NOT_FOUND
         * error is returned, independent on the status of the `destination`.
         *
         * If %G_FILE_COPY_OVERWRITE is not specified and the target exists,
         * then the error %G_IO_ERROR_EXISTS is returned.
         *
         * If trying to overwrite a file over a directory, the %G_IO_ERROR_IS_DIRECTORY
         * error is returned. If trying to overwrite a directory with a directory the
         * %G_IO_ERROR_WOULD_MERGE error is returned.
         *
         * If the source is a directory and the target does not exist, or
         * %G_FILE_COPY_OVERWRITE is specified and the target is a file, then
         * the %G_IO_ERROR_WOULD_RECURSE error may be returned (if the native
         * move operation isn't available).
         * @param destination #GFile pointing to the destination location
         * @param flags set of #GFileCopyFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param progress_callback #GFileProgressCallback   function for updates
         * @returns %TRUE on successful move, %FALSE otherwise.
         */
        move(
            destination: File,
            flags: FileCopyFlags,
            cancellable: Cancellable | null,
            progress_callback: FileProgressCallback | null
        ): boolean;
        /**
         * Asynchronously moves a file `source` to the location of `destination`. For details of the behaviour, see g_file_move().
         *
         * If `progress_callback` is not %NULL, then that function that will be called
         * just like in g_file_move(). The callback will run in the default main context
         * of the thread calling g_file_move_async()  the same context as `callback` is
         * run in.
         *
         * When the operation is finished, `callback` will be called. You can then call
         * g_file_move_finish() to get the result of the operation.
         * @param destination #GFile pointing to the destination location
         * @param flags set of #GFileCopyFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param progress_callback    #GFileProgressCallback function for updates
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        move_async(
            destination: File,
            flags: FileCopyFlags,
            io_priority: number,
            cancellable: Cancellable | null,
            progress_callback: FileProgressCallback | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of move_async

        /**
         * Promisified version of {@link move_async}
         *
         * Asynchronously moves a file `source` to the location of `destination`. For details of the behaviour, see g_file_move().
         *
         * If `progress_callback` is not %NULL, then that function that will be called
         * just like in g_file_move(). The callback will run in the default main context
         * of the thread calling g_file_move_async()  the same context as `callback` is
         * run in.
         *
         * When the operation is finished, `callback` will be called. You can then call
         * g_file_move_finish() to get the result of the operation.
         * @param destination #GFile pointing to the destination location
         * @param flags set of #GFileCopyFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param progress_callback    #GFileProgressCallback function for updates
         * @returns A Promise of: %TRUE on successful file move, %FALSE otherwise.
         */
        move_async(
            destination: File,
            flags: FileCopyFlags,
            io_priority: number,
            cancellable: Cancellable | null,
            progress_callback: FileProgressCallback | null
        ): globalThis.Promise<boolean>;
        /**
         * Finishes an asynchronous file movement, started with
         * g_file_move_async().
         * @param result a #GAsyncResult
         * @returns %TRUE on successful file move, %FALSE otherwise.
         */
        move_finish(result: AsyncResult): boolean;
        /**
         * Opens an existing file for reading and writing. The result is
         * a #GFileIOStream that can be used to read and write the contents
         * of the file.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled
         * by triggering the cancellable object from another thread. If the
         * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
         * returned.
         *
         * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
         * be returned. If the file is a directory, the %G_IO_ERROR_IS_DIRECTORY
         * error will be returned. Other errors are possible too, and depend on
         * what kind of filesystem the file is on. Note that in many non-local
         * file cases read and write streams are not supported, so make sure you
         * really need to do read and write streaming, rather than just opening
         * for reading or writing.
         * @param cancellable a #GCancellable
         * @returns #GFileIOStream or %NULL on error.   Free the returned object with g_object_unref().
         */
        open_readwrite(cancellable: Cancellable | null): FileIOStream;
        /**
         * Asynchronously opens `file` for reading and writing.
         *
         * For more details, see g_file_open_readwrite() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_open_readwrite_finish() to get
         * the result of the operation.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        open_readwrite_async(
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of open_readwrite_async

        /**
         * Promisified version of {@link open_readwrite_async}
         *
         * Asynchronously opens `file` for reading and writing.
         *
         * For more details, see g_file_open_readwrite() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_open_readwrite_finish() to get
         * the result of the operation.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns A Promise of: a #GFileIOStream or %NULL on error.   Free the returned object with g_object_unref().
         */
        open_readwrite_async(
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<FileIOStream>;
        /**
         * Finishes an asynchronous file read operation started with
         * g_file_open_readwrite_async().
         * @param res a #GAsyncResult
         * @returns a #GFileIOStream or %NULL on error.   Free the returned object with g_object_unref().
         */
        open_readwrite_finish(res: AsyncResult): FileIOStream;
        /**
         * Exactly like g_file_get_path(), but caches the result via
         * g_object_set_qdata_full().  This is useful for example in C
         * applications which mix `g_file_*` APIs with native ones.  It
         * also avoids an extra duplicated string when possible, so will be
         * generally more efficient.
         *
         * This call does no blocking I/O.
         * @returns string containing the #GFile's path,   or %NULL if no such path exists. The returned string is owned by @file.
         */
        peek_path(): string | null;
        /**
         * Polls a file of type %G_FILE_TYPE_MOUNTABLE.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_mount_mountable_finish() to get
         * the result of the operation.
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call   when the request is satisfied, or %NULL
         */
        poll_mountable(
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes a poll operation. See g_file_poll_mountable() for details.
         *
         * Finish an asynchronous poll operation that was polled
         * with g_file_poll_mountable().
         * @param result a #GAsyncResult
         * @returns %TRUE if the operation finished successfully. %FALSE otherwise.
         */
        poll_mountable_finish(result: AsyncResult): boolean;
        /**
         * Returns the #GAppInfo that is registered as the default
         * application to handle the file specified by `file`.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @returns a #GAppInfo if the handle was found,   %NULL if there were errors.   When you are done with it, release it with g_object_unref()
         */
        query_default_handler(cancellable: Cancellable | null): AppInfo;
        /**
         * Async version of g_file_query_default_handler().
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call when the request is done
         */
        query_default_handler_async(
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of query_default_handler_async

        /**
         * Promisified version of {@link query_default_handler_async}
         *
         * Async version of g_file_query_default_handler().
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @returns A Promise of: a #GAppInfo if the handle was found,   %NULL if there were errors.   When you are done with it, release it with g_object_unref()
         */
        query_default_handler_async(
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<AppInfo>;
        /**
         * Finishes a g_file_query_default_handler_async() operation.
         * @param result a #GAsyncResult
         * @returns a #GAppInfo if the handle was found,   %NULL if there were errors.   When you are done with it, release it with g_object_unref()
         */
        query_default_handler_finish(result: AsyncResult): AppInfo;
        /**
         * Utility function to check if a particular file exists. This is
         * implemented using g_file_query_info() and as such does blocking I/O.
         *
         * Note that in many cases it is [racy to first check for file existence](https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use)
         * and then execute something based on the outcome of that, because the
         * file might have been created or removed in between the operations. The
         * general approach to handling that is to not check, but just do the
         * operation and handle the errors as they come.
         *
         * As an example of race-free checking, take the case of reading a file,
         * and if it doesn't exist, creating it. There are two racy versions: read
         * it, and on error create it; and: check if it exists, if not create it.
         * These can both result in two processes creating the file (with perhaps
         * a partially written file as the result). The correct approach is to
         * always try to create the file with g_file_create() which will either
         * atomically create the file or fail with a %G_IO_ERROR_EXISTS error.
         *
         * However, in many cases an existence check is useful in a user interface,
         * for instance to make a menu item sensitive/insensitive, so that you don't
         * have to fool users that something is possible and then just show an error
         * dialog. If you do this, you should make sure to also handle the errors
         * that can happen due to races when you execute the operation.
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns %TRUE if the file exists (and can be detected without error),   %FALSE otherwise (or if cancelled).
         */
        query_exists(cancellable: Cancellable | null): boolean;
        /**
         * Utility function to inspect the #GFileType of a file. This is
         * implemented using g_file_query_info() and as such does blocking I/O.
         *
         * The primary use case of this method is to check if a file is
         * a regular file, directory, or symlink.
         * @param flags a set of #GFileQueryInfoFlags passed to g_file_query_info()
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns The #GFileType of the file and %G_FILE_TYPE_UNKNOWN   if the file does not exist
         */
        query_file_type(
            flags: FileQueryInfoFlags,
            cancellable: Cancellable | null
        ): FileType;
        /**
         * Similar to g_file_query_info(), but obtains information
         * about the filesystem the `file` is on, rather than the file itself.
         * For instance the amount of space available and the type of
         * the filesystem.
         *
         * The `attributes` value is a string that specifies the attributes
         * that should be gathered. It is not an error if it's not possible
         * to read a particular requested attribute from a file - it just
         * won't be set. `attributes` should be a comma-separated list of
         * attributes or attribute wildcards. The wildcard "*" means all
         * attributes, and a wildcard like "filesystem::*" means all attributes
         * in the filesystem namespace. The standard namespace for filesystem
         * attributes is "filesystem". Common attributes of interest are
         * %G_FILE_ATTRIBUTE_FILESYSTEM_SIZE (the total size of the filesystem
         * in bytes), %G_FILE_ATTRIBUTE_FILESYSTEM_FREE (number of bytes available),
         * and %G_FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the filesystem).
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled
         * by triggering the cancellable object from another thread. If the
         * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
         * returned.
         *
         * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
         * be returned. Other errors are possible too, and depend on what
         * kind of filesystem the file is on.
         * @param attributes an attribute query string
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFileInfo or %NULL if there was an error.   Free the returned object with g_object_unref().
         */
        query_filesystem_info(
            attributes: string | null,
            cancellable: Cancellable | null
        ): FileInfo;
        /**
         * Asynchronously gets the requested information about the filesystem
         * that the specified `file` is on. The result is a #GFileInfo object
         * that contains key-value attributes (such as type or size for the
         * file).
         *
         * For more details, see g_file_query_filesystem_info() which is the
         * synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called. You can
         * then call g_file_query_info_finish() to get the result of the
         * operation.
         * @param attributes an attribute query string
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        query_filesystem_info_async(
            attributes: string | null,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of query_filesystem_info_async

        /**
         * Promisified version of {@link query_filesystem_info_async}
         *
         * Asynchronously gets the requested information about the filesystem
         * that the specified `file` is on. The result is a #GFileInfo object
         * that contains key-value attributes (such as type or size for the
         * file).
         *
         * For more details, see g_file_query_filesystem_info() which is the
         * synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called. You can
         * then call g_file_query_info_finish() to get the result of the
         * operation.
         * @param attributes an attribute query string
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns A Promise of: #GFileInfo for given @file   or %NULL on error.   Free the returned object with g_object_unref().
         */
        query_filesystem_info_async(
            attributes: string | null,
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<FileInfo>;
        /**
         * Finishes an asynchronous filesystem info query.
         * See g_file_query_filesystem_info_async().
         * @param res a #GAsyncResult
         * @returns #GFileInfo for given @file   or %NULL on error.   Free the returned object with g_object_unref().
         */
        query_filesystem_info_finish(res: AsyncResult): FileInfo;
        /**
         * Gets the requested information about specified `file`.
         * The result is a #GFileInfo object that contains key-value
         * attributes (such as the type or size of the file).
         *
         * The `attributes` value is a string that specifies the file
         * attributes that should be gathered. It is not an error if
         * it's not possible to read a particular requested attribute
         * from a file - it just won't be set. `attributes` should be a
         * comma-separated list of attributes or attribute wildcards.
         * The wildcard "*" means all attributes, and a wildcard like
         * "standard::*" means all attributes in the standard namespace.
         * An example attribute query be "standard::*,owner::user".
         * The standard attributes are available as defines, like
         * %G_FILE_ATTRIBUTE_STANDARD_NAME.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled
         * by triggering the cancellable object from another thread. If the
         * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
         * returned.
         *
         * For symlinks, normally the information about the target of the
         * symlink is returned, rather than information about the symlink
         * itself. However if you pass %G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS
         * in `flags` the information about the symlink itself will be returned.
         * Also, for symlinks that point to non-existing files the information
         * about the symlink itself will be returned.
         *
         * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will be
         * returned. Other errors are possible too, and depend on what kind of
         * filesystem the file is on.
         * @param attributes an attribute query string
         * @param flags a set of #GFileQueryInfoFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFileInfo for the given @file, or %NULL   on error. Free the returned object with g_object_unref().
         */
        query_info(
            attributes: string | null,
            flags: FileQueryInfoFlags,
            cancellable: Cancellable | null
        ): FileInfo;
        /**
         * Asynchronously gets the requested information about specified `file`.
         * The result is a #GFileInfo object that contains key-value attributes
         * (such as type or size for the file).
         *
         * For more details, see g_file_query_info() which is the synchronous
         * version of this call.
         *
         * When the operation is finished, `callback` will be called. You can
         * then call g_file_query_info_finish() to get the result of the operation.
         * @param attributes an attribute query string
         * @param flags a set of #GFileQueryInfoFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        query_info_async(
            attributes: string | null,
            flags: FileQueryInfoFlags,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of query_info_async

        /**
         * Promisified version of {@link query_info_async}
         *
         * Asynchronously gets the requested information about specified `file`.
         * The result is a #GFileInfo object that contains key-value attributes
         * (such as type or size for the file).
         *
         * For more details, see g_file_query_info() which is the synchronous
         * version of this call.
         *
         * When the operation is finished, `callback` will be called. You can
         * then call g_file_query_info_finish() to get the result of the operation.
         * @param attributes an attribute query string
         * @param flags a set of #GFileQueryInfoFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns A Promise of: #GFileInfo for given @file   or %NULL on error. Free the returned object with   g_object_unref().
         */
        query_info_async(
            attributes: string | null,
            flags: FileQueryInfoFlags,
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<FileInfo>;
        /**
         * Finishes an asynchronous file info query.
         * See g_file_query_info_async().
         * @param res a #GAsyncResult
         * @returns #GFileInfo for given @file   or %NULL on error. Free the returned object with   g_object_unref().
         */
        query_info_finish(res: AsyncResult): FileInfo;
        /**
         * Obtain the list of settable attributes for the file.
         *
         * Returns the type and full attribute name of all the attributes
         * that can be set on this file. This doesn't mean setting it will
         * always succeed though, you might get an access failure, or some
         * specific file may not support a specific attribute.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFileAttributeInfoList describing the settable attributes.   When you are done with it, release it with   g_file_attribute_info_list_unref()
         */
        query_settable_attributes(
            cancellable: Cancellable | null
        ): FileAttributeInfoList;
        /**
         * Obtain the list of attribute namespaces where new attributes
         * can be created by a user. An example of this is extended
         * attributes (in the "xattr" namespace).
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFileAttributeInfoList describing the writable namespaces.   When you are done with it, release it with   g_file_attribute_info_list_unref()
         */
        query_writable_namespaces(
            cancellable: Cancellable | null
        ): FileAttributeInfoList;
        /**
         * Opens a file for reading. The result is a #GFileInputStream that
         * can be used to read the contents of the file.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will be
         * returned. If the file is a directory, the %G_IO_ERROR_IS_DIRECTORY
         * error will be returned. Other errors are possible too, and depend
         * on what kind of filesystem the file is on.
         * @param cancellable a #GCancellable
         * @returns #GFileInputStream or %NULL on error.   Free the returned object with g_object_unref().
         */
        read(cancellable: Cancellable | null): FileInputStream;
        /**
         * Asynchronously opens `file` for reading.
         *
         * For more details, see g_file_read() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_read_finish() to get the result
         * of the operation.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        read_async(
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of read_async

        /**
         * Promisified version of {@link read_async}
         *
         * Asynchronously opens `file` for reading.
         *
         * For more details, see g_file_read() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_read_finish() to get the result
         * of the operation.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns A Promise of: a #GFileInputStream or %NULL on error.   Free the returned object with g_object_unref().
         */
        read_async(
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<FileInputStream>;
        /**
         * Finishes an asynchronous file read operation started with
         * g_file_read_async().
         * @param res a #GAsyncResult
         * @returns a #GFileInputStream or %NULL on error.   Free the returned object with g_object_unref().
         */
        read_finish(res: AsyncResult): FileInputStream;
        /**
         * Returns an output stream for overwriting the file, possibly
         * creating a backup copy of the file first. If the file doesn't exist,
         * it will be created.
         *
         * This will try to replace the file in the safest way possible so
         * that any errors during the writing will not affect an already
         * existing copy of the file. For instance, for local files it
         * may write to a temporary file and then atomically rename over
         * the destination when the stream is closed.
         *
         * By default files created are generally readable by everyone,
         * but if you pass %G_FILE_CREATE_PRIVATE in `flags` the file
         * will be made readable only to the current user, to the level that
         * is supported on the target filesystem.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled
         * by triggering the cancellable object from another thread. If the
         * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
         * returned.
         *
         * If you pass in a non-%NULL `etag` value and `file` already exists, then
         * this value is compared to the current entity tag of the file, and if
         * they differ an %G_IO_ERROR_WRONG_ETAG error is returned. This
         * generally means that the file has been changed since you last read
         * it. You can get the new etag from g_file_output_stream_get_etag()
         * after you've finished writing and closed the #GFileOutputStream. When
         * you load a new file you can use g_file_input_stream_query_info() to
         * get the etag of the file.
         *
         * If `make_backup` is %TRUE, this function will attempt to make a
         * backup of the current file before overwriting it. If this fails
         * a %G_IO_ERROR_CANT_CREATE_BACKUP error will be returned. If you
         * want to replace anyway, try again with `make_backup` set to %FALSE.
         *
         * If the file is a directory the %G_IO_ERROR_IS_DIRECTORY error will
         * be returned, and if the file is some other form of non-regular file
         * then a %G_IO_ERROR_NOT_REGULAR_FILE error will be returned. Some
         * file systems don't allow all file names, and may return an
         * %G_IO_ERROR_INVALID_FILENAME error, and if the name is to long
         * %G_IO_ERROR_FILENAME_TOO_LONG will be returned. Other errors are
         * possible too, and depend on what kind of filesystem the file is on.
         * @param etag an optional [entity tag][gfile-etag]   for the current #GFile, or #NULL to ignore
         * @param make_backup %TRUE if a backup should be created
         * @param flags a set of #GFileCreateFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFileOutputStream or %NULL on error.   Free the returned object with g_object_unref().
         */
        replace(
            etag: string | null,
            make_backup: boolean,
            flags: FileCreateFlags,
            cancellable: Cancellable | null
        ): FileOutputStream;
        /**
         * Asynchronously overwrites the file, replacing the contents,
         * possibly creating a backup copy of the file first.
         *
         * For more details, see g_file_replace() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_replace_finish() to get the result
         * of the operation.
         * @param etag an [entity tag][gfile-etag] for the current #GFile,   or %NULL to ignore
         * @param make_backup %TRUE if a backup should be created
         * @param flags a set of #GFileCreateFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        replace_async(
            etag: string | null,
            make_backup: boolean,
            flags: FileCreateFlags,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of replace_async

        /**
         * Promisified version of {@link replace_async}
         *
         * Asynchronously overwrites the file, replacing the contents,
         * possibly creating a backup copy of the file first.
         *
         * For more details, see g_file_replace() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_replace_finish() to get the result
         * of the operation.
         * @param etag an [entity tag][gfile-etag] for the current #GFile,   or %NULL to ignore
         * @param make_backup %TRUE if a backup should be created
         * @param flags a set of #GFileCreateFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns A Promise of: a #GFileOutputStream, or %NULL on error.   Free the returned object with g_object_unref().
         */
        replace_async(
            etag: string | null,
            make_backup: boolean,
            flags: FileCreateFlags,
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<FileOutputStream>;
        /**
         * Replaces the contents of `file` with `contents` of `length` bytes.
         *
         * If `etag` is specified (not %NULL), any existing file must have that etag,
         * or the error %G_IO_ERROR_WRONG_ETAG will be returned.
         *
         * If `make_backup` is %TRUE, this function will attempt to make a backup
         * of `file`. Internally, it uses g_file_replace(), so will try to replace the
         * file contents in the safest way possible. For example, atomic renames are
         * used when replacing local files contents.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * The returned `new_etag` can be used to verify that the file hasn't
         * changed the next time it is saved over.
         * @param contents a string containing the new contents for `file`
         * @param etag the old [entity-tag][gfile-etag] for the document,   or %NULL
         * @param make_backup %TRUE if a backup should be created
         * @param flags a set of #GFileCreateFlags
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @returns %TRUE if successful. If an error has occurred, this function   will return %FALSE and set @error appropriately if present.
         */
        replace_contents(
            contents: Uint8Array,
            etag: string | null,
            make_backup: boolean,
            flags: FileCreateFlags,
            cancellable: Cancellable | null
        ): [/* returnType */ boolean, /* new_etag */ string | null];
        // Has conflict: replace_contents_async(contents: Uint8Array, etag: string | null, make_backup: boolean, flags: FileCreateFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

        // Overloads of replace_contents_async

        /**
         * Promisified version of {@link replace_contents_async}
         *
         * Starts an asynchronous replacement of `file` with the given
         * `contents` of `length` bytes. `etag` will replace the document's
         * current entity tag.
         *
         * When this operation has completed, `callback` will be called with
         * `user_user` data, and the operation can be finalized with
         * g_file_replace_contents_finish().
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * If `make_backup` is %TRUE, this function will attempt to
         * make a backup of `file`.
         *
         * Note that no copy of `contents` will be made, so it must stay valid
         * until `callback` is called. See g_file_replace_contents_bytes_async()
         * for a #GBytes version that will automatically hold a reference to the
         * contents (without copying) for the duration of the call.
         * @param contents string of contents to replace the file with
         * @param etag a new [entity tag][gfile-etag] for the `file,` or %NULL
         * @param make_backup %TRUE if a backup should be created
         * @param flags a set of #GFileCreateFlags
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @returns A Promise of: %TRUE on success, %FALSE on failure.
         */
        replace_contents_async(
            contents: Uint8Array,
            etag: string | null,
            make_backup: boolean,
            flags: FileCreateFlags,
            cancellable: Cancellable | null
        ): globalThis.Promise</* new_etag */ string | null>;
        /**
         * Same as g_file_replace_contents_async() but takes a #GBytes input instead.
         * This function will keep a ref on `contents` until the operation is done.
         * Unlike g_file_replace_contents_async() this allows forgetting about the
         * content without waiting for the callback.
         *
         * When this operation has completed, `callback` will be called with
         * `user_user` data, and the operation can be finalized with
         * g_file_replace_contents_finish().
         * @param contents a #GBytes
         * @param etag a new [entity tag][gfile-etag] for the `file,` or %NULL
         * @param make_backup %TRUE if a backup should be created
         * @param flags a set of #GFileCreateFlags
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied
         */
        replace_contents_bytes_async(
            contents: GLib.Bytes,
            etag: string | null,
            make_backup: boolean,
            flags: FileCreateFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes an asynchronous replace of the given `file`. See
         * g_file_replace_contents_async(). Sets `new_etag` to the new entity
         * tag for the document, if present.
         * @param res a #GAsyncResult
         * @returns %TRUE on success, %FALSE on failure.
         */
        replace_contents_finish(
            res: AsyncResult
        ): [/* returnType */ boolean, /* new_etag */ string | null];
        /**
         * Finishes an asynchronous file replace operation started with
         * g_file_replace_async().
         * @param res a #GAsyncResult
         * @returns a #GFileOutputStream, or %NULL on error.   Free the returned object with g_object_unref().
         */
        replace_finish(res: AsyncResult): FileOutputStream;
        /**
         * Returns an output stream for overwriting the file in readwrite mode,
         * possibly creating a backup copy of the file first. If the file doesn't
         * exist, it will be created.
         *
         * For details about the behaviour, see g_file_replace() which does the
         * same thing but returns an output stream only.
         *
         * Note that in many non-local file cases read and write streams are not
         * supported, so make sure you really need to do read and write streaming,
         * rather than just opening for reading or writing.
         * @param etag an optional [entity tag][gfile-etag]   for the current #GFile, or #NULL to ignore
         * @param make_backup %TRUE if a backup should be created
         * @param flags a set of #GFileCreateFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFileIOStream or %NULL on error.   Free the returned object with g_object_unref().
         */
        replace_readwrite(
            etag: string | null,
            make_backup: boolean,
            flags: FileCreateFlags,
            cancellable: Cancellable | null
        ): FileIOStream;
        /**
         * Asynchronously overwrites the file in read-write mode,
         * replacing the contents, possibly creating a backup copy
         * of the file first.
         *
         * For more details, see g_file_replace_readwrite() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_replace_readwrite_finish() to get
         * the result of the operation.
         * @param etag an [entity tag][gfile-etag] for the current #GFile,   or %NULL to ignore
         * @param make_backup %TRUE if a backup should be created
         * @param flags a set of #GFileCreateFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        replace_readwrite_async(
            etag: string | null,
            make_backup: boolean,
            flags: FileCreateFlags,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of replace_readwrite_async

        /**
         * Promisified version of {@link replace_readwrite_async}
         *
         * Asynchronously overwrites the file in read-write mode,
         * replacing the contents, possibly creating a backup copy
         * of the file first.
         *
         * For more details, see g_file_replace_readwrite() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_replace_readwrite_finish() to get
         * the result of the operation.
         * @param etag an [entity tag][gfile-etag] for the current #GFile,   or %NULL to ignore
         * @param make_backup %TRUE if a backup should be created
         * @param flags a set of #GFileCreateFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns A Promise of: a #GFileIOStream, or %NULL on error.   Free the returned object with g_object_unref().
         */
        replace_readwrite_async(
            etag: string | null,
            make_backup: boolean,
            flags: FileCreateFlags,
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<FileIOStream>;
        /**
         * Finishes an asynchronous file replace operation started with
         * g_file_replace_readwrite_async().
         * @param res a #GAsyncResult
         * @returns a #GFileIOStream, or %NULL on error.   Free the returned object with g_object_unref().
         */
        replace_readwrite_finish(res: AsyncResult): FileIOStream;
        /**
         * Resolves a relative path for `file` to an absolute path.
         *
         * This call does no blocking I/O.
         *
         * If the `relative_path` is an absolute path name, the resolution
         * is done absolutely (without taking `file` path as base).
         * @param relative_path a given relative path string
         * @returns a #GFile for the resolved path.
         */
        resolve_relative_path(relative_path: string): File;
        /**
         * Sets an attribute in the file with attribute name `attribute` to `value_p`.
         *
         * Some attributes can be unset by setting `type` to
         * %G_FILE_ATTRIBUTE_TYPE_INVALID and `value_p` to %NULL.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param attribute a string containing the attribute's name
         * @param type The type of the attribute
         * @param value_p a pointer to the value (or the pointer   itself if the type is a pointer type)
         * @param flags a set of #GFileQueryInfoFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns %TRUE if the attribute was set, %FALSE otherwise.
         */
        set_attribute(
            attribute: string | null,
            type: FileAttributeType,
            value_p: any | null,
            flags: FileQueryInfoFlags,
            cancellable: Cancellable | null
        ): boolean;
        /**
         * Sets `attribute` of type %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING to `value`.
         * If `attribute` is of a different type, this operation will fail,
         * returning %FALSE.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param attribute a string containing the attribute's name
         * @param value a string containing the attribute's new value
         * @param flags a #GFileQueryInfoFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns %TRUE if the @attribute was successfully set to @value   in the @file, %FALSE otherwise.
         */
        set_attribute_byte_string(
            attribute: string | null,
            value: string | null,
            flags: FileQueryInfoFlags,
            cancellable: Cancellable | null
        ): boolean;
        /**
         * Sets `attribute` of type %G_FILE_ATTRIBUTE_TYPE_INT32 to `value`.
         * If `attribute` is of a different type, this operation will fail.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param attribute a string containing the attribute's name
         * @param value a #gint32 containing the attribute's new value
         * @param flags a #GFileQueryInfoFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns %TRUE if the @attribute was successfully set to @value   in the @file, %FALSE otherwise.
         */
        set_attribute_int32(
            attribute: string | null,
            value: number,
            flags: FileQueryInfoFlags,
            cancellable: Cancellable | null
        ): boolean;
        /**
         * Sets `attribute` of type %G_FILE_ATTRIBUTE_TYPE_INT64 to `value`.
         * If `attribute` is of a different type, this operation will fail.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param attribute a string containing the attribute's name
         * @param value a #guint64 containing the attribute's new value
         * @param flags a #GFileQueryInfoFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns %TRUE if the @attribute was successfully set, %FALSE otherwise.
         */
        set_attribute_int64(
            attribute: string | null,
            value: number,
            flags: FileQueryInfoFlags,
            cancellable: Cancellable | null
        ): boolean;
        /**
         * Sets `attribute` of type %G_FILE_ATTRIBUTE_TYPE_STRING to `value`.
         * If `attribute` is of a different type, this operation will fail.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param attribute a string containing the attribute's name
         * @param value a string containing the attribute's value
         * @param flags #GFileQueryInfoFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns %TRUE if the @attribute was successfully set, %FALSE otherwise.
         */
        set_attribute_string(
            attribute: string | null,
            value: string | null,
            flags: FileQueryInfoFlags,
            cancellable: Cancellable | null
        ): boolean;
        /**
         * Sets `attribute` of type %G_FILE_ATTRIBUTE_TYPE_UINT32 to `value`.
         * If `attribute` is of a different type, this operation will fail.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param attribute a string containing the attribute's name
         * @param value a #guint32 containing the attribute's new value
         * @param flags a #GFileQueryInfoFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns %TRUE if the @attribute was successfully set to @value   in the @file, %FALSE otherwise.
         */
        set_attribute_uint32(
            attribute: string | null,
            value: number,
            flags: FileQueryInfoFlags,
            cancellable: Cancellable | null
        ): boolean;
        /**
         * Sets `attribute` of type %G_FILE_ATTRIBUTE_TYPE_UINT64 to `value`.
         * If `attribute` is of a different type, this operation will fail.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param attribute a string containing the attribute's name
         * @param value a #guint64 containing the attribute's new value
         * @param flags a #GFileQueryInfoFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns %TRUE if the @attribute was successfully set to @value   in the @file, %FALSE otherwise.
         */
        set_attribute_uint64(
            attribute: string | null,
            value: number,
            flags: FileQueryInfoFlags,
            cancellable: Cancellable | null
        ): boolean;
        /**
         * Asynchronously sets the attributes of `file` with `info`.
         *
         * For more details, see g_file_set_attributes_from_info(),
         * which is the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_set_attributes_finish() to get
         * the result of the operation.
         * @param info a #GFileInfo
         * @param flags a #GFileQueryInfoFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        set_attributes_async(
            info: FileInfo,
            flags: FileQueryInfoFlags,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of set_attributes_async

        /**
         * Promisified version of {@link set_attributes_async}
         *
         * Asynchronously sets the attributes of `file` with `info`.
         *
         * For more details, see g_file_set_attributes_from_info(),
         * which is the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_set_attributes_finish() to get
         * the result of the operation.
         * @param info a #GFileInfo
         * @param flags a #GFileQueryInfoFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns A Promise of: %TRUE if the attributes were set correctly, %FALSE otherwise.
         */
        set_attributes_async(
            info: FileInfo,
            flags: FileQueryInfoFlags,
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise</* info */ FileInfo>;
        /**
         * Finishes setting an attribute started in g_file_set_attributes_async().
         * @param result a #GAsyncResult
         * @returns %TRUE if the attributes were set correctly, %FALSE otherwise.
         */
        set_attributes_finish(
            result: AsyncResult
        ): [/* returnType */ boolean, /* info */ FileInfo];
        /**
         * Tries to set all attributes in the #GFileInfo on the target
         * values, not stopping on the first error.
         *
         * If there is any error during this operation then `error` will
         * be set to the first error. Error on particular fields are flagged
         * by setting the "status" field in the attribute value to
         * %G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING, which means you can
         * also detect further errors.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param info a #GFileInfo
         * @param flags #GFileQueryInfoFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns %FALSE if there was any error, %TRUE otherwise.
         */
        set_attributes_from_info(
            info: FileInfo,
            flags: FileQueryInfoFlags,
            cancellable: Cancellable | null
        ): boolean;
        /**
         * Renames `file` to the specified display name.
         *
         * The display name is converted from UTF-8 to the correct encoding
         * for the target filesystem if possible and the `file` is renamed to this.
         *
         * If you want to implement a rename operation in the user interface the
         * edit name (%G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME) should be used as the
         * initial value in the rename widget, and then the result after editing
         * should be passed to g_file_set_display_name().
         *
         * On success the resulting converted filename is returned.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param display_name a string
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFile specifying what @file was renamed to,   or %NULL if there was an error.   Free the returned object with g_object_unref().
         */
        set_display_name(
            display_name: string | null,
            cancellable: Cancellable | null
        ): File;
        /**
         * Asynchronously sets the display name for a given #GFile.
         *
         * For more details, see g_file_set_display_name() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_set_display_name_finish() to get
         * the result of the operation.
         * @param display_name a string
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        set_display_name_async(
            display_name: string | null,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of set_display_name_async

        /**
         * Promisified version of {@link set_display_name_async}
         *
         * Asynchronously sets the display name for a given #GFile.
         *
         * For more details, see g_file_set_display_name() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_set_display_name_finish() to get
         * the result of the operation.
         * @param display_name a string
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns A Promise of: a #GFile or %NULL on error.   Free the returned object with g_object_unref().
         */
        set_display_name_async(
            display_name: string | null,
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<File>;
        /**
         * Finishes setting a display name started with
         * g_file_set_display_name_async().
         * @param res a #GAsyncResult
         * @returns a #GFile or %NULL on error.   Free the returned object with g_object_unref().
         */
        set_display_name_finish(res: AsyncResult): File;
        /**
         * Starts a file of type %G_FILE_TYPE_MOUNTABLE.
         * Using `start_operation,` you can request callbacks when, for instance,
         * passwords are needed during authentication.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_mount_mountable_finish() to get
         * the result of the operation.
         * @param flags flags affecting the operation
         * @param start_operation a #GMountOperation, or %NULL to avoid user interaction
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied, or %NULL
         */
        start_mountable(
            flags: DriveStartFlags,
            start_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes a start operation. See g_file_start_mountable() for details.
         *
         * Finish an asynchronous start operation that was started
         * with g_file_start_mountable().
         * @param result a #GAsyncResult
         * @returns %TRUE if the operation finished successfully. %FALSE otherwise.
         */
        start_mountable_finish(result: AsyncResult): boolean;
        /**
         * Stops a file of type %G_FILE_TYPE_MOUNTABLE.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_stop_mountable_finish() to get
         * the result of the operation.
         * @param flags flags affecting the operation
         * @param mount_operation a #GMountOperation,   or %NULL to avoid user interaction.
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call   when the request is satisfied, or %NULL
         */
        stop_mountable(
            flags: MountUnmountFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes a stop operation, see g_file_stop_mountable() for details.
         *
         * Finish an asynchronous stop operation that was started
         * with g_file_stop_mountable().
         * @param result a #GAsyncResult
         * @returns %TRUE if the operation finished successfully.   %FALSE otherwise.
         */
        stop_mountable_finish(result: AsyncResult): boolean;
        /**
         * Checks if `file` supports
         * [thread-default contexts][g-main-context-push-thread-default-context].
         * If this returns %FALSE, you cannot perform asynchronous operations on
         * `file` in a thread that has a thread-default context.
         * @returns Whether or not @file supports thread-default contexts.
         */
        supports_thread_contexts(): boolean;
        /**
         * Sends `file` to the "Trashcan", if possible. This is similar to
         * deleting it, but the user can recover it before emptying the trashcan.
         * Not all file systems support trashing, so this call can return the
         * %G_IO_ERROR_NOT_SUPPORTED error. Since GLib 2.66, the `x-gvfs-notrash` unix
         * mount option can be used to disable g_file_trash() support for certain
         * mounts, the %G_IO_ERROR_NOT_SUPPORTED error will be returned in that case.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns %TRUE on successful trash, %FALSE otherwise.
         */
        trash(cancellable: Cancellable | null): boolean;
        /**
         * Asynchronously sends `file` to the Trash location, if possible.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
         */
        trash_async(
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of trash_async

        /**
         * Promisified version of {@link trash_async}
         *
         * Asynchronously sends `file` to the Trash location, if possible.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns A Promise of: %TRUE on successful trash, %FALSE otherwise.
         */
        trash_async(
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<boolean>;
        /**
         * Finishes an asynchronous file trashing operation, started with
         * g_file_trash_async().
         * @param result a #GAsyncResult
         * @returns %TRUE on successful trash, %FALSE otherwise.
         */
        trash_finish(result: AsyncResult): boolean;
        /**
         * Unmounts a file of type G_FILE_TYPE_MOUNTABLE.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_unmount_mountable_finish() to get
         * the result of the operation.
         * @param flags flags affecting the operation
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        unmount_mountable(
            flags: MountUnmountFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes an unmount operation, see g_file_unmount_mountable() for details.
         *
         * Finish an asynchronous unmount operation that was started
         * with g_file_unmount_mountable().
         * @param result a #GAsyncResult
         * @returns %TRUE if the operation finished successfully.   %FALSE otherwise.
         */
        unmount_mountable_finish(result: AsyncResult): boolean;
        /**
         * Unmounts a file of type %G_FILE_TYPE_MOUNTABLE.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_unmount_mountable_finish() to get
         * the result of the operation.
         * @param flags flags affecting the operation
         * @param mount_operation a #GMountOperation,   or %NULL to avoid user interaction
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        unmount_mountable_with_operation(
            flags: MountUnmountFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes an unmount operation,
         * see g_file_unmount_mountable_with_operation() for details.
         *
         * Finish an asynchronous unmount operation that was started
         * with g_file_unmount_mountable_with_operation().
         * @param result a #GAsyncResult
         * @returns %TRUE if the operation finished successfully.   %FALSE otherwise.
         */
        unmount_mountable_with_operation_finish(result: AsyncResult): boolean;
        /**
         * Starts an asynchronous replacement of `file` with the given
         * `contents` of `length` bytes. `etag` will replace the document's
         * current entity tag.
         *
         * When this operation has completed, `callback` will be called with
         * `user_user` data, and the operation can be finalized with
         * g_file_replace_contents_finish().
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * If `make_backup` is %TRUE, this function will attempt to
         * make a backup of `file`.
         *
         * Note that no copy of `contents` will be made, so it must stay valid
         * until `callback` is called. See g_file_replace_contents_bytes_async()
         * for a #GBytes version that will automatically hold a reference to the
         * contents (without copying) for the duration of the call.
         * @param contents string of contents to replace the file with
         * @param etag a new [entity tag][gfile-etag] for the `file,` or %NULL
         * @param make_backup %TRUE if a backup should be created
         * @param flags a set of #GFileCreateFlags
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied
         */
        replace_contents_async(
            contents: Uint8Array,
            etag: string | null,
            make_backup: boolean,
            flags: FileCreateFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ): void;

        // Own virtual methods of Gio-2.0.Gio.File

        /**
         * Gets an output stream for appending data to the file.
         * If the file doesn't already exist it is created.
         *
         * By default files created are generally readable by everyone,
         * but if you pass %G_FILE_CREATE_PRIVATE in `flags` the file
         * will be made readable only to the current user, to the level that
         * is supported on the target filesystem.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled
         * by triggering the cancellable object from another thread. If the
         * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
         * returned.
         *
         * Some file systems don't allow all file names, and may return an
         * %G_IO_ERROR_INVALID_FILENAME error. If the file is a directory the
         * %G_IO_ERROR_IS_DIRECTORY error will be returned. Other errors are
         * possible too, and depend on what kind of filesystem the file is on.
         * @virtual
         * @param flags a set of #GFileCreateFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFileOutputStream, or %NULL on error.   Free the returned object with g_object_unref().
         */
        vfunc_append_to(
            flags: FileCreateFlags,
            cancellable: Cancellable | null
        ): FileOutputStream;
        /**
         * Asynchronously opens `file` for appending.
         *
         * For more details, see g_file_append_to() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_append_to_finish() to get the result
         * of the operation.
         * @virtual
         * @param flags a set of #GFileCreateFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_append_to_async(
            flags: FileCreateFlags,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes an asynchronous file append operation started with
         * g_file_append_to_async().
         * @virtual
         * @param res #GAsyncResult
         * @returns a valid #GFileOutputStream   or %NULL on error.   Free the returned object with g_object_unref().
         */
        vfunc_append_to_finish(res: AsyncResult): FileOutputStream;
        /**
         * Copies the file `source` to the location specified by `destination`.
         * Can not handle recursive copies of directories.
         *
         * If the flag %G_FILE_COPY_OVERWRITE is specified an already
         * existing `destination` file is overwritten.
         *
         * If the flag %G_FILE_COPY_NOFOLLOW_SYMLINKS is specified then symlinks
         * will be copied as symlinks, otherwise the target of the
         * `source` symlink will be copied.
         *
         * If the flag %G_FILE_COPY_ALL_METADATA is specified then all the metadata
         * that is possible to copy is copied, not just the default subset (which,
         * for instance, does not include the owner, see #GFileInfo).
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * If `progress_callback` is not %NULL, then the operation can be monitored
         * by setting this to a #GFileProgressCallback function.
         * `progress_callback_data` will be passed to this function. It is guaranteed
         * that this callback will be called after all data has been transferred with
         * the total number of bytes copied during the operation.
         *
         * If the `source` file does not exist, then the %G_IO_ERROR_NOT_FOUND error
         * is returned, independent on the status of the `destination`.
         *
         * If %G_FILE_COPY_OVERWRITE is not specified and the target exists, then
         * the error %G_IO_ERROR_EXISTS is returned.
         *
         * If trying to overwrite a file over a directory, the %G_IO_ERROR_IS_DIRECTORY
         * error is returned. If trying to overwrite a directory with a directory the
         * %G_IO_ERROR_WOULD_MERGE error is returned.
         *
         * If the source is a directory and the target does not exist, or
         * %G_FILE_COPY_OVERWRITE is specified and the target is a file, then the
         * %G_IO_ERROR_WOULD_RECURSE error is returned.
         *
         * If you are interested in copying the #GFile object itself (not the on-disk
         * file), see g_file_dup().
         * @virtual
         * @param destination destination #GFile
         * @param flags set of #GFileCopyFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param progress_callback function to callback with   progress information, or %NULL if progress information is not needed
         * @returns %TRUE on success, %FALSE otherwise.
         */
        vfunc_copy(
            destination: File,
            flags: FileCopyFlags,
            cancellable: Cancellable | null,
            progress_callback: FileProgressCallback | null
        ): boolean;
        /**
         * Copies the file `source` to the location specified by `destination`
         * asynchronously. For details of the behaviour, see g_file_copy().
         *
         * If `progress_callback` is not %NULL, then that function that will be called
         * just like in g_file_copy(). The callback will run in the default main context
         * of the thread calling g_file_copy_async()  the same context as `callback` is
         * run in.
         *
         * When the operation is finished, `callback` will be called. You can then call
         * g_file_copy_finish() to get the result of the operation.
         * @virtual
         * @param destination destination #GFile
         * @param flags set of #GFileCopyFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param progress_callback    function to callback with progress information, or %NULL if   progress information is not needed
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_copy_async(
            destination: File,
            flags: FileCopyFlags,
            io_priority: number,
            cancellable: Cancellable | null,
            progress_callback: FileProgressCallback | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes copying the file started with g_file_copy_async().
         * @virtual
         * @param res a #GAsyncResult
         * @returns a %TRUE on success, %FALSE on error.
         */
        vfunc_copy_finish(res: AsyncResult): boolean;
        /**
         * Creates a new file and returns an output stream for writing to it.
         * The file must not already exist.
         *
         * By default files created are generally readable by everyone,
         * but if you pass %G_FILE_CREATE_PRIVATE in `flags` the file
         * will be made readable only to the current user, to the level
         * that is supported on the target filesystem.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled
         * by triggering the cancellable object from another thread. If the
         * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
         * returned.
         *
         * If a file or directory with this name already exists the
         * %G_IO_ERROR_EXISTS error will be returned. Some file systems don't
         * allow all file names, and may return an %G_IO_ERROR_INVALID_FILENAME
         * error, and if the name is to long %G_IO_ERROR_FILENAME_TOO_LONG will
         * be returned. Other errors are possible too, and depend on what kind
         * of filesystem the file is on.
         * @virtual
         * @param flags a set of #GFileCreateFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFileOutputStream for the newly created   file, or %NULL on error.   Free the returned object with g_object_unref().
         */
        vfunc_create(
            flags: FileCreateFlags,
            cancellable: Cancellable | null
        ): FileOutputStream;
        /**
         * Asynchronously creates a new file and returns an output stream
         * for writing to it. The file must not already exist.
         *
         * For more details, see g_file_create() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_create_finish() to get the result
         * of the operation.
         * @virtual
         * @param flags a set of #GFileCreateFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_create_async(
            flags: FileCreateFlags,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes an asynchronous file create operation started with
         * g_file_create_async().
         * @virtual
         * @param res a #GAsyncResult
         * @returns a #GFileOutputStream or %NULL on error.   Free the returned object with g_object_unref().
         */
        vfunc_create_finish(res: AsyncResult): FileOutputStream;
        /**
         * Creates a new file and returns a stream for reading and
         * writing to it. The file must not already exist.
         *
         * By default files created are generally readable by everyone,
         * but if you pass %G_FILE_CREATE_PRIVATE in `flags` the file
         * will be made readable only to the current user, to the level
         * that is supported on the target filesystem.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled
         * by triggering the cancellable object from another thread. If the
         * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
         * returned.
         *
         * If a file or directory with this name already exists, the
         * %G_IO_ERROR_EXISTS error will be returned. Some file systems don't
         * allow all file names, and may return an %G_IO_ERROR_INVALID_FILENAME
         * error, and if the name is too long, %G_IO_ERROR_FILENAME_TOO_LONG
         * will be returned. Other errors are possible too, and depend on what
         * kind of filesystem the file is on.
         *
         * Note that in many non-local file cases read and write streams are
         * not supported, so make sure you really need to do read and write
         * streaming, rather than just opening for reading or writing.
         * @virtual
         * @param flags a set of #GFileCreateFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFileIOStream for the newly created   file, or %NULL on error.   Free the returned object with g_object_unref().
         */
        vfunc_create_readwrite(
            flags: FileCreateFlags,
            cancellable: Cancellable | null
        ): FileIOStream;
        /**
         * Asynchronously creates a new file and returns a stream
         * for reading and writing to it. The file must not already exist.
         *
         * For more details, see g_file_create_readwrite() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_create_readwrite_finish() to get
         * the result of the operation.
         * @virtual
         * @param flags a set of #GFileCreateFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_create_readwrite_async(
            flags: FileCreateFlags,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes an asynchronous file create operation started with
         * g_file_create_readwrite_async().
         * @virtual
         * @param res a #GAsyncResult
         * @returns a #GFileIOStream or %NULL on error.   Free the returned object with g_object_unref().
         */
        vfunc_create_readwrite_finish(res: AsyncResult): FileIOStream;
        /**
         * Deletes a file. If the `file` is a directory, it will only be
         * deleted if it is empty. This has the same semantics as g_unlink().
         *
         * If `file` doesnt exist, %G_IO_ERROR_NOT_FOUND will be returned. This allows
         * for deletion to be implemented avoiding
         * [time-of-check to time-of-use races](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use):
         *
         * ```
         * g_autoptr(GError) local_error = NULL;
         * if (!g_file_delete (my_file, my_cancellable, &local_error) &&
         *     !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))
         *   {
         *     // deletion failed for some reason other than the file not existing:
         *     // so report the error
         *     g_warning ("Failed to delete %s: %s",
         *                g_file_peek_path (my_file), local_error->message);
         *   }
         * ```
         *
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @virtual
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns %TRUE if the file was deleted. %FALSE otherwise.
         */
        vfunc_delete_file(cancellable: Cancellable | null): boolean;
        /**
         * Asynchronously delete a file. If the `file` is a directory, it will
         * only be deleted if it is empty.  This has the same semantics as
         * g_unlink().
         * @virtual
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
         */
        vfunc_delete_file_async(
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes deleting a file started with g_file_delete_async().
         * @virtual
         * @param result a #GAsyncResult
         * @returns %TRUE if the file was deleted. %FALSE otherwise.
         */
        vfunc_delete_file_finish(result: AsyncResult): boolean;
        /**
         * Duplicates a #GFile handle. This operation does not duplicate
         * the actual file or directory represented by the #GFile; see
         * g_file_copy() if attempting to copy a file.
         *
         * g_file_dup() is useful when a second handle is needed to the same underlying
         * file, for use in a separate thread (#GFile is not thread-safe). For use
         * within the same thread, use g_object_ref() to increment the existing objects
         * reference count.
         *
         * This call does no blocking I/O.
         * @virtual
         * @returns a new #GFile that is a duplicate   of the given #GFile.
         */
        vfunc_dup(): File;
        /**
         * Starts an asynchronous eject on a mountable.
         * When this operation has completed, `callback` will be called with
         * `user_user` data, and the operation can be finalized with
         * g_file_eject_mountable_finish().
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @virtual
         * @param flags flags affecting the operation
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_eject_mountable(
            flags: MountUnmountFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes an asynchronous eject operation started by
         * g_file_eject_mountable().
         * @virtual
         * @param result a #GAsyncResult
         * @returns %TRUE if the @file was ejected successfully.   %FALSE otherwise.
         */
        vfunc_eject_mountable_finish(result: AsyncResult): boolean;
        /**
         * Starts an asynchronous eject on a mountable.
         * When this operation has completed, `callback` will be called with
         * `user_user` data, and the operation can be finalized with
         * g_file_eject_mountable_with_operation_finish().
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @virtual
         * @param flags flags affecting the operation
         * @param mount_operation a #GMountOperation,   or %NULL to avoid user interaction
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_eject_mountable_with_operation(
            flags: MountUnmountFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes an asynchronous eject operation started by
         * g_file_eject_mountable_with_operation().
         * @virtual
         * @param result a #GAsyncResult
         * @returns %TRUE if the @file was ejected successfully.   %FALSE otherwise.
         */
        vfunc_eject_mountable_with_operation_finish(
            result: AsyncResult
        ): boolean;
        /**
         * Gets the requested information about the files in a directory.
         * The result is a #GFileEnumerator object that will give out
         * #GFileInfo objects for all the files in the directory.
         *
         * The `attributes` value is a string that specifies the file
         * attributes that should be gathered. It is not an error if
         * it's not possible to read a particular requested attribute
         * from a file - it just won't be set. `attributes` should
         * be a comma-separated list of attributes or attribute wildcards.
         * The wildcard "*" means all attributes, and a wildcard like
         * "standard::*" means all attributes in the standard namespace.
         * An example attribute query be "standard::*,owner::user".
         * The standard attributes are available as defines, like
         * %G_FILE_ATTRIBUTE_STANDARD_NAME. %G_FILE_ATTRIBUTE_STANDARD_NAME should
         * always be specified if you plan to call g_file_enumerator_get_child() or
         * g_file_enumerator_iterate() on the returned enumerator.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled
         * by triggering the cancellable object from another thread. If the
         * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
         * returned.
         *
         * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
         * be returned. If the file is not a directory, the %G_IO_ERROR_NOT_DIRECTORY
         * error will be returned. Other errors are possible too.
         * @virtual
         * @param attributes an attribute query string
         * @param flags a set of #GFileQueryInfoFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns A #GFileEnumerator if successful,   %NULL on error. Free the returned object with g_object_unref().
         */
        vfunc_enumerate_children(
            attributes: string | null,
            flags: FileQueryInfoFlags,
            cancellable: Cancellable | null
        ): FileEnumerator;
        /**
         * Asynchronously gets the requested information about the files
         * in a directory. The result is a #GFileEnumerator object that will
         * give out #GFileInfo objects for all the files in the directory.
         *
         * For more details, see g_file_enumerate_children() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called. You can
         * then call g_file_enumerate_children_finish() to get the result of
         * the operation.
         * @virtual
         * @param attributes an attribute query string
         * @param flags a set of #GFileQueryInfoFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_enumerate_children_async(
            attributes: string | null,
            flags: FileQueryInfoFlags,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes an async enumerate children operation.
         * See g_file_enumerate_children_async().
         * @virtual
         * @param res a #GAsyncResult
         * @returns a #GFileEnumerator or %NULL   if an error occurred.   Free the returned object with g_object_unref().
         */
        vfunc_enumerate_children_finish(res: AsyncResult): FileEnumerator;
        /**
         * Checks if the two given #GFiles refer to the same file.
         *
         * Note that two #GFiles that differ can still refer to the same
         * file on the filesystem due to various forms of filename
         * aliasing.
         *
         * This call does no blocking I/O.
         * @virtual
         * @param file2 the second #GFile
         * @returns %TRUE if @file1 and @file2 are equal.
         */
        vfunc_equal(file2: File): boolean;
        /**
         * Gets a #GMount for the #GFile.
         *
         * #GMount is returned only for user interesting locations, see
         * #GVolumeMonitor. If the #GFileIface for `file` does not have a #mount,
         * `error` will be set to %G_IO_ERROR_NOT_FOUND and %NULL #will be returned.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @virtual
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GMount where the @file is located   or %NULL on error.   Free the returned object with g_object_unref().
         */
        vfunc_find_enclosing_mount(cancellable: Cancellable | null): Mount;
        /**
         * Asynchronously gets the mount for the file.
         *
         * For more details, see g_file_find_enclosing_mount() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_find_enclosing_mount_finish() to
         * get the result of the operation.
         * @virtual
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_find_enclosing_mount_async(
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes an asynchronous find mount request.
         * See g_file_find_enclosing_mount_async().
         * @virtual
         * @param res a #GAsyncResult
         * @returns #GMount for given @file or %NULL on error.   Free the returned object with g_object_unref().
         */
        vfunc_find_enclosing_mount_finish(res: AsyncResult): Mount;
        /**
         * Gets the base name (the last component of the path) for a given #GFile.
         *
         * If called for the top level of a system (such as the filesystem root
         * or a uri like sftp://host/) it will return a single directory separator
         * (and on Windows, possibly a drive letter).
         *
         * The base name is a byte string (not UTF-8). It has no defined encoding
         * or rules other than it may not contain zero bytes.  If you want to use
         * filenames in a user interface you should use the display name that you
         * can get by requesting the %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME
         * attribute with g_file_query_info().
         *
         * This call does no blocking I/O.
         * @virtual
         * @returns string containing the #GFile's   base name, or %NULL if given #GFile is invalid. The returned string   should be freed with g_free() when no longer needed.
         */
        vfunc_get_basename(): string | null;
        /**
         * Gets the child of `file` for a given `display_name` (i.e. a UTF-8
         * version of the name). If this function fails, it returns %NULL
         * and `error` will be set. This is very useful when constructing a
         * #GFile for a new file and the user entered the filename in the
         * user interface, for instance when you select a directory and
         * type a filename in the file selector.
         *
         * This call does no blocking I/O.
         * @virtual
         * @param display_name string to a possible child
         * @returns a #GFile to the specified child, or   %NULL if the display name couldn't be converted.   Free the returned object with g_object_unref().
         */
        vfunc_get_child_for_display_name(display_name: string | null): File;
        /**
         * Gets the parent directory for the `file`.
         * If the `file` represents the root directory of the
         * file system, then %NULL will be returned.
         *
         * This call does no blocking I/O.
         * @virtual
         * @returns a #GFile structure to the   parent of the given #GFile or %NULL if there is no parent. Free   the returned object with g_object_unref().
         */
        vfunc_get_parent(): File | null;
        /**
         * Gets the parse name of the `file`.
         * A parse name is a UTF-8 string that describes the
         * file such that one can get the #GFile back using
         * g_file_parse_name().
         *
         * This is generally used to show the #GFile as a nice
         * full-pathname kind of string in a user interface,
         * like in a location entry.
         *
         * For local files with names that can safely be converted
         * to UTF-8 the pathname is used, otherwise the IRI is used
         * (a form of URI that allows UTF-8 characters unescaped).
         *
         * This call does no blocking I/O.
         * @virtual
         * @returns a string containing the #GFile's parse name.   The returned string should be freed with g_free()   when no longer needed.
         */
        vfunc_get_parse_name(): string | null;
        /**
         * Gets the local pathname for #GFile, if one exists. If non-%NULL, this is
         * guaranteed to be an absolute, canonical path. It might contain symlinks.
         *
         * This call does no blocking I/O.
         * @virtual
         * @returns string containing the #GFile's path,   or %NULL if no such path exists. The returned string should be freed   with g_free() when no longer needed.
         */
        vfunc_get_path(): string | null;
        /**
         * Gets the path for `descendant` relative to `parent`.
         *
         * This call does no blocking I/O.
         * @virtual
         * @param descendant input #GFile
         * @returns string with the relative path from   @descendant to @parent, or %NULL if @descendant doesn't have @parent as   prefix. The returned string should be freed with g_free() when   no longer needed.
         */
        vfunc_get_relative_path(descendant: File): string | null;
        /**
         * Gets the URI for the `file`.
         *
         * This call does no blocking I/O.
         * @virtual
         * @returns a string containing the #GFile's URI. If the #GFile was constructed   with an invalid URI, an invalid URI is returned.   The returned string should be freed with g_free()   when no longer needed.
         */
        vfunc_get_uri(): string | null;
        /**
         * Gets the URI scheme for a #GFile.
         * RFC 3986 decodes the scheme as:
         *
         * ```
         * URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
         * ```
         *
         * Common schemes include "file", "http", "ftp", etc.
         *
         * The scheme can be different from the one used to construct the #GFile,
         * in that it might be replaced with one that is logically equivalent to the #GFile.
         *
         * This call does no blocking I/O.
         * @virtual
         * @returns a string containing the URI scheme for the given   #GFile or %NULL if the #GFile was constructed with an invalid URI. The   returned string should be freed with g_free() when no longer needed.
         */
        vfunc_get_uri_scheme(): string | null;
        /**
         * Checks to see if a #GFile has a given URI scheme.
         *
         * This call does no blocking I/O.
         * @virtual
         * @param uri_scheme a string containing a URI scheme
         * @returns %TRUE if #GFile's backend supports the   given URI scheme, %FALSE if URI scheme is %NULL,   not supported, or #GFile is invalid.
         */
        vfunc_has_uri_scheme(uri_scheme: string | null): boolean;
        /**
         * Creates a hash value for a #GFile.
         *
         * This call does no blocking I/O.
         * @virtual
         * @returns 0 if @file is not a valid #GFile, otherwise an   integer that can be used as hash value for the #GFile.   This function is intended for easily hashing a #GFile to   add to a #GHashTable or similar data structure.
         */
        vfunc_hash(): number;
        /**
         * Checks to see if a file is native to the platform.
         *
         * A native file is one expressed in the platform-native filename format,
         * e.g. "C:\Windows" or "/usr/bin/". This does not mean the file is local,
         * as it might be on a locally mounted remote filesystem.
         *
         * On some systems non-native files may be available using the native
         * filesystem via a userspace filesystem (FUSE), in these cases this call
         * will return %FALSE, but g_file_get_path() will still return a native path.
         *
         * This call does no blocking I/O.
         * @virtual
         * @returns %TRUE if @file is native
         */
        vfunc_is_native(): boolean;
        /**
         * Creates a directory. Note that this will only create a child directory
         * of the immediate parent directory of the path or URI given by the #GFile.
         * To recursively create directories, see g_file_make_directory_with_parents().
         * This function will fail if the parent directory does not exist, setting
         * `error` to %G_IO_ERROR_NOT_FOUND. If the file system doesn't support
         * creating directories, this function will fail, setting `error` to
         * %G_IO_ERROR_NOT_SUPPORTED.
         *
         * For a local #GFile the newly created directory will have the default
         * (current) ownership and permissions of the current process.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @virtual
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns %TRUE on successful creation, %FALSE otherwise.
         */
        vfunc_make_directory(cancellable: Cancellable | null): boolean;
        /**
         * Asynchronously creates a directory.
         * @virtual
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
         */
        vfunc_make_directory_async(
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes an asynchronous directory creation, started with
         * g_file_make_directory_async().
         * @virtual
         * @param result a #GAsyncResult
         * @returns %TRUE on successful directory creation, %FALSE otherwise.
         */
        vfunc_make_directory_finish(result: AsyncResult): boolean;
        /**
         * Creates a symbolic link named `file` which contains the string
         * `symlink_value`.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @virtual
         * @param symlink_value a string with the path for the target   of the new symlink
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns %TRUE on the creation of a new symlink, %FALSE otherwise.
         */
        vfunc_make_symbolic_link(
            symlink_value: string,
            cancellable: Cancellable | null
        ): boolean;
        /**
         * Asynchronously creates a symbolic link named `file` which contains the
         * string `symlink_value`.
         * @virtual
         * @param symlink_value a string with the path for the target   of the new symlink
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
         */
        vfunc_make_symbolic_link_async(
            symlink_value: string,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes an asynchronous symbolic link creation, started with
         * g_file_make_symbolic_link_async().
         * @virtual
         * @param result a #GAsyncResult
         * @returns %TRUE on successful directory creation, %FALSE otherwise.
         */
        vfunc_make_symbolic_link_finish(result: AsyncResult): boolean;
        /**
         * Collects the results from an earlier call to
         * g_file_measure_disk_usage_async().  See g_file_measure_disk_usage() for
         * more information.
         * @virtual
         * @param result the #GAsyncResult passed to your #GAsyncReadyCallback
         * @returns %TRUE if successful, with the out parameters set.   %FALSE otherwise, with @error set.
         */
        vfunc_measure_disk_usage_finish(
            result: AsyncResult
        ): [
            /* returnType */ boolean,
            /* disk_usage */ number,
            /* num_dirs */ number,
            /* num_files */ number
        ];
        /**
         * Obtains a directory monitor for the given file.
         * This may fail if directory monitoring is not supported.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * It does not make sense for `flags` to contain
         * %G_FILE_MONITOR_WATCH_HARD_LINKS, since hard links can not be made to
         * directories.  It is not possible to monitor all the files in a
         * directory for changes made via hard links; if you want to do this then
         * you must register individual watches with g_file_monitor().
         * @virtual
         * @param flags a set of #GFileMonitorFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFileMonitor for the given @file,   or %NULL on error.   Free the returned object with g_object_unref().
         */
        vfunc_monitor_dir(
            flags: FileMonitorFlags,
            cancellable: Cancellable | null
        ): FileMonitor;
        /**
         * Obtains a file monitor for the given file. If no file notification
         * mechanism exists, then regular polling of the file is used.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * If `flags` contains %G_FILE_MONITOR_WATCH_HARD_LINKS then the monitor
         * will also attempt to report changes made to the file via another
         * filename (ie, a hard link). Without this flag, you can only rely on
         * changes made through the filename contained in `file` to be
         * reported. Using this flag may result in an increase in resource
         * usage, and may not have any effect depending on the #GFileMonitor
         * backend and/or filesystem type.
         * @virtual
         * @param flags a set of #GFileMonitorFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFileMonitor for the given @file,   or %NULL on error.   Free the returned object with g_object_unref().
         */
        vfunc_monitor_file(
            flags: FileMonitorFlags,
            cancellable: Cancellable | null
        ): FileMonitor;
        /**
         * Starts a `mount_operation,` mounting the volume that contains
         * the file `location`.
         *
         * When this operation has completed, `callback` will be called with
         * `user_user` data, and the operation can be finalized with
         * g_file_mount_enclosing_volume_finish().
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @virtual
         * @param flags flags affecting the operation
         * @param mount_operation a #GMountOperation   or %NULL to avoid user interaction
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call   when the request is satisfied, or %NULL
         */
        vfunc_mount_enclosing_volume(
            flags: MountMountFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes a mount operation started by g_file_mount_enclosing_volume().
         * @virtual
         * @param result a #GAsyncResult
         * @returns %TRUE if successful. If an error has occurred,   this function will return %FALSE and set @error   appropriately if present.
         */
        vfunc_mount_enclosing_volume_finish(result: AsyncResult): boolean;
        /**
         * Mounts a file of type G_FILE_TYPE_MOUNTABLE.
         * Using `mount_operation,` you can request callbacks when, for instance,
         * passwords are needed during authentication.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_mount_mountable_finish() to get
         * the result of the operation.
         * @virtual
         * @param flags flags affecting the operation
         * @param mount_operation a #GMountOperation,   or %NULL to avoid user interaction
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_mount_mountable(
            flags: MountMountFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes a mount operation. See g_file_mount_mountable() for details.
         *
         * Finish an asynchronous mount operation that was started
         * with g_file_mount_mountable().
         * @virtual
         * @param result a #GAsyncResult
         * @returns a #GFile or %NULL on error.   Free the returned object with g_object_unref().
         */
        vfunc_mount_mountable_finish(result: AsyncResult): File;
        /**
         * Tries to move the file or directory `source` to the location specified
         * by `destination`. If native move operations are supported then this is
         * used, otherwise a copy + delete fallback is used. The native
         * implementation may support moving directories (for instance on moves
         * inside the same filesystem), but the fallback code does not.
         *
         * If the flag %G_FILE_COPY_OVERWRITE is specified an already
         * existing `destination` file is overwritten.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * If `progress_callback` is not %NULL, then the operation can be monitored
         * by setting this to a #GFileProgressCallback function.
         * `progress_callback_data` will be passed to this function. It is
         * guaranteed that this callback will be called after all data has been
         * transferred with the total number of bytes copied during the operation.
         *
         * If the `source` file does not exist, then the %G_IO_ERROR_NOT_FOUND
         * error is returned, independent on the status of the `destination`.
         *
         * If %G_FILE_COPY_OVERWRITE is not specified and the target exists,
         * then the error %G_IO_ERROR_EXISTS is returned.
         *
         * If trying to overwrite a file over a directory, the %G_IO_ERROR_IS_DIRECTORY
         * error is returned. If trying to overwrite a directory with a directory the
         * %G_IO_ERROR_WOULD_MERGE error is returned.
         *
         * If the source is a directory and the target does not exist, or
         * %G_FILE_COPY_OVERWRITE is specified and the target is a file, then
         * the %G_IO_ERROR_WOULD_RECURSE error may be returned (if the native
         * move operation isn't available).
         * @virtual
         * @param destination #GFile pointing to the destination location
         * @param flags set of #GFileCopyFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param progress_callback #GFileProgressCallback   function for updates
         * @returns %TRUE on successful move, %FALSE otherwise.
         */
        vfunc_move(
            destination: File,
            flags: FileCopyFlags,
            cancellable: Cancellable | null,
            progress_callback: FileProgressCallback | null
        ): boolean;
        /**
         * Asynchronously moves a file `source` to the location of `destination`. For details of the behaviour, see g_file_move().
         *
         * If `progress_callback` is not %NULL, then that function that will be called
         * just like in g_file_move(). The callback will run in the default main context
         * of the thread calling g_file_move_async()  the same context as `callback` is
         * run in.
         *
         * When the operation is finished, `callback` will be called. You can then call
         * g_file_move_finish() to get the result of the operation.
         * @virtual
         * @param destination #GFile pointing to the destination location
         * @param flags set of #GFileCopyFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param progress_callback    #GFileProgressCallback function for updates
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_move_async(
            destination: File,
            flags: FileCopyFlags,
            io_priority: number,
            cancellable: Cancellable | null,
            progress_callback: FileProgressCallback | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes an asynchronous file movement, started with
         * g_file_move_async().
         * @virtual
         * @param result a #GAsyncResult
         * @returns %TRUE on successful file move, %FALSE otherwise.
         */
        vfunc_move_finish(result: AsyncResult): boolean;
        /**
         * Opens an existing file for reading and writing. The result is
         * a #GFileIOStream that can be used to read and write the contents
         * of the file.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled
         * by triggering the cancellable object from another thread. If the
         * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
         * returned.
         *
         * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
         * be returned. If the file is a directory, the %G_IO_ERROR_IS_DIRECTORY
         * error will be returned. Other errors are possible too, and depend on
         * what kind of filesystem the file is on. Note that in many non-local
         * file cases read and write streams are not supported, so make sure you
         * really need to do read and write streaming, rather than just opening
         * for reading or writing.
         * @virtual
         * @param cancellable a #GCancellable
         * @returns #GFileIOStream or %NULL on error.   Free the returned object with g_object_unref().
         */
        vfunc_open_readwrite(cancellable: Cancellable | null): FileIOStream;
        /**
         * Asynchronously opens `file` for reading and writing.
         *
         * For more details, see g_file_open_readwrite() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_open_readwrite_finish() to get
         * the result of the operation.
         * @virtual
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_open_readwrite_async(
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes an asynchronous file read operation started with
         * g_file_open_readwrite_async().
         * @virtual
         * @param res a #GAsyncResult
         * @returns a #GFileIOStream or %NULL on error.   Free the returned object with g_object_unref().
         */
        vfunc_open_readwrite_finish(res: AsyncResult): FileIOStream;
        /**
         * Polls a file of type %G_FILE_TYPE_MOUNTABLE.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_mount_mountable_finish() to get
         * the result of the operation.
         * @virtual
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call   when the request is satisfied, or %NULL
         */
        vfunc_poll_mountable(
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes a poll operation. See g_file_poll_mountable() for details.
         *
         * Finish an asynchronous poll operation that was polled
         * with g_file_poll_mountable().
         * @virtual
         * @param result a #GAsyncResult
         * @returns %TRUE if the operation finished successfully. %FALSE otherwise.
         */
        vfunc_poll_mountable_finish(result: AsyncResult): boolean;
        /**
         * Checks whether `file` has the prefix specified by `prefix`.
         *
         * In other words, if the names of initial elements of `file'`s
         * pathname match `prefix`. Only full pathname elements are matched,
         * so a path like /foo is not considered a prefix of /foobar, only
         * of /foo/bar.
         *
         * A #GFile is not a prefix of itself. If you want to check for
         * equality, use g_file_equal().
         *
         * This call does no I/O, as it works purely on names. As such it can
         * sometimes return %FALSE even if `file` is inside a `prefix` (from a
         * filesystem point of view), because the prefix of `file` is an alias
         * of `prefix`.
         * @virtual
         * @param file input #GFile
         * @returns %TRUE if the @file's parent, grandparent, etc is @prefix,   %FALSE otherwise.
         */
        vfunc_prefix_matches(file: File): boolean;
        /**
         * Similar to g_file_query_info(), but obtains information
         * about the filesystem the `file` is on, rather than the file itself.
         * For instance the amount of space available and the type of
         * the filesystem.
         *
         * The `attributes` value is a string that specifies the attributes
         * that should be gathered. It is not an error if it's not possible
         * to read a particular requested attribute from a file - it just
         * won't be set. `attributes` should be a comma-separated list of
         * attributes or attribute wildcards. The wildcard "*" means all
         * attributes, and a wildcard like "filesystem::*" means all attributes
         * in the filesystem namespace. The standard namespace for filesystem
         * attributes is "filesystem". Common attributes of interest are
         * %G_FILE_ATTRIBUTE_FILESYSTEM_SIZE (the total size of the filesystem
         * in bytes), %G_FILE_ATTRIBUTE_FILESYSTEM_FREE (number of bytes available),
         * and %G_FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the filesystem).
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled
         * by triggering the cancellable object from another thread. If the
         * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
         * returned.
         *
         * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
         * be returned. Other errors are possible too, and depend on what
         * kind of filesystem the file is on.
         * @virtual
         * @param attributes an attribute query string
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFileInfo or %NULL if there was an error.   Free the returned object with g_object_unref().
         */
        vfunc_query_filesystem_info(
            attributes: string | null,
            cancellable: Cancellable | null
        ): FileInfo;
        /**
         * Asynchronously gets the requested information about the filesystem
         * that the specified `file` is on. The result is a #GFileInfo object
         * that contains key-value attributes (such as type or size for the
         * file).
         *
         * For more details, see g_file_query_filesystem_info() which is the
         * synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called. You can
         * then call g_file_query_info_finish() to get the result of the
         * operation.
         * @virtual
         * @param attributes an attribute query string
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_query_filesystem_info_async(
            attributes: string | null,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes an asynchronous filesystem info query.
         * See g_file_query_filesystem_info_async().
         * @virtual
         * @param res a #GAsyncResult
         * @returns #GFileInfo for given @file   or %NULL on error.   Free the returned object with g_object_unref().
         */
        vfunc_query_filesystem_info_finish(res: AsyncResult): FileInfo;
        /**
         * Gets the requested information about specified `file`.
         * The result is a #GFileInfo object that contains key-value
         * attributes (such as the type or size of the file).
         *
         * The `attributes` value is a string that specifies the file
         * attributes that should be gathered. It is not an error if
         * it's not possible to read a particular requested attribute
         * from a file - it just won't be set. `attributes` should be a
         * comma-separated list of attributes or attribute wildcards.
         * The wildcard "*" means all attributes, and a wildcard like
         * "standard::*" means all attributes in the standard namespace.
         * An example attribute query be "standard::*,owner::user".
         * The standard attributes are available as defines, like
         * %G_FILE_ATTRIBUTE_STANDARD_NAME.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled
         * by triggering the cancellable object from another thread. If the
         * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
         * returned.
         *
         * For symlinks, normally the information about the target of the
         * symlink is returned, rather than information about the symlink
         * itself. However if you pass %G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS
         * in `flags` the information about the symlink itself will be returned.
         * Also, for symlinks that point to non-existing files the information
         * about the symlink itself will be returned.
         *
         * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will be
         * returned. Other errors are possible too, and depend on what kind of
         * filesystem the file is on.
         * @virtual
         * @param attributes an attribute query string
         * @param flags a set of #GFileQueryInfoFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFileInfo for the given @file, or %NULL   on error. Free the returned object with g_object_unref().
         */
        vfunc_query_info(
            attributes: string | null,
            flags: FileQueryInfoFlags,
            cancellable: Cancellable | null
        ): FileInfo;
        /**
         * Asynchronously gets the requested information about specified `file`.
         * The result is a #GFileInfo object that contains key-value attributes
         * (such as type or size for the file).
         *
         * For more details, see g_file_query_info() which is the synchronous
         * version of this call.
         *
         * When the operation is finished, `callback` will be called. You can
         * then call g_file_query_info_finish() to get the result of the operation.
         * @virtual
         * @param attributes an attribute query string
         * @param flags a set of #GFileQueryInfoFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_query_info_async(
            attributes: string | null,
            flags: FileQueryInfoFlags,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes an asynchronous file info query.
         * See g_file_query_info_async().
         * @virtual
         * @param res a #GAsyncResult
         * @returns #GFileInfo for given @file   or %NULL on error. Free the returned object with   g_object_unref().
         */
        vfunc_query_info_finish(res: AsyncResult): FileInfo;
        /**
         * Obtain the list of settable attributes for the file.
         *
         * Returns the type and full attribute name of all the attributes
         * that can be set on this file. This doesn't mean setting it will
         * always succeed though, you might get an access failure, or some
         * specific file may not support a specific attribute.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @virtual
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFileAttributeInfoList describing the settable attributes.   When you are done with it, release it with   g_file_attribute_info_list_unref()
         */
        vfunc_query_settable_attributes(
            cancellable: Cancellable | null
        ): FileAttributeInfoList;
        /**
         * Obtain the list of attribute namespaces where new attributes
         * can be created by a user. An example of this is extended
         * attributes (in the "xattr" namespace).
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @virtual
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFileAttributeInfoList describing the writable namespaces.   When you are done with it, release it with   g_file_attribute_info_list_unref()
         */
        vfunc_query_writable_namespaces(
            cancellable: Cancellable | null
        ): FileAttributeInfoList;
        /**
         * Asynchronously opens `file` for reading.
         *
         * For more details, see g_file_read() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_read_finish() to get the result
         * of the operation.
         * @virtual
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_read_async(
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes an asynchronous file read operation started with
         * g_file_read_async().
         * @virtual
         * @param res a #GAsyncResult
         * @returns a #GFileInputStream or %NULL on error.   Free the returned object with g_object_unref().
         */
        vfunc_read_finish(res: AsyncResult): FileInputStream;
        /**
         * Opens a file for reading. The result is a #GFileInputStream that
         * can be used to read the contents of the file.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will be
         * returned. If the file is a directory, the %G_IO_ERROR_IS_DIRECTORY
         * error will be returned. Other errors are possible too, and depend
         * on what kind of filesystem the file is on.
         * @virtual
         * @param cancellable a #GCancellable
         * @returns #GFileInputStream or %NULL on error.   Free the returned object with g_object_unref().
         */
        vfunc_read_fn(cancellable: Cancellable | null): FileInputStream;
        /**
         * Returns an output stream for overwriting the file, possibly
         * creating a backup copy of the file first. If the file doesn't exist,
         * it will be created.
         *
         * This will try to replace the file in the safest way possible so
         * that any errors during the writing will not affect an already
         * existing copy of the file. For instance, for local files it
         * may write to a temporary file and then atomically rename over
         * the destination when the stream is closed.
         *
         * By default files created are generally readable by everyone,
         * but if you pass %G_FILE_CREATE_PRIVATE in `flags` the file
         * will be made readable only to the current user, to the level that
         * is supported on the target filesystem.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled
         * by triggering the cancellable object from another thread. If the
         * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
         * returned.
         *
         * If you pass in a non-%NULL `etag` value and `file` already exists, then
         * this value is compared to the current entity tag of the file, and if
         * they differ an %G_IO_ERROR_WRONG_ETAG error is returned. This
         * generally means that the file has been changed since you last read
         * it. You can get the new etag from g_file_output_stream_get_etag()
         * after you've finished writing and closed the #GFileOutputStream. When
         * you load a new file you can use g_file_input_stream_query_info() to
         * get the etag of the file.
         *
         * If `make_backup` is %TRUE, this function will attempt to make a
         * backup of the current file before overwriting it. If this fails
         * a %G_IO_ERROR_CANT_CREATE_BACKUP error will be returned. If you
         * want to replace anyway, try again with `make_backup` set to %FALSE.
         *
         * If the file is a directory the %G_IO_ERROR_IS_DIRECTORY error will
         * be returned, and if the file is some other form of non-regular file
         * then a %G_IO_ERROR_NOT_REGULAR_FILE error will be returned. Some
         * file systems don't allow all file names, and may return an
         * %G_IO_ERROR_INVALID_FILENAME error, and if the name is to long
         * %G_IO_ERROR_FILENAME_TOO_LONG will be returned. Other errors are
         * possible too, and depend on what kind of filesystem the file is on.
         * @virtual
         * @param etag an optional [entity tag][gfile-etag]   for the current #GFile, or #NULL to ignore
         * @param make_backup %TRUE if a backup should be created
         * @param flags a set of #GFileCreateFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFileOutputStream or %NULL on error.   Free the returned object with g_object_unref().
         */
        vfunc_replace(
            etag: string | null,
            make_backup: boolean,
            flags: FileCreateFlags,
            cancellable: Cancellable | null
        ): FileOutputStream;
        /**
         * Asynchronously overwrites the file, replacing the contents,
         * possibly creating a backup copy of the file first.
         *
         * For more details, see g_file_replace() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_replace_finish() to get the result
         * of the operation.
         * @virtual
         * @param etag an [entity tag][gfile-etag] for the current #GFile,   or %NULL to ignore
         * @param make_backup %TRUE if a backup should be created
         * @param flags a set of #GFileCreateFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_replace_async(
            etag: string | null,
            make_backup: boolean,
            flags: FileCreateFlags,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes an asynchronous file replace operation started with
         * g_file_replace_async().
         * @virtual
         * @param res a #GAsyncResult
         * @returns a #GFileOutputStream, or %NULL on error.   Free the returned object with g_object_unref().
         */
        vfunc_replace_finish(res: AsyncResult): FileOutputStream;
        /**
         * Returns an output stream for overwriting the file in readwrite mode,
         * possibly creating a backup copy of the file first. If the file doesn't
         * exist, it will be created.
         *
         * For details about the behaviour, see g_file_replace() which does the
         * same thing but returns an output stream only.
         *
         * Note that in many non-local file cases read and write streams are not
         * supported, so make sure you really need to do read and write streaming,
         * rather than just opening for reading or writing.
         * @virtual
         * @param etag an optional [entity tag][gfile-etag]   for the current #GFile, or #NULL to ignore
         * @param make_backup %TRUE if a backup should be created
         * @param flags a set of #GFileCreateFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFileIOStream or %NULL on error.   Free the returned object with g_object_unref().
         */
        vfunc_replace_readwrite(
            etag: string | null,
            make_backup: boolean,
            flags: FileCreateFlags,
            cancellable: Cancellable | null
        ): FileIOStream;
        /**
         * Asynchronously overwrites the file in read-write mode,
         * replacing the contents, possibly creating a backup copy
         * of the file first.
         *
         * For more details, see g_file_replace_readwrite() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_replace_readwrite_finish() to get
         * the result of the operation.
         * @virtual
         * @param etag an [entity tag][gfile-etag] for the current #GFile,   or %NULL to ignore
         * @param make_backup %TRUE if a backup should be created
         * @param flags a set of #GFileCreateFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_replace_readwrite_async(
            etag: string | null,
            make_backup: boolean,
            flags: FileCreateFlags,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes an asynchronous file replace operation started with
         * g_file_replace_readwrite_async().
         * @virtual
         * @param res a #GAsyncResult
         * @returns a #GFileIOStream, or %NULL on error.   Free the returned object with g_object_unref().
         */
        vfunc_replace_readwrite_finish(res: AsyncResult): FileIOStream;
        /**
         * Resolves a relative path for `file` to an absolute path.
         *
         * This call does no blocking I/O.
         *
         * If the `relative_path` is an absolute path name, the resolution
         * is done absolutely (without taking `file` path as base).
         * @virtual
         * @param relative_path a given relative path string
         * @returns a #GFile for the resolved path.
         */
        vfunc_resolve_relative_path(relative_path: string): File;
        /**
         * Sets an attribute in the file with attribute name `attribute` to `value_p`.
         *
         * Some attributes can be unset by setting `type` to
         * %G_FILE_ATTRIBUTE_TYPE_INVALID and `value_p` to %NULL.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @virtual
         * @param attribute a string containing the attribute's name
         * @param type The type of the attribute
         * @param value_p a pointer to the value (or the pointer   itself if the type is a pointer type)
         * @param flags a set of #GFileQueryInfoFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns %TRUE if the attribute was set, %FALSE otherwise.
         */
        vfunc_set_attribute(
            attribute: string | null,
            type: FileAttributeType,
            value_p: any | null,
            flags: FileQueryInfoFlags,
            cancellable: Cancellable | null
        ): boolean;
        /**
         * Asynchronously sets the attributes of `file` with `info`.
         *
         * For more details, see g_file_set_attributes_from_info(),
         * which is the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_set_attributes_finish() to get
         * the result of the operation.
         * @virtual
         * @param info a #GFileInfo
         * @param flags a #GFileQueryInfoFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_set_attributes_async(
            info: FileInfo,
            flags: FileQueryInfoFlags,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes setting an attribute started in g_file_set_attributes_async().
         * @virtual
         * @param result a #GAsyncResult
         * @returns %TRUE if the attributes were set correctly, %FALSE otherwise.
         */
        vfunc_set_attributes_finish(
            result: AsyncResult
        ): [/* returnType */ boolean, /* info */ FileInfo];
        /**
         * Tries to set all attributes in the #GFileInfo on the target
         * values, not stopping on the first error.
         *
         * If there is any error during this operation then `error` will
         * be set to the first error. Error on particular fields are flagged
         * by setting the "status" field in the attribute value to
         * %G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING, which means you can
         * also detect further errors.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @virtual
         * @param info a #GFileInfo
         * @param flags #GFileQueryInfoFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns %FALSE if there was any error, %TRUE otherwise.
         */
        vfunc_set_attributes_from_info(
            info: FileInfo,
            flags: FileQueryInfoFlags,
            cancellable: Cancellable | null
        ): boolean;
        /**
         * Renames `file` to the specified display name.
         *
         * The display name is converted from UTF-8 to the correct encoding
         * for the target filesystem if possible and the `file` is renamed to this.
         *
         * If you want to implement a rename operation in the user interface the
         * edit name (%G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME) should be used as the
         * initial value in the rename widget, and then the result after editing
         * should be passed to g_file_set_display_name().
         *
         * On success the resulting converted filename is returned.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @virtual
         * @param display_name a string
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFile specifying what @file was renamed to,   or %NULL if there was an error.   Free the returned object with g_object_unref().
         */
        vfunc_set_display_name(
            display_name: string | null,
            cancellable: Cancellable | null
        ): File;
        /**
         * Asynchronously sets the display name for a given #GFile.
         *
         * For more details, see g_file_set_display_name() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_set_display_name_finish() to get
         * the result of the operation.
         * @virtual
         * @param display_name a string
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_set_display_name_async(
            display_name: string | null,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes setting a display name started with
         * g_file_set_display_name_async().
         * @virtual
         * @param res a #GAsyncResult
         * @returns a #GFile or %NULL on error.   Free the returned object with g_object_unref().
         */
        vfunc_set_display_name_finish(res: AsyncResult): File;
        /**
         * Starts a file of type %G_FILE_TYPE_MOUNTABLE.
         * Using `start_operation,` you can request callbacks when, for instance,
         * passwords are needed during authentication.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_mount_mountable_finish() to get
         * the result of the operation.
         * @virtual
         * @param flags flags affecting the operation
         * @param start_operation a #GMountOperation, or %NULL to avoid user interaction
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied, or %NULL
         */
        vfunc_start_mountable(
            flags: DriveStartFlags,
            start_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes a start operation. See g_file_start_mountable() for details.
         *
         * Finish an asynchronous start operation that was started
         * with g_file_start_mountable().
         * @virtual
         * @param result a #GAsyncResult
         * @returns %TRUE if the operation finished successfully. %FALSE otherwise.
         */
        vfunc_start_mountable_finish(result: AsyncResult): boolean;
        /**
         * Stops a file of type %G_FILE_TYPE_MOUNTABLE.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_stop_mountable_finish() to get
         * the result of the operation.
         * @virtual
         * @param flags flags affecting the operation
         * @param mount_operation a #GMountOperation,   or %NULL to avoid user interaction.
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call   when the request is satisfied, or %NULL
         */
        vfunc_stop_mountable(
            flags: MountUnmountFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes a stop operation, see g_file_stop_mountable() for details.
         *
         * Finish an asynchronous stop operation that was started
         * with g_file_stop_mountable().
         * @virtual
         * @param result a #GAsyncResult
         * @returns %TRUE if the operation finished successfully.   %FALSE otherwise.
         */
        vfunc_stop_mountable_finish(result: AsyncResult): boolean;
        /**
         * Sends `file` to the "Trashcan", if possible. This is similar to
         * deleting it, but the user can recover it before emptying the trashcan.
         * Not all file systems support trashing, so this call can return the
         * %G_IO_ERROR_NOT_SUPPORTED error. Since GLib 2.66, the `x-gvfs-notrash` unix
         * mount option can be used to disable g_file_trash() support for certain
         * mounts, the %G_IO_ERROR_NOT_SUPPORTED error will be returned in that case.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @virtual
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns %TRUE on successful trash, %FALSE otherwise.
         */
        vfunc_trash(cancellable: Cancellable | null): boolean;
        /**
         * Asynchronously sends `file` to the Trash location, if possible.
         * @virtual
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
         */
        vfunc_trash_async(
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes an asynchronous file trashing operation, started with
         * g_file_trash_async().
         * @virtual
         * @param result a #GAsyncResult
         * @returns %TRUE on successful trash, %FALSE otherwise.
         */
        vfunc_trash_finish(result: AsyncResult): boolean;
        /**
         * Unmounts a file of type G_FILE_TYPE_MOUNTABLE.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_unmount_mountable_finish() to get
         * the result of the operation.
         * @virtual
         * @param flags flags affecting the operation
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_unmount_mountable(
            flags: MountUnmountFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes an unmount operation, see g_file_unmount_mountable() for details.
         *
         * Finish an asynchronous unmount operation that was started
         * with g_file_unmount_mountable().
         * @virtual
         * @param result a #GAsyncResult
         * @returns %TRUE if the operation finished successfully.   %FALSE otherwise.
         */
        vfunc_unmount_mountable_finish(result: AsyncResult): boolean;
        /**
         * Unmounts a file of type %G_FILE_TYPE_MOUNTABLE.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_unmount_mountable_finish() to get
         * the result of the operation.
         * @virtual
         * @param flags flags affecting the operation
         * @param mount_operation a #GMountOperation,   or %NULL to avoid user interaction
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_unmount_mountable_with_operation(
            flags: MountUnmountFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes an unmount operation,
         * see g_file_unmount_mountable_with_operation() for details.
         *
         * Finish an asynchronous unmount operation that was started
         * with g_file_unmount_mountable_with_operation().
         * @virtual
         * @param result a #GAsyncResult
         * @returns %TRUE if the operation finished successfully.   %FALSE otherwise.
         */
        vfunc_unmount_mountable_with_operation_finish(
            result: AsyncResult
        ): boolean;

        // Class property signals of Gio-2.0.Gio.File

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GFile is a high level abstraction for manipulating files on a
     * virtual file system. #GFiles are lightweight, immutable objects
     * that do no I/O upon creation. It is necessary to understand that
     * #GFile objects do not represent files, merely an identifier for a
     * file. All file content I/O is implemented as streaming operations
     * (see #GInputStream and #GOutputStream).
     *
     * To construct a #GFile, you can use:
     * - g_file_new_for_path() if you have a path.
     * - g_file_new_for_uri() if you have a URI.
     * - g_file_new_for_commandline_arg() for a command line argument.
     * - g_file_new_tmp() to create a temporary file from a template.
     * - g_file_new_tmp_async() to asynchronously create a temporary file.
     * - g_file_new_tmp_dir_async() to asynchronously create a temporary directory.
     * - g_file_parse_name() from a UTF-8 string gotten from g_file_get_parse_name().
     * - g_file_new_build_filename() or g_file_new_build_filenamev() to create a file from path elements.
     *
     * One way to think of a #GFile is as an abstraction of a pathname. For
     * normal files the system pathname is what is stored internally, but as
     * #GFiles are extensible it could also be something else that corresponds
     * to a pathname in a userspace implementation of a filesystem.
     *
     * #GFiles make up hierarchies of directories and files that correspond to
     * the files on a filesystem. You can move through the file system with
     * #GFile using g_file_get_parent() to get an identifier for the parent
     * directory, g_file_get_child() to get a child within a directory,
     * g_file_resolve_relative_path() to resolve a relative path between two
     * #GFiles. There can be multiple hierarchies, so you may not end up at
     * the same root if you repeatedly call g_file_get_parent() on two different
     * files.
     *
     * All #GFiles have a basename (get with g_file_get_basename()). These names
     * are byte strings that are used to identify the file on the filesystem
     * (relative to its parent directory) and there is no guarantees that they
     * have any particular charset encoding or even make any sense at all. If
     * you want to use filenames in a user interface you should use the display
     * name that you can get by requesting the
     * %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME attribute with g_file_query_info().
     * This is guaranteed to be in UTF-8 and can be used in a user interface.
     * But always store the real basename or the #GFile to use to actually
     * access the file, because there is no way to go from a display name to
     * the actual name.
     *
     * Using #GFile as an identifier has the same weaknesses as using a path
     * in that there may be multiple aliases for the same file. For instance,
     * hard or soft links may cause two different #GFiles to refer to the same
     * file. Other possible causes for aliases are: case insensitive filesystems,
     * short and long names on FAT/NTFS, or bind mounts in Linux. If you want to
     * check if two #GFiles point to the same file you can query for the
     * %G_FILE_ATTRIBUTE_ID_FILE attribute. Note that #GFile does some trivial
     * canonicalization of pathnames passed in, so that trivial differences in
     * the path string used at creation (duplicated slashes, slash at end of
     * path, "." or ".." path segments, etc) does not create different #GFiles.
     *
     * Many #GFile operations have both synchronous and asynchronous versions
     * to suit your application. Asynchronous versions of synchronous functions
     * simply have _async() appended to their function names. The asynchronous
     * I/O functions call a #GAsyncReadyCallback which is then used to finalize
     * the operation, producing a GAsyncResult which is then passed to the
     * function's matching _finish() operation.
     *
     * It is highly recommended to use asynchronous calls when running within a
     * shared main loop, such as in the main thread of an application. This avoids
     * I/O operations blocking other sources on the main loop from being dispatched.
     * Synchronous I/O operations should be performed from worker threads. See the
     * [introduction to asynchronous programming section][async-programming] for
     * more.
     *
     * Some #GFile operations almost always take a noticeable amount of time, and
     * so do not have synchronous analogs. Notable cases include:
     * - g_file_mount_mountable() to mount a mountable file.
     * - g_file_unmount_mountable_with_operation() to unmount a mountable file.
     * - g_file_eject_mountable_with_operation() to eject a mountable file.
     *
     * ## Entity Tags # {#gfile-etag}
     *
     * One notable feature of #GFiles are entity tags, or "etags" for
     * short. Entity tags are somewhat like a more abstract version of the
     * traditional mtime, and can be used to quickly determine if the file
     * has been modified from the version on the file system. See the
     * HTTP 1.1
     * [specification](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)
     * for HTTP Etag headers, which are a very similar concept.
     * @interface
     */
    class File extends GObject.Object {
        // Own properties of Gio-2.0.Gio.File

        static name: string;
        static $gtype: GObject.GType<File>;

        // Constructors of Gio-2.0.Gio.File

        constructor(config?: File.ConstructorProperties);
        _init(config?: File.ConstructorProperties): void;
        /**
         * Constructs a #GFile from a vector of elements using the correct
         * separator for filenames.
         *
         * Using this function is equivalent to calling g_build_filenamev(),
         * followed by g_file_new_for_path() on the result.
         * @param args %NULL-terminated   array of strings containing the path elements.
         * @returns a new #GFile
         */
        static new_build_filenamev(args: string[]): File;
        /**
         * Creates a #GFile with the given argument from the command line.
         * The value of `arg` can be either a URI, an absolute path or a
         * relative path resolved relative to the current working directory.
         * This operation never fails, but the returned object might not
         * support any I/O operation if `arg` points to a malformed path.
         *
         * Note that on Windows, this function expects its argument to be in
         * UTF-8 -- not the system code page.  This means that you
         * should not use this function with string from argv as it is passed
         * to main().  g_win32_get_command_line() will return a UTF-8 version of
         * the commandline.  #GApplication also uses UTF-8 but
         * g_application_command_line_create_file_for_arg() may be more useful
         * for you there.  It is also always possible to use this function with
         * #GOptionContext arguments of type %G_OPTION_ARG_FILENAME.
         * @param arg a command line string
         * @returns a new #GFile.   Free the returned object with g_object_unref().
         */
        static new_for_commandline_arg(arg: string): File;
        /**
         * Creates a #GFile with the given argument from the command line.
         *
         * This function is similar to g_file_new_for_commandline_arg() except
         * that it allows for passing the current working directory as an
         * argument instead of using the current working directory of the
         * process.
         *
         * This is useful if the commandline argument was given in a context
         * other than the invocation of the current process.
         *
         * See also g_application_command_line_create_file_for_arg().
         * @param arg a command line string
         * @param cwd the current working directory of the commandline
         * @returns a new #GFile
         */
        static new_for_commandline_arg_and_cwd(arg: string, cwd: string): File;
        /**
         * Constructs a #GFile for a given path. This operation never
         * fails, but the returned object might not support any I/O
         * operation if `path` is malformed.
         * @param path a string containing a relative or absolute path.   The string must be encoded in the glib filename encoding.
         * @returns a new #GFile for the given @path.   Free the returned object with g_object_unref().
         */
        static new_for_path(path: string): File;
        /**
         * Constructs a #GFile for a given URI. This operation never
         * fails, but the returned object might not support any I/O
         * operation if `uri` is malformed or if the uri type is
         * not supported.
         * @param uri a UTF-8 string containing a URI
         * @returns a new #GFile for the given @uri.   Free the returned object with g_object_unref().
         */
        static new_for_uri(uri: string | null): File;
        /**
         * Opens a file in the preferred directory for temporary files (as
         * returned by g_get_tmp_dir()) and returns a #GFile and
         * #GFileIOStream pointing to it.
         *
         * `tmpl` should be a string in the GLib file name encoding
         * containing a sequence of six 'X' characters, and containing no
         * directory components. If it is %NULL, a default template is used.
         *
         * Unlike the other #GFile constructors, this will return %NULL if
         * a temporary file could not be created.
         * @param tmpl Template for the file   name, as in g_file_open_tmp(), or %NULL for a default template
         * @returns a new #GFile.   Free the returned object with g_object_unref().
         */
        static new_tmp(
            tmpl: string | null
        ): [/* returnType */ File, /* iostream */ FileIOStream];
        /**
         * Asynchronously opens a file in the preferred directory for temporary files
         *  (as returned by g_get_tmp_dir()) as g_file_new_tmp().
         *
         * `tmpl` should be a string in the GLib file name encoding
         * containing a sequence of six 'X' characters, and containing no
         * directory components. If it is %NULL, a default template is used.
         * @param tmpl Template for the file   name, as in g_file_open_tmp(), or %NULL for a default template
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call when the request is done
         */
        static new_tmp_async(
            tmpl: string | null,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<File> | null
        ): void;
        /**
         * Asynchronously creates a directory in the preferred directory for
         * temporary files (as returned by g_get_tmp_dir()) as g_dir_make_tmp().
         *
         * `tmpl` should be a string in the GLib file name encoding
         * containing a sequence of six 'X' characters, and containing no
         * directory components. If it is %NULL, a default template is used.
         * @param tmpl Template for the file   name, as in g_dir_make_tmp(), or %NULL for a default template
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call when the request is done
         */
        static new_tmp_dir_async(
            tmpl: string | null,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<File> | null
        ): void;
        /**
         * Finishes a temporary directory creation started by
         * g_file_new_tmp_dir_async().
         * @param result a #GAsyncResult
         * @returns a new #GFile.   Free the returned object with g_object_unref().
         */
        static new_tmp_dir_finish(result: AsyncResult): File;
        /**
         * Finishes a temporary file creation started by g_file_new_tmp_async().
         * @param result a #GAsyncResult
         * @returns a new #GFile.   Free the returned object with g_object_unref().
         */
        static new_tmp_finish(
            result: AsyncResult
        ): [/* returnType */ File, /* iostream */ FileIOStream];
        /**
         * Constructs a #GFile with the given `parse_name` (i.e. something
         * given by g_file_get_parse_name()). This operation never fails,
         * but the returned object might not support any I/O operation if
         * the `parse_name` cannot be parsed.
         * @param parse_name a file name or path to be parsed
         * @returns a new #GFile.
         */
        static parse_name(parse_name: string | null): File;
    }

    namespace FileDescriptorBased {
        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface FileDescriptorBased {
        // Owm methods of Gio-2.0.Gio.FileDescriptorBased

        /**
         * Gets the underlying file descriptor.
         * @returns The file descriptor
         */
        get_fd(): number;

        // Own virtual methods of Gio-2.0.Gio.FileDescriptorBased

        /**
         * Gets the underlying file descriptor.
         * @virtual
         * @returns The file descriptor
         */
        vfunc_get_fd(): number;

        // Class property signals of Gio-2.0.Gio.FileDescriptorBased

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GFileDescriptorBased is implemented by streams (implementations of
     * #GInputStream or #GOutputStream) that are based on file descriptors.
     *
     * Note that `<gio/gfiledescriptorbased.h>` belongs to the UNIX-specific
     * GIO interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config
     * file when using it.
     * @interface
     */
    class FileDescriptorBased extends GObject.Object {
        // Own properties of Gio-2.0.Gio.FileDescriptorBased

        static name: string;
        static $gtype: GObject.GType<FileDescriptorBased>;

        // Constructors of Gio-2.0.Gio.FileDescriptorBased

        constructor(config?: FileDescriptorBased.ConstructorProperties);
        _init(config?: FileDescriptorBased.ConstructorProperties): void;
    }

    namespace Icon {
        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface Icon {
        // Owm methods of Gio-2.0.Gio.Icon

        /**
         * Checks if two icons are equal.
         * @param icon2 pointer to the second #GIcon.
         * @returns %TRUE if @icon1 is equal to @icon2. %FALSE otherwise.
         */
        equal(icon2: Icon | null): boolean;
        /**
         * Gets a hash for an icon.
         * @returns a #guint containing a hash for the @icon, suitable for use in a #GHashTable or similar data structure.
         */
        hash(): number;
        /**
         * Serializes a #GIcon into a #GVariant. An equivalent #GIcon can be retrieved
         * back by calling g_icon_deserialize() on the returned value.
         * As serialization will avoid using raw icon data when possible, it only
         * makes sense to transfer the #GVariant between processes on the same machine,
         * (as opposed to over the network), and within the same file system namespace.
         * @returns a #GVariant, or %NULL when serialization fails. The #GVariant will not be floating.
         */
        serialize(): GLib.Variant | null;
        /**
         * Generates a textual representation of `icon` that can be used for
         * serialization such as when passing `icon` to a different process or
         * saving it to persistent storage. Use g_icon_new_for_string() to
         * get `icon` back from the returned string.
         *
         * The encoding of the returned string is proprietary to #GIcon except
         * in the following two cases
         *
         * - If `icon` is a #GFileIcon, the returned string is a native path
         *   (such as `/path/to/my icon.png`) without escaping
         *   if the #GFile for `icon` is a native file.  If the file is not
         *   native, the returned string is the result of g_file_get_uri()
         *   (such as `sftp://path/to/my%20icon.png`).
         *
         * - If `icon` is a #GThemedIcon with exactly one name and no fallbacks,
         *   the encoding is simply the name (such as `network-server`).
         * @returns An allocated NUL-terminated UTF8 string or %NULL if @icon can't be serialized. Use g_free() to free.
         */
        to_string(): string | null;

        // Own virtual methods of Gio-2.0.Gio.Icon

        /**
         * Checks if two icons are equal.
         * @virtual
         * @param icon2 pointer to the second #GIcon.
         * @returns %TRUE if @icon1 is equal to @icon2. %FALSE otherwise.
         */
        vfunc_equal(icon2: Icon | null): boolean;
        /**
         * Gets a hash for an icon.
         * @virtual
         * @returns a #guint containing a hash for the @icon, suitable for use in a #GHashTable or similar data structure.
         */
        vfunc_hash(): number;
        /**
         * Serializes a #GIcon into a #GVariant. An equivalent #GIcon can be retrieved
         * back by calling g_icon_deserialize() on the returned value.
         * As serialization will avoid using raw icon data when possible, it only
         * makes sense to transfer the #GVariant between processes on the same machine,
         * (as opposed to over the network), and within the same file system namespace.
         * @virtual
         * @returns a #GVariant, or %NULL when serialization fails. The #GVariant will not be floating.
         */
        vfunc_serialize(): GLib.Variant | null;
        /**
         * Serializes the `icon` into string tokens.
         * This is can be invoked when g_icon_new_for_string() is called.
         * @virtual
         * @returns %TRUE if serialization took place, %FALSE otherwise
         */
        vfunc_to_tokens(): [
            /* returnType */ boolean,
            /* tokens */ string[],
            /* out_version */ number
        ];

        // Class property signals of Gio-2.0.Gio.Icon

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GIcon is a very minimal interface for icons. It provides functions
     * for checking the equality of two icons, hashing of icons and
     * serializing an icon to and from strings.
     *
     * #GIcon does not provide the actual pixmap for the icon as this is out
     * of GIO's scope, however implementations of #GIcon may contain the name
     * of an icon (see #GThemedIcon), or the path to an icon (see #GLoadableIcon).
     *
     * To obtain a hash of a #GIcon, see g_icon_hash().
     *
     * To check if two #GIcons are equal, see g_icon_equal().
     *
     * For serializing a #GIcon, use g_icon_serialize() and
     * g_icon_deserialize().
     *
     * If you want to consume #GIcon (for example, in a toolkit) you must
     * be prepared to handle at least the three following cases:
     * #GLoadableIcon, #GThemedIcon and #GEmblemedIcon.  It may also make
     * sense to have fast-paths for other cases (like handling #GdkPixbuf
     * directly, for example) but all compliant #GIcon implementations
     * outside of GIO must implement #GLoadableIcon.
     *
     * If your application or library provides one or more #GIcon
     * implementations you need to ensure that your new implementation also
     * implements #GLoadableIcon.  Additionally, you must provide an
     * implementation of g_icon_serialize() that gives a result that is
     * understood by g_icon_deserialize(), yielding one of the built-in icon
     * types.
     * @interface
     */
    class Icon extends GObject.Object {
        // Own properties of Gio-2.0.Gio.Icon

        static name: string;
        static $gtype: GObject.GType<Icon>;

        // Constructors of Gio-2.0.Gio.Icon

        constructor(config?: Icon.ConstructorProperties);
        _init(config?: Icon.ConstructorProperties): void;
        /**
         * Generate a #GIcon instance from `str`. This function can fail if
         * `str` is not valid - see g_icon_to_string() for discussion.
         *
         * If your application or library provides one or more #GIcon
         * implementations you need to ensure that each #GType is registered
         * with the type system prior to calling g_icon_new_for_string().
         * @param str A string obtained via g_icon_to_string().
         * @returns An object implementing the #GIcon          interface or %NULL if @error is set.
         */
        static new_for_string(str: string | null): Icon;
        /**
         * Deserializes a #GIcon previously serialized using g_icon_serialize().
         * @param value a #GVariant created with g_icon_serialize()
         * @returns a #GIcon, or %NULL when deserialization fails.
         */
        static deserialize(value: GLib.Variant): Icon | null;
    }

    namespace Initable {
        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface Initable {
        // Owm methods of Gio-2.0.Gio.Initable

        /**
         * Initializes the object implementing the interface.
         *
         * This method is intended for language bindings. If writing in C,
         * g_initable_new() should typically be used instead.
         *
         * The object must be initialized before any real use after initial
         * construction, either with this function or g_async_initable_init_async().
         *
         * Implementations may also support cancellation. If `cancellable` is not %NULL,
         * then initialization can be cancelled by triggering the cancellable object
         * from another thread. If the operation was cancelled, the error
         * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
         * the object doesn't support cancellable initialization the error
         * %G_IO_ERROR_NOT_SUPPORTED will be returned.
         *
         * If the object is not initialized, or initialization returns with an
         * error, then all operations on the object except g_object_ref() and
         * g_object_unref() are considered to be invalid, and have undefined
         * behaviour. See the [introduction][ginitable] for more details.
         *
         * Callers should not assume that a class which implements #GInitable can be
         * initialized multiple times, unless the class explicitly documents itself as
         * supporting this. Generally, a class implementation of init() can assume
         * (and assert) that it will only be called once. Previously, this documentation
         * recommended all #GInitable implementations should be idempotent; that
         * recommendation was relaxed in GLib 2.54.
         *
         * If a class explicitly supports being initialized multiple times, it is
         * recommended that the method is idempotent: multiple calls with the same
         * arguments should return the same results. Only the first call initializes
         * the object; further calls return the result of the first call.
         *
         * One reason why a class might need to support idempotent initialization is if
         * it is designed to be used via the singleton pattern, with a
         * #GObjectClass.constructor that sometimes returns an existing instance.
         * In this pattern, a caller would expect to be able to call g_initable_init()
         * on the result of g_object_new(), regardless of whether it is in fact a new
         * instance.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if successful. If an error has occurred, this function will     return %FALSE and set @error appropriately if present.
         */
        init(cancellable: Cancellable | null): boolean;

        // Own virtual methods of Gio-2.0.Gio.Initable

        /**
         * Initializes the object implementing the interface.
         *
         * This method is intended for language bindings. If writing in C,
         * g_initable_new() should typically be used instead.
         *
         * The object must be initialized before any real use after initial
         * construction, either with this function or g_async_initable_init_async().
         *
         * Implementations may also support cancellation. If `cancellable` is not %NULL,
         * then initialization can be cancelled by triggering the cancellable object
         * from another thread. If the operation was cancelled, the error
         * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
         * the object doesn't support cancellable initialization the error
         * %G_IO_ERROR_NOT_SUPPORTED will be returned.
         *
         * If the object is not initialized, or initialization returns with an
         * error, then all operations on the object except g_object_ref() and
         * g_object_unref() are considered to be invalid, and have undefined
         * behaviour. See the [introduction][ginitable] for more details.
         *
         * Callers should not assume that a class which implements #GInitable can be
         * initialized multiple times, unless the class explicitly documents itself as
         * supporting this. Generally, a class implementation of init() can assume
         * (and assert) that it will only be called once. Previously, this documentation
         * recommended all #GInitable implementations should be idempotent; that
         * recommendation was relaxed in GLib 2.54.
         *
         * If a class explicitly supports being initialized multiple times, it is
         * recommended that the method is idempotent: multiple calls with the same
         * arguments should return the same results. Only the first call initializes
         * the object; further calls return the result of the first call.
         *
         * One reason why a class might need to support idempotent initialization is if
         * it is designed to be used via the singleton pattern, with a
         * #GObjectClass.constructor that sometimes returns an existing instance.
         * In this pattern, a caller would expect to be able to call g_initable_init()
         * on the result of g_object_new(), regardless of whether it is in fact a new
         * instance.
         * @virtual
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if successful. If an error has occurred, this function will     return %FALSE and set @error appropriately if present.
         */
        vfunc_init(cancellable: Cancellable | null): boolean;

        // Class property signals of Gio-2.0.Gio.Initable

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GInitable is implemented by objects that can fail during
     * initialization. If an object implements this interface then
     * it must be initialized as the first thing after construction,
     * either via g_initable_init() or g_async_initable_init_async()
     * (the latter is only available if it also implements #GAsyncInitable).
     *
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. They will often fail with g_critical() or g_warning(), but
     * this must not be relied on.
     *
     * Users of objects implementing this are not intended to use
     * the interface method directly, instead it will be used automatically
     * in various ways. For C applications you generally just call
     * g_initable_new() directly, or indirectly via a foo_thing_new() wrapper.
     * This will call g_initable_init() under the cover, returning %NULL and
     * setting a #GError on failure (at which point the instance is
     * unreferenced).
     *
     * For bindings in languages where the native constructor supports
     * exceptions the binding could check for objects implementing %GInitable
     * during normal construction and automatically initialize them, throwing
     * an exception on failure.
     * @interface
     */
    class Initable extends GObject.Object {
        // Own properties of Gio-2.0.Gio.Initable

        static name: string;
        static $gtype: GObject.GType<Initable>;

        // Constructors of Gio-2.0.Gio.Initable

        constructor(config?: Initable.ConstructorProperties);
        _init(config?: Initable.ConstructorProperties): void;
        // Has conflict: static newv(object_type: GObject.GType, parameters: GObject.Parameter[], cancellable: Cancellable | null): GObject.Object

        // Overloads of newv

        /**
         * Creates a new instance of a #GObject subtype and sets its properties.
         *
         * Construction parameters (see %G_PARAM_CONSTRUCT, %G_PARAM_CONSTRUCT_ONLY)
         * which are not explicitly specified are set to their default values.
         * @constructor
         * @param object_type the type id of the #GObject subtype to instantiate
         * @param parameters an array of #GParameter
         * @returns a new instance of @object_type
         */
        static newv(
            object_type: GObject.GType,
            parameters: GObject.Parameter[]
        ): GObject.Object;
    }

    namespace ListModel {
        // Signal callback interfaces

        /**
         * Signal callback interface for `items-changed`
         */
        interface ItemsChangedSignalCallback {
            (
                $obj: ListModel,
                position: number,
                removed: number,
                added: number
            ): void;
        }

        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface ListModel {
        // Owm methods of Gio-2.0.Gio.ListModel

        /**
         * Gets the type of the items in `list`.
         *
         * All items returned from g_list_model_get_item() are of the type
         * returned by this function, or a subtype, or if the type is an
         * interface, they are an implementation of that interface.
         *
         * The item type of a #GListModel can not change during the life of the
         * model.
         * @returns the #GType of the items contained in @list.
         */
        get_item_type(): GObject.GType;
        /**
         * Gets the number of items in `list`.
         *
         * Depending on the model implementation, calling this function may be
         * less efficient than iterating the list with increasing values for
         * `position` until g_list_model_get_item() returns %NULL.
         * @returns the number of items in @list.
         */
        get_n_items(): number;
        /**
         * Get the item at `position`.
         *
         * If `position` is greater than the number of items in `list,` %NULL is
         * returned.
         *
         * %NULL is never returned for an index that is smaller than the length
         * of the list.
         *
         * This function is meant to be used by language bindings in place
         * of g_list_model_get_item().
         *
         * See also: g_list_model_get_n_items()
         * @param position the position of the item to fetch
         * @returns the object at @position.
         */
        get_item(position: number): GObject.Object | null;
        /**
         * Emits the #GListModel::items-changed signal on `list`.
         *
         * This function should only be called by classes implementing
         * #GListModel. It has to be called after the internal representation
         * of `list` has been updated, because handlers connected to this signal
         * might query the new state of the list.
         *
         * Implementations must only make changes to the model (as visible to
         * its consumer) in places that will not cause problems for that
         * consumer.  For models that are driven directly by a write API (such
         * as #GListStore), changes can be reported in response to uses of that
         * API.  For models that represent remote data, changes should only be
         * made from a fresh mainloop dispatch.  It is particularly not
         * permitted to make changes in response to a call to the #GListModel
         * consumer API.
         *
         * Stated another way: in general, it is assumed that code making a
         * series of accesses to the model via the API, without returning to the
         * mainloop, and without calling other code, will continue to view the
         * same contents of the model.
         * @param position the position at which `list` changed
         * @param removed the number of items removed
         * @param added the number of items added
         */
        items_changed(position: number, removed: number, added: number): void;

        // Own virtual methods of Gio-2.0.Gio.ListModel

        /**
         * Get the item at `position`. If `position` is greater than the number of
         * items in `list,` %NULL is returned.
         *
         * %NULL is never returned for an index that is smaller than the length
         * of the list.  See g_list_model_get_n_items().
         *
         * The same #GObject instance may not appear more than once in a #GListModel.
         * @virtual
         * @param position the position of the item to fetch
         * @returns the object at @position.
         */
        vfunc_get_item(position: number): GObject.Object | null;
        /**
         * Gets the type of the items in `list`.
         *
         * All items returned from g_list_model_get_item() are of the type
         * returned by this function, or a subtype, or if the type is an
         * interface, they are an implementation of that interface.
         *
         * The item type of a #GListModel can not change during the life of the
         * model.
         * @virtual
         * @returns the #GType of the items contained in @list.
         */
        vfunc_get_item_type(): GObject.GType;
        /**
         * Gets the number of items in `list`.
         *
         * Depending on the model implementation, calling this function may be
         * less efficient than iterating the list with increasing values for
         * `position` until g_list_model_get_item() returns %NULL.
         * @virtual
         * @returns the number of items in @list.
         */
        vfunc_get_n_items(): number;

        // Own signals of Gio-2.0.Gio.ListModel

        connect(
            sigName: 'items-changed',
            callback: ListModel.ItemsChangedSignalCallback
        ): number;
        connect_after(
            sigName: 'items-changed',
            callback: ListModel.ItemsChangedSignalCallback
        ): number;
        emit(
            sigName: 'items-changed',
            position: number,
            removed: number,
            added: number,
            ...args: any[]
        ): void;

        // Class property signals of Gio-2.0.Gio.ListModel

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GListModel is an interface that represents a mutable list of
     * #GObjects. Its main intention is as a model for various widgets in
     * user interfaces, such as list views, but it can also be used as a
     * convenient method of returning lists of data, with support for
     * updates.
     *
     * Each object in the list may also report changes in itself via some
     * mechanism (normally the #GObject::notify signal).  Taken together
     * with the #GListModel::items-changed signal, this provides for a list
     * that can change its membership, and in which the members can change
     * their individual properties.
     *
     * A good example would be the list of visible wireless network access
     * points, where each access point can report dynamic properties such as
     * signal strength.
     *
     * It is important to note that the #GListModel itself does not report
     * changes to the individual items.  It only reports changes to the list
     * membership.  If you want to observe changes to the objects themselves
     * then you need to connect signals to the objects that you are
     * interested in.
     *
     * All items in a #GListModel are of (or derived from) the same type.
     * g_list_model_get_item_type() returns that type.  The type may be an
     * interface, in which case all objects in the list must implement it.
     *
     * The semantics are close to that of an array:
     * g_list_model_get_n_items() returns the number of items in the list and
     * g_list_model_get_item() returns an item at a (0-based) position. In
     * order to allow implementations to calculate the list length lazily,
     * you can also iterate over items: starting from 0, repeatedly call
     * g_list_model_get_item() until it returns %NULL.
     *
     * An implementation may create objects lazily, but must take care to
     * return the same object for a given position until all references to
     * it are gone.
     *
     * On the other side, a consumer is expected only to hold references on
     * objects that are currently "user visible", in order to facilitate the
     * maximum level of laziness in the implementation of the list and to
     * reduce the required number of signal connections at a given time.
     *
     * This interface is intended only to be used from a single thread.  The
     * thread in which it is appropriate to use it depends on the particular
     * implementation, but typically it will be from the thread that owns
     * the [thread-default main context][g-main-context-push-thread-default]
     * in effect at the time that the model was created.
     *
     * Over time, it has established itself as good practice for listmodel
     * implementations to provide properties `item-type` and `n-items` to
     * ease working with them. While it is not required, it is recommended
     * that implementations provide these two properties. They should return
     * the values of g_list_model_get_item_type() and g_list_model_get_n_items()
     * respectively and be defined as such:
     *
     * ```c
     * properties[PROP_ITEM_TYPE] =
     *   g_param_spec_gtype ("item-type", "", "", G_TYPE_OBJECT,
     *                       G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
     * properties[PROP_N_ITEMS] =
     *   g_param_spec_uint ("n-items", "", "", 0, G_MAXUINT, 0,
     *                      G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);
     * ```
     *
     * @interface
     */
    class ListModel extends GObject.Object {
        // Own properties of Gio-2.0.Gio.ListModel

        static name: string;
        static $gtype: GObject.GType<ListModel>;

        // Constructors of Gio-2.0.Gio.ListModel

        constructor(config?: ListModel.ConstructorProperties);
        _init(config?: ListModel.ConstructorProperties): void;
    }

    namespace LoadableIcon {
        // Constructor properties interface

        interface ConstructorProperties
            extends Icon.ConstructorProperties,
                GObject.Object.ConstructorProperties {}
    }

    interface LoadableIcon extends Icon {
        // Owm methods of Gio-2.0.Gio.LoadableIcon

        /**
         * Loads a loadable icon. For the asynchronous version of this function,
         * see g_loadable_icon_load_async().
         * @param size an integer.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a #GInputStream to read the icon from.
         */
        load(
            size: number,
            cancellable: Cancellable | null
        ): [/* returnType */ InputStream, /* type */ string | null];
        /**
         * Loads an icon asynchronously. To finish this function, see
         * g_loadable_icon_load_finish(). For the synchronous, blocking
         * version of this function, see g_loadable_icon_load().
         * @param size an integer.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        load_async(
            size: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of load_async

        /**
         * Promisified version of {@link load_async}
         *
         * Loads an icon asynchronously. To finish this function, see
         * g_loadable_icon_load_finish(). For the synchronous, blocking
         * version of this function, see g_loadable_icon_load().
         * @param size an integer.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns A Promise of: a #GInputStream to read the icon from.
         */
        load_async(
            size: number,
            cancellable: Cancellable | null
        ): globalThis.Promise</* type */ string | null>;
        /**
         * Finishes an asynchronous icon load started in g_loadable_icon_load_async().
         * @param res a #GAsyncResult.
         * @returns a #GInputStream to read the icon from.
         */
        load_finish(
            res: AsyncResult
        ): [/* returnType */ InputStream, /* type */ string | null];

        // Own virtual methods of Gio-2.0.Gio.LoadableIcon

        /**
         * Loads a loadable icon. For the asynchronous version of this function,
         * see g_loadable_icon_load_async().
         * @virtual
         * @param size an integer.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a #GInputStream to read the icon from.
         */
        vfunc_load(
            size: number,
            cancellable: Cancellable | null
        ): [/* returnType */ InputStream, /* type */ string | null];
        /**
         * Loads an icon asynchronously. To finish this function, see
         * g_loadable_icon_load_finish(). For the synchronous, blocking
         * version of this function, see g_loadable_icon_load().
         * @virtual
         * @param size an integer.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_load_async(
            size: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes an asynchronous icon load started in g_loadable_icon_load_async().
         * @virtual
         * @param res a #GAsyncResult.
         * @returns a #GInputStream to read the icon from.
         */
        vfunc_load_finish(
            res: AsyncResult
        ): [/* returnType */ InputStream, /* type */ string | null];

        // Class property signals of Gio-2.0.Gio.LoadableIcon

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * Extends the #GIcon interface and adds the ability to
     * load icons from streams.
     * @interface
     */
    class LoadableIcon extends GObject.Object {
        // Own properties of Gio-2.0.Gio.LoadableIcon

        static name: string;
        static $gtype: GObject.GType<LoadableIcon>;

        // Constructors of Gio-2.0.Gio.LoadableIcon

        constructor(config?: LoadableIcon.ConstructorProperties);
        _init(config?: LoadableIcon.ConstructorProperties): void;
    }

    namespace MemoryMonitor {
        // Signal callback interfaces

        /**
         * Signal callback interface for `low-memory-warning`
         */
        interface LowMemoryWarningSignalCallback {
            ($obj: MemoryMonitor, level: MemoryMonitorWarningLevel): void;
        }

        // Constructor properties interface

        interface ConstructorProperties
            extends Initable.ConstructorProperties,
                GObject.Object.ConstructorProperties {}
    }

    interface MemoryMonitor extends Initable {
        // Own virtual methods of Gio-2.0.Gio.MemoryMonitor

        vfunc_low_memory_warning(level: MemoryMonitorWarningLevel): void;

        // Own signals of Gio-2.0.Gio.MemoryMonitor

        connect(
            sigName: 'low-memory-warning',
            callback: MemoryMonitor.LowMemoryWarningSignalCallback
        ): number;
        connect_after(
            sigName: 'low-memory-warning',
            callback: MemoryMonitor.LowMemoryWarningSignalCallback
        ): number;
        emit(
            sigName: 'low-memory-warning',
            level: MemoryMonitorWarningLevel,
            ...args: any[]
        ): void;

        // Class property signals of Gio-2.0.Gio.MemoryMonitor

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GMemoryMonitor will monitor system memory and suggest to the application
     * when to free memory so as to leave more room for other applications.
     * It is implemented on Linux using the [Low Memory Monitor](https://gitlab.freedesktop.org/hadess/low-memory-monitor/)
     * ([API documentation](https://hadess.pages.freedesktop.org/low-memory-monitor/)).
     *
     * There is also an implementation for use inside Flatpak sandboxes.
     *
     * Possible actions to take when the signal is received are:
     *
     *  - Free caches
     *  - Save files that haven't been looked at in a while to disk, ready to be reopened when needed
     *  - Run a garbage collection cycle
     *  - Try and compress fragmented allocations
     *  - Exit on idle if the process has no reason to stay around
     *  - Call [`malloc_trim(3)`](man:malloc_trim) to return cached heap pages to
     *    the kernel (if supported by your libc)
     *
     * Note that some actions may not always improve system performance, and so
     * should be profiled for your application. `malloc_trim()`, for example, may
     * make future heap allocations slower (due to releasing cached heap pages back
     * to the kernel).
     *
     * See #GMemoryMonitorWarningLevel for details on the various warning levels.
     *
     *
     * ```c
     * static void
     * warning_cb (GMemoryMonitor *m, GMemoryMonitorWarningLevel level)
     * {
     *   g_debug ("Warning level: %d", level);
     *   if (warning_level > G_MEMORY_MONITOR_WARNING_LEVEL_LOW)
     *     drop_caches ();
     * }
     *
     * static GMemoryMonitor *
     * monitor_low_memory (void)
     * {
     *   GMemoryMonitor *m;
     *   m = g_memory_monitor_dup_default ();
     *   g_signal_connect (G_OBJECT (m), "low-memory-warning",
     *                     G_CALLBACK (warning_cb), NULL);
     *   return m;
     * }
     * ```
     *
     *
     * Don't forget to disconnect the #GMemoryMonitor::low-memory-warning
     * signal, and unref the #GMemoryMonitor itself when exiting.
     * @interface
     */
    class MemoryMonitor extends GObject.Object {
        // Own properties of Gio-2.0.Gio.MemoryMonitor

        static name: string;
        static $gtype: GObject.GType<MemoryMonitor>;

        // Constructors of Gio-2.0.Gio.MemoryMonitor

        constructor(config?: MemoryMonitor.ConstructorProperties);
        _init(config?: MemoryMonitor.ConstructorProperties): void;
        /**
         * Gets a reference to the default #GMemoryMonitor for the system.
         * @returns a new reference to the default #GMemoryMonitor
         */
        static dup_default(): MemoryMonitor;
    }

    namespace Mount {
        // Signal callback interfaces

        /**
         * Signal callback interface for `changed`
         */
        interface ChangedSignalCallback {
            ($obj: Mount): void;
        }

        /**
         * Signal callback interface for `pre-unmount`
         */
        interface PreUnmountSignalCallback {
            ($obj: Mount): void;
        }

        /**
         * Signal callback interface for `unmounted`
         */
        interface UnmountedSignalCallback {
            ($obj: Mount): void;
        }

        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface Mount {
        // Owm methods of Gio-2.0.Gio.Mount

        /**
         * Checks if `mount` can be ejected.
         * @returns %TRUE if the @mount can be ejected.
         */
        can_eject(): boolean;
        /**
         * Checks if `mount` can be unmounted.
         * @returns %TRUE if the @mount can be unmounted.
         */
        can_unmount(): boolean;
        /**
         * Ejects a mount. This is an asynchronous operation, and is
         * finished by calling g_mount_eject_finish() with the `mount`
         * and #GAsyncResult data returned in the `callback`.
         * @param flags flags affecting the unmount if required for eject
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        eject(
            flags: MountUnmountFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes ejecting a mount. If any errors occurred during the operation,
         * `error` will be set to contain the errors and %FALSE will be returned.
         * @param result a #GAsyncResult.
         * @returns %TRUE if the mount was successfully ejected. %FALSE otherwise.
         */
        eject_finish(result: AsyncResult): boolean;
        /**
         * Ejects a mount. This is an asynchronous operation, and is
         * finished by calling g_mount_eject_with_operation_finish() with the `mount`
         * and #GAsyncResult data returned in the `callback`.
         * @param flags flags affecting the unmount if required for eject
         * @param mount_operation a #GMountOperation or %NULL to avoid     user interaction.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        eject_with_operation(
            flags: MountUnmountFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes ejecting a mount. If any errors occurred during the operation,
         * `error` will be set to contain the errors and %FALSE will be returned.
         * @param result a #GAsyncResult.
         * @returns %TRUE if the mount was successfully ejected. %FALSE otherwise.
         */
        eject_with_operation_finish(result: AsyncResult): boolean;
        /**
         * Gets the default location of `mount`. The default location of the given
         * `mount` is a path that reflects the main entry point for the user (e.g.
         * the home directory, or the root of the volume).
         * @returns a #GFile.      The returned object should be unreffed with      g_object_unref() when no longer needed.
         */
        get_default_location(): File;
        /**
         * Gets the drive for the `mount`.
         *
         * This is a convenience method for getting the #GVolume and then
         * using that object to get the #GDrive.
         * @returns a #GDrive or %NULL if @mount is not      associated with a volume or a drive.      The returned object should be unreffed with      g_object_unref() when no longer needed.
         */
        get_drive(): Drive | null;
        /**
         * Gets the icon for `mount`.
         * @returns a #GIcon.      The returned object should be unreffed with      g_object_unref() when no longer needed.
         */
        get_icon(): Icon;
        /**
         * Gets the name of `mount`.
         * @returns the name for the given @mount.     The returned string should be freed with g_free()     when no longer needed.
         */
        get_name(): string | null;
        /**
         * Gets the root directory on `mount`.
         * @returns a #GFile.      The returned object should be unreffed with      g_object_unref() when no longer needed.
         */
        get_root(): File;
        /**
         * Gets the sort key for `mount,` if any.
         * @returns Sorting key for @mount or %NULL if no such key is available.
         */
        get_sort_key(): string | null;
        /**
         * Gets the symbolic icon for `mount`.
         * @returns a #GIcon.      The returned object should be unreffed with      g_object_unref() when no longer needed.
         */
        get_symbolic_icon(): Icon;
        /**
         * Gets the UUID for the `mount`. The reference is typically based on
         * the file system UUID for the mount in question and should be
         * considered an opaque string. Returns %NULL if there is no UUID
         * available.
         * @returns the UUID for @mount or %NULL if no UUID     can be computed.     The returned string should be freed with g_free()     when no longer needed.
         */
        get_uuid(): string | null;
        /**
         * Gets the volume for the `mount`.
         * @returns a #GVolume or %NULL if @mount is not      associated with a volume.      The returned object should be unreffed with      g_object_unref() when no longer needed.
         */
        get_volume(): Volume | null;
        /**
         * Tries to guess the type of content stored on `mount`. Returns one or
         * more textual identifiers of well-known content types (typically
         * prefixed with "x-content/"), e.g. x-content/image-dcf for camera
         * memory cards. See the
         * [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
         * specification for more on x-content types.
         *
         * This is an asynchronous operation (see
         * g_mount_guess_content_type_sync() for the synchronous version), and
         * is finished by calling g_mount_guess_content_type_finish() with the
         * `mount` and #GAsyncResult data returned in the `callback`.
         * @param force_rescan Whether to force a rescan of the content.     Otherwise a cached result will be used if available
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback
         */
        guess_content_type(
            force_rescan: boolean,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes guessing content types of `mount`. If any errors occurred
         * during the operation, `error` will be set to contain the errors and
         * %FALSE will be returned. In particular, you may get an
         * %G_IO_ERROR_NOT_SUPPORTED if the mount does not support content
         * guessing.
         * @param result a #GAsyncResult
         * @returns a %NULL-terminated array of content types or %NULL on error.     Caller should free this array with g_strfreev() when done with it.
         */
        guess_content_type_finish(result: AsyncResult): string[];
        /**
         * Tries to guess the type of content stored on `mount`. Returns one or
         * more textual identifiers of well-known content types (typically
         * prefixed with "x-content/"), e.g. x-content/image-dcf for camera
         * memory cards. See the
         * [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
         * specification for more on x-content types.
         *
         * This is a synchronous operation and as such may block doing IO;
         * see g_mount_guess_content_type() for the asynchronous version.
         * @param force_rescan Whether to force a rescan of the content.     Otherwise a cached result will be used if available
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @returns a %NULL-terminated array of content types or %NULL on error.     Caller should free this array with g_strfreev() when done with it.
         */
        guess_content_type_sync(
            force_rescan: boolean,
            cancellable: Cancellable | null
        ): string[];
        /**
         * Determines if `mount` is shadowed. Applications or libraries should
         * avoid displaying `mount` in the user interface if it is shadowed.
         *
         * A mount is said to be shadowed if there exists one or more user
         * visible objects (currently #GMount objects) with a root that is
         * inside the root of `mount`.
         *
         * One application of shadow mounts is when exposing a single file
         * system that is used to address several logical volumes. In this
         * situation, a #GVolumeMonitor implementation would create two
         * #GVolume objects (for example, one for the camera functionality of
         * the device and one for a SD card reader on the device) with
         * activation URIs `gphoto2://[usb:001,002]/store1/`
         * and `gphoto2://[usb:001,002]/store2/`. When the
         * underlying mount (with root
         * `gphoto2://[usb:001,002]/`) is mounted, said
         * #GVolumeMonitor implementation would create two #GMount objects
         * (each with their root matching the corresponding volume activation
         * root) that would shadow the original mount.
         *
         * The proxy monitor in GVfs 2.26 and later, automatically creates and
         * manage shadow mounts (and shadows the underlying mount) if the
         * activation root on a #GVolume is set.
         * @returns %TRUE if @mount is shadowed.
         */
        is_shadowed(): boolean;
        /**
         * Remounts a mount. This is an asynchronous operation, and is
         * finished by calling g_mount_remount_finish() with the `mount`
         * and #GAsyncResults data returned in the `callback`.
         *
         * Remounting is useful when some setting affecting the operation
         * of the volume has been changed, as these may need a remount to
         * take affect. While this is semantically equivalent with unmounting
         * and then remounting not all backends might need to actually be
         * unmounted.
         * @param flags flags affecting the operation
         * @param mount_operation a #GMountOperation or %NULL to avoid     user interaction.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        remount(
            flags: MountMountFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes remounting a mount. If any errors occurred during the operation,
         * `error` will be set to contain the errors and %FALSE will be returned.
         * @param result a #GAsyncResult.
         * @returns %TRUE if the mount was successfully remounted. %FALSE otherwise.
         */
        remount_finish(result: AsyncResult): boolean;
        /**
         * Increments the shadow count on `mount`. Usually used by
         * #GVolumeMonitor implementations when creating a shadow mount for
         * `mount,` see g_mount_is_shadowed() for more information. The caller
         * will need to emit the #GMount::changed signal on `mount` manually.
         */
        shadow(): void;
        /**
         * Unmounts a mount. This is an asynchronous operation, and is
         * finished by calling g_mount_unmount_finish() with the `mount`
         * and #GAsyncResult data returned in the `callback`.
         * @param flags flags affecting the operation
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        unmount(
            flags: MountUnmountFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes unmounting a mount. If any errors occurred during the operation,
         * `error` will be set to contain the errors and %FALSE will be returned.
         * @param result a #GAsyncResult.
         * @returns %TRUE if the mount was successfully unmounted. %FALSE otherwise.
         */
        unmount_finish(result: AsyncResult): boolean;
        /**
         * Unmounts a mount. This is an asynchronous operation, and is
         * finished by calling g_mount_unmount_with_operation_finish() with the `mount`
         * and #GAsyncResult data returned in the `callback`.
         * @param flags flags affecting the operation
         * @param mount_operation a #GMountOperation or %NULL to avoid     user interaction.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        unmount_with_operation(
            flags: MountUnmountFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes unmounting a mount. If any errors occurred during the operation,
         * `error` will be set to contain the errors and %FALSE will be returned.
         * @param result a #GAsyncResult.
         * @returns %TRUE if the mount was successfully unmounted. %FALSE otherwise.
         */
        unmount_with_operation_finish(result: AsyncResult): boolean;
        /**
         * Decrements the shadow count on `mount`. Usually used by
         * #GVolumeMonitor implementations when destroying a shadow mount for
         * `mount,` see g_mount_is_shadowed() for more information. The caller
         * will need to emit the #GMount::changed signal on `mount` manually.
         */
        unshadow(): void;

        // Own virtual methods of Gio-2.0.Gio.Mount

        /**
         * Checks if `mount` can be ejected.
         * @virtual
         * @returns %TRUE if the @mount can be ejected.
         */
        vfunc_can_eject(): boolean;
        /**
         * Checks if `mount` can be unmounted.
         * @virtual
         * @returns %TRUE if the @mount can be unmounted.
         */
        vfunc_can_unmount(): boolean;
        vfunc_changed(): void;
        /**
         * Ejects a mount. This is an asynchronous operation, and is
         * finished by calling g_mount_eject_finish() with the `mount`
         * and #GAsyncResult data returned in the `callback`.
         * @virtual
         * @param flags flags affecting the unmount if required for eject
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        vfunc_eject(
            flags: MountUnmountFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes ejecting a mount. If any errors occurred during the operation,
         * `error` will be set to contain the errors and %FALSE will be returned.
         * @virtual
         * @param result a #GAsyncResult.
         * @returns %TRUE if the mount was successfully ejected. %FALSE otherwise.
         */
        vfunc_eject_finish(result: AsyncResult): boolean;
        /**
         * Ejects a mount. This is an asynchronous operation, and is
         * finished by calling g_mount_eject_with_operation_finish() with the `mount`
         * and #GAsyncResult data returned in the `callback`.
         * @virtual
         * @param flags flags affecting the unmount if required for eject
         * @param mount_operation a #GMountOperation or %NULL to avoid     user interaction.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        vfunc_eject_with_operation(
            flags: MountUnmountFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes ejecting a mount. If any errors occurred during the operation,
         * `error` will be set to contain the errors and %FALSE will be returned.
         * @virtual
         * @param result a #GAsyncResult.
         * @returns %TRUE if the mount was successfully ejected. %FALSE otherwise.
         */
        vfunc_eject_with_operation_finish(result: AsyncResult): boolean;
        /**
         * Gets the default location of `mount`. The default location of the given
         * `mount` is a path that reflects the main entry point for the user (e.g.
         * the home directory, or the root of the volume).
         * @virtual
         * @returns a #GFile.      The returned object should be unreffed with      g_object_unref() when no longer needed.
         */
        vfunc_get_default_location(): File;
        /**
         * Gets the drive for the `mount`.
         *
         * This is a convenience method for getting the #GVolume and then
         * using that object to get the #GDrive.
         * @virtual
         * @returns a #GDrive or %NULL if @mount is not      associated with a volume or a drive.      The returned object should be unreffed with      g_object_unref() when no longer needed.
         */
        vfunc_get_drive(): Drive | null;
        /**
         * Gets the icon for `mount`.
         * @virtual
         * @returns a #GIcon.      The returned object should be unreffed with      g_object_unref() when no longer needed.
         */
        vfunc_get_icon(): Icon;
        /**
         * Gets the name of `mount`.
         * @virtual
         * @returns the name for the given @mount.     The returned string should be freed with g_free()     when no longer needed.
         */
        vfunc_get_name(): string | null;
        /**
         * Gets the root directory on `mount`.
         * @virtual
         * @returns a #GFile.      The returned object should be unreffed with      g_object_unref() when no longer needed.
         */
        vfunc_get_root(): File;
        /**
         * Gets the sort key for `mount,` if any.
         * @virtual
         * @returns Sorting key for @mount or %NULL if no such key is available.
         */
        vfunc_get_sort_key(): string | null;
        /**
         * Gets the symbolic icon for `mount`.
         * @virtual
         * @returns a #GIcon.      The returned object should be unreffed with      g_object_unref() when no longer needed.
         */
        vfunc_get_symbolic_icon(): Icon;
        /**
         * Gets the UUID for the `mount`. The reference is typically based on
         * the file system UUID for the mount in question and should be
         * considered an opaque string. Returns %NULL if there is no UUID
         * available.
         * @virtual
         * @returns the UUID for @mount or %NULL if no UUID     can be computed.     The returned string should be freed with g_free()     when no longer needed.
         */
        vfunc_get_uuid(): string | null;
        /**
         * Gets the volume for the `mount`.
         * @virtual
         * @returns a #GVolume or %NULL if @mount is not      associated with a volume.      The returned object should be unreffed with      g_object_unref() when no longer needed.
         */
        vfunc_get_volume(): Volume | null;
        /**
         * Tries to guess the type of content stored on `mount`. Returns one or
         * more textual identifiers of well-known content types (typically
         * prefixed with "x-content/"), e.g. x-content/image-dcf for camera
         * memory cards. See the
         * [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
         * specification for more on x-content types.
         *
         * This is an asynchronous operation (see
         * g_mount_guess_content_type_sync() for the synchronous version), and
         * is finished by calling g_mount_guess_content_type_finish() with the
         * `mount` and #GAsyncResult data returned in the `callback`.
         * @virtual
         * @param force_rescan Whether to force a rescan of the content.     Otherwise a cached result will be used if available
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback
         */
        vfunc_guess_content_type(
            force_rescan: boolean,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes guessing content types of `mount`. If any errors occurred
         * during the operation, `error` will be set to contain the errors and
         * %FALSE will be returned. In particular, you may get an
         * %G_IO_ERROR_NOT_SUPPORTED if the mount does not support content
         * guessing.
         * @virtual
         * @param result a #GAsyncResult
         * @returns a %NULL-terminated array of content types or %NULL on error.     Caller should free this array with g_strfreev() when done with it.
         */
        vfunc_guess_content_type_finish(result: AsyncResult): string[];
        /**
         * Tries to guess the type of content stored on `mount`. Returns one or
         * more textual identifiers of well-known content types (typically
         * prefixed with "x-content/"), e.g. x-content/image-dcf for camera
         * memory cards. See the
         * [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
         * specification for more on x-content types.
         *
         * This is a synchronous operation and as such may block doing IO;
         * see g_mount_guess_content_type() for the asynchronous version.
         * @virtual
         * @param force_rescan Whether to force a rescan of the content.     Otherwise a cached result will be used if available
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @returns a %NULL-terminated array of content types or %NULL on error.     Caller should free this array with g_strfreev() when done with it.
         */
        vfunc_guess_content_type_sync(
            force_rescan: boolean,
            cancellable: Cancellable | null
        ): string[];
        vfunc_pre_unmount(): void;
        /**
         * Remounts a mount. This is an asynchronous operation, and is
         * finished by calling g_mount_remount_finish() with the `mount`
         * and #GAsyncResults data returned in the `callback`.
         *
         * Remounting is useful when some setting affecting the operation
         * of the volume has been changed, as these may need a remount to
         * take affect. While this is semantically equivalent with unmounting
         * and then remounting not all backends might need to actually be
         * unmounted.
         * @virtual
         * @param flags flags affecting the operation
         * @param mount_operation a #GMountOperation or %NULL to avoid     user interaction.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        vfunc_remount(
            flags: MountMountFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes remounting a mount. If any errors occurred during the operation,
         * `error` will be set to contain the errors and %FALSE will be returned.
         * @virtual
         * @param result a #GAsyncResult.
         * @returns %TRUE if the mount was successfully remounted. %FALSE otherwise.
         */
        vfunc_remount_finish(result: AsyncResult): boolean;
        /**
         * Unmounts a mount. This is an asynchronous operation, and is
         * finished by calling g_mount_unmount_finish() with the `mount`
         * and #GAsyncResult data returned in the `callback`.
         * @virtual
         * @param flags flags affecting the operation
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        vfunc_unmount(
            flags: MountUnmountFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes unmounting a mount. If any errors occurred during the operation,
         * `error` will be set to contain the errors and %FALSE will be returned.
         * @virtual
         * @param result a #GAsyncResult.
         * @returns %TRUE if the mount was successfully unmounted. %FALSE otherwise.
         */
        vfunc_unmount_finish(result: AsyncResult): boolean;
        /**
         * Unmounts a mount. This is an asynchronous operation, and is
         * finished by calling g_mount_unmount_with_operation_finish() with the `mount`
         * and #GAsyncResult data returned in the `callback`.
         * @virtual
         * @param flags flags affecting the operation
         * @param mount_operation a #GMountOperation or %NULL to avoid     user interaction.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        vfunc_unmount_with_operation(
            flags: MountUnmountFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes unmounting a mount. If any errors occurred during the operation,
         * `error` will be set to contain the errors and %FALSE will be returned.
         * @virtual
         * @param result a #GAsyncResult.
         * @returns %TRUE if the mount was successfully unmounted. %FALSE otherwise.
         */
        vfunc_unmount_with_operation_finish(result: AsyncResult): boolean;
        vfunc_unmounted(): void;

        // Own signals of Gio-2.0.Gio.Mount

        connect(
            sigName: 'changed',
            callback: Mount.ChangedSignalCallback
        ): number;
        connect_after(
            sigName: 'changed',
            callback: Mount.ChangedSignalCallback
        ): number;
        emit(sigName: 'changed', ...args: any[]): void;
        connect(
            sigName: 'pre-unmount',
            callback: Mount.PreUnmountSignalCallback
        ): number;
        connect_after(
            sigName: 'pre-unmount',
            callback: Mount.PreUnmountSignalCallback
        ): number;
        emit(sigName: 'pre-unmount', ...args: any[]): void;
        connect(
            sigName: 'unmounted',
            callback: Mount.UnmountedSignalCallback
        ): number;
        connect_after(
            sigName: 'unmounted',
            callback: Mount.UnmountedSignalCallback
        ): number;
        emit(sigName: 'unmounted', ...args: any[]): void;

        // Class property signals of Gio-2.0.Gio.Mount

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * The #GMount interface represents user-visible mounts. Note, when
     * porting from GnomeVFS, #GMount is the moral equivalent of #GnomeVFSVolume.
     *
     * #GMount is a "mounted" filesystem that you can access. Mounted is in
     * quotes because it's not the same as a unix mount, it might be a gvfs
     * mount, but you can still access the files on it if you use GIO. Might or
     * might not be related to a volume object.
     *
     * Unmounting a #GMount instance is an asynchronous operation. For
     * more information about asynchronous operations, see #GAsyncResult
     * and #GTask. To unmount a #GMount instance, first call
     * g_mount_unmount_with_operation() with (at least) the #GMount instance and a
     * #GAsyncReadyCallback.  The callback will be fired when the
     * operation has resolved (either with success or failure), and a
     * #GAsyncResult structure will be passed to the callback.  That
     * callback should then call g_mount_unmount_with_operation_finish() with the #GMount
     * and the #GAsyncResult data to see if the operation was completed
     * successfully.  If an `error` is present when g_mount_unmount_with_operation_finish()
     * is called, then it will be filled with any error information.
     * @interface
     */
    class Mount extends GObject.Object {
        // Own properties of Gio-2.0.Gio.Mount

        static name: string;
        static $gtype: GObject.GType<Mount>;

        // Constructors of Gio-2.0.Gio.Mount

        constructor(config?: Mount.ConstructorProperties);
        _init(config?: Mount.ConstructorProperties): void;
    }

    namespace NetworkMonitor {
        // Signal callback interfaces

        /**
         * Signal callback interface for `network-changed`
         */
        interface NetworkChangedSignalCallback {
            ($obj: NetworkMonitor, network_available: boolean): void;
        }

        // Constructor properties interface

        interface ConstructorProperties
            extends Initable.ConstructorProperties,
                GObject.Object.ConstructorProperties {}
    }

    interface NetworkMonitor extends Initable {
        // Own properties of Gio-2.0.Gio.NetworkMonitor

        /**
         * More detailed information about the host's network connectivity.
         * See g_network_monitor_get_connectivity() and
         * #GNetworkConnectivity for more details.
         */
        readonly connectivity: NetworkConnectivity;
        /**
         * Whether the network is considered available. That is, whether the
         * system has a default route for at least one of IPv4 or IPv6.
         *
         * Real-world networks are of course much more complicated than
         * this; the machine may be connected to a wifi hotspot that
         * requires payment before allowing traffic through, or may be
         * connected to a functioning router that has lost its own upstream
         * connectivity. Some hosts might only be accessible when a VPN is
         * active. Other hosts might only be accessible when the VPN is
         * not active. Thus, it is best to use g_network_monitor_can_reach()
         * or g_network_monitor_can_reach_async() to test for reachability
         * on a host-by-host basis. (On the other hand, when the property is
         * %FALSE, the application can reasonably expect that no remote
         * hosts at all are reachable, and should indicate this to the user
         * in its UI.)
         *
         * See also #GNetworkMonitor::network-changed.
         */
        readonly network_available: boolean;
        /**
         * Whether the network is considered metered.
         *
         * That is, whether the
         * system has traffic flowing through the default connection that is
         * subject to limitations set by service providers. For example, traffic
         * might be billed by the amount of data transmitted, or there might be a
         * quota on the amount of traffic per month. This is typical with tethered
         * connections (3G and 4G) and in such situations, bandwidth intensive
         * applications may wish to avoid network activity where possible if it will
         * cost the user money or use up their limited quota. Anything more than a
         * few hundreds of kilobytes of data usage per hour should be avoided without
         * asking permission from the user.
         *
         * If more information is required about specific devices then the
         * system network management API should be used instead (for example,
         * NetworkManager or ConnMan).
         *
         * If this information is not available then no networks will be
         * marked as metered.
         *
         * See also #GNetworkMonitor:network-available.
         */
        readonly network_metered: boolean;

        // Owm methods of Gio-2.0.Gio.NetworkMonitor

        /**
         * Attempts to determine whether or not the host pointed to by
         * `connectable` can be reached, without actually trying to connect to
         * it.
         *
         * This may return %TRUE even when #GNetworkMonitor:network-available
         * is %FALSE, if, for example, `monitor` can determine that
         * `connectable` refers to a host on a local network.
         *
         * If `monitor` believes that an attempt to connect to `connectable`
         * will succeed, it will return %TRUE. Otherwise, it will return
         * %FALSE and set `error` to an appropriate error (such as
         * %G_IO_ERROR_HOST_UNREACHABLE).
         *
         * Note that although this does not attempt to connect to
         * `connectable,` it may still block for a brief period of time (eg,
         * trying to do multicast DNS on the local network), so if you do not
         * want to block, you should use g_network_monitor_can_reach_async().
         * @param connectable a #GSocketConnectable
         * @param cancellable a #GCancellable, or %NULL
         * @returns %TRUE if @connectable is reachable, %FALSE if not.
         */
        can_reach(
            connectable: SocketConnectable,
            cancellable: Cancellable | null
        ): boolean;
        /**
         * Asynchronously attempts to determine whether or not the host
         * pointed to by `connectable` can be reached, without actually
         * trying to connect to it.
         *
         * For more details, see g_network_monitor_can_reach().
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_network_monitor_can_reach_finish()
         * to get the result of the operation.
         * @param connectable a #GSocketConnectable
         * @param cancellable a #GCancellable, or %NULL
         * @param callback a #GAsyncReadyCallback     to call when the request is satisfied
         */
        can_reach_async(
            connectable: SocketConnectable,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of can_reach_async

        /**
         * Promisified version of {@link can_reach_async}
         *
         * Asynchronously attempts to determine whether or not the host
         * pointed to by `connectable` can be reached, without actually
         * trying to connect to it.
         *
         * For more details, see g_network_monitor_can_reach().
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_network_monitor_can_reach_finish()
         * to get the result of the operation.
         * @param connectable a #GSocketConnectable
         * @param cancellable a #GCancellable, or %NULL
         * @returns A Promise of: %TRUE if network is reachable, %FALSE if not.
         */
        can_reach_async(
            connectable: SocketConnectable,
            cancellable: Cancellable | null
        ): globalThis.Promise<boolean>;
        /**
         * Finishes an async network connectivity test.
         * See g_network_monitor_can_reach_async().
         * @param result a #GAsyncResult
         * @returns %TRUE if network is reachable, %FALSE if not.
         */
        can_reach_finish(result: AsyncResult): boolean;
        /**
         * Gets a more detailed networking state than
         * g_network_monitor_get_network_available().
         *
         * If #GNetworkMonitor:network-available is %FALSE, then the
         * connectivity state will be %G_NETWORK_CONNECTIVITY_LOCAL.
         *
         * If #GNetworkMonitor:network-available is %TRUE, then the
         * connectivity state will be %G_NETWORK_CONNECTIVITY_FULL (if there
         * is full Internet connectivity), %G_NETWORK_CONNECTIVITY_LIMITED (if
         * the host has a default route, but appears to be unable to actually
         * reach the full Internet), or %G_NETWORK_CONNECTIVITY_PORTAL (if the
         * host is trapped behind a "captive portal" that requires some sort
         * of login or acknowledgement before allowing full Internet access).
         *
         * Note that in the case of %G_NETWORK_CONNECTIVITY_LIMITED and
         * %G_NETWORK_CONNECTIVITY_PORTAL, it is possible that some sites are
         * reachable but others are not. In this case, applications can
         * attempt to connect to remote servers, but should gracefully fall
         * back to their "offline" behavior if the connection attempt fails.
         * @returns the network connectivity state
         */
        get_connectivity(): NetworkConnectivity;
        /**
         * Checks if the network is available. "Available" here means that the
         * system has a default route available for at least one of IPv4 or
         * IPv6. It does not necessarily imply that the public Internet is
         * reachable. See #GNetworkMonitor:network-available for more details.
         * @returns whether the network is available
         */
        get_network_available(): boolean;
        /**
         * Checks if the network is metered.
         * See #GNetworkMonitor:network-metered for more details.
         * @returns whether the connection is metered
         */
        get_network_metered(): boolean;

        // Own virtual methods of Gio-2.0.Gio.NetworkMonitor

        /**
         * Attempts to determine whether or not the host pointed to by
         * `connectable` can be reached, without actually trying to connect to
         * it.
         *
         * This may return %TRUE even when #GNetworkMonitor:network-available
         * is %FALSE, if, for example, `monitor` can determine that
         * `connectable` refers to a host on a local network.
         *
         * If `monitor` believes that an attempt to connect to `connectable`
         * will succeed, it will return %TRUE. Otherwise, it will return
         * %FALSE and set `error` to an appropriate error (such as
         * %G_IO_ERROR_HOST_UNREACHABLE).
         *
         * Note that although this does not attempt to connect to
         * `connectable,` it may still block for a brief period of time (eg,
         * trying to do multicast DNS on the local network), so if you do not
         * want to block, you should use g_network_monitor_can_reach_async().
         * @virtual
         * @param connectable a #GSocketConnectable
         * @param cancellable a #GCancellable, or %NULL
         * @returns %TRUE if @connectable is reachable, %FALSE if not.
         */
        vfunc_can_reach(
            connectable: SocketConnectable,
            cancellable: Cancellable | null
        ): boolean;
        /**
         * Asynchronously attempts to determine whether or not the host
         * pointed to by `connectable` can be reached, without actually
         * trying to connect to it.
         *
         * For more details, see g_network_monitor_can_reach().
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_network_monitor_can_reach_finish()
         * to get the result of the operation.
         * @virtual
         * @param connectable a #GSocketConnectable
         * @param cancellable a #GCancellable, or %NULL
         * @param callback a #GAsyncReadyCallback     to call when the request is satisfied
         */
        vfunc_can_reach_async(
            connectable: SocketConnectable,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes an async network connectivity test.
         * See g_network_monitor_can_reach_async().
         * @virtual
         * @param result a #GAsyncResult
         * @returns %TRUE if network is reachable, %FALSE if not.
         */
        vfunc_can_reach_finish(result: AsyncResult): boolean;
        vfunc_network_changed(network_available: boolean): void;

        // Own signals of Gio-2.0.Gio.NetworkMonitor

        connect(
            sigName: 'network-changed',
            callback: NetworkMonitor.NetworkChangedSignalCallback
        ): number;
        connect_after(
            sigName: 'network-changed',
            callback: NetworkMonitor.NetworkChangedSignalCallback
        ): number;
        emit(
            sigName: 'network-changed',
            network_available: boolean,
            ...args: any[]
        ): void;

        // Class property signals of Gio-2.0.Gio.NetworkMonitor

        connect(
            sigName: 'notify::connectivity',
            callback: ($obj: NetworkMonitor, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::connectivity',
            callback: ($obj: NetworkMonitor, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::connectivity', ...args: any[]): void;
        connect(
            sigName: 'notify::network-available',
            callback: ($obj: NetworkMonitor, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::network-available',
            callback: ($obj: NetworkMonitor, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::network-available', ...args: any[]): void;
        connect(
            sigName: 'notify::network-metered',
            callback: ($obj: NetworkMonitor, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::network-metered',
            callback: ($obj: NetworkMonitor, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::network-metered', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GNetworkMonitor provides an easy-to-use cross-platform API
     * for monitoring network connectivity. On Linux, the available
     * implementations are based on the kernel's netlink interface and
     * on NetworkManager.
     *
     * There is also an implementation for use inside Flatpak sandboxes.
     * @interface
     */
    class NetworkMonitor extends GObject.Object {
        // Own properties of Gio-2.0.Gio.NetworkMonitor

        static name: string;
        static $gtype: GObject.GType<NetworkMonitor>;

        // Constructors of Gio-2.0.Gio.NetworkMonitor

        constructor(config?: NetworkMonitor.ConstructorProperties);
        _init(config?: NetworkMonitor.ConstructorProperties): void;
        /**
         * Gets the default #GNetworkMonitor for the system.
         * @returns a #GNetworkMonitor, which will be     a dummy object if no network monitor is available
         */
        static get_default(): NetworkMonitor;
    }

    namespace PollableInputStream {
        // Constructor properties interface

        interface ConstructorProperties
            extends InputStream.ConstructorProperties,
                GObject.Object.ConstructorProperties {}
    }

    interface PollableInputStream extends InputStream {
        // Owm methods of Gio-2.0.Gio.PollableInputStream

        /**
         * Checks if `stream` is actually pollable. Some classes may implement
         * #GPollableInputStream but have only certain instances of that class
         * be pollable. If this method returns %FALSE, then the behavior of
         * other #GPollableInputStream methods is undefined.
         *
         * For any given stream, the value returned by this method is constant;
         * a stream cannot switch from pollable to non-pollable or vice versa.
         * @returns %TRUE if @stream is pollable, %FALSE if not.
         */
        can_poll(): boolean;
        /**
         * Creates a #GSource that triggers when `stream` can be read, or
         * `cancellable` is triggered or an error occurs. The callback on the
         * source is of the #GPollableSourceFunc type.
         *
         * As with g_pollable_input_stream_is_readable(), it is possible that
         * the stream may not actually be readable even after the source
         * triggers, so you should use g_pollable_input_stream_read_nonblocking()
         * rather than g_input_stream_read() from the callback.
         *
         * The behaviour of this method is undefined if
         * g_pollable_input_stream_can_poll() returns %FALSE for `stream`.
         * @param cancellable a #GCancellable, or %NULL
         * @returns a new #GSource
         */
        create_source(cancellable: Cancellable | null): GLib.Source;
        /**
         * Checks if `stream` can be read.
         *
         * Note that some stream types may not be able to implement this 100%
         * reliably, and it is possible that a call to g_input_stream_read()
         * after this returns %TRUE would still block. To guarantee
         * non-blocking behavior, you should always use
         * g_pollable_input_stream_read_nonblocking(), which will return a
         * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
         *
         * The behaviour of this method is undefined if
         * g_pollable_input_stream_can_poll() returns %FALSE for `stream`.
         * @returns %TRUE if @stream is readable, %FALSE if not. If an error   has occurred on @stream, this will result in   g_pollable_input_stream_is_readable() returning %TRUE, and the   next attempt to read will return the error.
         */
        is_readable(): boolean;
        /**
         * Attempts to read up to `count` bytes from `stream` into `buffer,` as
         * with g_input_stream_read(). If `stream` is not currently readable,
         * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
         * use g_pollable_input_stream_create_source() to create a #GSource
         * that will be triggered when `stream` is readable.
         *
         * Note that since this method never blocks, you cannot actually
         * use `cancellable` to cancel it. However, it will return an error
         * if `cancellable` has already been cancelled when you call, which
         * may happen if you call this method after a source triggers due
         * to having been cancelled.
         *
         * The behaviour of this method is undefined if
         * g_pollable_input_stream_can_poll() returns %FALSE for `stream`.
         * @param cancellable a #GCancellable, or %NULL
         * @returns the number of bytes read, or -1 on error (including   %G_IO_ERROR_WOULD_BLOCK).
         */
        read_nonblocking(
            cancellable: Cancellable | null
        ): [/* returnType */ number, /* buffer */ Uint8Array];

        // Own virtual methods of Gio-2.0.Gio.PollableInputStream

        /**
         * Checks if `stream` is actually pollable. Some classes may implement
         * #GPollableInputStream but have only certain instances of that class
         * be pollable. If this method returns %FALSE, then the behavior of
         * other #GPollableInputStream methods is undefined.
         *
         * For any given stream, the value returned by this method is constant;
         * a stream cannot switch from pollable to non-pollable or vice versa.
         * @virtual
         * @returns %TRUE if @stream is pollable, %FALSE if not.
         */
        vfunc_can_poll(): boolean;
        /**
         * Creates a #GSource that triggers when `stream` can be read, or
         * `cancellable` is triggered or an error occurs. The callback on the
         * source is of the #GPollableSourceFunc type.
         *
         * As with g_pollable_input_stream_is_readable(), it is possible that
         * the stream may not actually be readable even after the source
         * triggers, so you should use g_pollable_input_stream_read_nonblocking()
         * rather than g_input_stream_read() from the callback.
         *
         * The behaviour of this method is undefined if
         * g_pollable_input_stream_can_poll() returns %FALSE for `stream`.
         * @virtual
         * @param cancellable a #GCancellable, or %NULL
         * @returns a new #GSource
         */
        vfunc_create_source(cancellable: Cancellable | null): GLib.Source;
        /**
         * Checks if `stream` can be read.
         *
         * Note that some stream types may not be able to implement this 100%
         * reliably, and it is possible that a call to g_input_stream_read()
         * after this returns %TRUE would still block. To guarantee
         * non-blocking behavior, you should always use
         * g_pollable_input_stream_read_nonblocking(), which will return a
         * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
         *
         * The behaviour of this method is undefined if
         * g_pollable_input_stream_can_poll() returns %FALSE for `stream`.
         * @virtual
         * @returns %TRUE if @stream is readable, %FALSE if not. If an error   has occurred on @stream, this will result in   g_pollable_input_stream_is_readable() returning %TRUE, and the   next attempt to read will return the error.
         */
        vfunc_is_readable(): boolean;
        /**
         * Attempts to read up to `count` bytes from `stream` into `buffer,` as
         * with g_input_stream_read(). If `stream` is not currently readable,
         * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
         * use g_pollable_input_stream_create_source() to create a #GSource
         * that will be triggered when `stream` is readable.
         *
         * Note that since this method never blocks, you cannot actually
         * use `cancellable` to cancel it. However, it will return an error
         * if `cancellable` has already been cancelled when you call, which
         * may happen if you call this method after a source triggers due
         * to having been cancelled.
         *
         * The behaviour of this method is undefined if
         * g_pollable_input_stream_can_poll() returns %FALSE for `stream`.
         * @virtual
         * @returns the number of bytes read, or -1 on error (including   %G_IO_ERROR_WOULD_BLOCK).
         */
        vfunc_read_nonblocking(): [
            /* returnType */ number,
            /* buffer */ Uint8Array | null
        ];

        // Class property signals of Gio-2.0.Gio.PollableInputStream

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GPollableInputStream is implemented by #GInputStreams that
     * can be polled for readiness to read. This can be used when
     * interfacing with a non-GIO API that expects
     * UNIX-file-descriptor-style asynchronous I/O rather than GIO-style.
     *
     * Some classes may implement #GPollableInputStream but have only certain
     * instances of that class be pollable. If g_pollable_input_stream_can_poll()
     * returns %FALSE, then the behavior of other #GPollableInputStream methods is
     * undefined.
     * @interface
     */
    class PollableInputStream extends GObject.Object {
        // Own properties of Gio-2.0.Gio.PollableInputStream

        static name: string;
        static $gtype: GObject.GType<PollableInputStream>;

        // Constructors of Gio-2.0.Gio.PollableInputStream

        constructor(config?: PollableInputStream.ConstructorProperties);
        _init(config?: PollableInputStream.ConstructorProperties): void;
    }

    namespace PollableOutputStream {
        // Constructor properties interface

        interface ConstructorProperties
            extends OutputStream.ConstructorProperties,
                GObject.Object.ConstructorProperties {}
    }

    interface PollableOutputStream extends OutputStream {
        // Owm methods of Gio-2.0.Gio.PollableOutputStream

        /**
         * Checks if `stream` is actually pollable. Some classes may implement
         * #GPollableOutputStream but have only certain instances of that
         * class be pollable. If this method returns %FALSE, then the behavior
         * of other #GPollableOutputStream methods is undefined.
         *
         * For any given stream, the value returned by this method is constant;
         * a stream cannot switch from pollable to non-pollable or vice versa.
         * @returns %TRUE if @stream is pollable, %FALSE if not.
         */
        can_poll(): boolean;
        /**
         * Creates a #GSource that triggers when `stream` can be written, or
         * `cancellable` is triggered or an error occurs. The callback on the
         * source is of the #GPollableSourceFunc type.
         *
         * As with g_pollable_output_stream_is_writable(), it is possible that
         * the stream may not actually be writable even after the source
         * triggers, so you should use g_pollable_output_stream_write_nonblocking()
         * rather than g_output_stream_write() from the callback.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         * @param cancellable a #GCancellable, or %NULL
         * @returns a new #GSource
         */
        create_source(cancellable: Cancellable | null): GLib.Source;
        /**
         * Checks if `stream` can be written.
         *
         * Note that some stream types may not be able to implement this 100%
         * reliably, and it is possible that a call to g_output_stream_write()
         * after this returns %TRUE would still block. To guarantee
         * non-blocking behavior, you should always use
         * g_pollable_output_stream_write_nonblocking(), which will return a
         * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         * @returns %TRUE if @stream is writable, %FALSE if not. If an error   has occurred on @stream, this will result in   g_pollable_output_stream_is_writable() returning %TRUE, and the   next attempt to write will return the error.
         */
        is_writable(): boolean;
        /**
         * Attempts to write up to `count` bytes from `buffer` to `stream,` as
         * with g_output_stream_write(). If `stream` is not currently writable,
         * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
         * use g_pollable_output_stream_create_source() to create a #GSource
         * that will be triggered when `stream` is writable.
         *
         * Note that since this method never blocks, you cannot actually
         * use `cancellable` to cancel it. However, it will return an error
         * if `cancellable` has already been cancelled when you call, which
         * may happen if you call this method after a source triggers due
         * to having been cancelled.
         *
         * Also note that if %G_IO_ERROR_WOULD_BLOCK is returned some underlying
         * transports like D/TLS require that you re-send the same `buffer` and
         * `count` in the next write call.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         * @param buffer a buffer to write     data from
         * @param cancellable a #GCancellable, or %NULL
         * @returns the number of bytes written, or -1 on error (including   %G_IO_ERROR_WOULD_BLOCK).
         */
        write_nonblocking(
            buffer: Uint8Array,
            cancellable: Cancellable | null
        ): number;
        /**
         * Attempts to write the bytes contained in the `n_vectors` `vectors` to `stream,`
         * as with g_output_stream_writev(). If `stream` is not currently writable,
         * this will immediately return %`G_POLLABLE_RETURN_WOULD_BLOCK,` and you can
         * use g_pollable_output_stream_create_source() to create a #GSource
         * that will be triggered when `stream` is writable. `error` will *not* be
         * set in that case.
         *
         * Note that since this method never blocks, you cannot actually
         * use `cancellable` to cancel it. However, it will return an error
         * if `cancellable` has already been cancelled when you call, which
         * may happen if you call this method after a source triggers due
         * to having been cancelled.
         *
         * Also note that if %G_POLLABLE_RETURN_WOULD_BLOCK is returned some underlying
         * transports like D/TLS require that you re-send the same `vectors` and
         * `n_vectors` in the next write call.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @param cancellable a #GCancellable, or %NULL
         * @returns %@G_POLLABLE_RETURN_OK on success, %G_POLLABLE_RETURN_WOULD_BLOCK if the stream is not currently writable (and @error is *not* set), or %G_POLLABLE_RETURN_FAILED if there was an error in which case @error will be set.
         */
        writev_nonblocking(
            vectors: OutputVector[],
            cancellable: Cancellable | null
        ): [/* returnType */ PollableReturn, /* bytes_written */ number];

        // Own virtual methods of Gio-2.0.Gio.PollableOutputStream

        /**
         * Checks if `stream` is actually pollable. Some classes may implement
         * #GPollableOutputStream but have only certain instances of that
         * class be pollable. If this method returns %FALSE, then the behavior
         * of other #GPollableOutputStream methods is undefined.
         *
         * For any given stream, the value returned by this method is constant;
         * a stream cannot switch from pollable to non-pollable or vice versa.
         * @virtual
         * @returns %TRUE if @stream is pollable, %FALSE if not.
         */
        vfunc_can_poll(): boolean;
        /**
         * Creates a #GSource that triggers when `stream` can be written, or
         * `cancellable` is triggered or an error occurs. The callback on the
         * source is of the #GPollableSourceFunc type.
         *
         * As with g_pollable_output_stream_is_writable(), it is possible that
         * the stream may not actually be writable even after the source
         * triggers, so you should use g_pollable_output_stream_write_nonblocking()
         * rather than g_output_stream_write() from the callback.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         * @virtual
         * @param cancellable a #GCancellable, or %NULL
         * @returns a new #GSource
         */
        vfunc_create_source(cancellable: Cancellable | null): GLib.Source;
        /**
         * Checks if `stream` can be written.
         *
         * Note that some stream types may not be able to implement this 100%
         * reliably, and it is possible that a call to g_output_stream_write()
         * after this returns %TRUE would still block. To guarantee
         * non-blocking behavior, you should always use
         * g_pollable_output_stream_write_nonblocking(), which will return a
         * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         * @virtual
         * @returns %TRUE if @stream is writable, %FALSE if not. If an error   has occurred on @stream, this will result in   g_pollable_output_stream_is_writable() returning %TRUE, and the   next attempt to write will return the error.
         */
        vfunc_is_writable(): boolean;
        /**
         * Attempts to write up to `count` bytes from `buffer` to `stream,` as
         * with g_output_stream_write(). If `stream` is not currently writable,
         * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
         * use g_pollable_output_stream_create_source() to create a #GSource
         * that will be triggered when `stream` is writable.
         *
         * Note that since this method never blocks, you cannot actually
         * use `cancellable` to cancel it. However, it will return an error
         * if `cancellable` has already been cancelled when you call, which
         * may happen if you call this method after a source triggers due
         * to having been cancelled.
         *
         * Also note that if %G_IO_ERROR_WOULD_BLOCK is returned some underlying
         * transports like D/TLS require that you re-send the same `buffer` and
         * `count` in the next write call.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         * @virtual
         * @param buffer a buffer to write     data from
         * @returns the number of bytes written, or -1 on error (including   %G_IO_ERROR_WOULD_BLOCK).
         */
        vfunc_write_nonblocking(buffer: Uint8Array | null): number;
        /**
         * Attempts to write the bytes contained in the `n_vectors` `vectors` to `stream,`
         * as with g_output_stream_writev(). If `stream` is not currently writable,
         * this will immediately return %`G_POLLABLE_RETURN_WOULD_BLOCK,` and you can
         * use g_pollable_output_stream_create_source() to create a #GSource
         * that will be triggered when `stream` is writable. `error` will *not* be
         * set in that case.
         *
         * Note that since this method never blocks, you cannot actually
         * use `cancellable` to cancel it. However, it will return an error
         * if `cancellable` has already been cancelled when you call, which
         * may happen if you call this method after a source triggers due
         * to having been cancelled.
         *
         * Also note that if %G_POLLABLE_RETURN_WOULD_BLOCK is returned some underlying
         * transports like D/TLS require that you re-send the same `vectors` and
         * `n_vectors` in the next write call.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         * @virtual
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @returns %@G_POLLABLE_RETURN_OK on success, %G_POLLABLE_RETURN_WOULD_BLOCK if the stream is not currently writable (and @error is *not* set), or %G_POLLABLE_RETURN_FAILED if there was an error in which case @error will be set.
         */
        vfunc_writev_nonblocking(
            vectors: OutputVector[]
        ): [/* returnType */ PollableReturn, /* bytes_written */ number];

        // Class property signals of Gio-2.0.Gio.PollableOutputStream

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GPollableOutputStream is implemented by #GOutputStreams that
     * can be polled for readiness to write. This can be used when
     * interfacing with a non-GIO API that expects
     * UNIX-file-descriptor-style asynchronous I/O rather than GIO-style.
     *
     * Some classes may implement #GPollableOutputStream but have only certain
     * instances of that class be pollable. If g_pollable_output_stream_can_poll()
     * returns %FALSE, then the behavior of other #GPollableOutputStream methods is
     * undefined.
     * @interface
     */
    class PollableOutputStream extends GObject.Object {
        // Own properties of Gio-2.0.Gio.PollableOutputStream

        static name: string;
        static $gtype: GObject.GType<PollableOutputStream>;

        // Constructors of Gio-2.0.Gio.PollableOutputStream

        constructor(config?: PollableOutputStream.ConstructorProperties);
        _init(config?: PollableOutputStream.ConstructorProperties): void;
    }

    namespace PowerProfileMonitor {
        // Constructor properties interface

        interface ConstructorProperties
            extends Initable.ConstructorProperties,
                GObject.Object.ConstructorProperties {}
    }

    interface PowerProfileMonitor extends Initable {
        // Own properties of Gio-2.0.Gio.PowerProfileMonitor

        /**
         * Whether Power Saver mode is enabled on the system.
         */
        readonly power_saver_enabled: boolean;

        // Owm methods of Gio-2.0.Gio.PowerProfileMonitor

        /**
         * Gets whether the system is in Power Saver mode.
         *
         * You are expected to listen to the
         * #GPowerProfileMonitor::notify::power-saver-enabled signal to know when the profile has
         * changed.
         * @returns Whether the system is in Power Saver mode.
         */
        get_power_saver_enabled(): boolean;

        // Class property signals of Gio-2.0.Gio.PowerProfileMonitor

        connect(
            sigName: 'notify::power-saver-enabled',
            callback: (
                $obj: PowerProfileMonitor,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::power-saver-enabled',
            callback: (
                $obj: PowerProfileMonitor,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::power-saver-enabled', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GPowerProfileMonitor makes it possible for applications as well as OS components
     * to monitor system power profiles and act upon them. It currently only exports
     * whether the system is in Power Saver mode (known as Low Power mode on
     * some systems).
     *
     * When in Low Power mode, it is recommended that applications:
     * - disable automatic downloads;
     * - reduce the rate of refresh from online sources such as calendar or
     *   email synchronisation;
     * - reduce the use of expensive visual effects.
     *
     * It is also likely that OS components providing services to applications will
     * lower their own background activity, for the sake of the system.
     *
     * There are a variety of tools that exist for power consumption analysis, but those
     * usually depend on the OS and hardware used. On Linux, one could use `upower` to
     * monitor the battery discharge rate, `powertop` to check on the background activity
     * or activity at all), `sysprof` to inspect CPU usage, and `intel_gpu_time` to
     * profile GPU usage.
     *
     * Don't forget to disconnect the #GPowerProfileMonitor::notify::power-saver-enabled
     * signal, and unref the #GPowerProfileMonitor itself when exiting.
     * @interface
     */
    class PowerProfileMonitor extends GObject.Object {
        // Own properties of Gio-2.0.Gio.PowerProfileMonitor

        static name: string;
        static $gtype: GObject.GType<PowerProfileMonitor>;

        // Constructors of Gio-2.0.Gio.PowerProfileMonitor

        constructor(config?: PowerProfileMonitor.ConstructorProperties);
        _init(config?: PowerProfileMonitor.ConstructorProperties): void;
        /**
         * Gets a reference to the default #GPowerProfileMonitor for the system.
         * @returns a new reference to the default #GPowerProfileMonitor
         */
        static dup_default(): PowerProfileMonitor;
    }

    namespace Proxy {
        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface Proxy {
        // Owm methods of Gio-2.0.Gio.Proxy

        /**
         * Given `connection` to communicate with a proxy (eg, a
         * #GSocketConnection that is connected to the proxy server), this
         * does the necessary handshake to connect to `proxy_address,` and if
         * required, wraps the #GIOStream to handle proxy payload.
         * @param connection a #GIOStream
         * @param proxy_address a #GProxyAddress
         * @param cancellable a #GCancellable
         * @returns a #GIOStream that will replace @connection. This might               be the same as @connection, in which case a reference               will be added.
         */
        connect(
            connection: IOStream,
            proxy_address: ProxyAddress,
            cancellable: Cancellable | null
        ): IOStream;
        /**
         * Asynchronous version of g_proxy_connect().
         * @param connection a #GIOStream
         * @param proxy_address a #GProxyAddress
         * @param cancellable a #GCancellable
         * @param callback a #GAsyncReadyCallback
         */
        connect_async(
            connection: IOStream,
            proxy_address: ProxyAddress,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of connect_async

        /**
         * Promisified version of {@link connect_async}
         *
         * Asynchronous version of g_proxy_connect().
         * @param connection a #GIOStream
         * @param proxy_address a #GProxyAddress
         * @param cancellable a #GCancellable
         * @returns A Promise of: a #GIOStream.
         */
        connect_async(
            connection: IOStream,
            proxy_address: ProxyAddress,
            cancellable: Cancellable | null
        ): globalThis.Promise<IOStream>;
        /**
         * See g_proxy_connect().
         * @param result a #GAsyncResult
         * @returns a #GIOStream.
         */
        connect_finish(result: AsyncResult): IOStream;
        /**
         * Some proxy protocols expect to be passed a hostname, which they
         * will resolve to an IP address themselves. Others, like SOCKS4, do
         * not allow this. This function will return %FALSE if `proxy` is
         * implementing such a protocol. When %FALSE is returned, the caller
         * should resolve the destination hostname first, and then pass a
         * #GProxyAddress containing the stringified IP address to
         * g_proxy_connect() or g_proxy_connect_async().
         * @returns %TRUE if hostname resolution is supported.
         */
        supports_hostname(): boolean;

        // Own virtual methods of Gio-2.0.Gio.Proxy

        /**
         * Given `connection` to communicate with a proxy (eg, a
         * #GSocketConnection that is connected to the proxy server), this
         * does the necessary handshake to connect to `proxy_address,` and if
         * required, wraps the #GIOStream to handle proxy payload.
         * @virtual
         * @param connection a #GIOStream
         * @param proxy_address a #GProxyAddress
         * @param cancellable a #GCancellable
         * @returns a #GIOStream that will replace @connection. This might               be the same as @connection, in which case a reference               will be added.
         */
        vfunc_connect(
            connection: IOStream,
            proxy_address: ProxyAddress,
            cancellable: Cancellable | null
        ): IOStream;
        /**
         * Asynchronous version of g_proxy_connect().
         * @virtual
         * @param connection a #GIOStream
         * @param proxy_address a #GProxyAddress
         * @param cancellable a #GCancellable
         * @param callback a #GAsyncReadyCallback
         */
        vfunc_connect_async(
            connection: IOStream,
            proxy_address: ProxyAddress,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * See g_proxy_connect().
         * @virtual
         * @param result a #GAsyncResult
         * @returns a #GIOStream.
         */
        vfunc_connect_finish(result: AsyncResult): IOStream;
        /**
         * Some proxy protocols expect to be passed a hostname, which they
         * will resolve to an IP address themselves. Others, like SOCKS4, do
         * not allow this. This function will return %FALSE if `proxy` is
         * implementing such a protocol. When %FALSE is returned, the caller
         * should resolve the destination hostname first, and then pass a
         * #GProxyAddress containing the stringified IP address to
         * g_proxy_connect() or g_proxy_connect_async().
         * @virtual
         * @returns %TRUE if hostname resolution is supported.
         */
        vfunc_supports_hostname(): boolean;

        // Class property signals of Gio-2.0.Gio.Proxy

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * A #GProxy handles connecting to a remote host via a given type of
     * proxy server. It is implemented by the 'gio-proxy' extension point.
     * The extensions are named after their proxy protocol name. As an
     * example, a SOCKS5 proxy implementation can be retrieved with the
     * name 'socks5' using the function
     * g_io_extension_point_get_extension_by_name().
     * @interface
     */
    class Proxy extends GObject.Object {
        // Own properties of Gio-2.0.Gio.Proxy

        static name: string;
        static $gtype: GObject.GType<Proxy>;

        // Constructors of Gio-2.0.Gio.Proxy

        constructor(config?: Proxy.ConstructorProperties);
        _init(config?: Proxy.ConstructorProperties): void;
        /**
         * Find the `gio-proxy` extension point for a proxy implementation that supports
         * the specified protocol.
         * @param protocol the proxy protocol name (e.g. http, socks, etc)
         * @returns return a #GProxy or NULL if protocol               is not supported.
         */
        static get_default_for_protocol(protocol: string | null): Proxy | null;
    }

    namespace ProxyResolver {
        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface ProxyResolver {
        // Owm methods of Gio-2.0.Gio.ProxyResolver

        /**
         * Checks if `resolver` can be used on this system. (This is used
         * internally; g_proxy_resolver_get_default() will only return a proxy
         * resolver that returns %TRUE for this method.)
         * @returns %TRUE if @resolver is supported.
         */
        is_supported(): boolean;
        /**
         * Looks into the system proxy configuration to determine what proxy,
         * if any, to use to connect to `uri`. The returned proxy URIs are of
         * the form `<protocol>://[user[:password]`]`host[:port]` or
         * `direct://`, where <protocol> could be http, rtsp, socks
         * or other proxying protocol.
         *
         * If you don't know what network protocol is being used on the
         * socket, you should use `none` as the URI protocol.
         * In this case, the resolver might still return a generic proxy type
         * (such as SOCKS), but would not return protocol-specific proxy types
         * (such as http).
         *
         * `direct://` is used when no proxy is needed.
         * Direct connection should not be attempted unless it is part of the
         * returned array of proxies.
         * @param uri a URI representing the destination to connect to
         * @param cancellable a #GCancellable, or %NULL
         * @returns A               NULL-terminated array of proxy URIs. Must be freed               with g_strfreev().
         */
        lookup(uri: string | null, cancellable: Cancellable | null): string[];
        /**
         * Asynchronous lookup of proxy. See g_proxy_resolver_lookup() for more
         * details.
         * @param uri a URI representing the destination to connect to
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call after resolution completes
         */
        lookup_async(
            uri: string | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of lookup_async

        /**
         * Promisified version of {@link lookup_async}
         *
         * Asynchronous lookup of proxy. See g_proxy_resolver_lookup() for more
         * details.
         * @param uri a URI representing the destination to connect to
         * @param cancellable a #GCancellable, or %NULL
         * @returns A Promise of: A               NULL-terminated array of proxy URIs. Must be freed               with g_strfreev().
         */
        lookup_async(
            uri: string | null,
            cancellable: Cancellable | null
        ): globalThis.Promise<string[]>;
        /**
         * Call this function to obtain the array of proxy URIs when
         * g_proxy_resolver_lookup_async() is complete. See
         * g_proxy_resolver_lookup() for more details.
         * @param result the result passed to your #GAsyncReadyCallback
         * @returns A               NULL-terminated array of proxy URIs. Must be freed               with g_strfreev().
         */
        lookup_finish(result: AsyncResult): string[];

        // Own virtual methods of Gio-2.0.Gio.ProxyResolver

        /**
         * Checks if `resolver` can be used on this system. (This is used
         * internally; g_proxy_resolver_get_default() will only return a proxy
         * resolver that returns %TRUE for this method.)
         * @virtual
         * @returns %TRUE if @resolver is supported.
         */
        vfunc_is_supported(): boolean;
        /**
         * Looks into the system proxy configuration to determine what proxy,
         * if any, to use to connect to `uri`. The returned proxy URIs are of
         * the form `<protocol>://[user[:password]`]`host[:port]` or
         * `direct://`, where <protocol> could be http, rtsp, socks
         * or other proxying protocol.
         *
         * If you don't know what network protocol is being used on the
         * socket, you should use `none` as the URI protocol.
         * In this case, the resolver might still return a generic proxy type
         * (such as SOCKS), but would not return protocol-specific proxy types
         * (such as http).
         *
         * `direct://` is used when no proxy is needed.
         * Direct connection should not be attempted unless it is part of the
         * returned array of proxies.
         * @virtual
         * @param uri a URI representing the destination to connect to
         * @param cancellable a #GCancellable, or %NULL
         * @returns A               NULL-terminated array of proxy URIs. Must be freed               with g_strfreev().
         */
        vfunc_lookup(
            uri: string | null,
            cancellable: Cancellable | null
        ): string[];
        /**
         * Asynchronous lookup of proxy. See g_proxy_resolver_lookup() for more
         * details.
         * @virtual
         * @param uri a URI representing the destination to connect to
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call after resolution completes
         */
        vfunc_lookup_async(
            uri: string | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Call this function to obtain the array of proxy URIs when
         * g_proxy_resolver_lookup_async() is complete. See
         * g_proxy_resolver_lookup() for more details.
         * @virtual
         * @param result the result passed to your #GAsyncReadyCallback
         * @returns A               NULL-terminated array of proxy URIs. Must be freed               with g_strfreev().
         */
        vfunc_lookup_finish(result: AsyncResult): string[];

        // Class property signals of Gio-2.0.Gio.ProxyResolver

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GProxyResolver provides synchronous and asynchronous network proxy
     * resolution. #GProxyResolver is used within #GSocketClient through
     * the method g_socket_connectable_proxy_enumerate().
     *
     * Implementations of #GProxyResolver based on libproxy and GNOME settings can
     * be found in glib-networking. GIO comes with an implementation for use inside
     * Flatpak portals.
     * @interface
     */
    class ProxyResolver extends GObject.Object {
        // Own properties of Gio-2.0.Gio.ProxyResolver

        static name: string;
        static $gtype: GObject.GType<ProxyResolver>;

        // Constructors of Gio-2.0.Gio.ProxyResolver

        constructor(config?: ProxyResolver.ConstructorProperties);
        _init(config?: ProxyResolver.ConstructorProperties): void;
        /**
         * Gets the default #GProxyResolver for the system.
         * @returns the default #GProxyResolver, which     will be a dummy object if no proxy resolver is available
         */
        static get_default(): ProxyResolver;
    }

    namespace RemoteActionGroup {
        // Constructor properties interface

        interface ConstructorProperties
            extends ActionGroup.ConstructorProperties,
                GObject.Object.ConstructorProperties {}
    }

    interface RemoteActionGroup extends ActionGroup {
        // Owm methods of Gio-2.0.Gio.RemoteActionGroup

        /**
         * Activates the remote action.
         *
         * This is the same as g_action_group_activate_action() except that it
         * allows for provision of "platform data" to be sent along with the
         * activation request.  This typically contains details such as the user
         * interaction timestamp or startup notification information.
         *
         * `platform_data` must be non-%NULL and must have the type
         * %G_VARIANT_TYPE_VARDICT.  If it is floating, it will be consumed.
         * @param action_name the name of the action to activate
         * @param parameter the optional parameter to the activation
         * @param platform_data the platform data to send
         */
        activate_action_full(
            action_name: string | null,
            parameter: GLib.Variant | null,
            platform_data: GLib.Variant
        ): void;
        /**
         * Changes the state of a remote action.
         *
         * This is the same as g_action_group_change_action_state() except that
         * it allows for provision of "platform data" to be sent along with the
         * state change request.  This typically contains details such as the
         * user interaction timestamp or startup notification information.
         *
         * `platform_data` must be non-%NULL and must have the type
         * %G_VARIANT_TYPE_VARDICT.  If it is floating, it will be consumed.
         * @param action_name the name of the action to change the state of
         * @param value the new requested value for the state
         * @param platform_data the platform data to send
         */
        change_action_state_full(
            action_name: string | null,
            value: GLib.Variant,
            platform_data: GLib.Variant
        ): void;

        // Own virtual methods of Gio-2.0.Gio.RemoteActionGroup

        /**
         * Activates the remote action.
         *
         * This is the same as g_action_group_activate_action() except that it
         * allows for provision of "platform data" to be sent along with the
         * activation request.  This typically contains details such as the user
         * interaction timestamp or startup notification information.
         *
         * `platform_data` must be non-%NULL and must have the type
         * %G_VARIANT_TYPE_VARDICT.  If it is floating, it will be consumed.
         * @virtual
         * @param action_name the name of the action to activate
         * @param parameter the optional parameter to the activation
         * @param platform_data the platform data to send
         */
        vfunc_activate_action_full(
            action_name: string | null,
            parameter: GLib.Variant | null,
            platform_data: GLib.Variant
        ): void;
        /**
         * Changes the state of a remote action.
         *
         * This is the same as g_action_group_change_action_state() except that
         * it allows for provision of "platform data" to be sent along with the
         * state change request.  This typically contains details such as the
         * user interaction timestamp or startup notification information.
         *
         * `platform_data` must be non-%NULL and must have the type
         * %G_VARIANT_TYPE_VARDICT.  If it is floating, it will be consumed.
         * @virtual
         * @param action_name the name of the action to change the state of
         * @param value the new requested value for the state
         * @param platform_data the platform data to send
         */
        vfunc_change_action_state_full(
            action_name: string | null,
            value: GLib.Variant,
            platform_data: GLib.Variant
        ): void;

        // Class property signals of Gio-2.0.Gio.RemoteActionGroup

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * The GRemoteActionGroup interface is implemented by #GActionGroup
     * instances that either transmit action invocations to other processes
     * or receive action invocations in the local process from other
     * processes.
     *
     * The interface has `_full` variants of the two
     * methods on #GActionGroup used to activate actions:
     * g_action_group_activate_action() and
     * g_action_group_change_action_state(). These variants allow a
     * "platform data" #GVariant to be specified: a dictionary providing
     * context for the action invocation (for example: timestamps, startup
     * notification IDs, etc).
     *
     * #GDBusActionGroup implements #GRemoteActionGroup.  This provides a
     * mechanism to send platform data for action invocations over D-Bus.
     *
     * Additionally, g_dbus_connection_export_action_group() will check if
     * the exported #GActionGroup implements #GRemoteActionGroup and use the
     * `_full` variants of the calls if available.  This
     * provides a mechanism by which to receive platform data for action
     * invocations that arrive by way of D-Bus.
     * @interface
     */
    class RemoteActionGroup extends GObject.Object {
        // Own properties of Gio-2.0.Gio.RemoteActionGroup

        static name: string;
        static $gtype: GObject.GType<RemoteActionGroup>;

        // Constructors of Gio-2.0.Gio.RemoteActionGroup

        constructor(config?: RemoteActionGroup.ConstructorProperties);
        _init(config?: RemoteActionGroup.ConstructorProperties): void;
    }

    namespace Seekable {
        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface Seekable {
        // Owm methods of Gio-2.0.Gio.Seekable

        /**
         * Tests if the stream supports the #GSeekableIface.
         * @returns %TRUE if @seekable can be seeked. %FALSE otherwise.
         */
        can_seek(): boolean;
        /**
         * Tests if the length of the stream can be adjusted with
         * g_seekable_truncate().
         * @returns %TRUE if the stream can be truncated, %FALSE otherwise.
         */
        can_truncate(): boolean;
        /**
         * Seeks in the stream by the given `offset,` modified by `type`.
         *
         * Attempting to seek past the end of the stream will have different
         * results depending on if the stream is fixed-sized or resizable.  If
         * the stream is resizable then seeking past the end and then writing
         * will result in zeros filling the empty space.  Seeking past the end
         * of a resizable stream and reading will result in EOF.  Seeking past
         * the end of a fixed-sized stream will fail.
         *
         * Any operation that would result in a negative offset will fail.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param offset a #goffset.
         * @param type a #GSeekType.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if successful. If an error     has occurred, this function will return %FALSE and set @error     appropriately if present.
         */
        seek(
            offset: number,
            type: GLib.SeekType,
            cancellable: Cancellable | null
        ): boolean;
        /**
         * Tells the current position within the stream.
         * @returns the (positive or zero) offset from the beginning of the buffer, zero if the target is not seekable.
         */
        tell(): number;
        /**
         * Sets the length of the stream to `offset`. If the stream was previously
         * larger than `offset,` the extra data is discarded. If the stream was
         * previously shorter than `offset,` it is extended with NUL ('\0') bytes.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         * @param offset new length for `seekable,` in bytes.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if successful. If an error     has occurred, this function will return %FALSE and set @error     appropriately if present.
         */
        truncate(offset: number, cancellable: Cancellable | null): boolean;

        // Own virtual methods of Gio-2.0.Gio.Seekable

        /**
         * Tests if the stream supports the #GSeekableIface.
         * @virtual
         * @returns %TRUE if @seekable can be seeked. %FALSE otherwise.
         */
        vfunc_can_seek(): boolean;
        /**
         * Tests if the length of the stream can be adjusted with
         * g_seekable_truncate().
         * @virtual
         * @returns %TRUE if the stream can be truncated, %FALSE otherwise.
         */
        vfunc_can_truncate(): boolean;
        /**
         * Seeks in the stream by the given `offset,` modified by `type`.
         *
         * Attempting to seek past the end of the stream will have different
         * results depending on if the stream is fixed-sized or resizable.  If
         * the stream is resizable then seeking past the end and then writing
         * will result in zeros filling the empty space.  Seeking past the end
         * of a resizable stream and reading will result in EOF.  Seeking past
         * the end of a fixed-sized stream will fail.
         *
         * Any operation that would result in a negative offset will fail.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @virtual
         * @param offset a #goffset.
         * @param type a #GSeekType.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if successful. If an error     has occurred, this function will return %FALSE and set @error     appropriately if present.
         */
        vfunc_seek(
            offset: number,
            type: GLib.SeekType,
            cancellable: Cancellable | null
        ): boolean;
        /**
         * Tells the current position within the stream.
         * @virtual
         * @returns the (positive or zero) offset from the beginning of the buffer, zero if the target is not seekable.
         */
        vfunc_tell(): number;
        /**
         * Sets the length of the stream to `offset`. If the stream was previously
         * larger than `offset,` the extra data is discarded. If the stream was
         * previously shorter than `offset,` it is extended with NUL ('\0') bytes.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         * @virtual
         * @param offset new length for `seekable,` in bytes.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if successful. If an error     has occurred, this function will return %FALSE and set @error     appropriately if present.
         */
        vfunc_truncate_fn(
            offset: number,
            cancellable: Cancellable | null
        ): boolean;

        // Class property signals of Gio-2.0.Gio.Seekable

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GSeekable is implemented by streams (implementations of
     * #GInputStream or #GOutputStream) that support seeking.
     *
     * Seekable streams largely fall into two categories: resizable and
     * fixed-size.
     *
     * #GSeekable on fixed-sized streams is approximately the same as POSIX
     * lseek() on a block device (for example: attempting to seek past the
     * end of the device is an error).  Fixed streams typically cannot be
     * truncated.
     *
     * #GSeekable on resizable streams is approximately the same as POSIX
     * lseek() on a normal file.  Seeking past the end and writing data will
     * usually cause the stream to resize by introducing zero bytes.
     * @interface
     */
    class Seekable extends GObject.Object {
        // Own properties of Gio-2.0.Gio.Seekable

        static name: string;
        static $gtype: GObject.GType<Seekable>;

        // Constructors of Gio-2.0.Gio.Seekable

        constructor(config?: Seekable.ConstructorProperties);
        _init(config?: Seekable.ConstructorProperties): void;
    }

    namespace SocketConnectable {
        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface SocketConnectable {
        // Owm methods of Gio-2.0.Gio.SocketConnectable

        /**
         * Creates a #GSocketAddressEnumerator for `connectable`.
         * @returns a new #GSocketAddressEnumerator.
         */
        enumerate(): SocketAddressEnumerator;
        /**
         * Creates a #GSocketAddressEnumerator for `connectable` that will
         * return a #GProxyAddress for each of its addresses that you must connect
         * to via a proxy.
         *
         * If `connectable` does not implement
         * g_socket_connectable_proxy_enumerate(), this will fall back to
         * calling g_socket_connectable_enumerate().
         * @returns a new #GSocketAddressEnumerator.
         */
        proxy_enumerate(): SocketAddressEnumerator;
        /**
         * Format a #GSocketConnectable as a string. This is a human-readable format for
         * use in debugging output, and is not a stable serialization format. It is not
         * suitable for use in user interfaces as it exposes too much information for a
         * user.
         *
         * If the #GSocketConnectable implementation does not support string formatting,
         * the implementations type name will be returned as a fallback.
         * @returns the formatted string
         */
        to_string(): string | null;

        // Own virtual methods of Gio-2.0.Gio.SocketConnectable

        /**
         * Creates a #GSocketAddressEnumerator for `connectable`.
         * @virtual
         * @returns a new #GSocketAddressEnumerator.
         */
        vfunc_enumerate(): SocketAddressEnumerator;
        /**
         * Creates a #GSocketAddressEnumerator for `connectable` that will
         * return a #GProxyAddress for each of its addresses that you must connect
         * to via a proxy.
         *
         * If `connectable` does not implement
         * g_socket_connectable_proxy_enumerate(), this will fall back to
         * calling g_socket_connectable_enumerate().
         * @virtual
         * @returns a new #GSocketAddressEnumerator.
         */
        vfunc_proxy_enumerate(): SocketAddressEnumerator;
        /**
         * Format a #GSocketConnectable as a string. This is a human-readable format for
         * use in debugging output, and is not a stable serialization format. It is not
         * suitable for use in user interfaces as it exposes too much information for a
         * user.
         *
         * If the #GSocketConnectable implementation does not support string formatting,
         * the implementations type name will be returned as a fallback.
         * @virtual
         * @returns the formatted string
         */
        vfunc_to_string(): string | null;

        // Class property signals of Gio-2.0.Gio.SocketConnectable

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * Objects that describe one or more potential socket endpoints
     * implement #GSocketConnectable. Callers can then use
     * g_socket_connectable_enumerate() to get a #GSocketAddressEnumerator
     * to try out each socket address in turn until one succeeds, as shown
     * in the sample code below.
     *
     *
     * ```c
     * MyConnectionType *
     * connect_to_host (const char    *hostname,
     *                  guint16        port,
     *                  GCancellable  *cancellable,
     *                  GError       **error)
     * {
     *   MyConnection *conn = NULL;
     *   GSocketConnectable *addr;
     *   GSocketAddressEnumerator *enumerator;
     *   GSocketAddress *sockaddr;
     *   GError *conn_error = NULL;
     *
     *   addr = g_network_address_new (hostname, port);
     *   enumerator = g_socket_connectable_enumerate (addr);
     *   g_object_unref (addr);
     *
     *   // Try each sockaddr until we succeed. Record the first connection error,
     *   // but not any further ones (since they'll probably be basically the same
     *   // as the first).
     *   while (!conn && (sockaddr = g_socket_address_enumerator_next (enumerator, cancellable, error))
     *     {
     *       conn = connect_to_sockaddr (sockaddr, conn_error ? NULL : &conn_error);
     *       g_object_unref (sockaddr);
     *     }
     *   g_object_unref (enumerator);
     *
     *   if (conn)
     *     {
     *       if (conn_error)
     *         {
     *           // We couldn't connect to the first address, but we succeeded
     *           // in connecting to a later address.
     *           g_error_free (conn_error);
     *         }
     *       return conn;
     *     }
     *   else if (error)
     *     {
     *       /// Either initial lookup failed, or else the caller cancelled us.
     *       if (conn_error)
     *         g_error_free (conn_error);
     *       return NULL;
     *     }
     *   else
     *     {
     *       g_error_propagate (error, conn_error);
     *       return NULL;
     *     }
     * }
     * ```
     *
     * @interface
     */
    class SocketConnectable extends GObject.Object {
        // Own properties of Gio-2.0.Gio.SocketConnectable

        static name: string;
        static $gtype: GObject.GType<SocketConnectable>;

        // Constructors of Gio-2.0.Gio.SocketConnectable

        constructor(config?: SocketConnectable.ConstructorProperties);
        _init(config?: SocketConnectable.ConstructorProperties): void;
    }

    namespace TlsBackend {
        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface TlsBackend {
        // Owm methods of Gio-2.0.Gio.TlsBackend

        /**
         * Gets the #GType of `backend'`s #GTlsCertificate implementation.
         * @returns the #GType of @backend's #GTlsCertificate   implementation.
         */
        get_certificate_type(): GObject.GType;
        /**
         * Gets the #GType of `backend'`s #GTlsClientConnection implementation.
         * @returns the #GType of @backend's #GTlsClientConnection   implementation.
         */
        get_client_connection_type(): GObject.GType;
        /**
         * Gets the default #GTlsDatabase used to verify TLS connections.
         * @returns the default database, which should be               unreffed when done.
         */
        get_default_database(): TlsDatabase;
        /**
         * Gets the #GType of `backend`s #GDtlsClientConnection implementation.
         * @returns the #GType of @backends #GDtlsClientConnection   implementation, or %G_TYPE_INVALID if this backend doesnt support DTLS.
         */
        get_dtls_client_connection_type(): GObject.GType;
        /**
         * Gets the #GType of `backend`s #GDtlsServerConnection implementation.
         * @returns the #GType of @backends #GDtlsServerConnection   implementation, or %G_TYPE_INVALID if this backend doesnt support DTLS.
         */
        get_dtls_server_connection_type(): GObject.GType;
        /**
         * Gets the #GType of `backend'`s #GTlsFileDatabase implementation.
         * @returns the #GType of backend's #GTlsFileDatabase implementation.
         */
        get_file_database_type(): GObject.GType;
        /**
         * Gets the #GType of `backend'`s #GTlsServerConnection implementation.
         * @returns the #GType of @backend's #GTlsServerConnection   implementation.
         */
        get_server_connection_type(): GObject.GType;
        /**
         * Set the default #GTlsDatabase used to verify TLS connections
         *
         * Any subsequent call to g_tls_backend_get_default_database() will return
         * the database set in this call.  Existing databases and connections are not
         * modified.
         *
         * Setting a %NULL default database will reset to using the system default
         * database as if g_tls_backend_set_default_database() had never been called.
         * @param database the #GTlsDatabase
         */
        set_default_database(database: TlsDatabase | null): void;
        /**
         * Checks if DTLS is supported. DTLS support may not be available even if TLS
         * support is available, and vice-versa.
         * @returns whether DTLS is supported
         */
        supports_dtls(): boolean;
        /**
         * Checks if TLS is supported; if this returns %FALSE for the default
         * #GTlsBackend, it means no "real" TLS backend is available.
         * @returns whether or not TLS is supported
         */
        supports_tls(): boolean;

        // Own virtual methods of Gio-2.0.Gio.TlsBackend

        /**
         * Gets the default #GTlsDatabase used to verify TLS connections.
         * @virtual
         * @returns the default database, which should be               unreffed when done.
         */
        vfunc_get_default_database(): TlsDatabase;
        /**
         * Checks if DTLS is supported. DTLS support may not be available even if TLS
         * support is available, and vice-versa.
         * @virtual
         * @returns whether DTLS is supported
         */
        vfunc_supports_dtls(): boolean;
        /**
         * Checks if TLS is supported; if this returns %FALSE for the default
         * #GTlsBackend, it means no "real" TLS backend is available.
         * @virtual
         * @returns whether or not TLS is supported
         */
        vfunc_supports_tls(): boolean;

        // Class property signals of Gio-2.0.Gio.TlsBackend

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * TLS (Transport Layer Security, aka SSL) and DTLS backend.
     * @interface
     */
    class TlsBackend extends GObject.Object {
        // Own properties of Gio-2.0.Gio.TlsBackend

        static name: string;
        static $gtype: GObject.GType<TlsBackend>;

        // Constructors of Gio-2.0.Gio.TlsBackend

        constructor(config?: TlsBackend.ConstructorProperties);
        _init(config?: TlsBackend.ConstructorProperties): void;
        /**
         * Gets the default #GTlsBackend for the system.
         * @returns a #GTlsBackend, which will be a     dummy object if no TLS backend is available
         */
        static get_default(): TlsBackend;
    }

    namespace TlsClientConnection {
        // Constructor properties interface

        interface ConstructorProperties
            extends TlsConnection.ConstructorProperties,
                GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.TlsClientConnection

            /**
             * A #GSocketConnectable describing the identity of the server that
             * is expected on the other end of the connection.
             *
             * If the %G_TLS_CERTIFICATE_BAD_IDENTITY flag is set in
             * #GTlsClientConnection:validation-flags, this object will be used
             * to determine the expected identify of the remote end of the
             * connection; if #GTlsClientConnection:server-identity is not set,
             * or does not match the identity presented by the server, then the
             * %G_TLS_CERTIFICATE_BAD_IDENTITY validation will fail.
             *
             * In addition to its use in verifying the server certificate,
             * this is also used to give a hint to the server about what
             * certificate we expect, which is useful for servers that serve
             * virtual hosts.
             */
            server_identity?: SocketConnectable | null;
            /**
             * SSL 3.0 is no longer supported. See
             * g_tls_client_connection_set_use_ssl3() for details.
             */
            use_ssl3?: boolean | null;
            /**
             * What steps to perform when validating a certificate received from
             * a server. Server certificates that fail to validate in any of the
             * ways indicated here will be rejected unless the application
             * overrides the default via #GTlsConnection::accept-certificate.
             *
             * GLib guarantees that if certificate verification fails, at least one
             * flag will be set, but it does not guarantee that all possible flags
             * will be set. Accordingly, you may not safely decide to ignore any
             * particular type of error. For example, it would be incorrect to mask
             * %G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates,
             * because this could potentially be the only error flag set even if
             * other problems exist with the certificate. Therefore, there is no
             * safe way to use this property. This is not a horrible problem,
             * though, because you should not be attempting to ignore validation
             * errors anyway. If you really must ignore TLS certificate errors,
             * connect to #GTlsConnection::accept-certificate.
             */
            validation_flags?: TlsCertificateFlags | null;
        }
    }

    interface TlsClientConnection extends TlsConnection {
        // Own properties of Gio-2.0.Gio.TlsClientConnection

        /**
         * A list of the distinguished names of the Certificate Authorities
         * that the server will accept client certificates signed by. If the
         * server requests a client certificate during the handshake, then
         * this property will be set after the handshake completes.
         *
         * Each item in the list is a #GByteArray which contains the complete
         * subject DN of the certificate authority.
         */
        readonly accepted_cas: any[];
        /**
         * A #GSocketConnectable describing the identity of the server that
         * is expected on the other end of the connection.
         *
         * If the %G_TLS_CERTIFICATE_BAD_IDENTITY flag is set in
         * #GTlsClientConnection:validation-flags, this object will be used
         * to determine the expected identify of the remote end of the
         * connection; if #GTlsClientConnection:server-identity is not set,
         * or does not match the identity presented by the server, then the
         * %G_TLS_CERTIFICATE_BAD_IDENTITY validation will fail.
         *
         * In addition to its use in verifying the server certificate,
         * this is also used to give a hint to the server about what
         * certificate we expect, which is useful for servers that serve
         * virtual hosts.
         */
        server_identity: SocketConnectable;
        /**
         * SSL 3.0 is no longer supported. See
         * g_tls_client_connection_set_use_ssl3() for details.
         */
        use_ssl3: boolean;
        /**
         * What steps to perform when validating a certificate received from
         * a server. Server certificates that fail to validate in any of the
         * ways indicated here will be rejected unless the application
         * overrides the default via #GTlsConnection::accept-certificate.
         *
         * GLib guarantees that if certificate verification fails, at least one
         * flag will be set, but it does not guarantee that all possible flags
         * will be set. Accordingly, you may not safely decide to ignore any
         * particular type of error. For example, it would be incorrect to mask
         * %G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates,
         * because this could potentially be the only error flag set even if
         * other problems exist with the certificate. Therefore, there is no
         * safe way to use this property. This is not a horrible problem,
         * though, because you should not be attempting to ignore validation
         * errors anyway. If you really must ignore TLS certificate errors,
         * connect to #GTlsConnection::accept-certificate.
         */
        validation_flags: TlsCertificateFlags;

        // Conflicting properties

        parent_instance: IOStream & GObject.Object & GObject.Object;

        // Owm methods of Gio-2.0.Gio.TlsClientConnection

        /**
         * Possibly copies session state from one connection to another, for use
         * in TLS session resumption. This is not normally needed, but may be
         * used when the same session needs to be used between different
         * endpoints, as is required by some protocols, such as FTP over TLS.
         * `source` should have already completed a handshake and, since TLS 1.3,
         * it should have been used to read data at least once. `conn` should not
         * have completed a handshake.
         *
         * It is not possible to know whether a call to this function will
         * actually do anything. Because session resumption is normally used
         * only for performance benefit, the TLS backend might not implement
         * this function. Even if implemented, it may not actually succeed in
         * allowing `conn` to resume `source'`s TLS session, because the server
         * may not have sent a session resumption token to `source,` or it may
         * refuse to accept the token from `conn`. There is no way to know
         * whether a call to this function is actually successful.
         *
         * Using this function is not required to benefit from session
         * resumption. If the TLS backend supports session resumption, the
         * session will be resumed automatically if it is possible to do so
         * without weakening the privacy guarantees normally provided by TLS,
         * without need to call this function. For example, with TLS 1.3,
         * a session ticket will be automatically copied from any
         * #GTlsClientConnection that has previously received session tickets
         * from the server, provided a ticket is available that has not
         * previously been used for session resumption, since session ticket
         * reuse would be a privacy weakness. Using this function causes the
         * ticket to be copied without regard for privacy considerations.
         * @param source a #GTlsClientConnection
         */
        copy_session_state(source: TlsClientConnection): void;
        /**
         * Gets the list of distinguished names of the Certificate Authorities
         * that the server will accept certificates from. This will be set
         * during the TLS handshake if the server requests a certificate.
         * Otherwise, it will be %NULL.
         *
         * Each item in the list is a #GByteArray which contains the complete
         * subject DN of the certificate authority.
         * @returns the list of CA DNs. You should unref each element with g_byte_array_unref() and then the free the list with g_list_free().
         */
        get_accepted_cas(): GLib.List[];
        /**
         * Gets `conn'`s expected server identity
         * @returns a #GSocketConnectable describing the expected server identity, or %NULL if the expected identity is not known.
         */
        get_server_identity(): SocketConnectable | null;
        /**
         * SSL 3.0 is no longer supported. See
         * g_tls_client_connection_set_use_ssl3() for details.
         * @returns %FALSE
         */
        get_use_ssl3(): boolean;
        /**
         * Gets `conn'`s validation flags
         *
         * This function does not work as originally designed and is impossible
         * to use correctly. See #GTlsClientConnection:validation-flags for more
         * information.
         * @returns the validation flags
         */
        get_validation_flags(): TlsCertificateFlags;
        /**
         * Sets `conn'`s expected server identity, which is used both to tell
         * servers on virtual hosts which certificate to present, and also
         * to let `conn` know what name to look for in the certificate when
         * performing %G_TLS_CERTIFICATE_BAD_IDENTITY validation, if enabled.
         * @param identity a #GSocketConnectable describing the expected server identity
         */
        set_server_identity(identity: SocketConnectable): void;
        /**
         * Since GLib 2.42.1, SSL 3.0 is no longer supported.
         *
         * From GLib 2.42.1 through GLib 2.62, this function could be used to
         * force use of TLS 1.0, the lowest-supported TLS protocol version at
         * the time. In the past, this was needed to connect to broken TLS
         * servers that exhibited protocol version intolerance. Such servers
         * are no longer common, and using TLS 1.0 is no longer considered
         * acceptable.
         *
         * Since GLib 2.64, this function does nothing.
         * @param use_ssl3 a #gboolean, ignored
         */
        set_use_ssl3(use_ssl3: boolean): void;
        /**
         * Sets `conn'`s validation flags, to override the default set of
         * checks performed when validating a server certificate. By default,
         * %G_TLS_CERTIFICATE_VALIDATE_ALL is used.
         *
         * This function does not work as originally designed and is impossible
         * to use correctly. See #GTlsClientConnection:validation-flags for more
         * information.
         * @param flags the #GTlsCertificateFlags to use
         */
        set_validation_flags(flags: TlsCertificateFlags): void;

        // Own virtual methods of Gio-2.0.Gio.TlsClientConnection

        /**
         * Possibly copies session state from one connection to another, for use
         * in TLS session resumption. This is not normally needed, but may be
         * used when the same session needs to be used between different
         * endpoints, as is required by some protocols, such as FTP over TLS.
         * `source` should have already completed a handshake and, since TLS 1.3,
         * it should have been used to read data at least once. `conn` should not
         * have completed a handshake.
         *
         * It is not possible to know whether a call to this function will
         * actually do anything. Because session resumption is normally used
         * only for performance benefit, the TLS backend might not implement
         * this function. Even if implemented, it may not actually succeed in
         * allowing `conn` to resume `source'`s TLS session, because the server
         * may not have sent a session resumption token to `source,` or it may
         * refuse to accept the token from `conn`. There is no way to know
         * whether a call to this function is actually successful.
         *
         * Using this function is not required to benefit from session
         * resumption. If the TLS backend supports session resumption, the
         * session will be resumed automatically if it is possible to do so
         * without weakening the privacy guarantees normally provided by TLS,
         * without need to call this function. For example, with TLS 1.3,
         * a session ticket will be automatically copied from any
         * #GTlsClientConnection that has previously received session tickets
         * from the server, provided a ticket is available that has not
         * previously been used for session resumption, since session ticket
         * reuse would be a privacy weakness. Using this function causes the
         * ticket to be copied without regard for privacy considerations.
         * @virtual
         * @param source a #GTlsClientConnection
         */
        vfunc_copy_session_state(source: TlsClientConnection): void;

        // Class property signals of Gio-2.0.Gio.TlsClientConnection

        connect(
            sigName: 'notify::accepted-cas',
            callback: (
                $obj: TlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::accepted-cas',
            callback: (
                $obj: TlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::accepted-cas', ...args: any[]): void;
        connect(
            sigName: 'notify::server-identity',
            callback: (
                $obj: TlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::server-identity',
            callback: (
                $obj: TlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::server-identity', ...args: any[]): void;
        connect(
            sigName: 'notify::use-ssl3',
            callback: (
                $obj: TlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::use-ssl3',
            callback: (
                $obj: TlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::use-ssl3', ...args: any[]): void;
        connect(
            sigName: 'notify::validation-flags',
            callback: (
                $obj: TlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::validation-flags',
            callback: (
                $obj: TlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::validation-flags', ...args: any[]): void;
        connect(
            sigName: 'notify::advertised-protocols',
            callback: (
                $obj: TlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::advertised-protocols',
            callback: (
                $obj: TlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::advertised-protocols', ...args: any[]): void;
        connect(
            sigName: 'notify::base-io-stream',
            callback: (
                $obj: TlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::base-io-stream',
            callback: (
                $obj: TlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::base-io-stream', ...args: any[]): void;
        connect(
            sigName: 'notify::certificate',
            callback: (
                $obj: TlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::certificate',
            callback: (
                $obj: TlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::certificate', ...args: any[]): void;
        connect(
            sigName: 'notify::ciphersuite-name',
            callback: (
                $obj: TlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::ciphersuite-name',
            callback: (
                $obj: TlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::ciphersuite-name', ...args: any[]): void;
        connect(
            sigName: 'notify::database',
            callback: (
                $obj: TlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::database',
            callback: (
                $obj: TlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::database', ...args: any[]): void;
        connect(
            sigName: 'notify::interaction',
            callback: (
                $obj: TlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::interaction',
            callback: (
                $obj: TlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::interaction', ...args: any[]): void;
        connect(
            sigName: 'notify::negotiated-protocol',
            callback: (
                $obj: TlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::negotiated-protocol',
            callback: (
                $obj: TlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::negotiated-protocol', ...args: any[]): void;
        connect(
            sigName: 'notify::peer-certificate',
            callback: (
                $obj: TlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::peer-certificate',
            callback: (
                $obj: TlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::peer-certificate', ...args: any[]): void;
        connect(
            sigName: 'notify::peer-certificate-errors',
            callback: (
                $obj: TlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::peer-certificate-errors',
            callback: (
                $obj: TlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::peer-certificate-errors', ...args: any[]): void;
        connect(
            sigName: 'notify::protocol-version',
            callback: (
                $obj: TlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::protocol-version',
            callback: (
                $obj: TlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::protocol-version', ...args: any[]): void;
        connect(
            sigName: 'notify::rehandshake-mode',
            callback: (
                $obj: TlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::rehandshake-mode',
            callback: (
                $obj: TlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::rehandshake-mode', ...args: any[]): void;
        connect(
            sigName: 'notify::require-close-notify',
            callback: (
                $obj: TlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::require-close-notify',
            callback: (
                $obj: TlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::require-close-notify', ...args: any[]): void;
        connect(
            sigName: 'notify::use-system-certdb',
            callback: (
                $obj: TlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::use-system-certdb',
            callback: (
                $obj: TlsClientConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::use-system-certdb', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GTlsClientConnection is the client-side subclass of
     * #GTlsConnection, representing a client-side TLS connection.
     * @interface
     */
    class TlsClientConnection extends GObject.Object {
        // Own properties of Gio-2.0.Gio.TlsClientConnection

        static name: string;
        static $gtype: GObject.GType<TlsClientConnection>;

        // Constructors of Gio-2.0.Gio.TlsClientConnection

        constructor(config?: TlsClientConnection.ConstructorProperties);
        _init(config?: TlsClientConnection.ConstructorProperties): void;
        /**
         * Creates a new #GTlsClientConnection wrapping `base_io_stream` (which
         * must have pollable input and output streams) which is assumed to
         * communicate with the server identified by `server_identity`.
         *
         * See the documentation for #GTlsConnection:base-io-stream for restrictions
         * on when application code can run operations on the `base_io_stream` after
         * this function has returned.
         * @param base_io_stream the #GIOStream to wrap
         * @param server_identity the expected identity of the server
         * @returns the new #GTlsClientConnection, or %NULL on error
         */
        static new(
            base_io_stream: IOStream,
            server_identity: SocketConnectable | null
        ): TlsClientConnection;
    }

    namespace TlsFileDatabase {
        // Constructor properties interface

        interface ConstructorProperties
            extends TlsDatabase.ConstructorProperties,
                GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.TlsFileDatabase

            /**
             * The path to a file containing PEM encoded certificate authority
             * root anchors. The certificates in this file will be treated as
             * root authorities for the purpose of verifying other certificates
             * via the g_tls_database_verify_chain() operation.
             */
            anchors?: string | null;
        }
    }

    interface TlsFileDatabase extends TlsDatabase {
        // Own properties of Gio-2.0.Gio.TlsFileDatabase

        /**
         * The path to a file containing PEM encoded certificate authority
         * root anchors. The certificates in this file will be treated as
         * root authorities for the purpose of verifying other certificates
         * via the g_tls_database_verify_chain() operation.
         */
        anchors: string | null;

        // Class property signals of Gio-2.0.Gio.TlsFileDatabase

        connect(
            sigName: 'notify::anchors',
            callback: ($obj: TlsFileDatabase, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::anchors',
            callback: ($obj: TlsFileDatabase, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::anchors', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GTlsFileDatabase is implemented by #GTlsDatabase objects which load
     * their certificate information from a file. It is an interface which
     * TLS library specific subtypes implement.
     * @interface
     */
    class TlsFileDatabase extends GObject.Object {
        // Own properties of Gio-2.0.Gio.TlsFileDatabase

        static name: string;
        static $gtype: GObject.GType<TlsFileDatabase>;

        // Constructors of Gio-2.0.Gio.TlsFileDatabase

        constructor(config?: TlsFileDatabase.ConstructorProperties);
        _init(config?: TlsFileDatabase.ConstructorProperties): void;
        /**
         * Creates a new #GTlsFileDatabase which uses anchor certificate authorities
         * in `anchors` to verify certificate chains.
         *
         * The certificates in `anchors` must be PEM encoded.
         * @param anchors filename of anchor certificate authorities.
         * @returns the new #GTlsFileDatabase, or %NULL on error
         */
        static new(anchors: string): TlsFileDatabase;
    }

    namespace TlsServerConnection {
        // Constructor properties interface

        interface ConstructorProperties
            extends TlsConnection.ConstructorProperties,
                GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.TlsServerConnection

            /**
             * The #GTlsAuthenticationMode for the server. This can be changed
             * before calling g_tls_connection_handshake() if you want to
             * rehandshake with a different mode from the initial handshake.
             */
            authentication_mode?: TlsAuthenticationMode | null;
        }
    }

    interface TlsServerConnection extends TlsConnection {
        // Own properties of Gio-2.0.Gio.TlsServerConnection

        /**
         * The #GTlsAuthenticationMode for the server. This can be changed
         * before calling g_tls_connection_handshake() if you want to
         * rehandshake with a different mode from the initial handshake.
         */
        authentication_mode: TlsAuthenticationMode;

        // Conflicting properties

        parent_instance: IOStream & GObject.Object & GObject.Object;

        // Class property signals of Gio-2.0.Gio.TlsServerConnection

        connect(
            sigName: 'notify::authentication-mode',
            callback: (
                $obj: TlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::authentication-mode',
            callback: (
                $obj: TlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::authentication-mode', ...args: any[]): void;
        connect(
            sigName: 'notify::advertised-protocols',
            callback: (
                $obj: TlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::advertised-protocols',
            callback: (
                $obj: TlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::advertised-protocols', ...args: any[]): void;
        connect(
            sigName: 'notify::base-io-stream',
            callback: (
                $obj: TlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::base-io-stream',
            callback: (
                $obj: TlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::base-io-stream', ...args: any[]): void;
        connect(
            sigName: 'notify::certificate',
            callback: (
                $obj: TlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::certificate',
            callback: (
                $obj: TlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::certificate', ...args: any[]): void;
        connect(
            sigName: 'notify::ciphersuite-name',
            callback: (
                $obj: TlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::ciphersuite-name',
            callback: (
                $obj: TlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::ciphersuite-name', ...args: any[]): void;
        connect(
            sigName: 'notify::database',
            callback: (
                $obj: TlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::database',
            callback: (
                $obj: TlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::database', ...args: any[]): void;
        connect(
            sigName: 'notify::interaction',
            callback: (
                $obj: TlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::interaction',
            callback: (
                $obj: TlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::interaction', ...args: any[]): void;
        connect(
            sigName: 'notify::negotiated-protocol',
            callback: (
                $obj: TlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::negotiated-protocol',
            callback: (
                $obj: TlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::negotiated-protocol', ...args: any[]): void;
        connect(
            sigName: 'notify::peer-certificate',
            callback: (
                $obj: TlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::peer-certificate',
            callback: (
                $obj: TlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::peer-certificate', ...args: any[]): void;
        connect(
            sigName: 'notify::peer-certificate-errors',
            callback: (
                $obj: TlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::peer-certificate-errors',
            callback: (
                $obj: TlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::peer-certificate-errors', ...args: any[]): void;
        connect(
            sigName: 'notify::protocol-version',
            callback: (
                $obj: TlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::protocol-version',
            callback: (
                $obj: TlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::protocol-version', ...args: any[]): void;
        connect(
            sigName: 'notify::rehandshake-mode',
            callback: (
                $obj: TlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::rehandshake-mode',
            callback: (
                $obj: TlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::rehandshake-mode', ...args: any[]): void;
        connect(
            sigName: 'notify::require-close-notify',
            callback: (
                $obj: TlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::require-close-notify',
            callback: (
                $obj: TlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::require-close-notify', ...args: any[]): void;
        connect(
            sigName: 'notify::use-system-certdb',
            callback: (
                $obj: TlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::use-system-certdb',
            callback: (
                $obj: TlsServerConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::use-system-certdb', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GTlsServerConnection is the server-side subclass of #GTlsConnection,
     * representing a server-side TLS connection.
     * @interface
     */
    class TlsServerConnection extends GObject.Object {
        // Own properties of Gio-2.0.Gio.TlsServerConnection

        static name: string;
        static $gtype: GObject.GType<TlsServerConnection>;

        // Constructors of Gio-2.0.Gio.TlsServerConnection

        constructor(config?: TlsServerConnection.ConstructorProperties);
        _init(config?: TlsServerConnection.ConstructorProperties): void;
        /**
         * Creates a new #GTlsServerConnection wrapping `base_io_stream` (which
         * must have pollable input and output streams).
         *
         * See the documentation for #GTlsConnection:base-io-stream for restrictions
         * on when application code can run operations on the `base_io_stream` after
         * this function has returned.
         * @param base_io_stream the #GIOStream to wrap
         * @param certificate the default server certificate, or %NULL
         * @returns the new #GTlsServerConnection, or %NULL on error
         */
        static new(
            base_io_stream: IOStream,
            certificate: TlsCertificate | null
        ): TlsServerConnection;
    }

    namespace Volume {
        // Signal callback interfaces

        /**
         * Signal callback interface for `changed`
         */
        interface ChangedSignalCallback {
            ($obj: Volume): void;
        }

        /**
         * Signal callback interface for `removed`
         */
        interface RemovedSignalCallback {
            ($obj: Volume): void;
        }

        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface Volume {
        // Owm methods of Gio-2.0.Gio.Volume

        /**
         * Checks if a volume can be ejected.
         * @returns %TRUE if the @volume can be ejected. %FALSE otherwise
         */
        can_eject(): boolean;
        /**
         * Checks if a volume can be mounted.
         * @returns %TRUE if the @volume can be mounted. %FALSE otherwise
         */
        can_mount(): boolean;
        /**
         * Ejects a volume. This is an asynchronous operation, and is
         * finished by calling g_volume_eject_finish() with the `volume`
         * and #GAsyncResult returned in the `callback`.
         * @param flags flags affecting the unmount if required for eject
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback, or %NULL
         */
        eject(
            flags: MountUnmountFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes ejecting a volume. If any errors occurred during the operation,
         * `error` will be set to contain the errors and %FALSE will be returned.
         * @param result a #GAsyncResult
         * @returns %TRUE, %FALSE if operation failed
         */
        eject_finish(result: AsyncResult): boolean;
        /**
         * Ejects a volume. This is an asynchronous operation, and is
         * finished by calling g_volume_eject_with_operation_finish() with the `volume`
         * and #GAsyncResult data returned in the `callback`.
         * @param flags flags affecting the unmount if required for eject
         * @param mount_operation a #GMountOperation or %NULL to     avoid user interaction
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback, or %NULL
         */
        eject_with_operation(
            flags: MountUnmountFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes ejecting a volume. If any errors occurred during the operation,
         * `error` will be set to contain the errors and %FALSE will be returned.
         * @param result a #GAsyncResult
         * @returns %TRUE if the volume was successfully ejected. %FALSE otherwise
         */
        eject_with_operation_finish(result: AsyncResult): boolean;
        /**
         * Gets the kinds of [identifiers][volume-identifier] that `volume` has.
         * Use g_volume_get_identifier() to obtain the identifiers themselves.
         * @returns a %NULL-terminated array   of strings containing kinds of identifiers. Use g_strfreev() to free.
         */
        enumerate_identifiers(): string[];
        /**
         * Gets the activation root for a #GVolume if it is known ahead of
         * mount time. Returns %NULL otherwise. If not %NULL and if `volume`
         * is mounted, then the result of g_mount_get_root() on the
         * #GMount object obtained from g_volume_get_mount() will always
         * either be equal or a prefix of what this function returns. In
         * other words, in code
         *
         *
         * ```c
         *   GMount *mount;
         *   GFile *mount_root
         *   GFile *volume_activation_root;
         *
         *   mount = g_volume_get_mount (volume); // mounted, so never NULL
         *   mount_root = g_mount_get_root (mount);
         *   volume_activation_root = g_volume_get_activation_root (volume); // assume not NULL
         * ```
         *
         * then the expression
         *
         * ```c
         *   (g_file_has_prefix (volume_activation_root, mount_root) ||
         *    g_file_equal (volume_activation_root, mount_root))
         * ```
         *
         * will always be %TRUE.
         *
         * Activation roots are typically used in #GVolumeMonitor
         * implementations to find the underlying mount to shadow, see
         * g_mount_is_shadowed() for more details.
         * @returns the activation root of @volume     or %NULL. Use g_object_unref() to free.
         */
        get_activation_root(): File | null;
        /**
         * Gets the drive for the `volume`.
         * @returns a #GDrive or %NULL if @volume is not     associated with a drive. The returned object should be unreffed     with g_object_unref() when no longer needed.
         */
        get_drive(): Drive | null;
        /**
         * Gets the icon for `volume`.
         * @returns a #GIcon.     The returned object should be unreffed with g_object_unref()     when no longer needed.
         */
        get_icon(): Icon;
        /**
         * Gets the identifier of the given kind for `volume`.
         * See the [introduction][volume-identifier] for more
         * information about volume identifiers.
         * @param kind the kind of identifier to return
         * @returns a newly allocated string containing the     requested identifier, or %NULL if the #GVolume     doesn't have this kind of identifier
         */
        get_identifier(kind: string | null): string | null;
        /**
         * Gets the mount for the `volume`.
         * @returns a #GMount or %NULL if @volume isn't mounted.     The returned object should be unreffed with g_object_unref()     when no longer needed.
         */
        get_mount(): Mount | null;
        /**
         * Gets the name of `volume`.
         * @returns the name for the given @volume. The returned string should     be freed with g_free() when no longer needed.
         */
        get_name(): string | null;
        /**
         * Gets the sort key for `volume,` if any.
         * @returns Sorting key for @volume or %NULL if no such key is available
         */
        get_sort_key(): string | null;
        /**
         * Gets the symbolic icon for `volume`.
         * @returns a #GIcon.     The returned object should be unreffed with g_object_unref()     when no longer needed.
         */
        get_symbolic_icon(): Icon;
        /**
         * Gets the UUID for the `volume`. The reference is typically based on
         * the file system UUID for the volume in question and should be
         * considered an opaque string. Returns %NULL if there is no UUID
         * available.
         * @returns the UUID for @volume or %NULL if no UUID     can be computed.     The returned string should be freed with g_free()     when no longer needed.
         */
        get_uuid(): string | null;
        /**
         * Mounts a volume. This is an asynchronous operation, and is
         * finished by calling g_volume_mount_finish() with the `volume`
         * and #GAsyncResult returned in the `callback`.
         * @param flags flags affecting the operation
         * @param mount_operation a #GMountOperation or %NULL to avoid user interaction
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback, or %NULL
         */
        mount(
            flags: MountMountFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes mounting a volume. If any errors occurred during the operation,
         * `error` will be set to contain the errors and %FALSE will be returned.
         *
         * If the mount operation succeeded, g_volume_get_mount() on `volume`
         * is guaranteed to return the mount right after calling this
         * function; there's no need to listen for the 'mount-added' signal on
         * #GVolumeMonitor.
         * @param result a #GAsyncResult
         * @returns %TRUE, %FALSE if operation failed
         */
        mount_finish(result: AsyncResult): boolean;
        /**
         * Returns whether the volume should be automatically mounted.
         * @returns %TRUE if the volume should be automatically mounted
         */
        should_automount(): boolean;

        // Own virtual methods of Gio-2.0.Gio.Volume

        /**
         * Checks if a volume can be ejected.
         * @virtual
         * @returns %TRUE if the @volume can be ejected. %FALSE otherwise
         */
        vfunc_can_eject(): boolean;
        /**
         * Checks if a volume can be mounted.
         * @virtual
         * @returns %TRUE if the @volume can be mounted. %FALSE otherwise
         */
        vfunc_can_mount(): boolean;
        vfunc_changed(): void;
        /**
         * Ejects a volume. This is an asynchronous operation, and is
         * finished by calling g_volume_eject_finish() with the `volume`
         * and #GAsyncResult returned in the `callback`.
         * @virtual
         * @param flags flags affecting the unmount if required for eject
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback, or %NULL
         */
        vfunc_eject(
            flags: MountUnmountFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes ejecting a volume. If any errors occurred during the operation,
         * `error` will be set to contain the errors and %FALSE will be returned.
         * @virtual
         * @param result a #GAsyncResult
         * @returns %TRUE, %FALSE if operation failed
         */
        vfunc_eject_finish(result: AsyncResult): boolean;
        /**
         * Ejects a volume. This is an asynchronous operation, and is
         * finished by calling g_volume_eject_with_operation_finish() with the `volume`
         * and #GAsyncResult data returned in the `callback`.
         * @virtual
         * @param flags flags affecting the unmount if required for eject
         * @param mount_operation a #GMountOperation or %NULL to     avoid user interaction
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback, or %NULL
         */
        vfunc_eject_with_operation(
            flags: MountUnmountFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes ejecting a volume. If any errors occurred during the operation,
         * `error` will be set to contain the errors and %FALSE will be returned.
         * @virtual
         * @param result a #GAsyncResult
         * @returns %TRUE if the volume was successfully ejected. %FALSE otherwise
         */
        vfunc_eject_with_operation_finish(result: AsyncResult): boolean;
        /**
         * Gets the kinds of [identifiers][volume-identifier] that `volume` has.
         * Use g_volume_get_identifier() to obtain the identifiers themselves.
         * @virtual
         * @returns a %NULL-terminated array   of strings containing kinds of identifiers. Use g_strfreev() to free.
         */
        vfunc_enumerate_identifiers(): string[];
        /**
         * Gets the activation root for a #GVolume if it is known ahead of
         * mount time. Returns %NULL otherwise. If not %NULL and if `volume`
         * is mounted, then the result of g_mount_get_root() on the
         * #GMount object obtained from g_volume_get_mount() will always
         * either be equal or a prefix of what this function returns. In
         * other words, in code
         *
         *
         * ```c
         *   GMount *mount;
         *   GFile *mount_root
         *   GFile *volume_activation_root;
         *
         *   mount = g_volume_get_mount (volume); // mounted, so never NULL
         *   mount_root = g_mount_get_root (mount);
         *   volume_activation_root = g_volume_get_activation_root (volume); // assume not NULL
         * ```
         *
         * then the expression
         *
         * ```c
         *   (g_file_has_prefix (volume_activation_root, mount_root) ||
         *    g_file_equal (volume_activation_root, mount_root))
         * ```
         *
         * will always be %TRUE.
         *
         * Activation roots are typically used in #GVolumeMonitor
         * implementations to find the underlying mount to shadow, see
         * g_mount_is_shadowed() for more details.
         * @virtual
         * @returns the activation root of @volume     or %NULL. Use g_object_unref() to free.
         */
        vfunc_get_activation_root(): File | null;
        /**
         * Gets the drive for the `volume`.
         * @virtual
         * @returns a #GDrive or %NULL if @volume is not     associated with a drive. The returned object should be unreffed     with g_object_unref() when no longer needed.
         */
        vfunc_get_drive(): Drive | null;
        /**
         * Gets the icon for `volume`.
         * @virtual
         * @returns a #GIcon.     The returned object should be unreffed with g_object_unref()     when no longer needed.
         */
        vfunc_get_icon(): Icon;
        /**
         * Gets the identifier of the given kind for `volume`.
         * See the [introduction][volume-identifier] for more
         * information about volume identifiers.
         * @virtual
         * @param kind the kind of identifier to return
         * @returns a newly allocated string containing the     requested identifier, or %NULL if the #GVolume     doesn't have this kind of identifier
         */
        vfunc_get_identifier(kind: string | null): string | null;
        /**
         * Gets the mount for the `volume`.
         * @virtual
         * @returns a #GMount or %NULL if @volume isn't mounted.     The returned object should be unreffed with g_object_unref()     when no longer needed.
         */
        vfunc_get_mount(): Mount | null;
        /**
         * Gets the name of `volume`.
         * @virtual
         * @returns the name for the given @volume. The returned string should     be freed with g_free() when no longer needed.
         */
        vfunc_get_name(): string | null;
        /**
         * Gets the sort key for `volume,` if any.
         * @virtual
         * @returns Sorting key for @volume or %NULL if no such key is available
         */
        vfunc_get_sort_key(): string | null;
        /**
         * Gets the symbolic icon for `volume`.
         * @virtual
         * @returns a #GIcon.     The returned object should be unreffed with g_object_unref()     when no longer needed.
         */
        vfunc_get_symbolic_icon(): Icon;
        /**
         * Gets the UUID for the `volume`. The reference is typically based on
         * the file system UUID for the volume in question and should be
         * considered an opaque string. Returns %NULL if there is no UUID
         * available.
         * @virtual
         * @returns the UUID for @volume or %NULL if no UUID     can be computed.     The returned string should be freed with g_free()     when no longer needed.
         */
        vfunc_get_uuid(): string | null;
        /**
         * Finishes mounting a volume. If any errors occurred during the operation,
         * `error` will be set to contain the errors and %FALSE will be returned.
         *
         * If the mount operation succeeded, g_volume_get_mount() on `volume`
         * is guaranteed to return the mount right after calling this
         * function; there's no need to listen for the 'mount-added' signal on
         * #GVolumeMonitor.
         * @virtual
         * @param result a #GAsyncResult
         * @returns %TRUE, %FALSE if operation failed
         */
        vfunc_mount_finish(result: AsyncResult): boolean;
        /**
         * Mounts a volume. This is an asynchronous operation, and is
         * finished by calling g_volume_mount_finish() with the `volume`
         * and #GAsyncResult returned in the `callback`.
         * @virtual
         * @param flags flags affecting the operation
         * @param mount_operation a #GMountOperation or %NULL to avoid user interaction
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback, or %NULL
         */
        vfunc_mount_fn(
            flags: MountMountFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        vfunc_removed(): void;
        /**
         * Returns whether the volume should be automatically mounted.
         * @virtual
         * @returns %TRUE if the volume should be automatically mounted
         */
        vfunc_should_automount(): boolean;

        // Own signals of Gio-2.0.Gio.Volume

        connect(
            sigName: 'changed',
            callback: Volume.ChangedSignalCallback
        ): number;
        connect_after(
            sigName: 'changed',
            callback: Volume.ChangedSignalCallback
        ): number;
        emit(sigName: 'changed', ...args: any[]): void;
        connect(
            sigName: 'removed',
            callback: Volume.RemovedSignalCallback
        ): number;
        connect_after(
            sigName: 'removed',
            callback: Volume.RemovedSignalCallback
        ): number;
        emit(sigName: 'removed', ...args: any[]): void;

        // Class property signals of Gio-2.0.Gio.Volume

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * The #GVolume interface represents user-visible objects that can be
     * mounted. Note, when porting from GnomeVFS, #GVolume is the moral
     * equivalent of #GnomeVFSDrive.
     *
     * Mounting a #GVolume instance is an asynchronous operation. For more
     * information about asynchronous operations, see #GAsyncResult and
     * #GTask. To mount a #GVolume, first call g_volume_mount() with (at
     * least) the #GVolume instance, optionally a #GMountOperation object
     * and a #GAsyncReadyCallback.
     *
     * Typically, one will only want to pass %NULL for the
     * #GMountOperation if automounting all volumes when a desktop session
     * starts since it's not desirable to put up a lot of dialogs asking
     * for credentials.
     *
     * The callback will be fired when the operation has resolved (either
     * with success or failure), and a #GAsyncResult instance will be
     * passed to the callback.  That callback should then call
     * g_volume_mount_finish() with the #GVolume instance and the
     * #GAsyncResult data to see if the operation was completed
     * successfully.  If an `error` is present when g_volume_mount_finish()
     * is called, then it will be filled with any error information.
     *
     * ## Volume Identifiers # {#volume-identifier}
     *
     * It is sometimes necessary to directly access the underlying
     * operating system object behind a volume (e.g. for passing a volume
     * to an application via the commandline). For this purpose, GIO
     * allows to obtain an 'identifier' for the volume. There can be
     * different kinds of identifiers, such as Hal UDIs, filesystem labels,
     * traditional Unix devices (e.g. `/dev/sda2`), UUIDs. GIO uses predefined
     * strings as names for the different kinds of identifiers:
     * %G_VOLUME_IDENTIFIER_KIND_UUID, %G_VOLUME_IDENTIFIER_KIND_LABEL, etc.
     * Use g_volume_get_identifier() to obtain an identifier for a volume.
     *
     *
     * Note that %G_VOLUME_IDENTIFIER_KIND_HAL_UDI will only be available
     * when the gvfs hal volume monitor is in use. Other volume monitors
     * will generally be able to provide the %G_VOLUME_IDENTIFIER_KIND_UNIX_DEVICE
     * identifier, which can be used to obtain a hal device by means of
     * libhal_manager_find_device_string_match().
     * @interface
     */
    class Volume extends GObject.Object {
        // Own properties of Gio-2.0.Gio.Volume

        static name: string;
        static $gtype: GObject.GType<Volume>;

        // Constructors of Gio-2.0.Gio.Volume

        constructor(config?: Volume.ConstructorProperties);
        _init(config?: Volume.ConstructorProperties): void;
    }

    // See https://gitlab.gnome.org/GNOME/gjs/-/blob/master/modules/core/overrides/Gio.js
    export const DBus: {
        readonly session: DBusConnection;
        readonly system: DBusConnection;
        get(
            bus_type: BusType,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback | null
        ): void;
        get_finish(res: AsyncResult): DBusConnection;
        get_sync(
            bus_type: BusType,
            cancellable?: Cancellable | null
        ): DBusConnection;
        own_name(
            bus_type: BusType,
            name: string,
            flags: BusNameOwnerFlags,
            bus_acquired_closure?: GObject.Closure | null,
            name_acquired_closure?: GObject.Closure | null,
            name_lost_closure?: GObject.Closure | null
        ): number;
        own_name_on_connection(
            connection: DBusConnection,
            name: string,
            flags: BusNameOwnerFlags,
            name_acquired_closure?: GObject.Closure | null,
            name_lost_closure?: GObject.Closure | null
        ): number;
        unown_name(owner_id: number): void;
        watch_name(
            bus_type: BusType,
            name: string,
            flags: BusNameWatcherFlags,
            name_appeared_closure?: GObject.Closure | null,
            name_vanished_closure?: GObject.Closure | null
        ): number;
        unwatch_name(watcher_id: number): void;
        watch_name_on_connection(
            connection: DBusConnection,
            name: string,
            flags: BusNameWatcherFlags,
            name_appeared_closure?: GObject.Closure | null,
            name_vanished_closure?: GObject.Closure | null
        ): number;
    };

    export namespace DBusExportedObject {
        export interface ConstructorProperties {
            [key: string]: any;
        }
    }

    // See https://gitlab.gnome.org/GNOME/gjs/-/blob/master/modules/core/overrides/Gio.js
    export class DBusExportedObject {
        static $gtype: GObject.GType<DBusExportedObject>;

        constructor(
            properties?: Partial<DBusExportedObject.ConstructorProperties>,
            ...args: any[]
        );
        _init(
            properties?: Partial<DBusExportedObject.ConstructorProperties>,
            ...args: any[]
        ): void;

        static wrapJSObject(info: string, obj: any): DBusExportedObject;
        get_info(): DBusInterfaceInfo;
        get_connection(): DBusConnection;
        get_object_path(): string;
        unexport_from_connection(connection: DBusConnection): void;
        ['export'](busConnection: DBusConnection, objectPath: string): void;
        unexport(): void;
        flush(): void;
        emit_signal(name: string, variant: GLib.Variant): void;
        emit_property_changed(name: string, variant: GLib.Variant): void;
    }

    /**
     * A convenient helper to create Promise wrappers for asynchronous functions in GJS.
     *
     * This utility replaces the original function on the class prototype with a Promise-based version,
     * allowing the function to be called on any instance of the class, including subclasses.
     * Simply pass the class prototype, the "async" function name, and the "finish" function name as arguments.
     *
     * The function can be used like any other Promise, without the need for a custom wrapper, by leaving out the callback argument.
     * The original function will still be available, and can be used by passing the callback.
     *
     * @param proto - The class prototype that contains the asynchronous function.
     * @param asyncFunc - The name of the asynchronous function.
     * @param finishFunc - The name of the "finish" function that is used to retrieve the result of the asynchronous function.
     *
     * @version Gjs 1.54
     * @see https://gjs.guide/guides/gjs/asynchronous-programming.html#promisify-helper
     *
     * @example
     * ```js
     * import Gio from "gi://Gio?version=2.0";
     *
     * Gio._promisify(Gio.InputStream.prototype, 'read_bytes_async', 'read_bytes_finish');
     *
     * try {
     *    const inputStream = new Gio.UnixInputStream({fd: 0});
     *    const bytes = await inputStream.read_bytes_async(4096, GLib.PRIORITY_DEFAULT, null);
     * } catch (e) {
     *    logError(e, 'Failed to read bytes');
     * }
     * ```
     *
     */
    export function _promisify(
        proto: any,
        asyncFunc: string,
        finishFunc?: string
    ): void;

    /** Temporary Gio.File.prototype fix */
    export const _LocalFilePrototype: typeof File.prototype;

    namespace AppInfoMonitor {
        // Signal callback interfaces

        /**
         * Signal callback interface for `changed`
         */
        interface ChangedSignalCallback {
            ($obj: AppInfoMonitor): void;
        }

        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface AppInfoMonitor {
        // Own signals of Gio-2.0.Gio.AppInfoMonitor

        connect(
            sigName: 'changed',
            callback: AppInfoMonitor.ChangedSignalCallback
        ): number;
        connect_after(
            sigName: 'changed',
            callback: AppInfoMonitor.ChangedSignalCallback
        ): number;
        emit(sigName: 'changed', ...args: any[]): void;

        // Class property signals of Gio-2.0.Gio.AppInfoMonitor

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GAppInfoMonitor is a very simple object used for monitoring the app
     * info database for changes (newly installed or removed applications).
     *
     * Call g_app_info_monitor_get() to get a #GAppInfoMonitor and connect
     * to the #GAppInfoMonitor::changed signal. The signal will be emitted once when
     * the app info database changes, and will not be emitted again until after the
     * next call to g_app_info_get_all() or another `g_app_info_*()` function. This
     * is because monitoring the app info database for changes is expensive.
     *
     * The following functions will re-arm the #GAppInfoMonitor::changed signal so
     * it can be emitted again:
     *  - g_app_info_get_all()
     *  - g_app_info_get_all_for_type()
     *  - g_app_info_get_default_for_type()
     *  - g_app_info_get_fallback_for_type()
     *  - g_app_info_get_recommended_for_type()
     *  - g_desktop_app_info_get_implementations()
     *  - g_desktop_app_info_new()
     *  - g_desktop_app_info_new_from_filename()
     *  - g_desktop_app_info_new_from_keyfile()
     *  - g_desktop_app_info_search()
     *
     * In the usual case, applications should try to make note of the change
     * (doing things like invalidating caches) but not act on it.  In
     * particular, applications should avoid making calls to #GAppInfo APIs
     * in response to the change signal, deferring these until the time that
     * the updated data is actually required.  The exception to this case is when
     * application information is actually being displayed on the screen
     * (for example, during a search or when the list of all applications is shown).
     * The reason for this is that changes to the list of installed
     * applications often come in groups (like during system updates) and
     * rescanning the list on every change is pointless and expensive.
     * @class
     */
    class AppInfoMonitor extends GObject.Object {
        // Own properties of Gio-2.0.Gio.AppInfoMonitor

        static name: string;
        static $gtype: GObject.GType<AppInfoMonitor>;

        // Constructors of Gio-2.0.Gio.AppInfoMonitor

        constructor(config?: AppInfoMonitor.ConstructorProperties);
        _init(config?: AppInfoMonitor.ConstructorProperties): void;
        /**
         * Gets the #GAppInfoMonitor for the current thread-default main
         * context.
         *
         * The #GAppInfoMonitor will emit a "changed" signal in the
         * thread-default main context whenever the list of installed
         * applications (as reported by g_app_info_get_all()) may have changed.
         *
         * The #GAppInfoMonitor::changed signal will only be emitted once until
         * g_app_info_get_all() (or another `g_app_info_*()` function) is called. Doing
         * so will re-arm the signal ready to notify about the next change.
         *
         * You must only call g_object_unref() on the return value from under
         * the same main context as you created it.
         * @returns a reference to a #GAppInfoMonitor
         */
        static get(): AppInfoMonitor;
    }

    namespace AppLaunchContext {
        // Signal callback interfaces

        /**
         * Signal callback interface for `launch-failed`
         */
        interface LaunchFailedSignalCallback {
            ($obj: AppLaunchContext, startup_notify_id: string | null): void;
        }

        /**
         * Signal callback interface for `launch-started`
         */
        interface LaunchStartedSignalCallback {
            (
                $obj: AppLaunchContext,
                info: AppInfo,
                platform_data: GLib.Variant | null
            ): void;
        }

        /**
         * Signal callback interface for `launched`
         */
        interface LaunchedSignalCallback {
            (
                $obj: AppLaunchContext,
                info: AppInfo,
                platform_data: GLib.Variant
            ): void;
        }

        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface AppLaunchContext {
        // Own fields of Gio-2.0.Gio.AppLaunchContext

        parent_instance: GObject.Object;

        // Owm methods of Gio-2.0.Gio.AppLaunchContext

        /**
         * Gets the display string for the `context`. This is used to ensure new
         * applications are started on the same display as the launching
         * application, by setting the `DISPLAY` environment variable.
         * @param info a #GAppInfo
         * @param files a #GList of #GFile objects
         * @returns a display string for the display.
         */
        get_display(info: AppInfo, files: File[]): string | null;
        /**
         * Gets the complete environment variable list to be passed to
         * the child process when `context` is used to launch an application.
         * This is a %NULL-terminated array of strings, where each string has
         * the form `KEY=VALUE`.
         * @returns      the child's environment
         */
        get_environment(): string[];
        /**
         * Initiates startup notification for the application and returns the
         * `XDG_ACTIVATION_TOKEN` or `DESKTOP_STARTUP_ID` for the launched operation,
         * if supported.
         *
         * The returned token may be referred to equivalently as an activation token
         * (using Wayland terminology) or a startup sequence ID (using X11 terminology).
         * The two [are interoperable](https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/staging/xdg-activation/x11-interoperation.rst).
         *
         * Activation tokens are defined in the [XDG Activation Protocol](https://wayland.app/protocols/xdg-activation-v1),
         * and startup notification IDs are defined in the
         * [freedesktop.org Startup Notification Protocol](http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt).
         *
         * Support for the XDG Activation Protocol was added in GLib 2.76.
         * @param info a #GAppInfo
         * @param files a #GList of #GFile objects
         * @returns a startup notification ID for the application, or %NULL if     not supported.
         */
        get_startup_notify_id(info: AppInfo, files: File[]): string | null;
        /**
         * Called when an application has failed to launch, so that it can cancel
         * the application startup notification started in g_app_launch_context_get_startup_notify_id().
         * @param startup_notify_id the startup notification id that was returned by g_app_launch_context_get_startup_notify_id().
         */
        launch_failed(startup_notify_id: string | null): void;
        /**
         * Arranges for `variable` to be set to `value` in the child's
         * environment when `context` is used to launch an application.
         * @param variable the environment variable to set
         * @param value the value for to set the variable to.
         */
        setenv(variable: string, value: string): void;
        /**
         * Arranges for `variable` to be unset in the child's environment
         * when `context` is used to launch an application.
         * @param variable the environment variable to remove
         */
        unsetenv(variable: string): void;

        // Own virtual methods of Gio-2.0.Gio.AppLaunchContext

        /**
         * Gets the display string for the `context`. This is used to ensure new
         * applications are started on the same display as the launching
         * application, by setting the `DISPLAY` environment variable.
         * @virtual
         * @param info a #GAppInfo
         * @param files a #GList of #GFile objects
         * @returns a display string for the display.
         */
        vfunc_get_display(info: AppInfo, files: File[]): string | null;
        /**
         * Initiates startup notification for the application and returns the
         * `XDG_ACTIVATION_TOKEN` or `DESKTOP_STARTUP_ID` for the launched operation,
         * if supported.
         *
         * The returned token may be referred to equivalently as an activation token
         * (using Wayland terminology) or a startup sequence ID (using X11 terminology).
         * The two [are interoperable](https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/staging/xdg-activation/x11-interoperation.rst).
         *
         * Activation tokens are defined in the [XDG Activation Protocol](https://wayland.app/protocols/xdg-activation-v1),
         * and startup notification IDs are defined in the
         * [freedesktop.org Startup Notification Protocol](http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt).
         *
         * Support for the XDG Activation Protocol was added in GLib 2.76.
         * @virtual
         * @param info a #GAppInfo
         * @param files a #GList of #GFile objects
         * @returns a startup notification ID for the application, or %NULL if     not supported.
         */
        vfunc_get_startup_notify_id(
            info: AppInfo,
            files: File[]
        ): string | null;
        /**
         * Called when an application has failed to launch, so that it can cancel
         * the application startup notification started in g_app_launch_context_get_startup_notify_id().
         * @virtual
         * @param startup_notify_id the startup notification id that was returned by g_app_launch_context_get_startup_notify_id().
         */
        vfunc_launch_failed(startup_notify_id: string | null): void;
        vfunc_launch_started(info: AppInfo, platform_data: GLib.Variant): void;
        vfunc_launched(info: AppInfo, platform_data: GLib.Variant): void;

        // Own signals of Gio-2.0.Gio.AppLaunchContext

        connect(
            sigName: 'launch-failed',
            callback: AppLaunchContext.LaunchFailedSignalCallback
        ): number;
        connect_after(
            sigName: 'launch-failed',
            callback: AppLaunchContext.LaunchFailedSignalCallback
        ): number;
        emit(
            sigName: 'launch-failed',
            startup_notify_id: string | null,
            ...args: any[]
        ): void;
        connect(
            sigName: 'launch-started',
            callback: AppLaunchContext.LaunchStartedSignalCallback
        ): number;
        connect_after(
            sigName: 'launch-started',
            callback: AppLaunchContext.LaunchStartedSignalCallback
        ): number;
        emit(
            sigName: 'launch-started',
            info: AppInfo,
            platform_data: GLib.Variant | null,
            ...args: any[]
        ): void;
        connect(
            sigName: 'launched',
            callback: AppLaunchContext.LaunchedSignalCallback
        ): number;
        connect_after(
            sigName: 'launched',
            callback: AppLaunchContext.LaunchedSignalCallback
        ): number;
        emit(
            sigName: 'launched',
            info: AppInfo,
            platform_data: GLib.Variant,
            ...args: any[]
        ): void;

        // Class property signals of Gio-2.0.Gio.AppLaunchContext

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * Integrating the launch with the launching application. This is used to
     * handle for instance startup notification and launching the new application
     * on the same screen as the launching window.
     * @class
     */
    class AppLaunchContext extends GObject.Object {
        // Own properties of Gio-2.0.Gio.AppLaunchContext

        static name: string;
        static $gtype: GObject.GType<AppLaunchContext>;

        // Constructors of Gio-2.0.Gio.AppLaunchContext

        constructor(config?: AppLaunchContext.ConstructorProperties);
        /**
         * Creates a new application launch context. This is not normally used,
         * instead you instantiate a subclass of this, such as #GdkAppLaunchContext.
         * @constructor
         * @returns a #GAppLaunchContext.
         */
        constructor();
        /**
         * Creates a new application launch context. This is not normally used,
         * instead you instantiate a subclass of this, such as #GdkAppLaunchContext.
         * @constructor
         * @returns a #GAppLaunchContext.
         */
        static new(): AppLaunchContext;
        _init(config?: AppLaunchContext.ConstructorProperties): void;
    }

    namespace Application {
        // Signal callback interfaces

        /**
         * Signal callback interface for `activate`
         */
        interface ActivateSignalCallback {
            ($obj: Application): void;
        }

        /**
         * Signal callback interface for `command-line`
         */
        interface CommandLineSignalCallback {
            ($obj: Application, command_line: ApplicationCommandLine): number;
        }

        /**
         * Signal callback interface for `handle-local-options`
         */
        interface HandleLocalOptionsSignalCallback {
            ($obj: Application, options: GLib.VariantDict): number;
        }

        /**
         * Signal callback interface for `name-lost`
         */
        interface NameLostSignalCallback {
            ($obj: Application): boolean;
        }

        /**
         * Signal callback interface for `open`
         */
        interface OpenSignalCallback {
            ($obj: Application, files: File[], hint: string | null): void;
        }

        /**
         * Signal callback interface for `shutdown`
         */
        interface ShutdownSignalCallback {
            ($obj: Application): void;
        }

        /**
         * Signal callback interface for `startup`
         */
        interface StartupSignalCallback {
            ($obj: Application): void;
        }

        // Constructor properties interface

        interface ConstructorProperties
            extends ActionGroup.ConstructorProperties,
                ActionMap.ConstructorProperties,
                GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.Application

            action_group?: ActionGroup | null;
            application_id?: string | null;
            flags?: ApplicationFlags | null;
            inactivity_timeout?: number | null;
            resource_base_path?: string | null;
        }
    }

    interface Application extends ActionGroup, ActionMap {
        // Own properties of Gio-2.0.Gio.Application

        action_group: ActionGroup;
        application_id: string | null;
        flags: ApplicationFlags;
        inactivity_timeout: number;
        /**
         * Whether the application is currently marked as busy through
         * g_application_mark_busy() or g_application_bind_busy_property().
         */
        readonly is_busy: boolean;
        readonly is_registered: boolean;
        readonly is_remote: boolean;
        resource_base_path: string | null;

        // Owm methods of Gio-2.0.Gio.Application

        /**
         * Activates the application.
         *
         * In essence, this results in the #GApplication::activate signal being
         * emitted in the primary instance.
         *
         * The application must be registered before calling this function.
         */
        activate(): void;
        /**
         * Add an option to be handled by `application`.
         *
         * Calling this function is the equivalent of calling
         * g_application_add_main_option_entries() with a single #GOptionEntry
         * that has its arg_data member set to %NULL.
         *
         * The parsed arguments will be packed into a #GVariantDict which
         * is passed to #GApplication::handle-local-options. If
         * %G_APPLICATION_HANDLES_COMMAND_LINE is set, then it will also
         * be sent to the primary instance. See
         * g_application_add_main_option_entries() for more details.
         *
         * See #GOptionEntry for more documentation of the arguments.
         * @param long_name the long name of an option used to specify it in a commandline
         * @param short_name the short name of an option
         * @param flags flags from #GOptionFlags
         * @param arg the type of the option, as a #GOptionArg
         * @param description the description for the option in `--help` output
         * @param arg_description the placeholder to use for the extra argument    parsed by the option in `--help` output
         */
        add_main_option(
            long_name: string | null,
            short_name: number,
            flags: GLib.OptionFlags,
            arg: GLib.OptionArg,
            description: string | null,
            arg_description: string | null
        ): void;
        /**
         * Adds main option entries to be handled by `application`.
         *
         * This function is comparable to g_option_context_add_main_entries().
         *
         * After the commandline arguments are parsed, the
         * #GApplication::handle-local-options signal will be emitted.  At this
         * point, the application can inspect the values pointed to by `arg_data`
         * in the given #GOptionEntrys.
         *
         * Unlike #GOptionContext, #GApplication supports giving a %NULL
         * `arg_data` for a non-callback #GOptionEntry.  This results in the
         * argument in question being packed into a #GVariantDict which is also
         * passed to #GApplication::handle-local-options, where it can be
         * inspected and modified.  If %G_APPLICATION_HANDLES_COMMAND_LINE is
         * set, then the resulting dictionary is sent to the primary instance,
         * where g_application_command_line_get_options_dict() will return it.
         * As it has been passed outside the process at this point, the types of all
         * values in the options dict must be checked before being used.
         * This "packing" is done according to the type of the argument --
         * booleans for normal flags, strings for strings, bytestrings for
         * filenames, etc.  The packing only occurs if the flag is given (ie: we
         * do not pack a "false" #GVariant in the case that a flag is missing).
         *
         * In general, it is recommended that all commandline arguments are
         * parsed locally.  The options dictionary should then be used to
         * transmit the result of the parsing to the primary instance, where
         * g_variant_dict_lookup() can be used.  For local options, it is
         * possible to either use `arg_data` in the usual way, or to consult (and
         * potentially remove) the option from the options dictionary.
         *
         * This function is new in GLib 2.40.  Before then, the only real choice
         * was to send all of the commandline arguments (options and all) to the
         * primary instance for handling.  #GApplication ignored them completely
         * on the local side.  Calling this function "opts in" to the new
         * behaviour, and in particular, means that unrecognised options will be
         * treated as errors.  Unrecognised options have never been ignored when
         * %G_APPLICATION_HANDLES_COMMAND_LINE is unset.
         *
         * If #GApplication::handle-local-options needs to see the list of
         * filenames, then the use of %G_OPTION_REMAINING is recommended.  If
         * `arg_data` is %NULL then %G_OPTION_REMAINING can be used as a key into
         * the options dictionary.  If you do use %G_OPTION_REMAINING then you
         * need to handle these arguments for yourself because once they are
         * consumed, they will no longer be visible to the default handling
         * (which treats them as filenames to be opened).
         *
         * It is important to use the proper GVariant format when retrieving
         * the options with g_variant_dict_lookup():
         * - for %G_OPTION_ARG_NONE, use `b`
         * - for %G_OPTION_ARG_STRING, use `&s`
         * - for %G_OPTION_ARG_INT, use `i`
         * - for %G_OPTION_ARG_INT64, use `x`
         * - for %G_OPTION_ARG_DOUBLE, use `d`
         * - for %G_OPTION_ARG_FILENAME, use `^&ay`
         * - for %G_OPTION_ARG_STRING_ARRAY, use `^a&s`
         * - for %G_OPTION_ARG_FILENAME_ARRAY, use `^a&ay`
         * @param entries a           %NULL-terminated list of #GOptionEntrys
         */
        add_main_option_entries(entries: GLib.OptionEntry[]): void;
        /**
         * Adds a #GOptionGroup to the commandline handling of `application`.
         *
         * This function is comparable to g_option_context_add_group().
         *
         * Unlike g_application_add_main_option_entries(), this function does
         * not deal with %NULL `arg_data` and never transmits options to the
         * primary instance.
         *
         * The reason for that is because, by the time the options arrive at the
         * primary instance, it is typically too late to do anything with them.
         * Taking the GTK option group as an example: GTK will already have been
         * initialised by the time the #GApplication::command-line handler runs.
         * In the case that this is not the first-running instance of the
         * application, the existing instance may already have been running for
         * a very long time.
         *
         * This means that the options from #GOptionGroup are only really usable
         * in the case that the instance of the application being run is the
         * first instance.  Passing options like `--display=` or `--gdk-debug=`
         * on future runs will have no effect on the existing primary instance.
         *
         * Calling this function will cause the options in the supplied option
         * group to be parsed, but it does not cause you to be "opted in" to the
         * new functionality whereby unrecognised options are rejected even if
         * %G_APPLICATION_HANDLES_COMMAND_LINE was given.
         * @param group a #GOptionGroup
         */
        add_option_group(group: GLib.OptionGroup): void;
        /**
         * Marks `application` as busy (see g_application_mark_busy()) while
         * `property` on `object` is %TRUE.
         *
         * The binding holds a reference to `application` while it is active, but
         * not to `object`. Instead, the binding is destroyed when `object` is
         * finalized.
         * @param object a #GObject
         * @param property the name of a boolean property of `object`
         */
        bind_busy_property(
            object: GObject.Object,
            property: string | null
        ): void;
        /**
         * Gets the unique identifier for `application`.
         * @returns the identifier for @application, owned by @application
         */
        get_application_id(): string | null;
        /**
         * Gets the #GDBusConnection being used by the application, or %NULL.
         *
         * If #GApplication is using its D-Bus backend then this function will
         * return the #GDBusConnection being used for uniqueness and
         * communication with the desktop environment and other instances of the
         * application.
         *
         * If #GApplication is not using D-Bus then this function will return
         * %NULL.  This includes the situation where the D-Bus backend would
         * normally be in use but we were unable to connect to the bus.
         *
         * This function must not be called before the application has been
         * registered.  See g_application_get_is_registered().
         * @returns a #GDBusConnection, or %NULL
         */
        get_dbus_connection(): DBusConnection | null;
        /**
         * Gets the D-Bus object path being used by the application, or %NULL.
         *
         * If #GApplication is using its D-Bus backend then this function will
         * return the D-Bus object path that #GApplication is using.  If the
         * application is the primary instance then there is an object published
         * at this path.  If the application is not the primary instance then
         * the result of this function is undefined.
         *
         * If #GApplication is not using D-Bus then this function will return
         * %NULL.  This includes the situation where the D-Bus backend would
         * normally be in use but we were unable to connect to the bus.
         *
         * This function must not be called before the application has been
         * registered.  See g_application_get_is_registered().
         * @returns the object path, or %NULL
         */
        get_dbus_object_path(): string | null;
        /**
         * Gets the flags for `application`.
         *
         * See #GApplicationFlags.
         * @returns the flags for @application
         */
        get_flags(): ApplicationFlags;
        /**
         * Gets the current inactivity timeout for the application.
         *
         * This is the amount of time (in milliseconds) after the last call to
         * g_application_release() before the application stops running.
         * @returns the timeout, in milliseconds
         */
        get_inactivity_timeout(): number;
        /**
         * Gets the application's current busy state, as set through
         * g_application_mark_busy() or g_application_bind_busy_property().
         * @returns %TRUE if @application is currently marked as busy
         */
        get_is_busy(): boolean;
        /**
         * Checks if `application` is registered.
         *
         * An application is registered if g_application_register() has been
         * successfully called.
         * @returns %TRUE if @application is registered
         */
        get_is_registered(): boolean;
        /**
         * Checks if `application` is remote.
         *
         * If `application` is remote then it means that another instance of
         * application already exists (the 'primary' instance).  Calls to
         * perform actions on `application` will result in the actions being
         * performed by the primary instance.
         *
         * The value of this property cannot be accessed before
         * g_application_register() has been called.  See
         * g_application_get_is_registered().
         * @returns %TRUE if @application is remote
         */
        get_is_remote(): boolean;
        /**
         * Gets the resource base path of `application`.
         *
         * See g_application_set_resource_base_path() for more information.
         * @returns the base resource path, if one is set
         */
        get_resource_base_path(): string | null;
        /**
         * Increases the use count of `application`.
         *
         * Use this function to indicate that the application has a reason to
         * continue to run.  For example, g_application_hold() is called by GTK
         * when a toplevel window is on the screen.
         *
         * To cancel the hold, call g_application_release().
         */
        hold(): void;
        /**
         * Increases the busy count of `application`.
         *
         * Use this function to indicate that the application is busy, for instance
         * while a long running operation is pending.
         *
         * The busy state will be exposed to other processes, so a session shell will
         * use that information to indicate the state to the user (e.g. with a
         * spinner).
         *
         * To cancel the busy indication, use g_application_unmark_busy().
         *
         * The application must be registered before calling this function.
         */
        mark_busy(): void;
        /**
         * Opens the given files.
         *
         * In essence, this results in the #GApplication::open signal being emitted
         * in the primary instance.
         *
         * `n_files` must be greater than zero.
         *
         * `hint` is simply passed through to the ::open signal.  It is
         * intended to be used by applications that have multiple modes for
         * opening files (eg: "view" vs "edit", etc).  Unless you have a need
         * for this functionality, you should use "".
         *
         * The application must be registered before calling this function
         * and it must have the %G_APPLICATION_HANDLES_OPEN flag set.
         * @param files an array of #GFiles to open
         * @param hint a hint (or ""), but never %NULL
         */
        open(files: File[], hint: string | null): void;
        /**
         * Immediately quits the application.
         *
         * Upon return to the mainloop, g_application_run() will return,
         * calling only the 'shutdown' function before doing so.
         *
         * The hold count is ignored.
         * Take care if your code has called g_application_hold() on the application and
         * is therefore still expecting it to exist.
         * (Note that you may have called g_application_hold() indirectly, for example
         * through gtk_application_add_window().)
         *
         * The result of calling g_application_run() again after it returns is
         * unspecified.
         */
        quit(): void;
        /**
         * Attempts registration of the application.
         *
         * This is the point at which the application discovers if it is the
         * primary instance or merely acting as a remote for an already-existing
         * primary instance.  This is implemented by attempting to acquire the
         * application identifier as a unique bus name on the session bus using
         * GDBus.
         *
         * If there is no application ID or if %G_APPLICATION_NON_UNIQUE was
         * given, then this process will always become the primary instance.
         *
         * Due to the internal architecture of GDBus, method calls can be
         * dispatched at any time (even if a main loop is not running).  For
         * this reason, you must ensure that any object paths that you wish to
         * register are registered before calling this function.
         *
         * If the application has already been registered then %TRUE is
         * returned with no work performed.
         *
         * The #GApplication::startup signal is emitted if registration succeeds
         * and `application` is the primary instance (including the non-unique
         * case).
         *
         * In the event of an error (such as `cancellable` being cancelled, or a
         * failure to connect to the session bus), %FALSE is returned and `error`
         * is set appropriately.
         *
         * Note: the return value of this function is not an indicator that this
         * instance is or is not the primary instance of the application.  See
         * g_application_get_is_remote() for that.
         * @param cancellable a #GCancellable, or %NULL
         * @returns %TRUE if registration succeeded
         */
        register(cancellable: Cancellable | null): boolean;
        /**
         * Decrease the use count of `application`.
         *
         * When the use count reaches zero, the application will stop running.
         *
         * Never call this function except to cancel the effect of a previous
         * call to g_application_hold().
         */
        release(): void;
        /**
         * Runs the application.
         *
         * This function is intended to be run from main() and its return value
         * is intended to be returned by main(). Although you are expected to pass
         * the `argc,` `argv` parameters from main() to this function, it is possible
         * to pass %NULL if `argv` is not available or commandline handling is not
         * required.  Note that on Windows, `argc` and `argv` are ignored, and
         * g_win32_get_command_line() is called internally (for proper support
         * of Unicode commandline arguments).
         *
         * #GApplication will attempt to parse the commandline arguments.  You
         * can add commandline flags to the list of recognised options by way of
         * g_application_add_main_option_entries().  After this, the
         * #GApplication::handle-local-options signal is emitted, from which the
         * application can inspect the values of its #GOptionEntrys.
         *
         * #GApplication::handle-local-options is a good place to handle options
         * such as `--version`, where an immediate reply from the local process is
         * desired (instead of communicating with an already-running instance).
         * A #GApplication::handle-local-options handler can stop further processing
         * by returning a non-negative value, which then becomes the exit status of
         * the process.
         *
         * What happens next depends on the flags: if
         * %G_APPLICATION_HANDLES_COMMAND_LINE was specified then the remaining
         * commandline arguments are sent to the primary instance, where a
         * #GApplication::command-line signal is emitted.  Otherwise, the
         * remaining commandline arguments are assumed to be a list of files.
         * If there are no files listed, the application is activated via the
         * #GApplication::activate signal.  If there are one or more files, and
         * %G_APPLICATION_HANDLES_OPEN was specified then the files are opened
         * via the #GApplication::open signal.
         *
         * If you are interested in doing more complicated local handling of the
         * commandline then you should implement your own #GApplication subclass
         * and override local_command_line(). In this case, you most likely want
         * to return %TRUE from your local_command_line() implementation to
         * suppress the default handling. See
         * [gapplication-example-cmdline2.c][https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline2.c]
         * for an example.
         *
         * If, after the above is done, the use count of the application is zero
         * then the exit status is returned immediately.  If the use count is
         * non-zero then the default main context is iterated until the use count
         * falls to zero, at which point 0 is returned.
         *
         * If the %G_APPLICATION_IS_SERVICE flag is set, then the service will
         * run for as much as 10 seconds with a use count of zero while waiting
         * for the message that caused the activation to arrive.  After that,
         * if the use count falls to zero the application will exit immediately,
         * except in the case that g_application_set_inactivity_timeout() is in
         * use.
         *
         * This function sets the prgname (g_set_prgname()), if not already set,
         * to the basename of argv[0].
         *
         * Much like g_main_loop_run(), this function will acquire the main context
         * for the duration that the application is running.
         *
         * Since 2.40, applications that are not explicitly flagged as services
         * or launchers (ie: neither %G_APPLICATION_IS_SERVICE or
         * %G_APPLICATION_IS_LAUNCHER are given as flags) will check (from the
         * default handler for local_command_line) if "--gapplication-service"
         * was given in the command line.  If this flag is present then normal
         * commandline processing is interrupted and the
         * %G_APPLICATION_IS_SERVICE flag is set.  This provides a "compromise"
         * solution whereby running an application directly from the commandline
         * will invoke it in the normal way (which can be useful for debugging)
         * while still allowing applications to be D-Bus activated in service
         * mode.  The D-Bus service file should invoke the executable with
         * "--gapplication-service" as the sole commandline argument.  This
         * approach is suitable for use by most graphical applications but
         * should not be used from applications like editors that need precise
         * control over when processes invoked via the commandline will exit and
         * what their exit status will be.
         * @param argv      the argv from main(), or %NULL
         * @returns the exit status
         */
        run(argv: string[] | null): number;
        /**
         * Sends a notification on behalf of `application` to the desktop shell.
         * There is no guarantee that the notification is displayed immediately,
         * or even at all.
         *
         * Notifications may persist after the application exits. It will be
         * D-Bus-activated when the notification or one of its actions is
         * activated.
         *
         * Modifying `notification` after this call has no effect. However, the
         * object can be reused for a later call to this function.
         *
         * `id` may be any string that uniquely identifies the event for the
         * application. It does not need to be in any special format. For
         * example, "new-message" might be appropriate for a notification about
         * new messages.
         *
         * If a previous notification was sent with the same `id,` it will be
         * replaced with `notification` and shown again as if it was a new
         * notification. This works even for notifications sent from a previous
         * execution of the application, as long as `id` is the same string.
         *
         * `id` may be %NULL, but it is impossible to replace or withdraw
         * notifications without an id.
         *
         * If `notification` is no longer relevant, it can be withdrawn with
         * g_application_withdraw_notification().
         * @param id id of the notification, or %NULL
         * @param notification the #GNotification to send
         */
        send_notification(id: string | null, notification: Notification): void;
        /**
         * This used to be how actions were associated with a #GApplication.
         * Now there is #GActionMap for that.
         * @param action_group a #GActionGroup, or %NULL
         */
        set_action_group(action_group: ActionGroup | null): void;
        /**
         * Sets the unique identifier for `application`.
         *
         * The application id can only be modified if `application` has not yet
         * been registered.
         *
         * If non-%NULL, the application id must be valid.  See
         * g_application_id_is_valid().
         * @param application_id the identifier for `application`
         */
        set_application_id(application_id: string | null): void;
        /**
         * Sets or unsets the default application for the process, as returned
         * by g_application_get_default().
         *
         * This function does not take its own reference on `application`.  If
         * `application` is destroyed then the default application will revert
         * back to %NULL.
         */
        set_default(): void;
        /**
         * Sets the flags for `application`.
         *
         * The flags can only be modified if `application` has not yet been
         * registered.
         *
         * See #GApplicationFlags.
         * @param flags the flags for `application`
         */
        set_flags(flags: ApplicationFlags): void;
        /**
         * Sets the current inactivity timeout for the application.
         *
         * This is the amount of time (in milliseconds) after the last call to
         * g_application_release() before the application stops running.
         *
         * This call has no side effects of its own.  The value set here is only
         * used for next time g_application_release() drops the use count to
         * zero.  Any timeouts currently in progress are not impacted.
         * @param inactivity_timeout the timeout, in milliseconds
         */
        set_inactivity_timeout(inactivity_timeout: number): void;
        /**
         * Adds a description to the `application` option context.
         *
         * See g_option_context_set_description() for more information.
         * @param description a string to be shown in `--help` output  after the list of options, or %NULL
         */
        set_option_context_description(description: string | null): void;
        /**
         * Sets the parameter string to be used by the commandline handling of `application`.
         *
         * This function registers the argument to be passed to g_option_context_new()
         * when the internal #GOptionContext of `application` is created.
         *
         * See g_option_context_new() for more information about `parameter_string`.
         * @param parameter_string a string which is displayed   in the first line of `--help` output, after the usage summary `programname [OPTION...]`.
         */
        set_option_context_parameter_string(
            parameter_string: string | null
        ): void;
        /**
         * Adds a summary to the `application` option context.
         *
         * See g_option_context_set_summary() for more information.
         * @param summary a string to be shown in `--help` output  before the list of options, or %NULL
         */
        set_option_context_summary(summary: string | null): void;
        /**
         * Sets (or unsets) the base resource path of `application`.
         *
         * The path is used to automatically load various [application
         * resources][gresource] such as menu layouts and action descriptions.
         * The various types of resources will be found at fixed names relative
         * to the given base path.
         *
         * By default, the resource base path is determined from the application
         * ID by prefixing '/' and replacing each '.' with '/'.  This is done at
         * the time that the #GApplication object is constructed.  Changes to
         * the application ID after that point will not have an impact on the
         * resource base path.
         *
         * As an example, if the application has an ID of "org.example.app" then
         * the default resource base path will be "/org/example/app".  If this
         * is a #GtkApplication (and you have not manually changed the path)
         * then Gtk will then search for the menus of the application at
         * "/org/example/app/gtk/menus.ui".
         *
         * See #GResource for more information about adding resources to your
         * application.
         *
         * You can disable automatic resource loading functionality by setting
         * the path to %NULL.
         *
         * Changing the resource base path once the application is running is
         * not recommended.  The point at which the resource path is consulted
         * for forming paths for various purposes is unspecified.  When writing
         * a sub-class of #GApplication you should either set the
         * #GApplication:resource-base-path property at construction time, or call
         * this function during the instance initialization. Alternatively, you
         * can call this function in the #GApplicationClass.startup virtual function,
         * before chaining up to the parent implementation.
         * @param resource_path the resource path to use
         */
        set_resource_base_path(resource_path: string | null): void;
        /**
         * Destroys a binding between `property` and the busy state of
         * `application` that was previously created with
         * g_application_bind_busy_property().
         * @param object a #GObject
         * @param property the name of a boolean property of `object`
         */
        unbind_busy_property(
            object: GObject.Object,
            property: string | null
        ): void;
        /**
         * Decreases the busy count of `application`.
         *
         * When the busy count reaches zero, the new state will be propagated
         * to other processes.
         *
         * This function must only be called to cancel the effect of a previous
         * call to g_application_mark_busy().
         */
        unmark_busy(): void;
        /**
         * Withdraws a notification that was sent with
         * g_application_send_notification().
         *
         * This call does nothing if a notification with `id` doesn't exist or
         * the notification was never sent.
         *
         * This function works even for notifications sent in previous
         * executions of this application, as long `id` is the same as it was for
         * the sent notification.
         *
         * Note that notifications are dismissed when the user clicks on one
         * of the buttons in a notification or triggers its default action, so
         * there is no need to explicitly withdraw the notification in that case.
         * @param id id of a previously sent notification
         */
        withdraw_notification(id: string | null): void;

        // Own virtual methods of Gio-2.0.Gio.Application

        /**
         * Activates the application.
         *
         * In essence, this results in the #GApplication::activate signal being
         * emitted in the primary instance.
         *
         * The application must be registered before calling this function.
         * @virtual
         */
        vfunc_activate(): void;
        vfunc_add_platform_data(builder: GLib.VariantBuilder): void;
        vfunc_after_emit(platform_data: GLib.Variant): void;
        vfunc_before_emit(platform_data: GLib.Variant): void;
        vfunc_command_line(command_line: ApplicationCommandLine): number;
        vfunc_dbus_register(
            connection: DBusConnection,
            object_path: string | null
        ): boolean;
        vfunc_dbus_unregister(
            connection: DBusConnection,
            object_path: string | null
        ): void;
        vfunc_handle_local_options(options: GLib.VariantDict): number;
        /**
         * This virtual function is always invoked in the local instance. It
         * gets passed a pointer to a %NULL-terminated copy of `argv` and is
         * expected to remove arguments that it handled (shifting up remaining
         * arguments).
         *
         * The last argument to local_command_line() is a pointer to the `status`
         * variable which can used to set the exit status that is returned from
         * g_application_run().
         *
         * See g_application_run() for more details on #GApplication startup.
         * @virtual
         * @param arguments_ array of command line arguments
         * @returns %TRUE if the commandline has been completely handled
         */
        vfunc_local_command_line(
            arguments_: string[]
        ): [
            /* returnType */ boolean,
            /* arguments_ */ string[],
            /* exit_status */ number
        ];
        vfunc_name_lost(): boolean;
        /**
         * Opens the given files.
         *
         * In essence, this results in the #GApplication::open signal being emitted
         * in the primary instance.
         *
         * `n_files` must be greater than zero.
         *
         * `hint` is simply passed through to the ::open signal.  It is
         * intended to be used by applications that have multiple modes for
         * opening files (eg: "view" vs "edit", etc).  Unless you have a need
         * for this functionality, you should use "".
         *
         * The application must be registered before calling this function
         * and it must have the %G_APPLICATION_HANDLES_OPEN flag set.
         * @virtual
         * @param files an array of #GFiles to open
         * @param hint a hint (or ""), but never %NULL
         */
        vfunc_open(files: File[], hint: string | null): void;
        vfunc_quit_mainloop(): void;
        vfunc_run_mainloop(): void;
        vfunc_shutdown(): void;
        vfunc_startup(): void;

        // Own signals of Gio-2.0.Gio.Application

        connect(
            sigName: 'activate',
            callback: Application.ActivateSignalCallback
        ): number;
        connect_after(
            sigName: 'activate',
            callback: Application.ActivateSignalCallback
        ): number;
        emit(sigName: 'activate', ...args: any[]): void;
        connect(
            sigName: 'command-line',
            callback: Application.CommandLineSignalCallback
        ): number;
        connect_after(
            sigName: 'command-line',
            callback: Application.CommandLineSignalCallback
        ): number;
        emit(
            sigName: 'command-line',
            command_line: ApplicationCommandLine,
            ...args: any[]
        ): void;
        connect(
            sigName: 'handle-local-options',
            callback: Application.HandleLocalOptionsSignalCallback
        ): number;
        connect_after(
            sigName: 'handle-local-options',
            callback: Application.HandleLocalOptionsSignalCallback
        ): number;
        emit(
            sigName: 'handle-local-options',
            options: GLib.VariantDict,
            ...args: any[]
        ): void;
        connect(
            sigName: 'name-lost',
            callback: Application.NameLostSignalCallback
        ): number;
        connect_after(
            sigName: 'name-lost',
            callback: Application.NameLostSignalCallback
        ): number;
        emit(sigName: 'name-lost', ...args: any[]): void;
        connect(
            sigName: 'open',
            callback: Application.OpenSignalCallback
        ): number;
        connect_after(
            sigName: 'open',
            callback: Application.OpenSignalCallback
        ): number;
        emit(
            sigName: 'open',
            files: File[],
            hint: string | null,
            ...args: any[]
        ): void;
        connect(
            sigName: 'shutdown',
            callback: Application.ShutdownSignalCallback
        ): number;
        connect_after(
            sigName: 'shutdown',
            callback: Application.ShutdownSignalCallback
        ): number;
        emit(sigName: 'shutdown', ...args: any[]): void;
        connect(
            sigName: 'startup',
            callback: Application.StartupSignalCallback
        ): number;
        connect_after(
            sigName: 'startup',
            callback: Application.StartupSignalCallback
        ): number;
        emit(sigName: 'startup', ...args: any[]): void;

        // Class property signals of Gio-2.0.Gio.Application

        connect(
            sigName: 'notify::action-group',
            callback: ($obj: Application, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::action-group',
            callback: ($obj: Application, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::action-group', ...args: any[]): void;
        connect(
            sigName: 'notify::application-id',
            callback: ($obj: Application, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::application-id',
            callback: ($obj: Application, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::application-id', ...args: any[]): void;
        connect(
            sigName: 'notify::flags',
            callback: ($obj: Application, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::flags',
            callback: ($obj: Application, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::flags', ...args: any[]): void;
        connect(
            sigName: 'notify::inactivity-timeout',
            callback: ($obj: Application, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::inactivity-timeout',
            callback: ($obj: Application, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::inactivity-timeout', ...args: any[]): void;
        connect(
            sigName: 'notify::is-busy',
            callback: ($obj: Application, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::is-busy',
            callback: ($obj: Application, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::is-busy', ...args: any[]): void;
        connect(
            sigName: 'notify::is-registered',
            callback: ($obj: Application, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::is-registered',
            callback: ($obj: Application, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::is-registered', ...args: any[]): void;
        connect(
            sigName: 'notify::is-remote',
            callback: ($obj: Application, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::is-remote',
            callback: ($obj: Application, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::is-remote', ...args: any[]): void;
        connect(
            sigName: 'notify::resource-base-path',
            callback: ($obj: Application, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::resource-base-path',
            callback: ($obj: Application, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::resource-base-path', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * A #GApplication is the foundation of an application.  It wraps some
     * low-level platform-specific services and is intended to act as the
     * foundation for higher-level application classes such as
     * #GtkApplication or #MxApplication.  In general, you should not use
     * this class outside of a higher level framework.
     *
     * GApplication provides convenient life cycle management by maintaining
     * a "use count" for the primary application instance. The use count can
     * be changed using g_application_hold() and g_application_release(). If
     * it drops to zero, the application exits. Higher-level classes such as
     * #GtkApplication employ the use count to ensure that the application
     * stays alive as long as it has any opened windows.
     *
     * Another feature that GApplication (optionally) provides is process
     * uniqueness. Applications can make use of this functionality by
     * providing a unique application ID. If given, only one application
     * with this ID can be running at a time per session. The session
     * concept is platform-dependent, but corresponds roughly to a graphical
     * desktop login. When your application is launched again, its
     * arguments are passed through platform communication to the already
     * running program. The already running instance of the program is
     * called the "primary instance"; for non-unique applications this is
     * always the current instance. On Linux, the D-Bus session bus
     * is used for communication.
     *
     * The use of #GApplication differs from some other commonly-used
     * uniqueness libraries (such as libunique) in important ways. The
     * application is not expected to manually register itself and check
     * if it is the primary instance. Instead, the main() function of a
     * #GApplication should do very little more than instantiating the
     * application instance, possibly connecting signal handlers, then
     * calling g_application_run(). All checks for uniqueness are done
     * internally. If the application is the primary instance then the
     * startup signal is emitted and the mainloop runs. If the application
     * is not the primary instance then a signal is sent to the primary
     * instance and g_application_run() promptly returns. See the code
     * examples below.
     *
     * If used, the expected form of an application identifier is the
     * same as that of a
     * [D-Bus well-known bus name](https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus).
     * Examples include: `com.example.MyApp`, `org.example.internal_apps.Calculator`,
     * `org._7_zip.Archiver`.
     * For details on valid application identifiers, see g_application_id_is_valid().
     *
     * On Linux, the application identifier is claimed as a well-known bus name
     * on the user's session bus.  This means that the uniqueness of your
     * application is scoped to the current session.  It also means that your
     * application may provide additional services (through registration of other
     * object paths) at that bus name.  The registration of these object paths
     * should be done with the shared GDBus session bus.  Note that due to the
     * internal architecture of GDBus, method calls can be dispatched at any time
     * (even if a main loop is not running).  For this reason, you must ensure that
     * any object paths that you wish to register are registered before #GApplication
     * attempts to acquire the bus name of your application (which happens in
     * g_application_register()).  Unfortunately, this means that you cannot use
     * g_application_get_is_remote() to decide if you want to register object paths.
     *
     * GApplication also implements the #GActionGroup and #GActionMap
     * interfaces and lets you easily export actions by adding them with
     * g_action_map_add_action(). When invoking an action by calling
     * g_action_group_activate_action() on the application, it is always
     * invoked in the primary instance. The actions are also exported on
     * the session bus, and GIO provides the #GDBusActionGroup wrapper to
     * conveniently access them remotely. GIO provides a #GDBusMenuModel wrapper
     * for remote access to exported #GMenuModels.
     *
     * Note: Due to the fact that actions are exported on the session bus,
     * using `maybe` parameters is not supported, since D-Bus does not support
     * `maybe` types.
     *
     * There is a number of different entry points into a GApplication:
     *
     * - via 'Activate' (i.e. just starting the application)
     *
     * - via 'Open' (i.e. opening some files)
     *
     * - by handling a command-line
     *
     * - via activating an action
     *
     * The #GApplication::startup signal lets you handle the application
     * initialization for all of these in a single place.
     *
     * Regardless of which of these entry points is used to start the
     * application, GApplication passes some platform data from the
     * launching instance to the primary instance, in the form of a
     * #GVariant dictionary mapping strings to variants. To use platform
     * data, override the `before_emit` or `after_emit` virtual functions
     * in your #GApplication subclass. When dealing with
     * #GApplicationCommandLine objects, the platform data is
     * directly available via g_application_command_line_get_cwd(),
     * g_application_command_line_get_environ() and
     * g_application_command_line_get_platform_data().
     *
     * As the name indicates, the platform data may vary depending on the
     * operating system, but it always includes the current directory (key
     * "cwd"), and optionally the environment (ie the set of environment
     * variables and their values) of the calling process (key "environ").
     * The environment is only added to the platform data if the
     * %G_APPLICATION_SEND_ENVIRONMENT flag is set. #GApplication subclasses
     * can add their own platform data by overriding the `add_platform_data`
     * virtual function. For instance, #GtkApplication adds startup notification
     * data in this way.
     *
     * To parse commandline arguments you may handle the
     * #GApplication::command-line signal or override the local_command_line()
     * vfunc, to parse them in either the primary instance or the local instance,
     * respectively.
     *
     * For an example of opening files with a GApplication, see
     * [gapplication-example-open.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-open.c).
     *
     * For an example of using actions with GApplication, see
     * [gapplication-example-actions.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-actions.c).
     *
     * For an example of using extra D-Bus hooks with GApplication, see
     * [gapplication-example-dbushooks.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-dbushooks.c).
     * @class
     */
    class Application extends GObject.Object {
        // Own properties of Gio-2.0.Gio.Application

        static name: string;
        static $gtype: GObject.GType<Application>;

        // Constructors of Gio-2.0.Gio.Application

        constructor(config?: Application.ConstructorProperties);
        /**
         * Creates a new #GApplication instance.
         *
         * If non-%NULL, the application id must be valid.  See
         * g_application_id_is_valid().
         *
         * If no application ID is given then some features of #GApplication
         * (most notably application uniqueness) will be disabled.
         * @constructor
         * @param application_id the application id
         * @param flags the application flags
         * @returns a new #GApplication instance
         */
        constructor(application_id: string | null, flags: ApplicationFlags);
        /**
         * Creates a new #GApplication instance.
         *
         * If non-%NULL, the application id must be valid.  See
         * g_application_id_is_valid().
         *
         * If no application ID is given then some features of #GApplication
         * (most notably application uniqueness) will be disabled.
         * @constructor
         * @param application_id the application id
         * @param flags the application flags
         * @returns a new #GApplication instance
         */
        static new(
            application_id: string | null,
            flags: ApplicationFlags
        ): Application;
        _init(config?: Application.ConstructorProperties): void;
        /**
         * Returns the default #GApplication instance for this process.
         *
         * Normally there is only one #GApplication per process and it becomes
         * the default when it is created.  You can exercise more control over
         * this by using g_application_set_default().
         *
         * If there is no default application then %NULL is returned.
         * @returns the default application for this process, or %NULL
         */
        static get_default(): Application | null;
        /**
         * Checks if `application_id` is a valid application identifier.
         *
         * A valid ID is required for calls to g_application_new() and
         * g_application_set_application_id().
         *
         * Application identifiers follow the same format as
         * [D-Bus well-known bus names](https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus).
         * For convenience, the restrictions on application identifiers are
         * reproduced here:
         *
         * - Application identifiers are composed of 1 or more elements separated by a
         *   period (`.`) character. All elements must contain at least one character.
         *
         * - Each element must only contain the ASCII characters `[A-Z][a-z][0-9]_-`,
         *   with `-` discouraged in new application identifiers. Each element must not
         *   begin with a digit.
         *
         * - Application identifiers must contain at least one `.` (period) character
         *   (and thus at least two elements).
         *
         * - Application identifiers must not begin with a `.` (period) character.
         *
         * - Application identifiers must not exceed 255 characters.
         *
         * Note that the hyphen (`-`) character is allowed in application identifiers,
         * but is problematic or not allowed in various specifications and APIs that
         * refer to D-Bus, such as
         * [Flatpak application IDs](http://docs.flatpak.org/en/latest/introduction.html#identifiers),
         * the
         * [`DBusActivatable` interface in the Desktop Entry Specification](https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html#dbus),
         * and the convention that an application's "main" interface and object path
         * resemble its application identifier and bus name. To avoid situations that
         * require special-case handling, it is recommended that new application
         * identifiers consistently replace hyphens with underscores.
         *
         * Like D-Bus interface names, application identifiers should start with the
         * reversed DNS domain name of the author of the interface (in lower-case), and
         * it is conventional for the rest of the application identifier to consist of
         * words run together, with initial capital letters.
         *
         * As with D-Bus interface names, if the author's DNS domain name contains
         * hyphen/minus characters they should be replaced by underscores, and if it
         * contains leading digits they should be escaped by prepending an underscore.
         * For example, if the owner of 7-zip.org used an application identifier for an
         * archiving application, it might be named `org._7_zip.Archiver`.
         * @param application_id a potential application identifier
         * @returns %TRUE if @application_id is valid
         */
        static id_is_valid(application_id: string | null): boolean;
    }

    namespace ApplicationCommandLine {
        // Constructor properties interface

        interface ConstructorProperties
            extends GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.ApplicationCommandLine

            arguments?: GLib.Variant | null;
            options?: GLib.Variant | null;
            platform_data?: GLib.Variant | null;
        }
    }

    interface ApplicationCommandLine {
        // Own properties of Gio-2.0.Gio.ApplicationCommandLine

        readonly arguments: GLib.Variant;
        readonly is_remote: boolean;
        readonly options: GLib.Variant;
        readonly platform_data: GLib.Variant;

        // Owm methods of Gio-2.0.Gio.ApplicationCommandLine

        /**
         * Creates a #GFile corresponding to a filename that was given as part
         * of the invocation of `cmdline`.
         *
         * This differs from g_file_new_for_commandline_arg() in that it
         * resolves relative pathnames using the current working directory of
         * the invoking process rather than the local process.
         * @param arg an argument from `cmdline`
         * @returns a new #GFile
         */
        create_file_for_arg(arg: string): File;
        /**
         * Gets the list of arguments that was passed on the command line.
         *
         * The strings in the array may contain non-UTF-8 data on UNIX (such as
         * filenames or arguments given in the system locale) but are always in
         * UTF-8 on Windows.
         *
         * If you wish to use the return value with #GOptionContext, you must
         * use g_option_context_parse_strv().
         *
         * The return value is %NULL-terminated and should be freed using
         * g_strfreev().
         * @returns       the string array containing the arguments (the argv)
         */
        get_arguments(): string[];
        /**
         * Gets the working directory of the command line invocation.
         * The string may contain non-utf8 data.
         *
         * It is possible that the remote application did not send a working
         * directory, so this may be %NULL.
         *
         * The return value should not be modified or freed and is valid for as
         * long as `cmdline` exists.
         * @returns the current directory, or %NULL
         */
        get_cwd(): string | null;
        /**
         * Gets the contents of the 'environ' variable of the command line
         * invocation, as would be returned by g_get_environ(), ie as a
         * %NULL-terminated list of strings in the form 'NAME=VALUE'.
         * The strings may contain non-utf8 data.
         *
         * The remote application usually does not send an environment.  Use
         * %G_APPLICATION_SEND_ENVIRONMENT to affect that.  Even with this flag
         * set it is possible that the environment is still not available (due
         * to invocation messages from other applications).
         *
         * The return value should not be modified or freed and is valid for as
         * long as `cmdline` exists.
         *
         * See g_application_command_line_getenv() if you are only interested
         * in the value of a single environment variable.
         * @returns      the environment strings, or %NULL if they were not sent
         */
        get_environ(): string[];
        /**
         * Gets the exit status of `cmdline`.  See
         * g_application_command_line_set_exit_status() for more information.
         * @returns the exit status
         */
        get_exit_status(): number;
        /**
         * Determines if `cmdline` represents a remote invocation.
         * @returns %TRUE if the invocation was remote
         */
        get_is_remote(): boolean;
        /**
         * Gets the options that were passed to g_application_command_line().
         *
         * If you did not override local_command_line() then these are the same
         * options that were parsed according to the #GOptionEntrys added to the
         * application with g_application_add_main_option_entries() and possibly
         * modified from your GApplication::handle-local-options handler.
         *
         * If no options were sent then an empty dictionary is returned so that
         * you don't need to check for %NULL.
         *
         * The data has been passed via an untrusted external process, so the types of
         * all values must be checked before being used.
         * @returns a #GVariantDict with the options
         */
        get_options_dict(): GLib.VariantDict;
        /**
         * Gets the platform data associated with the invocation of `cmdline`.
         *
         * This is a #GVariant dictionary containing information about the
         * context in which the invocation occurred.  It typically contains
         * information like the current working directory and the startup
         * notification ID.
         *
         * It comes from an untrusted external process and hence the types of all
         * values must be validated before being used.
         *
         * For local invocation, it will be %NULL.
         * @returns the platform data, or %NULL
         */
        get_platform_data(): GLib.Variant | null;
        /**
         * Gets the stdin of the invoking process.
         *
         * The #GInputStream can be used to read data passed to the standard
         * input of the invoking process.
         * This doesn't work on all platforms.  Presently, it is only available
         * on UNIX when using a D-Bus daemon capable of passing file descriptors.
         * If stdin is not available then %NULL will be returned.  In the
         * future, support may be expanded to other platforms.
         *
         * You must only call this function once per commandline invocation.
         * @returns a #GInputStream for stdin
         */
        get_stdin(): InputStream | null;
        /**
         * Gets the value of a particular environment variable of the command
         * line invocation, as would be returned by g_getenv().  The strings may
         * contain non-utf8 data.
         *
         * The remote application usually does not send an environment.  Use
         * %G_APPLICATION_SEND_ENVIRONMENT to affect that.  Even with this flag
         * set it is possible that the environment is still not available (due
         * to invocation messages from other applications).
         *
         * The return value should not be modified or freed and is valid for as
         * long as `cmdline` exists.
         * @param name the environment variable to get
         * @returns the value of the variable, or %NULL if unset or unsent
         */
        getenv(name: string): string | null;
        /**
         * Sets the exit status that will be used when the invoking process
         * exits.
         *
         * The return value of the #GApplication::command-line signal is
         * passed to this function when the handler returns.  This is the usual
         * way of setting the exit status.
         *
         * In the event that you want the remote invocation to continue running
         * and want to decide on the exit status in the future, you can use this
         * call.  For the case of a remote invocation, the remote process will
         * typically exit when the last reference is dropped on `cmdline`.  The
         * exit status of the remote process will be equal to the last value
         * that was set with this function.
         *
         * In the case that the commandline invocation is local, the situation
         * is slightly more complicated.  If the commandline invocation results
         * in the mainloop running (ie: because the use-count of the application
         * increased to a non-zero value) then the application is considered to
         * have been 'successful' in a certain sense, and the exit status is
         * always zero.  If the application use count is zero, though, the exit
         * status of the local #GApplicationCommandLine is used.
         * @param exit_status the exit status
         */
        set_exit_status(exit_status: number): void;

        // Own virtual methods of Gio-2.0.Gio.ApplicationCommandLine

        /**
         * Gets the stdin of the invoking process.
         *
         * The #GInputStream can be used to read data passed to the standard
         * input of the invoking process.
         * This doesn't work on all platforms.  Presently, it is only available
         * on UNIX when using a D-Bus daemon capable of passing file descriptors.
         * If stdin is not available then %NULL will be returned.  In the
         * future, support may be expanded to other platforms.
         *
         * You must only call this function once per commandline invocation.
         * @virtual
         * @returns a #GInputStream for stdin
         */
        vfunc_get_stdin(): InputStream | null;
        vfunc_print_literal(message: string | null): void;
        vfunc_printerr_literal(message: string | null): void;

        // Class property signals of Gio-2.0.Gio.ApplicationCommandLine

        connect(
            sigName: 'notify::arguments',
            callback: (
                $obj: ApplicationCommandLine,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::arguments',
            callback: (
                $obj: ApplicationCommandLine,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::arguments', ...args: any[]): void;
        connect(
            sigName: 'notify::is-remote',
            callback: (
                $obj: ApplicationCommandLine,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::is-remote',
            callback: (
                $obj: ApplicationCommandLine,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::is-remote', ...args: any[]): void;
        connect(
            sigName: 'notify::options',
            callback: (
                $obj: ApplicationCommandLine,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::options',
            callback: (
                $obj: ApplicationCommandLine,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::options', ...args: any[]): void;
        connect(
            sigName: 'notify::platform-data',
            callback: (
                $obj: ApplicationCommandLine,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::platform-data',
            callback: (
                $obj: ApplicationCommandLine,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::platform-data', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GApplicationCommandLine represents a command-line invocation of
     * an application.  It is created by #GApplication and emitted
     * in the #GApplication::command-line signal and virtual function.
     *
     * The class contains the list of arguments that the program was invoked
     * with.  It is also possible to query if the commandline invocation was
     * local (ie: the current process is running in direct response to the
     * invocation) or remote (ie: some other process forwarded the
     * commandline to this process).
     *
     * The GApplicationCommandLine object can provide the `argc` and `argv`
     * parameters for use with the #GOptionContext command-line parsing API,
     * with the g_application_command_line_get_arguments() function. See
     * [gapplication-example-cmdline3.c][gapplication-example-cmdline3]
     * for an example.
     *
     * The exit status of the originally-invoked process may be set and
     * messages can be printed to stdout or stderr of that process.  The
     * lifecycle of the originally-invoked process is tied to the lifecycle
     * of this object (ie: the process exits when the last reference is
     * dropped).
     *
     * The main use for #GApplicationCommandLine (and the
     * #GApplication::command-line signal) is 'Emacs server' like use cases:
     * You can set the `EDITOR` environment variable to have e.g. git use
     * your favourite editor to edit commit messages, and if you already
     * have an instance of the editor running, the editing will happen
     * in the running instance, instead of opening a new one. An important
     * aspect of this use case is that the process that gets started by git
     * does not return until the editing is done.
     *
     * Normally, the commandline is completely handled in the
     * #GApplication::command-line handler. The launching instance exits
     * once the signal handler in the primary instance has returned, and
     * the return value of the signal handler becomes the exit status
     * of the launching instance.
     *
     * ```c
     * static int
     * command_line (GApplication            *application,
     *               GApplicationCommandLine *cmdline)
     * {
     *   gchar **argv;
     *   gint argc;
     *   gint i;
     *
     *   argv = g_application_command_line_get_arguments (cmdline, &argc);
     *
     *   g_application_command_line_print (cmdline,
     *                                     "This text is written back\n"
     *                                     "to stdout of the caller\n");
     *
     *   for (i = 0; i < argc; i++)
     *     g_print ("argument %d: %s\n", i, argv[i]);
     *
     *   g_strfreev (argv);
     *
     *   return 0;
     * }
     * ```
     *
     * The complete example can be found here:
     * [gapplication-example-cmdline.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline.c)
     *
     * In more complicated cases, the handling of the commandline can be
     * split between the launcher and the primary instance.
     *
     * ```c
     * static gboolean
     *  test_local_cmdline (GApplication   *application,
     *                      gchar        ***arguments,
     *                      gint           *exit_status)
     * {
     *   gint i, j;
     *   gchar **argv;
     *
     *   argv = *arguments;
     *
     *   if (argv[0] == NULL)
     *     {
     *       *exit_status = 0;
     *       return FALSE;
     *     }
     *
     *   i = 1;
     *   while (argv[i])
     *     {
     *       if (g_str_has_prefix (argv[i], "--local-"))
     *         {
     *           g_print ("handling argument %s locally\n", argv[i]);
     *           g_free (argv[i]);
     *           for (j = i; argv[j]; j++)
     *             argv[j] = argv[j + 1];
     *         }
     *       else
     *         {
     *           g_print ("not handling argument %s locally\n", argv[i]);
     *           i++;
     *         }
     *     }
     *
     *   *exit_status = 0;
     *
     *   return FALSE;
     * }
     *
     * static void
     * test_application_class_init (TestApplicationClass *class)
     * {
     *   G_APPLICATION_CLASS (class)->local_command_line = test_local_cmdline;
     *
     *   ...
     * }
     * ```
     *
     * In this example of split commandline handling, options that start
     * with `--local-` are handled locally, all other options are passed
     * to the #GApplication::command-line handler which runs in the primary
     * instance.
     *
     * The complete example can be found here:
     * [gapplication-example-cmdline2.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline2.c)
     *
     * If handling the commandline requires a lot of work, it may
     * be better to defer it.
     *
     * ```c
     * static gboolean
     * my_cmdline_handler (gpointer data)
     * {
     *   GApplicationCommandLine *cmdline = data;
     *
     *   // do the heavy lifting in an idle
     *
     *   g_application_command_line_set_exit_status (cmdline, 0);
     *   g_object_unref (cmdline); // this releases the application
     *
     *   return G_SOURCE_REMOVE;
     * }
     *
     * static int
     * command_line (GApplication            *application,
     *               GApplicationCommandLine *cmdline)
     * {
     *   // keep the application running until we are done with this commandline
     *   g_application_hold (application);
     *
     *   g_object_set_data_full (G_OBJECT (cmdline),
     *                           "application", application,
     *                           (GDestroyNotify)g_application_release);
     *
     *   g_object_ref (cmdline);
     *   g_idle_add (my_cmdline_handler, cmdline);
     *
     *   return 0;
     * }
     * ```
     *
     * In this example the commandline is not completely handled before
     * the #GApplication::command-line handler returns. Instead, we keep
     * a reference to the #GApplicationCommandLine object and handle it
     * later (in this example, in an idle). Note that it is necessary to
     * hold the application until you are done with the commandline.
     *
     * The complete example can be found here:
     * [gapplication-example-cmdline3.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline3.c)
     * @class
     */
    class ApplicationCommandLine extends GObject.Object {
        // Own properties of Gio-2.0.Gio.ApplicationCommandLine

        static name: string;
        static $gtype: GObject.GType<ApplicationCommandLine>;

        // Constructors of Gio-2.0.Gio.ApplicationCommandLine

        constructor(config?: ApplicationCommandLine.ConstructorProperties);
        _init(config?: ApplicationCommandLine.ConstructorProperties): void;
    }

    namespace BufferedInputStream {
        // Constructor properties interface

        interface ConstructorProperties
            extends Seekable.ConstructorProperties,
                FilterInputStream.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.BufferedInputStream

            buffer_size?: number | null;
        }
    }

    interface BufferedInputStream extends Seekable {
        // Own properties of Gio-2.0.Gio.BufferedInputStream

        buffer_size: number;

        // Own fields of Gio-2.0.Gio.BufferedInputStream

        parent_instance: FilterInputStream &
            InputStream &
            GObject.Object &
            GObject.Object;

        // Owm methods of Gio-2.0.Gio.BufferedInputStream

        /**
         * Tries to read `count` bytes from the stream into the buffer.
         * Will block during this read.
         *
         * If `count` is zero, returns zero and does nothing. A value of `count`
         * larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes read into the buffer is returned.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. near the end of a file. Zero is returned on end of file
         * (or if `count` is zero),  but never otherwise.
         *
         * If `count` is -1 then the attempted read size is equal to the number of
         * bytes that are required to fill the buffer.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         *
         * On error -1 is returned and `error` is set accordingly.
         *
         * For the asynchronous, non-blocking, version of this function, see
         * g_buffered_input_stream_fill_async().
         * @param count the number of bytes that will be read from the stream
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @returns the number of bytes read into @stream's buffer, up to @count,     or -1 on error.
         */
        fill(count: number, cancellable: Cancellable | null): number;
        /**
         * Reads data into `stream'`s buffer asynchronously, up to `count` size.
         * `io_priority` can be used to prioritize reads. For the synchronous
         * version of this function, see g_buffered_input_stream_fill().
         *
         * If `count` is -1 then the attempted read size is equal to the number
         * of bytes that are required to fill the buffer.
         * @param count the number of bytes that will be read from the stream
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object
         * @param callback a #GAsyncReadyCallback
         */
        fill_async(
            count: number,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of fill_async

        /**
         * Promisified version of {@link fill_async}
         *
         * Reads data into `stream'`s buffer asynchronously, up to `count` size.
         * `io_priority` can be used to prioritize reads. For the synchronous
         * version of this function, see g_buffered_input_stream_fill().
         *
         * If `count` is -1 then the attempted read size is equal to the number
         * of bytes that are required to fill the buffer.
         * @param count the number of bytes that will be read from the stream
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object
         * @returns A Promise of: a #gssize of the read stream, or `-1` on an error.
         */
        fill_async(
            count: number,
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<number>;
        /**
         * Finishes an asynchronous read.
         * @param result a #GAsyncResult
         * @returns a #gssize of the read stream, or `-1` on an error.
         */
        fill_finish(result: AsyncResult): number;
        /**
         * Gets the size of the available data within the stream.
         * @returns size of the available stream.
         */
        get_available(): number;
        /**
         * Gets the size of the input buffer.
         * @returns the current buffer size.
         */
        get_buffer_size(): number;
        /**
         * Peeks in the buffer, copying data of size `count` into `buffer,`
         * offset `offset` bytes.
         * @param buffer a pointer to   an allocated chunk of memory
         * @param offset a #gsize
         * @returns a #gsize of the number of bytes peeked, or -1 on error.
         */
        peek(buffer: Uint8Array, offset: number): number;
        /**
         * Returns the buffer with the currently available bytes. The returned
         * buffer must not be modified and will become invalid when reading from
         * the stream or filling the buffer.
         * @returns           read-only buffer
         */
        peek_buffer(): Uint8Array;
        /**
         * Tries to read a single byte from the stream or the buffer. Will block
         * during this read.
         *
         * On success, the byte read from the stream is returned. On end of stream
         * -1 is returned but it's not an exceptional error and `error` is not set.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         *
         * On error -1 is returned and `error` is set accordingly.
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @returns the byte read from the @stream, or -1 on end of stream or error.
         */
        read_byte(cancellable: Cancellable | null): number;
        /**
         * Sets the size of the internal buffer of `stream` to `size,` or to the
         * size of the contents of the buffer. The buffer can never be resized
         * smaller than its current contents.
         * @param size a #gsize
         */
        set_buffer_size(size: number): void;

        // Own virtual methods of Gio-2.0.Gio.BufferedInputStream

        /**
         * Tries to read `count` bytes from the stream into the buffer.
         * Will block during this read.
         *
         * If `count` is zero, returns zero and does nothing. A value of `count`
         * larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes read into the buffer is returned.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. near the end of a file. Zero is returned on end of file
         * (or if `count` is zero),  but never otherwise.
         *
         * If `count` is -1 then the attempted read size is equal to the number of
         * bytes that are required to fill the buffer.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         *
         * On error -1 is returned and `error` is set accordingly.
         *
         * For the asynchronous, non-blocking, version of this function, see
         * g_buffered_input_stream_fill_async().
         * @virtual
         * @param count the number of bytes that will be read from the stream
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @returns the number of bytes read into @stream's buffer, up to @count,     or -1 on error.
         */
        vfunc_fill(count: number, cancellable: Cancellable | null): number;
        /**
         * Reads data into `stream'`s buffer asynchronously, up to `count` size.
         * `io_priority` can be used to prioritize reads. For the synchronous
         * version of this function, see g_buffered_input_stream_fill().
         *
         * If `count` is -1 then the attempted read size is equal to the number
         * of bytes that are required to fill the buffer.
         * @virtual
         * @param count the number of bytes that will be read from the stream
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object
         * @param callback a #GAsyncReadyCallback
         */
        vfunc_fill_async(
            count: number,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes an asynchronous read.
         * @virtual
         * @param result a #GAsyncResult
         * @returns a #gssize of the read stream, or `-1` on an error.
         */
        vfunc_fill_finish(result: AsyncResult): number;

        // Class property signals of Gio-2.0.Gio.BufferedInputStream

        connect(
            sigName: 'notify::buffer-size',
            callback: (
                $obj: BufferedInputStream,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::buffer-size',
            callback: (
                $obj: BufferedInputStream,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::buffer-size', ...args: any[]): void;
        connect(
            sigName: 'notify::close-base-stream',
            callback: (
                $obj: BufferedInputStream,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::close-base-stream',
            callback: (
                $obj: BufferedInputStream,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::close-base-stream', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * Buffered input stream implements #GFilterInputStream and provides
     * for buffered reads.
     *
     * By default, #GBufferedInputStream's buffer size is set at 4 kilobytes.
     *
     * To create a buffered input stream, use g_buffered_input_stream_new(),
     * or g_buffered_input_stream_new_sized() to specify the buffer's size at
     * construction.
     *
     * To get the size of a buffer within a buffered input stream, use
     * g_buffered_input_stream_get_buffer_size(). To change the size of a
     * buffered input stream's buffer, use
     * g_buffered_input_stream_set_buffer_size(). Note that the buffer's size
     * cannot be reduced below the size of the data within the buffer.
     * @class
     */
    class BufferedInputStream extends FilterInputStream {
        // Own properties of Gio-2.0.Gio.BufferedInputStream

        static name: string;
        static $gtype: GObject.GType<BufferedInputStream>;

        // Constructors of Gio-2.0.Gio.BufferedInputStream

        constructor(config?: BufferedInputStream.ConstructorProperties);
        /**
         * Creates a new #GInputStream from the given `base_stream,` with
         * a buffer set to the default size (4 kilobytes).
         * @constructor
         * @param base_stream a #GInputStream
         * @returns a #GInputStream for the given @base_stream.
         */
        constructor(base_stream: InputStream);
        /**
         * Creates a new #GInputStream from the given `base_stream,` with
         * a buffer set to the default size (4 kilobytes).
         * @constructor
         * @param base_stream a #GInputStream
         * @returns a #GInputStream for the given @base_stream.
         */
        static new(base_stream: InputStream): BufferedInputStream;
        /**
         * Creates a new #GBufferedInputStream from the given `base_stream,`
         * with a buffer set to `size`.
         * @constructor
         * @param base_stream a #GInputStream
         * @param size a #gsize
         * @returns a #GInputStream.
         */
        static new_sized(
            base_stream: InputStream,
            size: number
        ): BufferedInputStream;
        _init(config?: BufferedInputStream.ConstructorProperties): void;
    }

    namespace BufferedOutputStream {
        // Constructor properties interface

        interface ConstructorProperties
            extends Seekable.ConstructorProperties,
                FilterOutputStream.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.BufferedOutputStream

            auto_grow?: boolean | null;
            buffer_size?: number | null;
        }
    }

    interface BufferedOutputStream extends Seekable {
        // Own properties of Gio-2.0.Gio.BufferedOutputStream

        auto_grow: boolean;
        buffer_size: number;

        // Own fields of Gio-2.0.Gio.BufferedOutputStream

        parent_instance: FilterOutputStream &
            OutputStream &
            GObject.Object &
            GObject.Object;
        priv: BufferedOutputStreamPrivate;

        // Owm methods of Gio-2.0.Gio.BufferedOutputStream

        /**
         * Checks if the buffer automatically grows as data is added.
         * @returns %TRUE if the @stream's buffer automatically grows, %FALSE otherwise.
         */
        get_auto_grow(): boolean;
        /**
         * Gets the size of the buffer in the `stream`.
         * @returns the current size of the buffer.
         */
        get_buffer_size(): number;
        /**
         * Sets whether or not the `stream'`s buffer should automatically grow.
         * If `auto_grow` is true, then each write will just make the buffer
         * larger, and you must manually flush the buffer to actually write out
         * the data to the underlying stream.
         * @param auto_grow a #gboolean.
         */
        set_auto_grow(auto_grow: boolean): void;
        /**
         * Sets the size of the internal buffer to `size`.
         * @param size a #gsize.
         */
        set_buffer_size(size: number): void;

        // Class property signals of Gio-2.0.Gio.BufferedOutputStream

        connect(
            sigName: 'notify::auto-grow',
            callback: (
                $obj: BufferedOutputStream,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::auto-grow',
            callback: (
                $obj: BufferedOutputStream,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::auto-grow', ...args: any[]): void;
        connect(
            sigName: 'notify::buffer-size',
            callback: (
                $obj: BufferedOutputStream,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::buffer-size',
            callback: (
                $obj: BufferedOutputStream,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::buffer-size', ...args: any[]): void;
        connect(
            sigName: 'notify::close-base-stream',
            callback: (
                $obj: BufferedOutputStream,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::close-base-stream',
            callback: (
                $obj: BufferedOutputStream,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::close-base-stream', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * Buffered output stream implements #GFilterOutputStream and provides
     * for buffered writes.
     *
     * By default, #GBufferedOutputStream's buffer size is set at 4 kilobytes.
     *
     * To create a buffered output stream, use g_buffered_output_stream_new(),
     * or g_buffered_output_stream_new_sized() to specify the buffer's size
     * at construction.
     *
     * To get the size of a buffer within a buffered input stream, use
     * g_buffered_output_stream_get_buffer_size(). To change the size of a
     * buffered output stream's buffer, use
     * g_buffered_output_stream_set_buffer_size(). Note that the buffer's
     * size cannot be reduced below the size of the data within the buffer.
     * @class
     */
    class BufferedOutputStream extends FilterOutputStream {
        // Own properties of Gio-2.0.Gio.BufferedOutputStream

        static name: string;
        static $gtype: GObject.GType<BufferedOutputStream>;

        // Constructors of Gio-2.0.Gio.BufferedOutputStream

        constructor(config?: BufferedOutputStream.ConstructorProperties);
        /**
         * Creates a new buffered output stream for a base stream.
         * @constructor
         * @param base_stream a #GOutputStream.
         * @returns a #GOutputStream for the given @base_stream.
         */
        constructor(base_stream: OutputStream);
        /**
         * Creates a new buffered output stream for a base stream.
         * @constructor
         * @param base_stream a #GOutputStream.
         * @returns a #GOutputStream for the given @base_stream.
         */
        static new(base_stream: OutputStream): BufferedOutputStream;
        /**
         * Creates a new buffered output stream with a given buffer size.
         * @constructor
         * @param base_stream a #GOutputStream.
         * @param size a #gsize.
         * @returns a #GOutputStream with an internal buffer set to @size.
         */
        static new_sized(
            base_stream: OutputStream,
            size: number
        ): BufferedOutputStream;
        _init(config?: BufferedOutputStream.ConstructorProperties): void;
    }

    namespace BytesIcon {
        // Constructor properties interface

        interface ConstructorProperties
            extends Icon.ConstructorProperties,
                LoadableIcon.ConstructorProperties,
                GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.BytesIcon

            /**
             * The bytes containing the icon.
             */
            bytes?: GLib.Bytes | null;
        }
    }

    interface BytesIcon extends Icon, LoadableIcon {
        // Own properties of Gio-2.0.Gio.BytesIcon

        /**
         * The bytes containing the icon.
         */
        readonly bytes: GLib.Bytes;

        // Owm methods of Gio-2.0.Gio.BytesIcon

        /**
         * Gets the #GBytes associated with the given `icon`.
         * @returns a #GBytes.
         */
        get_bytes(): GLib.Bytes;

        // Class property signals of Gio-2.0.Gio.BytesIcon

        connect(
            sigName: 'notify::bytes',
            callback: ($obj: BytesIcon, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::bytes',
            callback: ($obj: BytesIcon, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::bytes', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GBytesIcon specifies an image held in memory in a common format (usually
     * png) to be used as icon.
     * @class
     */
    class BytesIcon extends GObject.Object {
        // Own properties of Gio-2.0.Gio.BytesIcon

        static name: string;
        static $gtype: GObject.GType<BytesIcon>;

        // Constructors of Gio-2.0.Gio.BytesIcon

        constructor(config?: BytesIcon.ConstructorProperties);
        /**
         * Creates a new icon for a bytes.
         *
         * This cannot fail, but loading and interpreting the bytes may fail later on
         * (for example, if g_loadable_icon_load() is called) if the image is invalid.
         * @constructor
         * @param bytes a #GBytes.
         * @returns a #GIcon for the given   @bytes.
         */
        constructor(bytes: GLib.Bytes);
        /**
         * Creates a new icon for a bytes.
         *
         * This cannot fail, but loading and interpreting the bytes may fail later on
         * (for example, if g_loadable_icon_load() is called) if the image is invalid.
         * @constructor
         * @param bytes a #GBytes.
         * @returns a #GIcon for the given   @bytes.
         */
        static new(bytes: GLib.Bytes): BytesIcon;
        _init(config?: BytesIcon.ConstructorProperties): void;
    }

    namespace Cancellable {
        // Signal callback interfaces

        /**
         * Signal callback interface for `cancelled`
         */
        interface CancelledSignalCallback {
            ($obj: Cancellable): void;
        }

        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface Cancellable {
        // Own fields of Gio-2.0.Gio.Cancellable

        parent_instance: GObject.Object;

        // Owm methods of Gio-2.0.Gio.Cancellable

        /**
         * Will set `cancellable` to cancelled, and will emit the
         * #GCancellable::cancelled signal. (However, see the warning about
         * race conditions in the documentation for that signal if you are
         * planning to connect to it.)
         *
         * This function is thread-safe. In other words, you can safely call
         * it from a thread other than the one running the operation that was
         * passed the `cancellable`.
         *
         * If `cancellable` is %NULL, this function returns immediately for convenience.
         *
         * The convention within GIO is that cancelling an asynchronous
         * operation causes it to complete asynchronously. That is, if you
         * cancel the operation from the same thread in which it is running,
         * then the operation's #GAsyncReadyCallback will not be invoked until
         * the application returns to the main loop.
         */
        cancel(): void;
        /**
         * Convenience function to connect to the #GCancellable::cancelled
         * signal. Also handles the race condition that may happen
         * if the cancellable is cancelled right before connecting.
         *
         * `callback` is called at most once, either directly at the
         * time of the connect if `cancellable` is already cancelled,
         * or when `cancellable` is cancelled in some thread.
         *
         * `data_destroy_func` will be called when the handler is
         * disconnected, or immediately if the cancellable is already
         * cancelled.
         *
         * See #GCancellable::cancelled for details on how to use this.
         *
         * Since GLib 2.40, the lock protecting `cancellable` is not held when
         * `callback` is invoked.  This lifts a restriction in place for
         * earlier GLib versions which now makes it easier to write cleanup
         * code that unconditionally invokes e.g. g_cancellable_cancel().
         * @param callback The #GCallback to connect.
         * @returns The id of the signal handler or 0 if @cancellable has already          been cancelled.
         */
        connect(callback: GObject.Callback): number;
        /**
         * Disconnects a handler from a cancellable instance similar to
         * g_signal_handler_disconnect().  Additionally, in the event that a
         * signal handler is currently running, this call will block until the
         * handler has finished.  Calling this function from a
         * #GCancellable::cancelled signal handler will therefore result in a
         * deadlock.
         *
         * This avoids a race condition where a thread cancels at the
         * same time as the cancellable operation is finished and the
         * signal handler is removed. See #GCancellable::cancelled for
         * details on how to use this.
         *
         * If `cancellable` is %NULL or `handler_id` is `0` this function does
         * nothing.
         * @param handler_id Handler id of the handler to be disconnected, or `0`.
         */
        disconnect(handler_id: number): void;
        /**
         * Gets the file descriptor for a cancellable job. This can be used to
         * implement cancellable operations on Unix systems. The returned fd will
         * turn readable when `cancellable` is cancelled.
         *
         * You are not supposed to read from the fd yourself, just check for
         * readable status. Reading to unset the readable status is done
         * with g_cancellable_reset().
         *
         * After a successful return from this function, you should use
         * g_cancellable_release_fd() to free up resources allocated for
         * the returned file descriptor.
         *
         * See also g_cancellable_make_pollfd().
         * @returns A valid file descriptor. `-1` if the file descriptor is not supported, or on errors.
         */
        get_fd(): number;
        /**
         * Checks if a cancellable job has been cancelled.
         * @returns %TRUE if @cancellable is cancelled, FALSE if called with %NULL or if item is not cancelled.
         */
        is_cancelled(): boolean;
        /**
         * Creates a #GPollFD corresponding to `cancellable;` this can be passed
         * to g_poll() and used to poll for cancellation. This is useful both
         * for unix systems without a native poll and for portability to
         * windows.
         *
         * When this function returns %TRUE, you should use
         * g_cancellable_release_fd() to free up resources allocated for the
         * `pollfd`. After a %FALSE return, do not call g_cancellable_release_fd().
         *
         * If this function returns %FALSE, either no `cancellable` was given or
         * resource limits prevent this function from allocating the necessary
         * structures for polling. (On Linux, you will likely have reached
         * the maximum number of file descriptors.) The suggested way to handle
         * these cases is to ignore the `cancellable`.
         *
         * You are not supposed to read from the fd yourself, just check for
         * readable status. Reading to unset the readable status is done
         * with g_cancellable_reset().
         * @param pollfd a pointer to a #GPollFD
         * @returns %TRUE if @pollfd was successfully initialized, %FALSE on          failure to prepare the cancellable.
         */
        make_pollfd(pollfd: GLib.PollFD): boolean;
        /**
         * Pops `cancellable` off the cancellable stack (verifying that `cancellable`
         * is on the top of the stack).
         */
        pop_current(): void;
        /**
         * Pushes `cancellable` onto the cancellable stack. The current
         * cancellable can then be received using g_cancellable_get_current().
         *
         * This is useful when implementing cancellable operations in
         * code that does not allow you to pass down the cancellable object.
         *
         * This is typically called automatically by e.g. #GFile operations,
         * so you rarely have to call this yourself.
         */
        push_current(): void;
        /**
         * Releases a resources previously allocated by g_cancellable_get_fd()
         * or g_cancellable_make_pollfd().
         *
         * For compatibility reasons with older releases, calling this function
         * is not strictly required, the resources will be automatically freed
         * when the `cancellable` is finalized. However, the `cancellable` will
         * block scarce file descriptors until it is finalized if this function
         * is not called. This can cause the application to run out of file
         * descriptors when many #GCancellables are used at the same time.
         */
        release_fd(): void;
        /**
         * Resets `cancellable` to its uncancelled state.
         *
         * If cancellable is currently in use by any cancellable operation
         * then the behavior of this function is undefined.
         *
         * Note that it is generally not a good idea to reuse an existing
         * cancellable for more operations after it has been cancelled once,
         * as this function might tempt you to do. The recommended practice
         * is to drop the reference to a cancellable after cancelling it,
         * and let it die with the outstanding async operations. You should
         * create a fresh cancellable for further async operations.
         */
        reset(): void;
        /**
         * If the `cancellable` is cancelled, sets the error to notify
         * that the operation was cancelled.
         * @returns %TRUE if @cancellable was cancelled, %FALSE if it was not
         */
        set_error_if_cancelled(): boolean;
        /**
         * Creates a source that triggers if `cancellable` is cancelled and
         * calls its callback of type #GCancellableSourceFunc. This is
         * primarily useful for attaching to another (non-cancellable) source
         * with g_source_add_child_source() to add cancellability to it.
         *
         * For convenience, you can call this with a %NULL #GCancellable,
         * in which case the source will never trigger.
         *
         * The new #GSource will hold a reference to the #GCancellable.
         * @returns the new #GSource.
         */
        source_new(): GLib.Source;

        // Own virtual methods of Gio-2.0.Gio.Cancellable

        vfunc_cancelled(): void;

        // Own signals of Gio-2.0.Gio.Cancellable

        connect(
            sigName: 'cancelled',
            callback: Cancellable.CancelledSignalCallback
        ): number;
        connect_after(
            sigName: 'cancelled',
            callback: Cancellable.CancelledSignalCallback
        ): number;
        emit(sigName: 'cancelled', ...args: any[]): void;

        // Class property signals of Gio-2.0.Gio.Cancellable

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * GCancellable is a thread-safe operation cancellation stack used
     * throughout GIO to allow for cancellation of synchronous and
     * asynchronous operations.
     * @class
     */
    class Cancellable extends GObject.Object {
        // Own properties of Gio-2.0.Gio.Cancellable

        static name: string;
        static $gtype: GObject.GType<Cancellable>;

        // Constructors of Gio-2.0.Gio.Cancellable

        constructor(config?: Cancellable.ConstructorProperties);
        /**
         * Creates a new #GCancellable object.
         *
         * Applications that want to start one or more operations
         * that should be cancellable should create a #GCancellable
         * and pass it to the operations.
         *
         * One #GCancellable can be used in multiple consecutive
         * operations or in multiple concurrent operations.
         * @constructor
         * @returns a #GCancellable.
         */
        constructor();
        /**
         * Creates a new #GCancellable object.
         *
         * Applications that want to start one or more operations
         * that should be cancellable should create a #GCancellable
         * and pass it to the operations.
         *
         * One #GCancellable can be used in multiple consecutive
         * operations or in multiple concurrent operations.
         * @constructor
         * @returns a #GCancellable.
         */
        static new(): Cancellable;
        _init(config?: Cancellable.ConstructorProperties): void;
        /**
         * Gets the top cancellable from the stack.
         * @returns a #GCancellable from the top of the stack, or %NULL if the stack is empty.
         */
        static get_current(): Cancellable | null;
    }

    namespace CharsetConverter {
        // Constructor properties interface

        interface ConstructorProperties
            extends Converter.ConstructorProperties,
                Initable.ConstructorProperties,
                GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.CharsetConverter

            from_charset?: string | null;
            to_charset?: string | null;
            use_fallback?: boolean | null;
        }
    }

    interface CharsetConverter extends Converter, Initable {
        // Own properties of Gio-2.0.Gio.CharsetConverter

        readonly from_charset: string | null;
        readonly to_charset: string | null;
        use_fallback: boolean;

        // Owm methods of Gio-2.0.Gio.CharsetConverter

        /**
         * Gets the number of fallbacks that `converter` has applied so far.
         * @returns the number of fallbacks that @converter has applied
         */
        get_num_fallbacks(): number;
        /**
         * Gets the #GCharsetConverter:use-fallback property.
         * @returns %TRUE if fallbacks are used by @converter
         */
        get_use_fallback(): boolean;
        /**
         * Sets the #GCharsetConverter:use-fallback property.
         * @param use_fallback %TRUE to use fallbacks
         */
        set_use_fallback(use_fallback: boolean): void;

        // Class property signals of Gio-2.0.Gio.CharsetConverter

        connect(
            sigName: 'notify::from-charset',
            callback: ($obj: CharsetConverter, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::from-charset',
            callback: ($obj: CharsetConverter, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::from-charset', ...args: any[]): void;
        connect(
            sigName: 'notify::to-charset',
            callback: ($obj: CharsetConverter, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::to-charset',
            callback: ($obj: CharsetConverter, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::to-charset', ...args: any[]): void;
        connect(
            sigName: 'notify::use-fallback',
            callback: ($obj: CharsetConverter, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::use-fallback',
            callback: ($obj: CharsetConverter, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::use-fallback', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GCharsetConverter is an implementation of #GConverter based on
     * GIConv.
     * @class
     */
    class CharsetConverter extends GObject.Object {
        // Own properties of Gio-2.0.Gio.CharsetConverter

        static name: string;
        static $gtype: GObject.GType<CharsetConverter>;

        // Constructors of Gio-2.0.Gio.CharsetConverter

        constructor(config?: CharsetConverter.ConstructorProperties);
        /**
         * Creates a new #GCharsetConverter.
         * @constructor
         * @param to_charset destination charset
         * @param from_charset source charset
         * @returns a new #GCharsetConverter or %NULL on error.
         */
        constructor(to_charset: string | null, from_charset: string | null);
        /**
         * Creates a new #GCharsetConverter.
         * @constructor
         * @param to_charset destination charset
         * @param from_charset source charset
         * @returns a new #GCharsetConverter or %NULL on error.
         */
        static new(
            to_charset: string | null,
            from_charset: string | null
        ): CharsetConverter;
        _init(config?: CharsetConverter.ConstructorProperties): void;
    }

    namespace ConverterInputStream {
        // Constructor properties interface

        interface ConstructorProperties
            extends PollableInputStream.ConstructorProperties,
                FilterInputStream.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.ConverterInputStream

            converter?: Converter | null;
        }
    }

    interface ConverterInputStream extends PollableInputStream {
        // Own properties of Gio-2.0.Gio.ConverterInputStream

        readonly converter: Converter;

        // Own fields of Gio-2.0.Gio.ConverterInputStream

        parent_instance: FilterInputStream &
            InputStream &
            GObject.Object &
            GObject.Object;

        // Owm methods of Gio-2.0.Gio.ConverterInputStream

        /**
         * Gets the #GConverter that is used by `converter_stream`.
         * @returns the converter of the converter input stream
         */
        get_converter(): Converter;

        // Class property signals of Gio-2.0.Gio.ConverterInputStream

        connect(
            sigName: 'notify::converter',
            callback: (
                $obj: ConverterInputStream,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::converter',
            callback: (
                $obj: ConverterInputStream,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::converter', ...args: any[]): void;
        connect(
            sigName: 'notify::close-base-stream',
            callback: (
                $obj: ConverterInputStream,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::close-base-stream',
            callback: (
                $obj: ConverterInputStream,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::close-base-stream', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * Converter input stream implements #GInputStream and allows
     * conversion of data of various types during reading.
     *
     * As of GLib 2.34, #GConverterInputStream implements
     * #GPollableInputStream.
     * @class
     */
    class ConverterInputStream extends FilterInputStream {
        // Own properties of Gio-2.0.Gio.ConverterInputStream

        static name: string;
        static $gtype: GObject.GType<ConverterInputStream>;

        // Constructors of Gio-2.0.Gio.ConverterInputStream

        constructor(config?: ConverterInputStream.ConstructorProperties);
        /**
         * Creates a new converter input stream for the `base_stream`.
         * @constructor
         * @param base_stream a #GInputStream
         * @param converter a #GConverter
         * @returns a new #GInputStream.
         */
        constructor(base_stream: InputStream, converter: Converter);
        /**
         * Creates a new converter input stream for the `base_stream`.
         * @constructor
         * @param base_stream a #GInputStream
         * @param converter a #GConverter
         * @returns a new #GInputStream.
         */
        static new(
            base_stream: InputStream,
            converter: Converter
        ): ConverterInputStream;
        _init(config?: ConverterInputStream.ConstructorProperties): void;
    }

    namespace ConverterOutputStream {
        // Constructor properties interface

        interface ConstructorProperties
            extends PollableOutputStream.ConstructorProperties,
                FilterOutputStream.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.ConverterOutputStream

            converter?: Converter | null;
        }
    }

    interface ConverterOutputStream extends PollableOutputStream {
        // Own properties of Gio-2.0.Gio.ConverterOutputStream

        readonly converter: Converter;

        // Own fields of Gio-2.0.Gio.ConverterOutputStream

        parent_instance: FilterOutputStream &
            OutputStream &
            GObject.Object &
            GObject.Object;

        // Owm methods of Gio-2.0.Gio.ConverterOutputStream

        /**
         * Gets the #GConverter that is used by `converter_stream`.
         * @returns the converter of the converter output stream
         */
        get_converter(): Converter;

        // Class property signals of Gio-2.0.Gio.ConverterOutputStream

        connect(
            sigName: 'notify::converter',
            callback: (
                $obj: ConverterOutputStream,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::converter',
            callback: (
                $obj: ConverterOutputStream,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::converter', ...args: any[]): void;
        connect(
            sigName: 'notify::close-base-stream',
            callback: (
                $obj: ConverterOutputStream,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::close-base-stream',
            callback: (
                $obj: ConverterOutputStream,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::close-base-stream', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * Converter output stream implements #GOutputStream and allows
     * conversion of data of various types during reading.
     *
     * As of GLib 2.34, #GConverterOutputStream implements
     * #GPollableOutputStream.
     * @class
     */
    class ConverterOutputStream extends FilterOutputStream {
        // Own properties of Gio-2.0.Gio.ConverterOutputStream

        static name: string;
        static $gtype: GObject.GType<ConverterOutputStream>;

        // Constructors of Gio-2.0.Gio.ConverterOutputStream

        constructor(config?: ConverterOutputStream.ConstructorProperties);
        /**
         * Creates a new converter output stream for the `base_stream`.
         * @constructor
         * @param base_stream a #GOutputStream
         * @param converter a #GConverter
         * @returns a new #GOutputStream.
         */
        constructor(base_stream: OutputStream, converter: Converter);
        /**
         * Creates a new converter output stream for the `base_stream`.
         * @constructor
         * @param base_stream a #GOutputStream
         * @param converter a #GConverter
         * @returns a new #GOutputStream.
         */
        static new(
            base_stream: OutputStream,
            converter: Converter
        ): ConverterOutputStream;
        _init(config?: ConverterOutputStream.ConstructorProperties): void;
    }

    namespace Credentials {
        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface Credentials {
        // Owm methods of Gio-2.0.Gio.Credentials

        /**
         * Tries to get the UNIX process identifier from `credentials`. This
         * method is only available on UNIX platforms.
         *
         * This operation can fail if #GCredentials is not supported on the
         * OS or if the native credentials type does not contain information
         * about the UNIX process ID.
         * @returns The UNIX process ID, or `-1` if @error is set.
         */
        get_unix_pid(): number;
        /**
         * Tries to get the UNIX user identifier from `credentials`. This
         * method is only available on UNIX platforms.
         *
         * This operation can fail if #GCredentials is not supported on the
         * OS or if the native credentials type does not contain information
         * about the UNIX user.
         * @returns The UNIX user identifier or `-1` if @error is set.
         */
        get_unix_user(): number;
        /**
         * Checks if `credentials` and `other_credentials` is the same user.
         *
         * This operation can fail if #GCredentials is not supported on the
         * the OS.
         * @param other_credentials A #GCredentials.
         * @returns %TRUE if @credentials and @other_credentials has the same user, %FALSE otherwise or if @error is set.
         */
        is_same_user(other_credentials: Credentials): boolean;
        /**
         * Copies the native credentials of type `native_type` from `native`
         * into `credentials`.
         *
         * It is a programming error (which will cause a warning to be
         * logged) to use this method if there is no #GCredentials support for
         * the OS or if `native_type` isn't supported by the OS.
         * @param native_type The type of native credentials to set.
         * @param native A pointer to native credentials.
         */
        set_native(native_type: CredentialsType, native: any): void;
        /**
         * Tries to set the UNIX user identifier on `credentials`. This method
         * is only available on UNIX platforms.
         *
         * This operation can fail if #GCredentials is not supported on the
         * OS or if the native credentials type does not contain information
         * about the UNIX user. It can also fail if the OS does not allow the
         * use of "spoofed" credentials.
         * @param uid The UNIX user identifier to set.
         * @returns %TRUE if @uid was set, %FALSE if error is set.
         */
        set_unix_user(uid: number): boolean;
        /**
         * Creates a human-readable textual representation of `credentials`
         * that can be used in logging and debug messages. The format of the
         * returned string may change in future GLib release.
         * @returns A string that should be freed with g_free().
         */
        to_string(): string | null;

        // Class property signals of Gio-2.0.Gio.Credentials

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * The #GCredentials type is a reference-counted wrapper for native
     * credentials. This information is typically used for identifying,
     * authenticating and authorizing other processes.
     *
     * Some operating systems supports looking up the credentials of the
     * remote peer of a communication endpoint - see e.g.
     * g_socket_get_credentials().
     *
     * Some operating systems supports securely sending and receiving
     * credentials over a Unix Domain Socket, see
     * #GUnixCredentialsMessage, g_unix_connection_send_credentials() and
     * g_unix_connection_receive_credentials() for details.
     *
     * On Linux, the native credential type is a `struct ucred` - see the
     * unix(7) man page for details. This corresponds to
     * %G_CREDENTIALS_TYPE_LINUX_UCRED.
     *
     * On Apple operating systems (including iOS, tvOS, and macOS),
     * the native credential type is a `struct xucred`.
     * This corresponds to %G_CREDENTIALS_TYPE_APPLE_XUCRED.
     *
     * On FreeBSD, Debian GNU/kFreeBSD, and GNU/Hurd, the native
     * credential type is a `struct cmsgcred`. This corresponds
     * to %G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED.
     *
     * On NetBSD, the native credential type is a `struct unpcbid`.
     * This corresponds to %G_CREDENTIALS_TYPE_NETBSD_UNPCBID.
     *
     * On OpenBSD, the native credential type is a `struct sockpeercred`.
     * This corresponds to %G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED.
     *
     * On Solaris (including OpenSolaris and its derivatives), the native
     * credential type is a `ucred_t`. This corresponds to
     * %G_CREDENTIALS_TYPE_SOLARIS_UCRED.
     *
     * Since GLib 2.72, on Windows, the native credentials may contain the PID of a
     * process. This corresponds to %G_CREDENTIALS_TYPE_WIN32_PID.
     * @class
     */
    class Credentials extends GObject.Object {
        // Own properties of Gio-2.0.Gio.Credentials

        static name: string;
        static $gtype: GObject.GType<Credentials>;

        // Constructors of Gio-2.0.Gio.Credentials

        constructor(config?: Credentials.ConstructorProperties);
        /**
         * Creates a new #GCredentials object with credentials matching the
         * the current process.
         * @constructor
         * @returns A #GCredentials. Free with g_object_unref().
         */
        constructor();
        /**
         * Creates a new #GCredentials object with credentials matching the
         * the current process.
         * @constructor
         * @returns A #GCredentials. Free with g_object_unref().
         */
        static new(): Credentials;
        _init(config?: Credentials.ConstructorProperties): void;
    }

    namespace DBusActionGroup {
        // Constructor properties interface

        interface ConstructorProperties
            extends ActionGroup.ConstructorProperties,
                RemoteActionGroup.ConstructorProperties,
                GObject.Object.ConstructorProperties {}
    }

    interface DBusActionGroup extends ActionGroup, RemoteActionGroup {
        // Class property signals of Gio-2.0.Gio.DBusActionGroup

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GDBusActionGroup is an implementation of the #GActionGroup
     * interface that can be used as a proxy for an action group
     * that is exported over D-Bus with g_dbus_connection_export_action_group().
     * @class
     */
    class DBusActionGroup extends GObject.Object {
        // Own properties of Gio-2.0.Gio.DBusActionGroup

        static name: string;
        static $gtype: GObject.GType<DBusActionGroup>;

        // Constructors of Gio-2.0.Gio.DBusActionGroup

        constructor(config?: DBusActionGroup.ConstructorProperties);
        _init(config?: DBusActionGroup.ConstructorProperties): void;
        /**
         * Obtains a #GDBusActionGroup for the action group which is exported at
         * the given `bus_name` and `object_path`.
         *
         * The thread default main context is taken at the time of this call.
         * All signals on the menu model (and any linked models) are reported
         * with respect to this context.  All calls on the returned menu model
         * (and linked models) must also originate from this same context, with
         * the thread default main context unchanged.
         *
         * This call is non-blocking.  The returned action group may or may not
         * already be filled in.  The correct thing to do is connect the signals
         * for the action group to monitor for changes and then to call
         * g_action_group_list_actions() to get the initial list.
         * @param connection A #GDBusConnection
         * @param bus_name the bus name which exports the action     group or %NULL if `connection` is not a message bus connection
         * @param object_path the object path at which the action group is exported
         * @returns a #GDBusActionGroup
         */
        static get(
            connection: DBusConnection,
            bus_name: string | null,
            object_path: string | null
        ): DBusActionGroup;
    }

    namespace DBusAuthObserver {
        // Signal callback interfaces

        /**
         * Signal callback interface for `allow-mechanism`
         */
        interface AllowMechanismSignalCallback {
            ($obj: DBusAuthObserver, mechanism: string | null): boolean;
        }

        /**
         * Signal callback interface for `authorize-authenticated-peer`
         */
        interface AuthorizeAuthenticatedPeerSignalCallback {
            (
                $obj: DBusAuthObserver,
                stream: IOStream,
                credentials: Credentials | null
            ): boolean;
        }

        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface DBusAuthObserver {
        // Owm methods of Gio-2.0.Gio.DBusAuthObserver

        /**
         * Emits the #GDBusAuthObserver::allow-mechanism signal on `observer`.
         * @param mechanism The name of the mechanism, e.g. `DBUS_COOKIE_SHA1`.
         * @returns %TRUE if @mechanism can be used to authenticate the other peer, %FALSE if not.
         */
        allow_mechanism(mechanism: string | null): boolean;
        /**
         * Emits the #GDBusAuthObserver::authorize-authenticated-peer signal on `observer`.
         * @param stream A #GIOStream for the #GDBusConnection.
         * @param credentials Credentials received from the peer or %NULL.
         * @returns %TRUE if the peer is authorized, %FALSE if not.
         */
        authorize_authenticated_peer(
            stream: IOStream,
            credentials: Credentials | null
        ): boolean;

        // Own signals of Gio-2.0.Gio.DBusAuthObserver

        connect(
            sigName: 'allow-mechanism',
            callback: DBusAuthObserver.AllowMechanismSignalCallback
        ): number;
        connect_after(
            sigName: 'allow-mechanism',
            callback: DBusAuthObserver.AllowMechanismSignalCallback
        ): number;
        emit(
            sigName: 'allow-mechanism',
            mechanism: string | null,
            ...args: any[]
        ): void;
        connect(
            sigName: 'authorize-authenticated-peer',
            callback: DBusAuthObserver.AuthorizeAuthenticatedPeerSignalCallback
        ): number;
        connect_after(
            sigName: 'authorize-authenticated-peer',
            callback: DBusAuthObserver.AuthorizeAuthenticatedPeerSignalCallback
        ): number;
        emit(
            sigName: 'authorize-authenticated-peer',
            stream: IOStream,
            credentials: Credentials | null,
            ...args: any[]
        ): void;

        // Class property signals of Gio-2.0.Gio.DBusAuthObserver

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * The #GDBusAuthObserver type provides a mechanism for participating
     * in how a #GDBusServer (or a #GDBusConnection) authenticates remote
     * peers. Simply instantiate a #GDBusAuthObserver and connect to the
     * signals you are interested in. Note that new signals may be added
     * in the future
     *
     * ## Controlling Authentication Mechanisms
     *
     * By default, a #GDBusServer or server-side #GDBusConnection will allow
     * any authentication mechanism to be used. If you only
     * want to allow D-Bus connections with the `EXTERNAL` mechanism,
     * which makes use of credentials passing and is the recommended
     * mechanism for modern Unix platforms such as Linux and the BSD family,
     * you would use a signal handler like this:
     *
     *
     * ```c
     * static gboolean
     * on_allow_mechanism (GDBusAuthObserver *observer,
     *                     const gchar       *mechanism,
     *                     gpointer           user_data)
     * {
     *   if (g_strcmp0 (mechanism, "EXTERNAL") == 0)
     *     {
     *       return TRUE;
     *     }
     *
     *   return FALSE;
     * }
     * ```
     *
     *
     * ## Controlling Authorization # {#auth-observer}
     *
     * By default, a #GDBusServer or server-side #GDBusConnection will accept
     * connections from any successfully authenticated user (but not from
     * anonymous connections using the `ANONYMOUS` mechanism). If you only
     * want to allow D-Bus connections from processes owned by the same uid
     * as the server, since GLib 2.68, you should use the
     * %G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER flag. Its equivalent
     * to the following signal handler:
     *
     *
     * ```c
     * static gboolean
     * on_authorize_authenticated_peer (GDBusAuthObserver *observer,
     *                                  GIOStream         *stream,
     *                                  GCredentials      *credentials,
     *                                  gpointer           user_data)
     * {
     *   gboolean authorized;
     *
     *   authorized = FALSE;
     *   if (credentials != NULL)
     *     {
     *       GCredentials *own_credentials;
     *       own_credentials = g_credentials_new ();
     *       if (g_credentials_is_same_user (credentials, own_credentials, NULL))
     *         authorized = TRUE;
     *       g_object_unref (own_credentials);
     *     }
     *
     *   return authorized;
     * }
     * ```
     *
     * @class
     */
    class DBusAuthObserver extends GObject.Object {
        // Own properties of Gio-2.0.Gio.DBusAuthObserver

        static name: string;
        static $gtype: GObject.GType<DBusAuthObserver>;

        // Constructors of Gio-2.0.Gio.DBusAuthObserver

        constructor(config?: DBusAuthObserver.ConstructorProperties);
        /**
         * Creates a new #GDBusAuthObserver object.
         * @constructor
         * @returns A #GDBusAuthObserver. Free with g_object_unref().
         */
        constructor();
        /**
         * Creates a new #GDBusAuthObserver object.
         * @constructor
         * @returns A #GDBusAuthObserver. Free with g_object_unref().
         */
        static new(): DBusAuthObserver;
        _init(config?: DBusAuthObserver.ConstructorProperties): void;
    }

    namespace DBusConnection {
        // Signal callback interfaces

        /**
         * Signal callback interface for `closed`
         */
        interface ClosedSignalCallback {
            (
                $obj: DBusConnection,
                remote_peer_vanished: boolean,
                error: GLib.Error | null
            ): void;
        }

        // Constructor properties interface

        interface ConstructorProperties
            extends AsyncInitable.ConstructorProperties,
                Initable.ConstructorProperties,
                GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.DBusConnection

            /**
             * A D-Bus address specifying potential endpoints that can be used
             * when establishing the connection.
             */
            address?: string | null;
            /**
             * A #GDBusAuthObserver object to assist in the authentication process or %NULL.
             */
            authentication_observer?: DBusAuthObserver | null;
            /**
             * A boolean specifying whether the process will be terminated (by
             * calling `raise(SIGTERM)`) if the connection is closed by the
             * remote peer.
             *
             * Note that #GDBusConnection objects returned by g_bus_get_finish()
             * and g_bus_get_sync() will (usually) have this property set to %TRUE.
             */
            exit_on_close?: boolean | null;
            /**
             * Flags from the #GDBusConnectionFlags enumeration.
             */
            flags?: DBusConnectionFlags | null;
            /**
             * The GUID of the peer performing the role of server when
             * authenticating.
             *
             * If you are constructing a #GDBusConnection and pass
             * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER in the
             * #GDBusConnection:flags property then you **must** also set this
             * property to a valid guid.
             *
             * If you are constructing a #GDBusConnection and pass
             * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT in the
             * #GDBusConnection:flags property you will be able to read the GUID
             * of the other peer here after the connection has been successfully
             * initialized.
             *
             * Note that the
             * [D-Bus specification](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses)
             * uses the term UUID to refer to this, whereas GLib consistently uses the
             * term GUID for historical reasons.
             *
             * Despite its name, the format of #GDBusConnection:guid does not follow
             * [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122) or the Microsoft
             * GUID format.
             */
            guid?: string | null;
            /**
             * The underlying #GIOStream used for I/O.
             *
             * If this is passed on construction and is a #GSocketConnection,
             * then the corresponding #GSocket will be put into non-blocking mode.
             *
             * While the #GDBusConnection is active, it will interact with this
             * stream from a worker thread, so it is not safe to interact with
             * the stream directly.
             */
            stream?: IOStream | null;
        }
    }

    interface DBusConnection extends AsyncInitable, Initable {
        // Own properties of Gio-2.0.Gio.DBusConnection

        /**
         * A D-Bus address specifying potential endpoints that can be used
         * when establishing the connection.
         */
        readonly address: string | null;
        /**
         * A #GDBusAuthObserver object to assist in the authentication process or %NULL.
         */
        readonly authentication_observer: DBusAuthObserver;
        /**
         * Flags from the #GDBusCapabilityFlags enumeration
         * representing connection features negotiated with the other peer.
         */
        readonly capabilities: DBusCapabilityFlags;
        /**
         * A boolean specifying whether the connection has been closed.
         */
        readonly closed: boolean;
        /**
         * A boolean specifying whether the process will be terminated (by
         * calling `raise(SIGTERM)`) if the connection is closed by the
         * remote peer.
         *
         * Note that #GDBusConnection objects returned by g_bus_get_finish()
         * and g_bus_get_sync() will (usually) have this property set to %TRUE.
         */
        exit_on_close: boolean;
        /**
         * Flags from the #GDBusConnectionFlags enumeration.
         */
        readonly flags: DBusConnectionFlags;
        /**
         * The GUID of the peer performing the role of server when
         * authenticating.
         *
         * If you are constructing a #GDBusConnection and pass
         * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER in the
         * #GDBusConnection:flags property then you **must** also set this
         * property to a valid guid.
         *
         * If you are constructing a #GDBusConnection and pass
         * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT in the
         * #GDBusConnection:flags property you will be able to read the GUID
         * of the other peer here after the connection has been successfully
         * initialized.
         *
         * Note that the
         * [D-Bus specification](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses)
         * uses the term UUID to refer to this, whereas GLib consistently uses the
         * term GUID for historical reasons.
         *
         * Despite its name, the format of #GDBusConnection:guid does not follow
         * [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122) or the Microsoft
         * GUID format.
         */
        readonly guid: string | null;
        /**
         * The underlying #GIOStream used for I/O.
         *
         * If this is passed on construction and is a #GSocketConnection,
         * then the corresponding #GSocket will be put into non-blocking mode.
         *
         * While the #GDBusConnection is active, it will interact with this
         * stream from a worker thread, so it is not safe to interact with
         * the stream directly.
         */
        readonly stream: IOStream;
        /**
         * The unique name as assigned by the message bus or %NULL if the
         * connection is not open or not a message bus connection.
         */
        readonly unique_name: string | null;

        // Owm methods of Gio-2.0.Gio.DBusConnection

        /**
         * Adds a message filter. Filters are handlers that are run on all
         * incoming and outgoing messages, prior to standard dispatch. Filters
         * are run in the order that they were added.  The same handler can be
         * added as a filter more than once, in which case it will be run more
         * than once.  Filters added during a filter callback won't be run on
         * the message being processed. Filter functions are allowed to modify
         * and even drop messages.
         *
         * Note that filters are run in a dedicated message handling thread so
         * they can't block and, generally, can't do anything but signal a
         * worker thread. Also note that filters are rarely needed - use API
         * such as g_dbus_connection_send_message_with_reply(),
         * g_dbus_connection_signal_subscribe() or g_dbus_connection_call() instead.
         *
         * If a filter consumes an incoming message the message is not
         * dispatched anywhere else - not even the standard dispatch machinery
         * (that API such as g_dbus_connection_signal_subscribe() and
         * g_dbus_connection_send_message_with_reply() relies on) will see the
         * message. Similarly, if a filter consumes an outgoing message, the
         * message will not be sent to the other peer.
         *
         * If `user_data_free_func` is non-%NULL, it will be called (in the
         * thread-default main context of the thread you are calling this
         * method from) at some point after `user_data` is no longer
         * needed. (It is not guaranteed to be called synchronously when the
         * filter is removed, and may be called after `connection` has been
         * destroyed.)
         * @param filter_function a filter function
         * @returns a filter identifier that can be used with     g_dbus_connection_remove_filter()
         */
        add_filter(filter_function: DBusMessageFilterFunction): number;
        /**
         * Asynchronously invokes the `method_name` method on the
         * `interface_name` D-Bus interface on the remote object at
         * `object_path` owned by `bus_name`.
         *
         * If `connection` is closed then the operation will fail with
         * %G_IO_ERROR_CLOSED. If `cancellable` is canceled, the operation will
         * fail with %G_IO_ERROR_CANCELLED. If `parameters` contains a value
         * not compatible with the D-Bus protocol, the operation fails with
         * %G_IO_ERROR_INVALID_ARGUMENT.
         *
         * If `reply_type` is non-%NULL then the reply will be checked for having this type and an
         * error will be raised if it does not match.  Said another way, if you give a `reply_type`
         * then any non-%NULL return value will be of this type. Unless its
         * %G_VARIANT_TYPE_UNIT, the `reply_type` will be a tuple containing one or more
         * values.
         *
         * If the `parameters` #GVariant is floating, it is consumed. This allows
         * convenient 'inline' use of g_variant_new(), e.g.:
         *
         * ```c
         *  g_dbus_connection_call (connection,
         *                          "org.freedesktop.StringThings",
         *                          "/org/freedesktop/StringThings",
         *                          "org.freedesktop.StringThings",
         *                          "TwoStrings",
         *                          g_variant_new ("(ss)",
         *                                         "Thing One",
         *                                         "Thing Two"),
         *                          NULL,
         *                          G_DBUS_CALL_FLAGS_NONE,
         *                          -1,
         *                          NULL,
         *                          (GAsyncReadyCallback) two_strings_done,
         *                          NULL);
         * ```
         *
         *
         * This is an asynchronous method. When the operation is finished,
         * `callback` will be invoked in the
         * [thread-default main context][g-main-context-push-thread-default]
         * of the thread you are calling this method from. You can then call
         * g_dbus_connection_call_finish() to get the result of the operation.
         * See g_dbus_connection_call_sync() for the synchronous version of this
         * function.
         *
         * If `callback` is %NULL then the D-Bus method call message will be sent with
         * the %G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set.
         * @param bus_name a unique or well-known bus name or %NULL if     `connection` is not a message bus connection
         * @param object_path path of remote object
         * @param interface_name D-Bus interface to invoke method on
         * @param method_name the name of the method to invoke
         * @param parameters a #GVariant tuple with parameters for the method     or %NULL if not passing parameters
         * @param reply_type the expected type of the reply (which will be a     tuple), or %NULL
         * @param flags flags from the #GDBusCallFlags enumeration
         * @param timeout_msec the timeout in milliseconds, -1 to use the default     timeout or %G_MAXINT for no timeout
         * @param cancellable a #GCancellable or %NULL
         * @param callback a #GAsyncReadyCallback to call when the request     is satisfied or %NULL if you don't care about the result of the     method invocation
         */
        call(
            bus_name: string | null,
            object_path: string | null,
            interface_name: string | null,
            method_name: string | null,
            parameters: GLib.Variant | null,
            reply_type: GLib.VariantType | null,
            flags: DBusCallFlags,
            timeout_msec: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes an operation started with g_dbus_connection_call().
         * @param res a #GAsyncResult obtained from the #GAsyncReadyCallback passed to g_dbus_connection_call()
         * @returns %NULL if @error is set. Otherwise a non-floating     #GVariant tuple with return values. Free with g_variant_unref().
         */
        call_finish(res: AsyncResult): GLib.Variant;
        /**
         * Synchronously invokes the `method_name` method on the
         * `interface_name` D-Bus interface on the remote object at
         * `object_path` owned by `bus_name`.
         *
         * If `connection` is closed then the operation will fail with
         * %G_IO_ERROR_CLOSED. If `cancellable` is canceled, the
         * operation will fail with %G_IO_ERROR_CANCELLED. If `parameters`
         * contains a value not compatible with the D-Bus protocol, the operation
         * fails with %G_IO_ERROR_INVALID_ARGUMENT.
         *
         * If `reply_type` is non-%NULL then the reply will be checked for having
         * this type and an error will be raised if it does not match.  Said
         * another way, if you give a `reply_type` then any non-%NULL return
         * value will be of this type.
         *
         * If the `parameters` #GVariant is floating, it is consumed.
         * This allows convenient 'inline' use of g_variant_new(), e.g.:
         *
         * ```c
         *  g_dbus_connection_call_sync (connection,
         *                               "org.freedesktop.StringThings",
         *                               "/org/freedesktop/StringThings",
         *                               "org.freedesktop.StringThings",
         *                               "TwoStrings",
         *                               g_variant_new ("(ss)",
         *                                              "Thing One",
         *                                              "Thing Two"),
         *                               NULL,
         *                               G_DBUS_CALL_FLAGS_NONE,
         *                               -1,
         *                               NULL,
         *                               &error);
         * ```
         *
         *
         * The calling thread is blocked until a reply is received. See
         * g_dbus_connection_call() for the asynchronous version of
         * this method.
         * @param bus_name a unique or well-known bus name or %NULL if     `connection` is not a message bus connection
         * @param object_path path of remote object
         * @param interface_name D-Bus interface to invoke method on
         * @param method_name the name of the method to invoke
         * @param parameters a #GVariant tuple with parameters for the method     or %NULL if not passing parameters
         * @param reply_type the expected type of the reply, or %NULL
         * @param flags flags from the #GDBusCallFlags enumeration
         * @param timeout_msec the timeout in milliseconds, -1 to use the default     timeout or %G_MAXINT for no timeout
         * @param cancellable a #GCancellable or %NULL
         * @returns %NULL if @error is set. Otherwise a non-floating     #GVariant tuple with return values. Free with g_variant_unref().
         */
        call_sync(
            bus_name: string | null,
            object_path: string | null,
            interface_name: string | null,
            method_name: string | null,
            parameters: GLib.Variant | null,
            reply_type: GLib.VariantType | null,
            flags: DBusCallFlags,
            timeout_msec: number,
            cancellable: Cancellable | null
        ): GLib.Variant;
        /**
         * Like g_dbus_connection_call() but also takes a #GUnixFDList object.
         *
         * The file descriptors normally correspond to %G_VARIANT_TYPE_HANDLE
         * values in the body of the message. For example, if a message contains
         * two file descriptors, `fd_list` would have length 2, and
         * `g_variant_new_handle (0)` and `g_variant_new_handle (1)` would appear
         * somewhere in the body of the message (not necessarily in that order!)
         * to represent the file descriptors at indexes 0 and 1 respectively.
         *
         * When designing D-Bus APIs that are intended to be interoperable,
         * please note that non-GDBus implementations of D-Bus can usually only
         * access file descriptors if they are referenced in this way by a
         * value of type %G_VARIANT_TYPE_HANDLE in the body of the message.
         *
         * This method is only available on UNIX.
         * @param bus_name a unique or well-known bus name or %NULL if     `connection` is not a message bus connection
         * @param object_path path of remote object
         * @param interface_name D-Bus interface to invoke method on
         * @param method_name the name of the method to invoke
         * @param parameters a #GVariant tuple with parameters for the method     or %NULL if not passing parameters
         * @param reply_type the expected type of the reply, or %NULL
         * @param flags flags from the #GDBusCallFlags enumeration
         * @param timeout_msec the timeout in milliseconds, -1 to use the default     timeout or %G_MAXINT for no timeout
         * @param fd_list a #GUnixFDList or %NULL
         * @param cancellable a #GCancellable or %NULL
         * @param callback a #GAsyncReadyCallback to call when the request is     satisfied or %NULL if you don't * care about the result of the     method invocation
         */
        call_with_unix_fd_list(
            bus_name: string | null,
            object_path: string | null,
            interface_name: string | null,
            method_name: string | null,
            parameters: GLib.Variant | null,
            reply_type: GLib.VariantType | null,
            flags: DBusCallFlags,
            timeout_msec: number,
            fd_list: UnixFDList | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes an operation started with g_dbus_connection_call_with_unix_fd_list().
         *
         * The file descriptors normally correspond to %G_VARIANT_TYPE_HANDLE
         * values in the body of the message. For example,
         * if g_variant_get_handle() returns 5, that is intended to be a reference
         * to the file descriptor that can be accessed by
         * `g_unix_fd_list_get (*out_fd_list, 5, ...)`.
         *
         * When designing D-Bus APIs that are intended to be interoperable,
         * please note that non-GDBus implementations of D-Bus can usually only
         * access file descriptors if they are referenced in this way by a
         * value of type %G_VARIANT_TYPE_HANDLE in the body of the message.
         * @param res a #GAsyncResult obtained from the #GAsyncReadyCallback passed to     g_dbus_connection_call_with_unix_fd_list()
         * @returns %NULL if @error is set. Otherwise a non-floating     #GVariant tuple with return values. Free with g_variant_unref().
         */
        call_with_unix_fd_list_finish(
            res: AsyncResult
        ): [/* returnType */ GLib.Variant, /* out_fd_list */ UnixFDList];
        /**
         * Like g_dbus_connection_call_sync() but also takes and returns #GUnixFDList objects.
         * See g_dbus_connection_call_with_unix_fd_list() and
         * g_dbus_connection_call_with_unix_fd_list_finish() for more details.
         *
         * This method is only available on UNIX.
         * @param bus_name a unique or well-known bus name or %NULL     if `connection` is not a message bus connection
         * @param object_path path of remote object
         * @param interface_name D-Bus interface to invoke method on
         * @param method_name the name of the method to invoke
         * @param parameters a #GVariant tuple with parameters for     the method or %NULL if not passing parameters
         * @param reply_type the expected type of the reply, or %NULL
         * @param flags flags from the #GDBusCallFlags enumeration
         * @param timeout_msec the timeout in milliseconds, -1 to use the default     timeout or %G_MAXINT for no timeout
         * @param fd_list a #GUnixFDList or %NULL
         * @param cancellable a #GCancellable or %NULL
         * @returns %NULL if @error is set. Otherwise a non-floating     #GVariant tuple with return values. Free with g_variant_unref().
         */
        call_with_unix_fd_list_sync(
            bus_name: string | null,
            object_path: string | null,
            interface_name: string | null,
            method_name: string | null,
            parameters: GLib.Variant | null,
            reply_type: GLib.VariantType | null,
            flags: DBusCallFlags,
            timeout_msec: number,
            fd_list: UnixFDList | null,
            cancellable: Cancellable | null
        ): [/* returnType */ GLib.Variant, /* out_fd_list */ UnixFDList];
        /**
         * Closes `connection`. Note that this never causes the process to
         * exit (this might only happen if the other end of a shared message
         * bus connection disconnects, see #GDBusConnection:exit-on-close).
         *
         * Once the connection is closed, operations such as sending a message
         * will return with the error %G_IO_ERROR_CLOSED. Closing a connection
         * will not automatically flush the connection so queued messages may
         * be lost. Use g_dbus_connection_flush() if you need such guarantees.
         *
         * If `connection` is already closed, this method fails with
         * %G_IO_ERROR_CLOSED.
         *
         * When `connection` has been closed, the #GDBusConnection::closed
         * signal is emitted in the
         * [thread-default main context][g-main-context-push-thread-default]
         * of the thread that `connection` was constructed in.
         *
         * This is an asynchronous method. When the operation is finished,
         * `callback` will be invoked in the
         * [thread-default main context][g-main-context-push-thread-default]
         * of the thread you are calling this method from. You can
         * then call g_dbus_connection_close_finish() to get the result of the
         * operation. See g_dbus_connection_close_sync() for the synchronous
         * version.
         * @param cancellable a #GCancellable or %NULL
         * @param callback a #GAsyncReadyCallback to call when the request is     satisfied or %NULL if you don't care about the result
         */
        close(
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes an operation started with g_dbus_connection_close().
         * @param res a #GAsyncResult obtained from the #GAsyncReadyCallback passed     to g_dbus_connection_close()
         * @returns %TRUE if the operation succeeded, %FALSE if @error is set
         */
        close_finish(res: AsyncResult): boolean;
        /**
         * Synchronously closes `connection`. The calling thread is blocked
         * until this is done. See g_dbus_connection_close() for the
         * asynchronous version of this method and more details about what it
         * does.
         * @param cancellable a #GCancellable or %NULL
         * @returns %TRUE if the operation succeeded, %FALSE if @error is set
         */
        close_sync(cancellable: Cancellable | null): boolean;
        /**
         * Emits a signal.
         *
         * If the parameters GVariant is floating, it is consumed.
         *
         * This can only fail if `parameters` is not compatible with the D-Bus protocol
         * (%G_IO_ERROR_INVALID_ARGUMENT), or if `connection` has been closed
         * (%G_IO_ERROR_CLOSED).
         * @param destination_bus_name the unique bus name for the destination     for the signal or %NULL to emit to all listeners
         * @param object_path path of remote object
         * @param interface_name D-Bus interface to emit a signal on
         * @param signal_name the name of the signal to emit
         * @param parameters a #GVariant tuple with parameters for the signal              or %NULL if not passing parameters
         * @returns %TRUE unless @error is set
         */
        emit_signal(
            destination_bus_name: string | null,
            object_path: string | null,
            interface_name: string | null,
            signal_name: string | null,
            parameters: GLib.Variant | null
        ): boolean;
        /**
         * Exports `action_group` on `connection` at `object_path`.
         *
         * The implemented D-Bus API should be considered private.  It is
         * subject to change in the future.
         *
         * A given object path can only have one action group exported on it.
         * If this constraint is violated, the export will fail and 0 will be
         * returned (with `error` set accordingly).
         *
         * You can unexport the action group using
         * g_dbus_connection_unexport_action_group() with the return value of
         * this function.
         *
         * The thread default main context is taken at the time of this call.
         * All incoming action activations and state change requests are
         * reported from this context.  Any changes on the action group that
         * cause it to emit signals must also come from this same context.
         * Since incoming action activations and state change requests are
         * rather likely to cause changes on the action group, this effectively
         * limits a given action group to being exported from only one main
         * context.
         * @param object_path a D-Bus object path
         * @param action_group a #GActionGroup
         * @returns the ID of the export (never zero), or 0 in case of failure
         */
        export_action_group(
            object_path: string | null,
            action_group: ActionGroup
        ): number;
        /**
         * Exports `menu` on `connection` at `object_path`.
         *
         * The implemented D-Bus API should be considered private.
         * It is subject to change in the future.
         *
         * An object path can only have one menu model exported on it. If this
         * constraint is violated, the export will fail and 0 will be
         * returned (with `error` set accordingly).
         *
         * Exporting menus with sections containing more than
         * %G_MENU_EXPORTER_MAX_SECTION_SIZE items is not supported and results in
         * undefined behavior.
         *
         * You can unexport the menu model using
         * g_dbus_connection_unexport_menu_model() with the return value of
         * this function.
         * @param object_path a D-Bus object path
         * @param menu a #GMenuModel
         * @returns the ID of the export (never zero), or 0 in case of failure
         */
        export_menu_model(object_path: string | null, menu: MenuModel): number;
        /**
         * Asynchronously flushes `connection,` that is, writes all queued
         * outgoing message to the transport and then flushes the transport
         * (using g_output_stream_flush_async()). This is useful in programs
         * that wants to emit a D-Bus signal and then exit immediately. Without
         * flushing the connection, there is no guaranteed that the message has
         * been sent to the networking buffers in the OS kernel.
         *
         * This is an asynchronous method. When the operation is finished,
         * `callback` will be invoked in the
         * [thread-default main context][g-main-context-push-thread-default]
         * of the thread you are calling this method from. You can
         * then call g_dbus_connection_flush_finish() to get the result of the
         * operation. See g_dbus_connection_flush_sync() for the synchronous
         * version.
         * @param cancellable a #GCancellable or %NULL
         * @param callback a #GAsyncReadyCallback to call when the     request is satisfied or %NULL if you don't care about the result
         */
        flush(
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes an operation started with g_dbus_connection_flush().
         * @param res a #GAsyncResult obtained from the #GAsyncReadyCallback passed     to g_dbus_connection_flush()
         * @returns %TRUE if the operation succeeded, %FALSE if @error is set
         */
        flush_finish(res: AsyncResult): boolean;
        /**
         * Synchronously flushes `connection`. The calling thread is blocked
         * until this is done. See g_dbus_connection_flush() for the
         * asynchronous version of this method and more details about what it
         * does.
         * @param cancellable a #GCancellable or %NULL
         * @returns %TRUE if the operation succeeded, %FALSE if @error is set
         */
        flush_sync(cancellable: Cancellable | null): boolean;
        /**
         * Gets the capabilities negotiated with the remote peer
         * @returns zero or more flags from the #GDBusCapabilityFlags enumeration
         */
        get_capabilities(): DBusCapabilityFlags;
        /**
         * Gets whether the process is terminated when `connection` is
         * closed by the remote peer. See
         * #GDBusConnection:exit-on-close for more details.
         * @returns whether the process is terminated when @connection is     closed by the remote peer
         */
        get_exit_on_close(): boolean;
        /**
         * Gets the flags used to construct this connection
         * @returns zero or more flags from the #GDBusConnectionFlags enumeration
         */
        get_flags(): DBusConnectionFlags;
        /**
         * The GUID of the peer performing the role of server when
         * authenticating. See #GDBusConnection:guid for more details.
         * @returns The GUID. Do not free this string, it is owned by     @connection.
         */
        get_guid(): string | null;
        /**
         * Retrieves the last serial number assigned to a #GDBusMessage on
         * the current thread. This includes messages sent via both low-level
         * API such as g_dbus_connection_send_message() as well as
         * high-level API such as g_dbus_connection_emit_signal(),
         * g_dbus_connection_call() or g_dbus_proxy_call().
         * @returns the last used serial or zero when no message has been sent     within the current thread
         */
        get_last_serial(): number;
        /**
         * Gets the credentials of the authenticated peer. This will always
         * return %NULL unless `connection` acted as a server
         * (e.g. %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER was passed)
         * when set up and the client passed credentials as part of the
         * authentication process.
         *
         * In a message bus setup, the message bus is always the server and
         * each application is a client. So this method will always return
         * %NULL for message bus clients.
         * @returns a #GCredentials or %NULL if not     available. Do not free this object, it is owned by @connection.
         */
        get_peer_credentials(): Credentials | null;
        /**
         * Gets the underlying stream used for IO.
         *
         * While the #GDBusConnection is active, it will interact with this
         * stream from a worker thread, so it is not safe to interact with
         * the stream directly.
         * @returns the stream used for IO
         */
        get_stream(): IOStream;
        /**
         * Gets the unique name of `connection` as assigned by the message
         * bus. This can also be used to figure out if `connection` is a
         * message bus connection.
         * @returns the unique name or %NULL if @connection is not a message     bus connection. Do not free this string, it is owned by     @connection.
         */
        get_unique_name(): string | null;
        /**
         * Gets whether `connection` is closed.
         * @returns %TRUE if the connection is closed, %FALSE otherwise
         */
        is_closed(): boolean;
        /**
         * Version of g_dbus_connection_register_object() using closures instead of a
         * #GDBusInterfaceVTable for easier binding in other languages.
         * @param object_path The object path to register at.
         * @param interface_info Introspection data for the interface.
         * @param method_call_closure #GClosure for handling incoming method calls.
         * @param get_property_closure #GClosure for getting a property.
         * @param set_property_closure #GClosure for setting a property.
         * @returns 0 if @error is set, otherwise a registration ID (never 0) that can be used with g_dbus_connection_unregister_object() .
         */
        register_object(
            object_path: string | null,
            interface_info: DBusInterfaceInfo,
            method_call_closure: GObject.TClosure | null,
            get_property_closure: GObject.TClosure | null,
            set_property_closure: GObject.TClosure | null
        ): number;
        /**
         * Registers a whole subtree of dynamic objects.
         *
         * The `enumerate` and `introspection` functions in `vtable` are used to
         * convey, to remote callers, what nodes exist in the subtree rooted
         * by `object_path`.
         *
         * When handling remote calls into any node in the subtree, first the
         * `enumerate` function is used to check if the node exists. If the node exists
         * or the %G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES flag is set
         * the `introspection` function is used to check if the node supports the
         * requested method. If so, the `dispatch` function is used to determine
         * where to dispatch the call. The collected #GDBusInterfaceVTable and
         * #gpointer will be used to call into the interface vtable for processing
         * the request.
         *
         * All calls into user-provided code will be invoked in the
         * [thread-default main context][g-main-context-push-thread-default]
         * of the thread you are calling this method from.
         *
         * If an existing subtree is already registered at `object_path` or
         * then `error` is set to %G_IO_ERROR_EXISTS.
         *
         * Note that it is valid to register regular objects (using
         * g_dbus_connection_register_object()) in a subtree registered with
         * g_dbus_connection_register_subtree() - if so, the subtree handler
         * is tried as the last resort. One way to think about a subtree
         * handler is to consider it a fallback handler for object paths not
         * registered via g_dbus_connection_register_object() or other bindings.
         *
         * Note that `vtable` will be copied so you cannot change it after
         * registration.
         *
         * See this [server][gdbus-subtree-server] for an example of how to use
         * this method.
         * @param object_path the object path to register the subtree at
         * @param vtable a #GDBusSubtreeVTable to enumerate, introspect and     dispatch nodes in the subtree
         * @param flags flags used to fine tune the behavior of the subtree
         * @param user_data data to pass to functions in `vtable`
         * @param user_data_free_func function to call when the subtree is unregistered
         * @returns 0 if @error is set, otherwise a subtree registration ID (never 0) that can be used with g_dbus_connection_unregister_subtree()
         */
        register_subtree(
            object_path: string | null,
            vtable: DBusSubtreeVTable,
            flags: DBusSubtreeFlags,
            user_data: any | null,
            user_data_free_func: GLib.DestroyNotify
        ): number;
        /**
         * Removes a filter.
         *
         * Note that since filters run in a different thread, there is a race
         * condition where it is possible that the filter will be running even
         * after calling g_dbus_connection_remove_filter(), so you cannot just
         * free data that the filter might be using. Instead, you should pass
         * a #GDestroyNotify to g_dbus_connection_add_filter(), which will be
         * called when it is guaranteed that the data is no longer needed.
         * @param filter_id an identifier obtained from g_dbus_connection_add_filter()
         */
        remove_filter(filter_id: number): void;
        /**
         * Asynchronously sends `message` to the peer represented by `connection`.
         *
         * Unless `flags` contain the
         * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number
         * will be assigned by `connection` and set on `message` via
         * g_dbus_message_set_serial(). If `out_serial` is not %NULL, then the
         * serial number used will be written to this location prior to
         * submitting the message to the underlying transport. While it has a `volatile`
         * qualifier, this is a historical artifact and the argument passed to it should
         * not be `volatile`.
         *
         * If `connection` is closed then the operation will fail with
         * %G_IO_ERROR_CLOSED. If `message` is not well-formed,
         * the operation fails with %G_IO_ERROR_INVALID_ARGUMENT.
         *
         * See this [server][gdbus-server] and [client][gdbus-unix-fd-client]
         * for an example of how to use this low-level API to send and receive
         * UNIX file descriptors.
         *
         * Note that `message` must be unlocked, unless `flags` contain the
         * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
         * @param message a #GDBusMessage
         * @param flags flags affecting how the message is sent
         * @returns %TRUE if the message was well-formed and queued for     transmission, %FALSE if @error is set
         */
        send_message(
            message: DBusMessage,
            flags: DBusSendMessageFlags
        ): [/* returnType */ boolean, /* out_serial */ number];
        /**
         * Asynchronously sends `message` to the peer represented by `connection`.
         *
         * Unless `flags` contain the
         * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number
         * will be assigned by `connection` and set on `message` via
         * g_dbus_message_set_serial(). If `out_serial` is not %NULL, then the
         * serial number used will be written to this location prior to
         * submitting the message to the underlying transport. While it has a `volatile`
         * qualifier, this is a historical artifact and the argument passed to it should
         * not be `volatile`.
         *
         * If `connection` is closed then the operation will fail with
         * %G_IO_ERROR_CLOSED. If `cancellable` is canceled, the operation will
         * fail with %G_IO_ERROR_CANCELLED. If `message` is not well-formed,
         * the operation fails with %G_IO_ERROR_INVALID_ARGUMENT.
         *
         * This is an asynchronous method. When the operation is finished, `callback`
         * will be invoked in the
         * [thread-default main context][g-main-context-push-thread-default]
         * of the thread you are calling this method from. You can then call
         * g_dbus_connection_send_message_with_reply_finish() to get the result of the operation.
         * See g_dbus_connection_send_message_with_reply_sync() for the synchronous version.
         *
         * Note that `message` must be unlocked, unless `flags` contain the
         * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
         *
         * See this [server][gdbus-server] and [client][gdbus-unix-fd-client]
         * for an example of how to use this low-level API to send and receive
         * UNIX file descriptors.
         * @param message a #GDBusMessage
         * @param flags flags affecting how the message is sent
         * @param timeout_msec the timeout in milliseconds, -1 to use the default     timeout or %G_MAXINT for no timeout
         * @param cancellable a #GCancellable or %NULL
         * @param callback a #GAsyncReadyCallback to call when the request     is satisfied or %NULL if you don't care about the result
         */
        send_message_with_reply(
            message: DBusMessage,
            flags: DBusSendMessageFlags,
            timeout_msec: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): /* out_serial */ number;
        /**
         * Finishes an operation started with g_dbus_connection_send_message_with_reply().
         *
         * Note that `error` is only set if a local in-process error
         * occurred. That is to say that the returned #GDBusMessage object may
         * be of type %G_DBUS_MESSAGE_TYPE_ERROR. Use
         * g_dbus_message_to_gerror() to transcode this to a #GError.
         *
         * See this [server][gdbus-server] and [client][gdbus-unix-fd-client]
         * for an example of how to use this low-level API to send and receive
         * UNIX file descriptors.
         * @param res a #GAsyncResult obtained from the #GAsyncReadyCallback passed to     g_dbus_connection_send_message_with_reply()
         * @returns a locked #GDBusMessage or %NULL if @error is set
         */
        send_message_with_reply_finish(res: AsyncResult): DBusMessage;
        /**
         * Synchronously sends `message` to the peer represented by `connection`
         * and blocks the calling thread until a reply is received or the
         * timeout is reached. See g_dbus_connection_send_message_with_reply()
         * for the asynchronous version of this method.
         *
         * Unless `flags` contain the
         * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number
         * will be assigned by `connection` and set on `message` via
         * g_dbus_message_set_serial(). If `out_serial` is not %NULL, then the
         * serial number used will be written to this location prior to
         * submitting the message to the underlying transport. While it has a `volatile`
         * qualifier, this is a historical artifact and the argument passed to it should
         * not be `volatile`.
         *
         * If `connection` is closed then the operation will fail with
         * %G_IO_ERROR_CLOSED. If `cancellable` is canceled, the operation will
         * fail with %G_IO_ERROR_CANCELLED. If `message` is not well-formed,
         * the operation fails with %G_IO_ERROR_INVALID_ARGUMENT.
         *
         * Note that `error` is only set if a local in-process error
         * occurred. That is to say that the returned #GDBusMessage object may
         * be of type %G_DBUS_MESSAGE_TYPE_ERROR. Use
         * g_dbus_message_to_gerror() to transcode this to a #GError.
         *
         * See this [server][gdbus-server] and [client][gdbus-unix-fd-client]
         * for an example of how to use this low-level API to send and receive
         * UNIX file descriptors.
         *
         * Note that `message` must be unlocked, unless `flags` contain the
         * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
         * @param message a #GDBusMessage
         * @param flags flags affecting how the message is sent.
         * @param timeout_msec the timeout in milliseconds, -1 to use the default     timeout or %G_MAXINT for no timeout
         * @param cancellable a #GCancellable or %NULL
         * @returns a locked #GDBusMessage that is the reply     to @message or %NULL if @error is set
         */
        send_message_with_reply_sync(
            message: DBusMessage,
            flags: DBusSendMessageFlags,
            timeout_msec: number,
            cancellable: Cancellable | null
        ): [/* returnType */ DBusMessage, /* out_serial */ number];
        /**
         * Sets whether the process should be terminated when `connection` is
         * closed by the remote peer. See #GDBusConnection:exit-on-close for
         * more details.
         *
         * Note that this function should be used with care. Most modern UNIX
         * desktops tie the notion of a user session with the session bus, and expect
         * all of a user's applications to quit when their bus connection goes away.
         * If you are setting `exit_on_close` to %FALSE for the shared session
         * bus connection, you should make sure that your application exits
         * when the user session ends.
         * @param exit_on_close whether the process should be terminated     when `connection` is closed by the remote peer
         */
        set_exit_on_close(exit_on_close: boolean): void;
        /**
         * Subscribes to signals on `connection` and invokes `callback` whenever
         * the signal is received. Note that `callback` will be invoked in the
         * [thread-default main context][g-main-context-push-thread-default]
         * of the thread you are calling this method from.
         *
         * If `connection` is not a message bus connection, `sender` must be
         * %NULL.
         *
         * If `sender` is a well-known name note that `callback` is invoked with
         * the unique name for the owner of `sender,` not the well-known name
         * as one would expect. This is because the message bus rewrites the
         * name. As such, to avoid certain race conditions, users should be
         * tracking the name owner of the well-known name and use that when
         * processing the received signal.
         *
         * If one of %G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE or
         * %G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH are given, `arg0` is
         * interpreted as part of a namespace or path.  The first argument
         * of a signal is matched against that part as specified by D-Bus.
         *
         * If `user_data_free_func` is non-%NULL, it will be called (in the
         * thread-default main context of the thread you are calling this
         * method from) at some point after `user_data` is no longer
         * needed. (It is not guaranteed to be called synchronously when the
         * signal is unsubscribed from, and may be called after `connection`
         * has been destroyed.)
         *
         * As `callback` is potentially invoked in a different thread from where its
         * emitted, its possible for this to happen after
         * g_dbus_connection_signal_unsubscribe() has been called in another thread.
         * Due to this, `user_data` should have a strong reference which is freed with
         * `user_data_free_func,` rather than pointing to data whose lifecycle is tied
         * to the signal subscription. For example, if a #GObject is used to store the
         * subscription ID from g_dbus_connection_signal_subscribe(), a strong reference
         * to that #GObject must be passed to `user_data,` and g_object_unref() passed to
         * `user_data_free_func`. You are responsible for breaking the resulting
         * reference count cycle by explicitly unsubscribing from the signal when
         * dropping the last external reference to the #GObject. Alternatively, a weak
         * reference may be used.
         *
         * It is guaranteed that if you unsubscribe from a signal using
         * g_dbus_connection_signal_unsubscribe() from the same thread which made the
         * corresponding g_dbus_connection_signal_subscribe() call, `callback` will not
         * be invoked after g_dbus_connection_signal_unsubscribe() returns.
         *
         * The returned subscription identifier is an opaque value which is guaranteed
         * to never be zero.
         *
         * This function can never fail.
         * @param sender sender name to match on (unique or well-known name)     or %NULL to listen from all senders
         * @param interface_name D-Bus interface name to match on or %NULL to     match on all interfaces
         * @param member D-Bus signal name to match on or %NULL to match on     all signals
         * @param object_path object path to match on or %NULL to match on     all object paths
         * @param arg0 contents of first string argument to match on or %NULL     to match on all kinds of arguments
         * @param flags #GDBusSignalFlags describing how arg0 is used in subscribing to the     signal
         * @param callback callback to invoke when there is a signal matching the requested data
         * @returns a subscription identifier that can be used with g_dbus_connection_signal_unsubscribe()
         */
        signal_subscribe(
            sender: string | null,
            interface_name: string | null,
            member: string | null,
            object_path: string | null,
            arg0: string | null,
            flags: DBusSignalFlags,
            callback: DBusSignalCallback
        ): number;
        /**
         * Unsubscribes from signals.
         *
         * Note that there may still be D-Bus traffic to process (relating to this
         * signal subscription) in the current thread-default #GMainContext after this
         * function has returned. You should continue to iterate the #GMainContext
         * until the #GDestroyNotify function passed to
         * g_dbus_connection_signal_subscribe() is called, in order to avoid memory
         * leaks through callbacks queued on the #GMainContext after its stopped being
         * iterated.
         * Alternatively, any idle source with a priority lower than %G_PRIORITY_DEFAULT
         * that was scheduled after unsubscription, also indicates that all resources
         * of this subscription are released.
         * @param subscription_id a subscription id obtained from     g_dbus_connection_signal_subscribe()
         */
        signal_unsubscribe(subscription_id: number): void;
        /**
         * If `connection` was created with
         * %G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING, this method
         * starts processing messages. Does nothing on if `connection` wasn't
         * created with this flag or if the method has already been called.
         */
        start_message_processing(): void;
        /**
         * Reverses the effect of a previous call to
         * g_dbus_connection_export_action_group().
         *
         * It is an error to call this function with an ID that wasn't returned
         * from g_dbus_connection_export_action_group() or to call it with the
         * same ID more than once.
         * @param export_id the ID from g_dbus_connection_export_action_group()
         */
        unexport_action_group(export_id: number): void;
        /**
         * Reverses the effect of a previous call to
         * g_dbus_connection_export_menu_model().
         *
         * It is an error to call this function with an ID that wasn't returned
         * from g_dbus_connection_export_menu_model() or to call it with the
         * same ID more than once.
         * @param export_id the ID from g_dbus_connection_export_menu_model()
         */
        unexport_menu_model(export_id: number): void;
        /**
         * Unregisters an object.
         * @param registration_id a registration id obtained from     g_dbus_connection_register_object()
         * @returns %TRUE if the object was unregistered, %FALSE otherwise
         */
        unregister_object(registration_id: number): boolean;
        /**
         * Unregisters a subtree.
         * @param registration_id a subtree registration id obtained from     g_dbus_connection_register_subtree()
         * @returns %TRUE if the subtree was unregistered, %FALSE otherwise
         */
        unregister_subtree(registration_id: number): boolean;
        watch_name(
            name: string,
            flags: BusNameWatcherFlags,
            name_appeared_closure: GObject.TClosure | null,
            name_vanished_closure: GObject.TClosure | null
        ): number;
        unwatch_name(id: number): void;
        own_name(
            name: string,
            flags: BusNameOwnerFlags,
            name_acquired_closure: GObject.TClosure | null,
            name_lost_closure: GObject.TClosure | null
        ): number;
        unown_name(id: number): void;

        // Own signals of Gio-2.0.Gio.DBusConnection

        connect(
            sigName: 'closed',
            callback: DBusConnection.ClosedSignalCallback
        ): number;
        connect_after(
            sigName: 'closed',
            callback: DBusConnection.ClosedSignalCallback
        ): number;
        emit(
            sigName: 'closed',
            remote_peer_vanished: boolean,
            error: GLib.Error | null,
            ...args: any[]
        ): void;

        // Class property signals of Gio-2.0.Gio.DBusConnection

        connect(
            sigName: 'notify::address',
            callback: ($obj: DBusConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::address',
            callback: ($obj: DBusConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::address', ...args: any[]): void;
        connect(
            sigName: 'notify::authentication-observer',
            callback: ($obj: DBusConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::authentication-observer',
            callback: ($obj: DBusConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::authentication-observer', ...args: any[]): void;
        connect(
            sigName: 'notify::capabilities',
            callback: ($obj: DBusConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::capabilities',
            callback: ($obj: DBusConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::capabilities', ...args: any[]): void;
        connect(
            sigName: 'notify::closed',
            callback: ($obj: DBusConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::closed',
            callback: ($obj: DBusConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::closed', ...args: any[]): void;
        connect(
            sigName: 'notify::exit-on-close',
            callback: ($obj: DBusConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::exit-on-close',
            callback: ($obj: DBusConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::exit-on-close', ...args: any[]): void;
        connect(
            sigName: 'notify::flags',
            callback: ($obj: DBusConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::flags',
            callback: ($obj: DBusConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::flags', ...args: any[]): void;
        connect(
            sigName: 'notify::guid',
            callback: ($obj: DBusConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::guid',
            callback: ($obj: DBusConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::guid', ...args: any[]): void;
        connect(
            sigName: 'notify::stream',
            callback: ($obj: DBusConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::stream',
            callback: ($obj: DBusConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::stream', ...args: any[]): void;
        connect(
            sigName: 'notify::unique-name',
            callback: ($obj: DBusConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::unique-name',
            callback: ($obj: DBusConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::unique-name', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * The #GDBusConnection type is used for D-Bus connections to remote
     * peers such as a message buses. It is a low-level API that offers a
     * lot of flexibility. For instance, it lets you establish a connection
     * over any transport that can by represented as a #GIOStream.
     *
     * This class is rarely used directly in D-Bus clients. If you are writing
     * a D-Bus client, it is often easier to use the g_bus_own_name(),
     * g_bus_watch_name() or g_dbus_proxy_new_for_bus() APIs.
     *
     * As an exception to the usual GLib rule that a particular object must not
     * be used by two threads at the same time, #GDBusConnection's methods may be
     * called from any thread. This is so that g_bus_get() and g_bus_get_sync()
     * can safely return the same #GDBusConnection when called from any thread.
     *
     * Most of the ways to obtain a #GDBusConnection automatically initialize it
     * (i.e. connect to D-Bus): for instance, g_dbus_connection_new() and
     * g_bus_get(), and the synchronous versions of those methods, give you an
     * initialized connection. Language bindings for GIO should use
     * g_initable_new() or g_async_initable_new_async(), which also initialize the
     * connection.
     *
     * If you construct an uninitialized #GDBusConnection, such as via
     * g_object_new(), you must initialize it via g_initable_init() or
     * g_async_initable_init_async() before using its methods or properties.
     * Calling methods or accessing properties on a #GDBusConnection that has not
     * completed initialization successfully is considered to be invalid, and leads
     * to undefined behaviour. In particular, if initialization fails with a
     * #GError, the only valid thing you can do with that #GDBusConnection is to
     * free it with g_object_unref().
     *
     * ## An example D-Bus server # {#gdbus-server}
     *
     * Here is an example for a D-Bus server:
     * [gdbus-example-server.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-server.c)
     *
     * ## An example for exporting a subtree # {#gdbus-subtree-server}
     *
     * Here is an example for exporting a subtree:
     * [gdbus-example-subtree.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-subtree.c)
     *
     * ## An example for file descriptor passing # {#gdbus-unix-fd-client}
     *
     * Here is an example for passing UNIX file descriptors:
     * [gdbus-unix-fd-client.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-unix-fd-client.c)
     *
     * ## An example for exporting a GObject # {#gdbus-export}
     *
     * Here is an example for exporting a #GObject:
     * [gdbus-example-export.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-export.c)
     * @class
     */
    class DBusConnection extends GObject.Object {
        // Own properties of Gio-2.0.Gio.DBusConnection

        static name: string;
        static $gtype: GObject.GType<DBusConnection>;

        // Constructors of Gio-2.0.Gio.DBusConnection

        constructor(config?: DBusConnection.ConstructorProperties);
        /**
         * Finishes an operation started with g_dbus_connection_new().
         * @constructor
         * @param res a #GAsyncResult obtained from the #GAsyncReadyCallback     passed to g_dbus_connection_new().
         * @returns a #GDBusConnection or %NULL if @error is set. Free     with g_object_unref().
         */
        static new_finish(res: AsyncResult): DBusConnection;
        /**
         * Finishes an operation started with g_dbus_connection_new_for_address().
         * @constructor
         * @param res a #GAsyncResult obtained from the #GAsyncReadyCallback passed     to g_dbus_connection_new()
         * @returns a #GDBusConnection or %NULL if @error is set.     Free with g_object_unref().
         */
        static new_for_address_finish(res: AsyncResult): DBusConnection;
        /**
         * Synchronously connects and sets up a D-Bus client connection for
         * exchanging D-Bus messages with an endpoint specified by `address`
         * which must be in the
         * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
         *
         * This constructor can only be used to initiate client-side
         * connections - use g_dbus_connection_new_sync() if you need to act
         * as the server. In particular, `flags` cannot contain the
         * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER,
         * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS or
         * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER flags.
         *
         * This is a synchronous failable constructor. See
         * g_dbus_connection_new_for_address() for the asynchronous version.
         *
         * If `observer` is not %NULL it may be used to control the
         * authentication process.
         * @constructor
         * @param address a D-Bus address
         * @param flags flags describing how to make the connection
         * @param observer a #GDBusAuthObserver or %NULL
         * @param cancellable a #GCancellable or %NULL
         * @returns a #GDBusConnection or %NULL if @error is set.     Free with g_object_unref().
         */
        static new_for_address_sync(
            address: string | null,
            flags: DBusConnectionFlags,
            observer: DBusAuthObserver | null,
            cancellable: Cancellable | null
        ): DBusConnection;
        /**
         * Synchronously sets up a D-Bus connection for exchanging D-Bus messages
         * with the end represented by `stream`.
         *
         * If `stream` is a #GSocketConnection, then the corresponding #GSocket
         * will be put into non-blocking mode.
         *
         * The D-Bus connection will interact with `stream` from a worker thread.
         * As a result, the caller should not interact with `stream` after this
         * method has been called, except by calling g_object_unref() on it.
         *
         * If `observer` is not %NULL it may be used to control the
         * authentication process.
         *
         * This is a synchronous failable constructor. See
         * g_dbus_connection_new() for the asynchronous version.
         * @constructor
         * @param stream a #GIOStream
         * @param guid the GUID to use if authenticating as a server or %NULL
         * @param flags flags describing how to make the connection
         * @param observer a #GDBusAuthObserver or %NULL
         * @param cancellable a #GCancellable or %NULL
         * @returns a #GDBusConnection or %NULL if @error is set.     Free with g_object_unref().
         */
        static new_sync(
            stream: IOStream,
            guid: string | null,
            flags: DBusConnectionFlags,
            observer: DBusAuthObserver | null,
            cancellable: Cancellable | null
        ): DBusConnection;
        _init(config?: DBusConnection.ConstructorProperties): void;
        /**
         * Asynchronously sets up a D-Bus connection for exchanging D-Bus messages
         * with the end represented by `stream`.
         *
         * If `stream` is a #GSocketConnection, then the corresponding #GSocket
         * will be put into non-blocking mode.
         *
         * The D-Bus connection will interact with `stream` from a worker thread.
         * As a result, the caller should not interact with `stream` after this
         * method has been called, except by calling g_object_unref() on it.
         *
         * If `observer` is not %NULL it may be used to control the
         * authentication process.
         *
         * When the operation is finished, `callback` will be invoked. You can
         * then call g_dbus_connection_new_finish() to get the result of the
         * operation.
         *
         * This is an asynchronous failable constructor. See
         * g_dbus_connection_new_sync() for the synchronous
         * version.
         * @param stream a #GIOStream
         * @param guid the GUID to use if authenticating as a server or %NULL
         * @param flags flags describing how to make the connection
         * @param observer a #GDBusAuthObserver or %NULL
         * @param cancellable a #GCancellable or %NULL
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied
         */
        static new(
            stream: IOStream,
            guid: string | null,
            flags: DBusConnectionFlags,
            observer: DBusAuthObserver | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<DBusConnection> | null
        ): void;
        /**
         * Asynchronously connects and sets up a D-Bus client connection for
         * exchanging D-Bus messages with an endpoint specified by `address`
         * which must be in the
         * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
         *
         * This constructor can only be used to initiate client-side
         * connections - use g_dbus_connection_new() if you need to act as the
         * server. In particular, `flags` cannot contain the
         * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER,
         * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS or
         * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER flags.
         *
         * When the operation is finished, `callback` will be invoked. You can
         * then call g_dbus_connection_new_for_address_finish() to get the result of
         * the operation.
         *
         * If `observer` is not %NULL it may be used to control the
         * authentication process.
         *
         * This is an asynchronous failable constructor. See
         * g_dbus_connection_new_for_address_sync() for the synchronous
         * version.
         * @param address a D-Bus address
         * @param flags flags describing how to make the connection
         * @param observer a #GDBusAuthObserver or %NULL
         * @param cancellable a #GCancellable or %NULL
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied
         */
        static new_for_address(
            address: string | null,
            flags: DBusConnectionFlags,
            observer: DBusAuthObserver | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<DBusConnection> | null
        ): void;
    }

    namespace DBusInterfaceSkeleton {
        // Signal callback interfaces

        /**
         * Signal callback interface for `g-authorize-method`
         */
        interface GAuthorizeMethodSignalCallback {
            (
                $obj: DBusInterfaceSkeleton,
                invocation: DBusMethodInvocation
            ): boolean;
        }

        // Constructor properties interface

        interface ConstructorProperties
            extends DBusInterface.ConstructorProperties,
                GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.DBusInterfaceSkeleton

            /**
             * Flags from the #GDBusInterfaceSkeletonFlags enumeration.
             */
            g_flags?: DBusInterfaceSkeletonFlags | null;
        }
    }

    interface DBusInterfaceSkeleton extends DBusInterface {
        // Own properties of Gio-2.0.Gio.DBusInterfaceSkeleton

        /**
         * Flags from the #GDBusInterfaceSkeletonFlags enumeration.
         */
        g_flags: DBusInterfaceSkeletonFlags;

        // Owm methods of Gio-2.0.Gio.DBusInterfaceSkeleton

        /**
         * Exports `interface_` at `object_path` on `connection`.
         *
         * This can be called multiple times to export the same `interface_`
         * onto multiple connections however the `object_path` provided must be
         * the same for all connections.
         *
         * Use g_dbus_interface_skeleton_unexport() to unexport the object.
         * @param connection A #GDBusConnection to export `interface_` on.
         * @param object_path The path to export the interface at.
         * @returns %TRUE if the interface was exported on @connection, otherwise %FALSE with @error set.
         */
        export(connection: DBusConnection, object_path: string | null): boolean;
        /**
         * If `interface_` has outstanding changes, request for these changes to be
         * emitted immediately.
         *
         * For example, an exported D-Bus interface may queue up property
         * changes and emit the
         * `org.freedesktop.DBus.Properties.PropertiesChanged`
         * signal later (e.g. in an idle handler). This technique is useful
         * for collapsing multiple property changes into one.
         */
        flush(): void;
        /**
         * Gets the first connection that `interface_` is exported on, if any.
         * @returns A #GDBusConnection or %NULL if @interface_ is not exported anywhere. Do not free, the object belongs to @interface_.
         */
        get_connection(): DBusConnection | null;
        /**
         * Gets a list of the connections that `interface_` is exported on.
         * @returns A list of   all the connections that @interface_ is exported on. The returned   list should be freed with g_list_free() after each element has   been freed with g_object_unref().
         */
        get_connections(): DBusConnection[];
        /**
         * Gets the #GDBusInterfaceSkeletonFlags that describes what the behavior
         * of `interface_`
         * @returns One or more flags from the #GDBusInterfaceSkeletonFlags enumeration.
         */
        get_flags(): DBusInterfaceSkeletonFlags;
        /**
         * Gets D-Bus introspection information for the D-Bus interface
         * implemented by `interface_`.
         * @returns A #GDBusInterfaceInfo (never %NULL). Do not free.
         */
        get_info(): DBusInterfaceInfo;
        /**
         * Gets the object path that `interface_` is exported on, if any.
         * @returns A string owned by @interface_ or %NULL if @interface_ is not exported anywhere. Do not free, the string belongs to @interface_.
         */
        get_object_path(): string | null;
        /**
         * Gets all D-Bus properties for `interface_`.
         * @returns A #GVariant of type ['a{sv}'][G-VARIANT-TYPE-VARDICT:CAPS]. Free with g_variant_unref().
         */
        get_properties(): GLib.Variant;
        /**
         * Gets the interface vtable for the D-Bus interface implemented by
         * `interface_`. The returned function pointers should expect `interface_`
         * itself to be passed as `user_data`.
         * @returns the vtable of the D-Bus interface implemented by the skeleton
         */
        get_vtable(): DBusInterfaceVTable;
        /**
         * Checks if `interface_` is exported on `connection`.
         * @param connection A #GDBusConnection.
         * @returns %TRUE if @interface_ is exported on @connection, %FALSE otherwise.
         */
        has_connection(connection: DBusConnection): boolean;
        /**
         * Sets flags describing what the behavior of `skeleton` should be.
         * @param flags Flags from the #GDBusInterfaceSkeletonFlags enumeration.
         */
        set_flags(flags: DBusInterfaceSkeletonFlags): void;
        /**
         * Stops exporting `interface_` on all connections it is exported on.
         *
         * To unexport `interface_` from only a single connection, use
         * g_dbus_interface_skeleton_unexport_from_connection()
         */
        unexport(): void;
        /**
         * Stops exporting `interface_` on `connection`.
         *
         * To stop exporting on all connections the interface is exported on,
         * use g_dbus_interface_skeleton_unexport().
         * @param connection A #GDBusConnection.
         */
        unexport_from_connection(connection: DBusConnection): void;

        // Own virtual methods of Gio-2.0.Gio.DBusInterfaceSkeleton

        /**
         * If `interface_` has outstanding changes, request for these changes to be
         * emitted immediately.
         *
         * For example, an exported D-Bus interface may queue up property
         * changes and emit the
         * `org.freedesktop.DBus.Properties.PropertiesChanged`
         * signal later (e.g. in an idle handler). This technique is useful
         * for collapsing multiple property changes into one.
         * @virtual
         */
        vfunc_flush(): void;
        vfunc_g_authorize_method(invocation: DBusMethodInvocation): boolean;
        /**
         * Gets D-Bus introspection information for the D-Bus interface
         * implemented by `interface_`.
         * @virtual
         * @returns A #GDBusInterfaceInfo (never %NULL). Do not free.
         */
        vfunc_get_info(): DBusInterfaceInfo;
        /**
         * Gets all D-Bus properties for `interface_`.
         * @virtual
         * @returns A #GVariant of type ['a{sv}'][G-VARIANT-TYPE-VARDICT:CAPS]. Free with g_variant_unref().
         */
        vfunc_get_properties(): GLib.Variant;
        /**
         * Gets the interface vtable for the D-Bus interface implemented by
         * `interface_`. The returned function pointers should expect `interface_`
         * itself to be passed as `user_data`.
         * @virtual
         * @returns the vtable of the D-Bus interface implemented by the skeleton
         */
        vfunc_get_vtable(): DBusInterfaceVTable;

        // Own signals of Gio-2.0.Gio.DBusInterfaceSkeleton

        connect(
            sigName: 'g-authorize-method',
            callback: DBusInterfaceSkeleton.GAuthorizeMethodSignalCallback
        ): number;
        connect_after(
            sigName: 'g-authorize-method',
            callback: DBusInterfaceSkeleton.GAuthorizeMethodSignalCallback
        ): number;
        emit(
            sigName: 'g-authorize-method',
            invocation: DBusMethodInvocation,
            ...args: any[]
        ): void;

        // Class property signals of Gio-2.0.Gio.DBusInterfaceSkeleton

        connect(
            sigName: 'notify::g-flags',
            callback: (
                $obj: DBusInterfaceSkeleton,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::g-flags',
            callback: (
                $obj: DBusInterfaceSkeleton,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::g-flags', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * Abstract base class for D-Bus interfaces on the service side.
     * @class
     */
    class DBusInterfaceSkeleton extends GObject.Object {
        // Own properties of Gio-2.0.Gio.DBusInterfaceSkeleton

        static name: string;
        static $gtype: GObject.GType<DBusInterfaceSkeleton>;

        // Constructors of Gio-2.0.Gio.DBusInterfaceSkeleton

        constructor(config?: DBusInterfaceSkeleton.ConstructorProperties);
        _init(config?: DBusInterfaceSkeleton.ConstructorProperties): void;
    }

    namespace DBusMenuModel {
        // Constructor properties interface

        type ConstructorProperties = MenuModel.ConstructorProperties;
    }

    interface DBusMenuModel {
        // Class property signals of Gio-2.0.Gio.DBusMenuModel

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GDBusMenuModel is an implementation of #GMenuModel that can be used
     * as a proxy for a menu model that is exported over D-Bus with
     * g_dbus_connection_export_menu_model().
     * @class
     */
    class DBusMenuModel extends MenuModel {
        // Own properties of Gio-2.0.Gio.DBusMenuModel

        static name: string;
        static $gtype: GObject.GType<DBusMenuModel>;

        // Constructors of Gio-2.0.Gio.DBusMenuModel

        constructor(config?: DBusMenuModel.ConstructorProperties);
        _init(config?: DBusMenuModel.ConstructorProperties): void;
        /**
         * Obtains a #GDBusMenuModel for the menu model which is exported
         * at the given `bus_name` and `object_path`.
         *
         * The thread default main context is taken at the time of this call.
         * All signals on the menu model (and any linked models) are reported
         * with respect to this context.  All calls on the returned menu model
         * (and linked models) must also originate from this same context, with
         * the thread default main context unchanged.
         * @param connection a #GDBusConnection
         * @param bus_name the bus name which exports the menu model     or %NULL if `connection` is not a message bus connection
         * @param object_path the object path at which the menu model is exported
         * @returns a #GDBusMenuModel object. Free with     g_object_unref().
         */
        static get(
            connection: DBusConnection,
            bus_name: string | null,
            object_path: string | null
        ): DBusMenuModel;
    }

    namespace DBusMessage {
        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface DBusMessage {
        // Own properties of Gio-2.0.Gio.DBusMessage

        readonly locked: boolean;

        // Owm methods of Gio-2.0.Gio.DBusMessage

        /**
         * Copies `message`. The copy is a deep copy and the returned
         * #GDBusMessage is completely identical except that it is guaranteed
         * to not be locked.
         *
         * This operation can fail if e.g. `message` contains file descriptors
         * and the per-process or system-wide open files limit is reached.
         * @returns A new #GDBusMessage or %NULL if @error is set.     Free with g_object_unref().
         */
        copy(): DBusMessage;
        /**
         * Convenience to get the first item in the body of `message`.
         * @returns The string item or %NULL if the first item in the body of @message is not a string.
         */
        get_arg0(): string | null;
        /**
         * Gets the body of a message.
         * @returns A #GVariant or %NULL if the body is empty. Do not free, it is owned by @message.
         */
        get_body(): GLib.Variant | null;
        /**
         * Gets the byte order of `message`.
         * @returns The byte order.
         */
        get_byte_order(): DBusMessageByteOrder;
        /**
         * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
         * @returns The value.
         */
        get_destination(): string | null;
        /**
         * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
         * @returns The value.
         */
        get_error_name(): string | null;
        /**
         * Gets the flags for `message`.
         * @returns Flags that are set (typically values from the #GDBusMessageFlags enumeration bitwise ORed together).
         */
        get_flags(): DBusMessageFlags;
        /**
         * Gets a header field on `message`.
         *
         * The caller is responsible for checking the type of the returned #GVariant
         * matches what is expected.
         * @param header_field A 8-bit unsigned integer (typically a value from the #GDBusMessageHeaderField enumeration)
         * @returns A #GVariant with the value if the header was found, %NULL otherwise. Do not free, it is owned by @message.
         */
        get_header(header_field: DBusMessageHeaderField): GLib.Variant | null;
        /**
         * Gets an array of all header fields on `message` that are set.
         * @returns An array of header fields terminated by %G_DBUS_MESSAGE_HEADER_FIELD_INVALID.  Each element is a #guchar. Free with g_free().
         */
        get_header_fields(): Uint8Array;
        /**
         * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
         * @returns The value.
         */
        get_interface(): string | null;
        /**
         * Checks whether `message` is locked. To monitor changes to this
         * value, conncet to the #GObject::notify signal to listen for changes
         * on the #GDBusMessage:locked property.
         * @returns %TRUE if @message is locked, %FALSE otherwise.
         */
        get_locked(): boolean;
        /**
         * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_MEMBER header field.
         * @returns The value.
         */
        get_member(): string | null;
        /**
         * Gets the type of `message`.
         * @returns A 8-bit unsigned integer (typically a value from the #GDBusMessageType enumeration).
         */
        get_message_type(): DBusMessageType;
        /**
         * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
         * @returns The value.
         */
        get_num_unix_fds(): number;
        /**
         * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_PATH header field.
         * @returns The value.
         */
        get_path(): string | null;
        /**
         * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
         * @returns The value.
         */
        get_reply_serial(): number;
        /**
         * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_SENDER header field.
         * @returns The value.
         */
        get_sender(): string | null;
        /**
         * Gets the serial for `message`.
         * @returns A #guint32.
         */
        get_serial(): number;
        /**
         * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.
         *
         * This will always be non-%NULL, but may be an empty string.
         * @returns The value.
         */
        get_signature(): string | null;
        /**
         * Gets the UNIX file descriptors associated with `message,` if any.
         *
         * This method is only available on UNIX.
         *
         * The file descriptors normally correspond to %G_VARIANT_TYPE_HANDLE
         * values in the body of the message. For example,
         * if g_variant_get_handle() returns 5, that is intended to be a reference
         * to the file descriptor that can be accessed by
         * `g_unix_fd_list_get (list, 5, ...)`.
         * @returns A #GUnixFDList or %NULL if no file descriptors are associated. Do not free, this object is owned by @message.
         */
        get_unix_fd_list(): UnixFDList | null;
        /**
         * If `message` is locked, does nothing. Otherwise locks the message.
         */
        lock(): void;
        /**
         * Creates a new #GDBusMessage that is an error reply to `method_call_message`.
         * @param error_name A valid D-Bus error name.
         * @param error_message The D-Bus error message.
         * @returns A #GDBusMessage. Free with g_object_unref().
         */
        new_method_error_literal(
            error_name: string | null,
            error_message: string | null
        ): DBusMessage;
        /**
         * Creates a new #GDBusMessage that is a reply to `method_call_message`.
         * @returns #GDBusMessage. Free with g_object_unref().
         */
        new_method_reply(): DBusMessage;
        /**
         * Produces a human-readable multi-line description of `message`.
         *
         * The contents of the description has no ABI guarantees, the contents
         * and formatting is subject to change at any time. Typical output
         * looks something like this:
         *
         * ```
         * Flags:   none
         * Version: 0
         * Serial:  4
         * Headers:
         *   path -> objectpath '/org/gtk/GDBus/TestObject'
         *   interface -> 'org.gtk.GDBus.TestInterface'
         *   member -> 'GimmeStdout'
         *   destination -> ':1.146'
         * Body: ()
         * UNIX File Descriptors:
         *   (none)
         * ```
         *
         * or
         *
         * ```
         * Flags:   no-reply-expected
         * Version: 0
         * Serial:  477
         * Headers:
         *   reply-serial -> uint32 4
         *   destination -> ':1.159'
         *   sender -> ':1.146'
         *   num-unix-fds -> uint32 1
         * Body: ()
         * UNIX File Descriptors:
         *   fd 12: dev=0:10,mode=020620,ino=5,uid=500,gid=5,rdev=136:2,size=0,atime=1273085037,mtime=1273085851,ctime=1272982635
         * ```
         *
         * @param indent Indentation level.
         * @returns A string that should be freed with g_free().
         */
        print(indent: number): string | null;
        /**
         * Sets the body `message`. As a side-effect the
         * %G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field is set to the
         * type string of `body` (or cleared if `body` is %NULL).
         *
         * If `body` is floating, `message` assumes ownership of `body`.
         * @param body Either %NULL or a #GVariant that is a tuple.
         */
        set_body(body: GLib.Variant): void;
        /**
         * Sets the byte order of `message`.
         * @param byte_order The byte order.
         */
        set_byte_order(byte_order: DBusMessageByteOrder): void;
        /**
         * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
         * @param value The value to set.
         */
        set_destination(value: string | null): void;
        /**
         * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
         * @param value The value to set.
         */
        set_error_name(value: string | null): void;
        /**
         * Sets the flags to set on `message`.
         * @param flags Flags for `message` that are set (typically values from the #GDBusMessageFlags enumeration bitwise ORed together).
         */
        set_flags(flags: DBusMessageFlags): void;
        /**
         * Sets a header field on `message`.
         *
         * If `value` is floating, `message` assumes ownership of `value`.
         * @param header_field A 8-bit unsigned integer (typically a value from the #GDBusMessageHeaderField enumeration)
         * @param value A #GVariant to set the header field or %NULL to clear the header field.
         */
        set_header(
            header_field: DBusMessageHeaderField,
            value: GLib.Variant | null
        ): void;
        /**
         * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
         * @param value The value to set.
         */
        set_interface(value: string | null): void;
        /**
         * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_MEMBER header field.
         * @param value The value to set.
         */
        set_member(value: string | null): void;
        /**
         * Sets `message` to be of `type`.
         * @param type A 8-bit unsigned integer (typically a value from the #GDBusMessageType enumeration).
         */
        set_message_type(type: DBusMessageType): void;
        /**
         * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
         * @param value The value to set.
         */
        set_num_unix_fds(value: number): void;
        /**
         * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_PATH header field.
         * @param value The value to set.
         */
        set_path(value: string | null): void;
        /**
         * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
         * @param value The value to set.
         */
        set_reply_serial(value: number): void;
        /**
         * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_SENDER header field.
         * @param value The value to set.
         */
        set_sender(value: string | null): void;
        /**
         * Sets the serial for `message`.
         * @param serial A #guint32.
         */
        set_serial(serial: number): void;
        /**
         * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.
         * @param value The value to set.
         */
        set_signature(value: string | null): void;
        /**
         * Sets the UNIX file descriptors associated with `message`. As a
         * side-effect the %G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header
         * field is set to the number of fds in `fd_list` (or cleared if
         * `fd_list` is %NULL).
         *
         * This method is only available on UNIX.
         *
         * When designing D-Bus APIs that are intended to be interoperable,
         * please note that non-GDBus implementations of D-Bus can usually only
         * access file descriptors if they are referenced by a value of type
         * %G_VARIANT_TYPE_HANDLE in the body of the message.
         * @param fd_list A #GUnixFDList or %NULL.
         */
        set_unix_fd_list(fd_list: UnixFDList | null): void;
        /**
         * Serializes `message` to a blob. The byte order returned by
         * g_dbus_message_get_byte_order() will be used.
         * @param capabilities A #GDBusCapabilityFlags describing what protocol features are supported.
         * @returns A pointer to a valid binary D-Bus message of @out_size bytes generated by @message or %NULL if @error is set. Free with g_free().
         */
        to_blob(capabilities: DBusCapabilityFlags): Uint8Array;
        /**
         * If `message` is not of type %G_DBUS_MESSAGE_TYPE_ERROR does
         * nothing and returns %FALSE.
         *
         * Otherwise this method encodes the error in `message` as a #GError
         * using g_dbus_error_set_dbus_error() using the information in the
         * %G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field of `message` as
         * well as the first string item in `message'`s body.
         * @returns %TRUE if @error was set, %FALSE otherwise.
         */
        to_gerror(): boolean;

        // Class property signals of Gio-2.0.Gio.DBusMessage

        connect(
            sigName: 'notify::locked',
            callback: ($obj: DBusMessage, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::locked',
            callback: ($obj: DBusMessage, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::locked', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * A type for representing D-Bus messages that can be sent or received
     * on a #GDBusConnection.
     * @class
     */
    class DBusMessage extends GObject.Object {
        // Own properties of Gio-2.0.Gio.DBusMessage

        static name: string;
        static $gtype: GObject.GType<DBusMessage>;

        // Constructors of Gio-2.0.Gio.DBusMessage

        constructor(config?: DBusMessage.ConstructorProperties);
        /**
         * Creates a new empty #GDBusMessage.
         * @constructor
         * @returns A #GDBusMessage. Free with g_object_unref().
         */
        constructor();
        /**
         * Creates a new empty #GDBusMessage.
         * @constructor
         * @returns A #GDBusMessage. Free with g_object_unref().
         */
        static new(): DBusMessage;
        /**
         * Creates a new #GDBusMessage from the data stored at `blob`. The byte
         * order that the message was in can be retrieved using
         * g_dbus_message_get_byte_order().
         *
         * If the `blob` cannot be parsed, contains invalid fields, or contains invalid
         * headers, %G_IO_ERROR_INVALID_ARGUMENT will be returned.
         * @constructor
         * @param blob A blob representing a binary D-Bus message.
         * @param capabilities A #GDBusCapabilityFlags describing what protocol features are supported.
         * @returns A new #GDBusMessage or %NULL if @error is set. Free with g_object_unref().
         */
        static new_from_blob(
            blob: Uint8Array,
            capabilities: DBusCapabilityFlags
        ): DBusMessage;
        /**
         * Creates a new #GDBusMessage for a method call.
         * @constructor
         * @param name A valid D-Bus name or %NULL.
         * @param path A valid object path.
         * @param interface_ A valid D-Bus interface name or %NULL.
         * @param method A valid method name.
         * @returns A #GDBusMessage. Free with g_object_unref().
         */
        static new_method_call(
            name: string | null,
            path: string | null,
            interface_: string | null,
            method: string | null
        ): DBusMessage;
        /**
         * Creates a new #GDBusMessage for a signal emission.
         * @constructor
         * @param path A valid object path.
         * @param interface_ A valid D-Bus interface name.
         * @param signal A valid signal name.
         * @returns A #GDBusMessage. Free with g_object_unref().
         */
        static new_signal(
            path: string | null,
            interface_: string | null,
            signal: string | null
        ): DBusMessage;
        _init(config?: DBusMessage.ConstructorProperties): void;
        /**
         * Utility function to calculate how many bytes are needed to
         * completely deserialize the D-Bus message stored at `blob`.
         * @param blob A blob representing a binary D-Bus message.
         * @returns Number of bytes needed or -1 if @error is set (e.g. if @blob contains invalid data or not enough data is available to determine the size).
         */
        static bytes_needed(blob: Uint8Array): number;
    }

    namespace DBusMethodInvocation {
        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface DBusMethodInvocation {
        // Owm methods of Gio-2.0.Gio.DBusMethodInvocation

        /**
         * Gets the #GDBusConnection the method was invoked on.
         * @returns A #GDBusConnection. Do not free, it is owned by @invocation.
         */
        get_connection(): DBusConnection;
        /**
         * Gets the name of the D-Bus interface the method was invoked on.
         *
         * If this method call is a property Get, Set or GetAll call that has
         * been redirected to the method call handler then
         * "org.freedesktop.DBus.Properties" will be returned.  See
         * #GDBusInterfaceVTable for more information.
         * @returns A string. Do not free, it is owned by @invocation.
         */
        get_interface_name(): string | null;
        /**
         * Gets the #GDBusMessage for the method invocation. This is useful if
         * you need to use low-level protocol features, such as UNIX file
         * descriptor passing, that cannot be properly expressed in the
         * #GVariant API.
         *
         * See this [server][gdbus-server] and [client][gdbus-unix-fd-client]
         * for an example of how to use this low-level API to send and receive
         * UNIX file descriptors.
         * @returns #GDBusMessage. Do not free, it is owned by @invocation.
         */
        get_message(): DBusMessage;
        /**
         * Gets information about the method call, if any.
         *
         * If this method invocation is a property Get, Set or GetAll call that
         * has been redirected to the method call handler then %NULL will be
         * returned.  See g_dbus_method_invocation_get_property_info() and
         * #GDBusInterfaceVTable for more information.
         * @returns A #GDBusMethodInfo or %NULL. Do not free, it is owned by @invocation.
         */
        get_method_info(): DBusMethodInfo | null;
        /**
         * Gets the name of the method that was invoked.
         * @returns A string. Do not free, it is owned by @invocation.
         */
        get_method_name(): string | null;
        /**
         * Gets the object path the method was invoked on.
         * @returns A string. Do not free, it is owned by @invocation.
         */
        get_object_path(): string | null;
        /**
         * Gets the parameters of the method invocation. If there are no input
         * parameters then this will return a GVariant with 0 children rather than NULL.
         * @returns A #GVariant tuple. Do not unref this because it is owned by @invocation.
         */
        get_parameters(): GLib.Variant;
        /**
         * Gets information about the property that this method call is for, if
         * any.
         *
         * This will only be set in the case of an invocation in response to a
         * property Get or Set call that has been directed to the method call
         * handler for an object on account of its property_get() or
         * property_set() vtable pointers being unset.
         *
         * See #GDBusInterfaceVTable for more information.
         *
         * If the call was GetAll, %NULL will be returned.
         * @returns a #GDBusPropertyInfo or %NULL
         */
        get_property_info(): DBusPropertyInfo | null;
        /**
         * Gets the bus name that invoked the method.
         * @returns A string. Do not free, it is owned by @invocation.
         */
        get_sender(): string | null;
        /**
         * Finishes handling a D-Bus method call by returning an error.
         *
         * This method will take ownership of `invocation`. See
         * #GDBusInterfaceVTable for more information about the ownership of
         * `invocation`.
         * @param error_name A valid D-Bus error name.
         * @param error_message A valid D-Bus error message.
         */
        return_dbus_error(
            error_name: string | null,
            error_message: string | null
        ): void;
        /**
         * Like g_dbus_method_invocation_return_error() but without printf()-style formatting.
         *
         * This method will take ownership of `invocation`. See
         * #GDBusInterfaceVTable for more information about the ownership of
         * `invocation`.
         * @param domain A #GQuark for the #GError error domain.
         * @param code The error code.
         * @param message The error message.
         */
        return_error_literal(
            domain: GLib.Quark,
            code: number,
            message: string | null
        ): void;
        /**
         * Like g_dbus_method_invocation_return_error() but takes a #GError
         * instead of the error domain, error code and message.
         *
         * This method will take ownership of `invocation`. See
         * #GDBusInterfaceVTable for more information about the ownership of
         * `invocation`.
         * @param error A #GError.
         */
        return_gerror(error: GLib.Error): void;
        /**
         * Finishes handling a D-Bus method call by returning `parameters`.
         * If the `parameters` GVariant is floating, it is consumed.
         *
         * It is an error if `parameters` is not of the right format: it must be a tuple
         * containing the out-parameters of the D-Bus method. Even if the method has a
         * single out-parameter, it must be contained in a tuple. If the method has no
         * out-parameters, `parameters` may be %NULL or an empty tuple.
         *
         *
         * ```c
         * GDBusMethodInvocation *invocation = some_invocation;
         * g_autofree gchar *result_string = NULL;
         * g_autoptr (GError) error = NULL;
         *
         * result_string = calculate_result (&error);
         *
         * if (error != NULL)
         *   g_dbus_method_invocation_return_gerror (invocation, error);
         * else
         *   g_dbus_method_invocation_return_value (invocation,
         *                                          g_variant_new ("(s)", result_string));
         *
         * // Do not free `invocation` here; returning a value does that
         * ```
         *
         *
         * This method will take ownership of `invocation`. See
         * #GDBusInterfaceVTable for more information about the ownership of
         * `invocation`.
         *
         * Since 2.48, if the method call requested for a reply not to be sent
         * then this call will sink `parameters` and free `invocation,` but
         * otherwise do nothing (as per the recommendations of the D-Bus
         * specification).
         * @param parameters A #GVariant tuple with out parameters for the method or %NULL if not passing any parameters.
         */
        return_value(parameters: GLib.Variant | null): void;
        /**
         * Like g_dbus_method_invocation_return_value() but also takes a #GUnixFDList.
         *
         * This method is only available on UNIX.
         *
         * This method will take ownership of `invocation`. See
         * #GDBusInterfaceVTable for more information about the ownership of
         * `invocation`.
         * @param parameters A #GVariant tuple with out parameters for the method or %NULL if not passing any parameters.
         * @param fd_list A #GUnixFDList or %NULL.
         */
        return_value_with_unix_fd_list(
            parameters: GLib.Variant | null,
            fd_list: UnixFDList | null
        ): void;

        // Class property signals of Gio-2.0.Gio.DBusMethodInvocation

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * Instances of the #GDBusMethodInvocation class are used when
     * handling D-Bus method calls. It provides a way to asynchronously
     * return results and errors.
     *
     * The normal way to obtain a #GDBusMethodInvocation object is to receive
     * it as an argument to the handle_method_call() function in a
     * #GDBusInterfaceVTable that was passed to g_dbus_connection_register_object().
     * @class
     */
    class DBusMethodInvocation extends GObject.Object {
        // Own properties of Gio-2.0.Gio.DBusMethodInvocation

        static name: string;
        static $gtype: GObject.GType<DBusMethodInvocation>;

        // Constructors of Gio-2.0.Gio.DBusMethodInvocation

        constructor(config?: DBusMethodInvocation.ConstructorProperties);
        _init(config?: DBusMethodInvocation.ConstructorProperties): void;
    }

    namespace DBusObjectManagerClient {
        // Signal callback interfaces

        /**
         * Signal callback interface for `interface-proxy-properties-changed`
         */
        interface InterfaceProxyPropertiesChangedSignalCallback {
            (
                $obj: DBusObjectManagerClient,
                object_proxy: DBusObjectProxy,
                interface_proxy: DBusProxy,
                changed_properties: GLib.Variant,
                invalidated_properties: string[]
            ): void;
        }

        /**
         * Signal callback interface for `interface-proxy-signal`
         */
        interface InterfaceProxySignalSignalCallback {
            (
                $obj: DBusObjectManagerClient,
                object_proxy: DBusObjectProxy,
                interface_proxy: DBusProxy,
                sender_name: string | null,
                signal_name: string | null,
                parameters: GLib.Variant
            ): void;
        }

        // Constructor properties interface

        interface ConstructorProperties
            extends AsyncInitable.ConstructorProperties,
                DBusObjectManager.ConstructorProperties,
                Initable.ConstructorProperties,
                GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.DBusObjectManagerClient

            /**
             * If this property is not %G_BUS_TYPE_NONE, then
             * #GDBusObjectManagerClient:connection must be %NULL and will be set to the
             * #GDBusConnection obtained by calling g_bus_get() with the value
             * of this property.
             */
            bus_type?: BusType | null;
            /**
             * The #GDBusConnection to use.
             */
            connection?: DBusConnection | null;
            /**
             * Flags from the #GDBusObjectManagerClientFlags enumeration.
             */
            flags?: DBusObjectManagerClientFlags | null;
            /**
             * A #GDestroyNotify for the #gpointer user_data in #GDBusObjectManagerClient:get-proxy-type-user-data.
             */
            get_proxy_type_destroy_notify?: any | null;
            /**
             * The #GDBusProxyTypeFunc to use when determining what #GType to
             * use for interface proxies or %NULL.
             */
            get_proxy_type_func?: any | null;
            /**
             * The #gpointer user_data to pass to #GDBusObjectManagerClient:get-proxy-type-func.
             */
            get_proxy_type_user_data?: any | null;
            /**
             * The well-known name or unique name that the manager is for.
             */
            name?: string | null;
            /**
             * The object path the manager is for.
             */
            object_path?: string | null;
        }
    }

    interface DBusObjectManagerClient
        extends AsyncInitable,
            DBusObjectManager,
            Initable {
        // Own properties of Gio-2.0.Gio.DBusObjectManagerClient

        /**
         * If this property is not %G_BUS_TYPE_NONE, then
         * #GDBusObjectManagerClient:connection must be %NULL and will be set to the
         * #GDBusConnection obtained by calling g_bus_get() with the value
         * of this property.
         */
        readonly bus_type: BusType;
        /**
         * The #GDBusConnection to use.
         */
        readonly connection: DBusConnection;
        /**
         * Flags from the #GDBusObjectManagerClientFlags enumeration.
         */
        readonly flags: DBusObjectManagerClientFlags;
        /**
         * A #GDestroyNotify for the #gpointer user_data in #GDBusObjectManagerClient:get-proxy-type-user-data.
         */
        readonly get_proxy_type_destroy_notify: any;
        /**
         * The #GDBusProxyTypeFunc to use when determining what #GType to
         * use for interface proxies or %NULL.
         */
        readonly get_proxy_type_func: any;
        /**
         * The #gpointer user_data to pass to #GDBusObjectManagerClient:get-proxy-type-func.
         */
        readonly get_proxy_type_user_data: any;
        /**
         * The well-known name or unique name that the manager is for.
         */
        readonly name: string | null;
        /**
         * The unique name that owns #GDBusObjectManagerClient:name or %NULL if
         * no-one is currently owning the name. Connect to the
         * #GObject::notify signal to track changes to this property.
         */
        readonly name_owner: string | null;
        /**
         * The object path the manager is for.
         */
        readonly object_path: string | null;

        // Owm methods of Gio-2.0.Gio.DBusObjectManagerClient

        /**
         * Gets the #GDBusConnection used by `manager`.
         * @returns A #GDBusConnection object. Do not free,   the object belongs to @manager.
         */
        get_connection(): DBusConnection;
        /**
         * Gets the flags that `manager` was constructed with.
         * @returns Zero of more flags from the #GDBusObjectManagerClientFlags enumeration.
         */
        get_flags(): DBusObjectManagerClientFlags;
        /**
         * Gets the name that `manager` is for, or %NULL if not a message bus
         * connection.
         * @returns A unique or well-known name. Do not free, the string belongs to @manager.
         */
        get_name(): string | null;
        /**
         * The unique name that owns the name that `manager` is for or %NULL if
         * no-one currently owns that name. You can connect to the
         * #GObject::notify signal to track changes to the
         * #GDBusObjectManagerClient:name-owner property.
         * @returns The name owner or %NULL if no name owner exists. Free with g_free().
         */
        get_name_owner(): string | null;

        // Own virtual methods of Gio-2.0.Gio.DBusObjectManagerClient

        vfunc_interface_proxy_properties_changed(
            object_proxy: DBusObjectProxy,
            interface_proxy: DBusProxy,
            changed_properties: GLib.Variant,
            invalidated_properties: string | null
        ): void;
        vfunc_interface_proxy_signal(
            object_proxy: DBusObjectProxy,
            interface_proxy: DBusProxy,
            sender_name: string | null,
            signal_name: string | null,
            parameters: GLib.Variant
        ): void;

        // Own signals of Gio-2.0.Gio.DBusObjectManagerClient

        connect(
            sigName: 'interface-proxy-properties-changed',
            callback: DBusObjectManagerClient.InterfaceProxyPropertiesChangedSignalCallback
        ): number;
        connect_after(
            sigName: 'interface-proxy-properties-changed',
            callback: DBusObjectManagerClient.InterfaceProxyPropertiesChangedSignalCallback
        ): number;
        emit(
            sigName: 'interface-proxy-properties-changed',
            object_proxy: DBusObjectProxy,
            interface_proxy: DBusProxy,
            changed_properties: GLib.Variant,
            invalidated_properties: string[],
            ...args: any[]
        ): void;
        connect(
            sigName: 'interface-proxy-signal',
            callback: DBusObjectManagerClient.InterfaceProxySignalSignalCallback
        ): number;
        connect_after(
            sigName: 'interface-proxy-signal',
            callback: DBusObjectManagerClient.InterfaceProxySignalSignalCallback
        ): number;
        emit(
            sigName: 'interface-proxy-signal',
            object_proxy: DBusObjectProxy,
            interface_proxy: DBusProxy,
            sender_name: string | null,
            signal_name: string | null,
            parameters: GLib.Variant,
            ...args: any[]
        ): void;

        // Class property signals of Gio-2.0.Gio.DBusObjectManagerClient

        connect(
            sigName: 'notify::bus-type',
            callback: (
                $obj: DBusObjectManagerClient,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::bus-type',
            callback: (
                $obj: DBusObjectManagerClient,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::bus-type', ...args: any[]): void;
        connect(
            sigName: 'notify::connection',
            callback: (
                $obj: DBusObjectManagerClient,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::connection',
            callback: (
                $obj: DBusObjectManagerClient,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::connection', ...args: any[]): void;
        connect(
            sigName: 'notify::flags',
            callback: (
                $obj: DBusObjectManagerClient,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::flags',
            callback: (
                $obj: DBusObjectManagerClient,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::flags', ...args: any[]): void;
        connect(
            sigName: 'notify::get-proxy-type-destroy-notify',
            callback: (
                $obj: DBusObjectManagerClient,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::get-proxy-type-destroy-notify',
            callback: (
                $obj: DBusObjectManagerClient,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(
            sigName: 'notify::get-proxy-type-destroy-notify',
            ...args: any[]
        ): void;
        connect(
            sigName: 'notify::get-proxy-type-func',
            callback: (
                $obj: DBusObjectManagerClient,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::get-proxy-type-func',
            callback: (
                $obj: DBusObjectManagerClient,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::get-proxy-type-func', ...args: any[]): void;
        connect(
            sigName: 'notify::get-proxy-type-user-data',
            callback: (
                $obj: DBusObjectManagerClient,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::get-proxy-type-user-data',
            callback: (
                $obj: DBusObjectManagerClient,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::get-proxy-type-user-data', ...args: any[]): void;
        connect(
            sigName: 'notify::name',
            callback: (
                $obj: DBusObjectManagerClient,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::name',
            callback: (
                $obj: DBusObjectManagerClient,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::name', ...args: any[]): void;
        connect(
            sigName: 'notify::name-owner',
            callback: (
                $obj: DBusObjectManagerClient,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::name-owner',
            callback: (
                $obj: DBusObjectManagerClient,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::name-owner', ...args: any[]): void;
        connect(
            sigName: 'notify::object-path',
            callback: (
                $obj: DBusObjectManagerClient,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::object-path',
            callback: (
                $obj: DBusObjectManagerClient,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::object-path', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GDBusObjectManagerClient is used to create, monitor and delete object
     * proxies for remote objects exported by a #GDBusObjectManagerServer (or any
     * code implementing the
     * [org.freedesktop.DBus.ObjectManager](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
     * interface).
     *
     * Once an instance of this type has been created, you can connect to
     * the #GDBusObjectManager::object-added and
     * #GDBusObjectManager::object-removed signals and inspect the
     * #GDBusObjectProxy objects returned by
     * g_dbus_object_manager_get_objects().
     *
     * If the name for a #GDBusObjectManagerClient is not owned by anyone at
     * object construction time, the default behavior is to request the
     * message bus to launch an owner for the name. This behavior can be
     * disabled using the %G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START
     * flag. It's also worth noting that this only works if the name of
     * interest is activatable in the first place. E.g. in some cases it
     * is not possible to launch an owner for the requested name. In this
     * case, #GDBusObjectManagerClient object construction still succeeds but
     * there will be no object proxies
     * (e.g. g_dbus_object_manager_get_objects() returns the empty list) and
     * the #GDBusObjectManagerClient:name-owner property is %NULL.
     *
     * The owner of the requested name can come and go (for example
     * consider a system service being restarted)  #GDBusObjectManagerClient
     * handles this case too; simply connect to the #GObject::notify
     * signal to watch for changes on the #GDBusObjectManagerClient:name-owner
     * property. When the name owner vanishes, the behavior is that
     * #GDBusObjectManagerClient:name-owner is set to %NULL (this includes
     * emission of the #GObject::notify signal) and then
     * #GDBusObjectManager::object-removed signals are synthesized
     * for all currently existing object proxies. Since
     * #GDBusObjectManagerClient:name-owner is %NULL when this happens, you can
     * use this information to disambiguate a synthesized signal from a
     * genuine signal caused by object removal on the remote
     * #GDBusObjectManager. Similarly, when a new name owner appears,
     * #GDBusObjectManager::object-added signals are synthesized
     * while #GDBusObjectManagerClient:name-owner is still %NULL. Only when all
     * object proxies have been added, the #GDBusObjectManagerClient:name-owner
     * is set to the new name owner (this includes emission of the
     * #GObject::notify signal).  Furthermore, you are guaranteed that
     * #GDBusObjectManagerClient:name-owner will alternate between a name owner
     * (e.g. `:1.42`) and %NULL even in the case where
     * the name of interest is atomically replaced
     *
     * Ultimately, #GDBusObjectManagerClient is used to obtain #GDBusProxy
     * instances. All signals (including the
     * org.freedesktop.DBus.Properties::PropertiesChanged signal)
     * delivered to #GDBusProxy instances are guaranteed to originate
     * from the name owner. This guarantee along with the behavior
     * described above, means that certain race conditions including the
     * "half the proxy is from the old owner and the other half is from
     * the new owner" problem cannot happen.
     *
     * To avoid having the application connect to signals on the returned
     * #GDBusObjectProxy and #GDBusProxy objects, the
     * #GDBusObject::interface-added,
     * #GDBusObject::interface-removed,
     * #GDBusProxy::g-properties-changed and
     * #GDBusProxy::g-signal signals
     * are also emitted on the #GDBusObjectManagerClient instance managing these
     * objects. The signals emitted are
     * #GDBusObjectManager::interface-added,
     * #GDBusObjectManager::interface-removed,
     * #GDBusObjectManagerClient::interface-proxy-properties-changed and
     * #GDBusObjectManagerClient::interface-proxy-signal.
     *
     * Note that all callbacks and signals are emitted in the
     * [thread-default main context][g-main-context-push-thread-default]
     * that the #GDBusObjectManagerClient object was constructed
     * in. Additionally, the #GDBusObjectProxy and #GDBusProxy objects
     * originating from the #GDBusObjectManagerClient object will be created in
     * the same context and, consequently, will deliver signals in the
     * same main loop.
     * @class
     */
    class DBusObjectManagerClient extends GObject.Object {
        // Own properties of Gio-2.0.Gio.DBusObjectManagerClient

        static name: string;
        static $gtype: GObject.GType<DBusObjectManagerClient>;

        // Constructors of Gio-2.0.Gio.DBusObjectManagerClient

        constructor(config?: DBusObjectManagerClient.ConstructorProperties);
        /**
         * Finishes an operation started with g_dbus_object_manager_client_new().
         * @constructor
         * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback passed to g_dbus_object_manager_client_new().
         * @returns A   #GDBusObjectManagerClient object or %NULL if @error is set. Free   with g_object_unref().
         */
        static new_finish(res: AsyncResult): DBusObjectManagerClient;
        /**
         * Finishes an operation started with g_dbus_object_manager_client_new_for_bus().
         * @constructor
         * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback passed to g_dbus_object_manager_client_new_for_bus().
         * @returns A   #GDBusObjectManagerClient object or %NULL if @error is set. Free   with g_object_unref().
         */
        static new_for_bus_finish(res: AsyncResult): DBusObjectManagerClient;
        /**
         * Like g_dbus_object_manager_client_new_sync() but takes a #GBusType instead
         * of a #GDBusConnection.
         *
         * This is a synchronous failable constructor - the calling thread is
         * blocked until a reply is received. See g_dbus_object_manager_client_new_for_bus()
         * for the asynchronous version.
         * @constructor
         * @param bus_type A #GBusType.
         * @param flags Zero or more flags from the #GDBusObjectManagerClientFlags enumeration.
         * @param name The owner of the control object (unique or well-known name).
         * @param object_path The object path of the control object.
         * @param get_proxy_type_func A #GDBusProxyTypeFunc function or %NULL to always construct #GDBusProxy proxies.
         * @param cancellable A #GCancellable or %NULL
         * @returns A   #GDBusObjectManagerClient object or %NULL if @error is set. Free   with g_object_unref().
         */
        static new_for_bus_sync(
            bus_type: BusType,
            flags: DBusObjectManagerClientFlags,
            name: string | null,
            object_path: string | null,
            get_proxy_type_func: DBusProxyTypeFunc | null,
            cancellable: Cancellable | null
        ): DBusObjectManagerClient;
        /**
         * Creates a new #GDBusObjectManagerClient object.
         *
         * This is a synchronous failable constructor - the calling thread is
         * blocked until a reply is received. See g_dbus_object_manager_client_new()
         * for the asynchronous version.
         * @constructor
         * @param connection A #GDBusConnection.
         * @param flags Zero or more flags from the #GDBusObjectManagerClientFlags enumeration.
         * @param name The owner of the control object (unique or well-known name), or %NULL when not using a message bus connection.
         * @param object_path The object path of the control object.
         * @param get_proxy_type_func A #GDBusProxyTypeFunc function or %NULL to always construct #GDBusProxy proxies.
         * @param cancellable A #GCancellable or %NULL
         * @returns A   #GDBusObjectManagerClient object or %NULL if @error is set. Free   with g_object_unref().
         */
        static new_sync(
            connection: DBusConnection,
            flags: DBusObjectManagerClientFlags,
            name: string | null,
            object_path: string | null,
            get_proxy_type_func: DBusProxyTypeFunc | null,
            cancellable: Cancellable | null
        ): DBusObjectManagerClient;
        _init(config?: DBusObjectManagerClient.ConstructorProperties): void;
        /**
         * Asynchronously creates a new #GDBusObjectManagerClient object.
         *
         * This is an asynchronous failable constructor. When the result is
         * ready, `callback` will be invoked in the
         * [thread-default main context][g-main-context-push-thread-default]
         * of the thread you are calling this method from. You can
         * then call g_dbus_object_manager_client_new_finish() to get the result. See
         * g_dbus_object_manager_client_new_sync() for the synchronous version.
         * @param connection A #GDBusConnection.
         * @param flags Zero or more flags from the #GDBusObjectManagerClientFlags enumeration.
         * @param name The owner of the control object (unique or well-known name).
         * @param object_path The object path of the control object.
         * @param get_proxy_type_func A #GDBusProxyTypeFunc function or %NULL to always construct #GDBusProxy proxies.
         * @param cancellable A #GCancellable or %NULL
         * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
         */
        static new(
            connection: DBusConnection,
            flags: DBusObjectManagerClientFlags,
            name: string | null,
            object_path: string | null,
            get_proxy_type_func: DBusProxyTypeFunc | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<DBusObjectManagerClient> | null
        ): void;
        /**
         * Like g_dbus_object_manager_client_new() but takes a #GBusType instead of a
         * #GDBusConnection.
         *
         * This is an asynchronous failable constructor. When the result is
         * ready, `callback` will be invoked in the
         * [thread-default main loop][g-main-context-push-thread-default]
         * of the thread you are calling this method from. You can
         * then call g_dbus_object_manager_client_new_for_bus_finish() to get the result. See
         * g_dbus_object_manager_client_new_for_bus_sync() for the synchronous version.
         * @param bus_type A #GBusType.
         * @param flags Zero or more flags from the #GDBusObjectManagerClientFlags enumeration.
         * @param name The owner of the control object (unique or well-known name).
         * @param object_path The object path of the control object.
         * @param get_proxy_type_func A #GDBusProxyTypeFunc function or %NULL to always construct #GDBusProxy proxies.
         * @param cancellable A #GCancellable or %NULL
         * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
         */
        static new_for_bus(
            bus_type: BusType,
            flags: DBusObjectManagerClientFlags,
            name: string | null,
            object_path: string | null,
            get_proxy_type_func: DBusProxyTypeFunc | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<DBusObjectManagerClient> | null
        ): void;
    }

    namespace DBusObjectManagerServer {
        // Constructor properties interface

        interface ConstructorProperties
            extends DBusObjectManager.ConstructorProperties,
                GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.DBusObjectManagerServer

            /**
             * The #GDBusConnection to export objects on.
             */
            connection?: DBusConnection | null;
            /**
             * The object path to register the manager object at.
             */
            object_path?: string | null;
        }
    }

    interface DBusObjectManagerServer extends DBusObjectManager {
        // Own properties of Gio-2.0.Gio.DBusObjectManagerServer

        /**
         * The #GDBusConnection to export objects on.
         */
        connection: DBusConnection;
        /**
         * The object path to register the manager object at.
         */
        readonly object_path: string | null;

        // Owm methods of Gio-2.0.Gio.DBusObjectManagerServer

        /**
         * Exports `object` on `manager`.
         *
         * If there is already a #GDBusObject exported at the object path,
         * then the old object is removed.
         *
         * The object path for `object` must be in the hierarchy rooted by the
         * object path for `manager`.
         *
         * Note that `manager` will take a reference on `object` for as long as
         * it is exported.
         * @param object A #GDBusObjectSkeleton.
         */
        export(object: DBusObjectSkeleton): void;
        /**
         * Like g_dbus_object_manager_server_export() but appends a string of
         * the form _N (with N being a natural number) to `object'`s object path
         * if an object with the given path already exists. As such, the
         * #GDBusObjectProxy:g-object-path property of `object` may be modified.
         * @param object An object.
         */
        export_uniquely(object: DBusObjectSkeleton): void;
        /**
         * Gets the #GDBusConnection used by `manager`.
         * @returns A #GDBusConnection object or %NULL if   @manager isn't exported on a connection. The returned object should   be freed with g_object_unref().
         */
        get_connection(): DBusConnection | null;
        /**
         * Returns whether `object` is currently exported on `manager`.
         * @param object An object.
         * @returns %TRUE if @object is exported
         */
        is_exported(object: DBusObjectSkeleton): boolean;
        /**
         * Exports all objects managed by `manager` on `connection`. If
         * `connection` is %NULL, stops exporting objects.
         * @param connection A #GDBusConnection or %NULL.
         */
        set_connection(connection: DBusConnection | null): void;
        /**
         * If `manager` has an object at `path,` removes the object. Otherwise
         * does nothing.
         *
         * Note that `object_path` must be in the hierarchy rooted by the
         * object path for `manager`.
         * @param object_path An object path.
         * @returns %TRUE if object at @object_path was removed, %FALSE otherwise.
         */
        unexport(object_path: string | null): boolean;

        // Class property signals of Gio-2.0.Gio.DBusObjectManagerServer

        connect(
            sigName: 'notify::connection',
            callback: (
                $obj: DBusObjectManagerServer,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::connection',
            callback: (
                $obj: DBusObjectManagerServer,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::connection', ...args: any[]): void;
        connect(
            sigName: 'notify::object-path',
            callback: (
                $obj: DBusObjectManagerServer,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::object-path',
            callback: (
                $obj: DBusObjectManagerServer,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::object-path', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GDBusObjectManagerServer is used to export #GDBusObject instances using
     * the standardized
     * [org.freedesktop.DBus.ObjectManager](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
     * interface. For example, remote D-Bus clients can get all objects
     * and properties in a single call. Additionally, any change in the
     * object hierarchy is broadcast using signals. This means that D-Bus
     * clients can keep caches up to date by only listening to D-Bus
     * signals.
     *
     * The recommended path to export an object manager at is the path form of the
     * well-known name of a D-Bus service, or below. For example, if a D-Bus service
     * is available at the well-known name `net.example.ExampleService1`, the object
     * manager should typically be exported at `/net/example/ExampleService1`, or
     * below (to allow for multiple object managers in a service).
     *
     * It is supported, but not recommended, to export an object manager at the root
     * path, `/`.
     *
     * See #GDBusObjectManagerClient for the client-side code that is
     * intended to be used with #GDBusObjectManagerServer or any D-Bus
     * object implementing the org.freedesktop.DBus.ObjectManager
     * interface.
     * @class
     */
    class DBusObjectManagerServer extends GObject.Object {
        // Own properties of Gio-2.0.Gio.DBusObjectManagerServer

        static name: string;
        static $gtype: GObject.GType<DBusObjectManagerServer>;

        // Constructors of Gio-2.0.Gio.DBusObjectManagerServer

        constructor(config?: DBusObjectManagerServer.ConstructorProperties);
        /**
         * Creates a new #GDBusObjectManagerServer object.
         *
         * The returned server isn't yet exported on any connection. To do so,
         * use g_dbus_object_manager_server_set_connection(). Normally you
         * want to export all of your objects before doing so to avoid
         * [InterfacesAdded](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
         * signals being emitted.
         * @constructor
         * @param object_path The object path to export the manager object at.
         * @returns A #GDBusObjectManagerServer object. Free with g_object_unref().
         */
        constructor(object_path: string | null);
        /**
         * Creates a new #GDBusObjectManagerServer object.
         *
         * The returned server isn't yet exported on any connection. To do so,
         * use g_dbus_object_manager_server_set_connection(). Normally you
         * want to export all of your objects before doing so to avoid
         * [InterfacesAdded](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
         * signals being emitted.
         * @constructor
         * @param object_path The object path to export the manager object at.
         * @returns A #GDBusObjectManagerServer object. Free with g_object_unref().
         */
        static new(object_path: string | null): DBusObjectManagerServer;
        _init(config?: DBusObjectManagerServer.ConstructorProperties): void;
    }

    namespace DBusObjectProxy {
        // Constructor properties interface

        interface ConstructorProperties
            extends DBusObject.ConstructorProperties,
                GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.DBusObjectProxy

            /**
             * The connection of the proxy.
             */
            g_connection?: DBusConnection | null;
            /**
             * The object path of the proxy.
             */
            g_object_path?: string | null;
        }
    }

    interface DBusObjectProxy extends DBusObject {
        // Own properties of Gio-2.0.Gio.DBusObjectProxy

        /**
         * The connection of the proxy.
         */
        readonly g_connection: DBusConnection;
        /**
         * The object path of the proxy.
         */
        readonly g_object_path: string | null;

        // Owm methods of Gio-2.0.Gio.DBusObjectProxy

        /**
         * Gets the connection that `proxy` is for.
         * @returns A #GDBusConnection. Do not free, the   object is owned by @proxy.
         */
        get_connection(): DBusConnection;

        // Class property signals of Gio-2.0.Gio.DBusObjectProxy

        connect(
            sigName: 'notify::g-connection',
            callback: ($obj: DBusObjectProxy, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::g-connection',
            callback: ($obj: DBusObjectProxy, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::g-connection', ...args: any[]): void;
        connect(
            sigName: 'notify::g-object-path',
            callback: ($obj: DBusObjectProxy, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::g-object-path',
            callback: ($obj: DBusObjectProxy, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::g-object-path', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * A #GDBusObjectProxy is an object used to represent a remote object
     * with one or more D-Bus interfaces. Normally, you don't instantiate
     * a #GDBusObjectProxy yourself - typically #GDBusObjectManagerClient
     * is used to obtain it.
     * @class
     */
    class DBusObjectProxy extends GObject.Object {
        // Own properties of Gio-2.0.Gio.DBusObjectProxy

        static name: string;
        static $gtype: GObject.GType<DBusObjectProxy>;

        // Constructors of Gio-2.0.Gio.DBusObjectProxy

        constructor(config?: DBusObjectProxy.ConstructorProperties);
        /**
         * Creates a new #GDBusObjectProxy for the given connection and
         * object path.
         * @constructor
         * @param connection a #GDBusConnection
         * @param object_path the object path
         * @returns a new #GDBusObjectProxy
         */
        constructor(connection: DBusConnection, object_path: string | null);
        /**
         * Creates a new #GDBusObjectProxy for the given connection and
         * object path.
         * @constructor
         * @param connection a #GDBusConnection
         * @param object_path the object path
         * @returns a new #GDBusObjectProxy
         */
        static new(
            connection: DBusConnection,
            object_path: string | null
        ): DBusObjectProxy;
        _init(config?: DBusObjectProxy.ConstructorProperties): void;
    }

    namespace DBusObjectSkeleton {
        // Signal callback interfaces

        /**
         * Signal callback interface for `authorize-method`
         */
        interface AuthorizeMethodSignalCallback {
            (
                $obj: DBusObjectSkeleton,
                interface: DBusInterfaceSkeleton,
                invocation: DBusMethodInvocation
            ): boolean;
        }

        // Constructor properties interface

        interface ConstructorProperties
            extends DBusObject.ConstructorProperties,
                GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.DBusObjectSkeleton

            /**
             * The object path where the object is exported.
             */
            g_object_path?: string | null;
        }
    }

    interface DBusObjectSkeleton extends DBusObject {
        // Own properties of Gio-2.0.Gio.DBusObjectSkeleton

        /**
         * The object path where the object is exported.
         */
        g_object_path: string | null;

        // Owm methods of Gio-2.0.Gio.DBusObjectSkeleton

        /**
         * Adds `interface_` to `object`.
         *
         * If `object` already contains a #GDBusInterfaceSkeleton with the same
         * interface name, it is removed before `interface_` is added.
         *
         * Note that `object` takes its own reference on `interface_` and holds
         * it until removed.
         * @param interface_ A #GDBusInterfaceSkeleton.
         */
        add_interface(interface_: DBusInterfaceSkeleton): void;
        /**
         * This method simply calls g_dbus_interface_skeleton_flush() on all
         * interfaces belonging to `object`. See that method for when flushing
         * is useful.
         */
        flush(): void;
        /**
         * Removes `interface_` from `object`.
         * @param interface_ A #GDBusInterfaceSkeleton.
         */
        remove_interface(interface_: DBusInterfaceSkeleton): void;
        /**
         * Removes the #GDBusInterface with `interface_name` from `object`.
         *
         * If no D-Bus interface of the given interface exists, this function
         * does nothing.
         * @param interface_name A D-Bus interface name.
         */
        remove_interface_by_name(interface_name: string | null): void;
        /**
         * Sets the object path for `object`.
         * @param object_path A valid D-Bus object path.
         */
        set_object_path(object_path: string | null): void;

        // Own virtual methods of Gio-2.0.Gio.DBusObjectSkeleton

        vfunc_authorize_method(
            interface_: DBusInterfaceSkeleton,
            invocation: DBusMethodInvocation
        ): boolean;

        // Own signals of Gio-2.0.Gio.DBusObjectSkeleton

        connect(
            sigName: 'authorize-method',
            callback: DBusObjectSkeleton.AuthorizeMethodSignalCallback
        ): number;
        connect_after(
            sigName: 'authorize-method',
            callback: DBusObjectSkeleton.AuthorizeMethodSignalCallback
        ): number;
        emit(
            sigName: 'authorize-method',
            interface: DBusInterfaceSkeleton,
            invocation: DBusMethodInvocation,
            ...args: any[]
        ): void;

        // Class property signals of Gio-2.0.Gio.DBusObjectSkeleton

        connect(
            sigName: 'notify::g-object-path',
            callback: (
                $obj: DBusObjectSkeleton,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::g-object-path',
            callback: (
                $obj: DBusObjectSkeleton,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::g-object-path', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * A #GDBusObjectSkeleton instance is essentially a group of D-Bus
     * interfaces. The set of exported interfaces on the object may be
     * dynamic and change at runtime.
     *
     * This type is intended to be used with #GDBusObjectManager.
     * @class
     */
    class DBusObjectSkeleton extends GObject.Object {
        // Own properties of Gio-2.0.Gio.DBusObjectSkeleton

        static name: string;
        static $gtype: GObject.GType<DBusObjectSkeleton>;

        // Constructors of Gio-2.0.Gio.DBusObjectSkeleton

        constructor(config?: DBusObjectSkeleton.ConstructorProperties);
        /**
         * Creates a new #GDBusObjectSkeleton.
         * @constructor
         * @param object_path An object path.
         * @returns A #GDBusObjectSkeleton. Free with g_object_unref().
         */
        constructor(object_path: string | null);
        /**
         * Creates a new #GDBusObjectSkeleton.
         * @constructor
         * @param object_path An object path.
         * @returns A #GDBusObjectSkeleton. Free with g_object_unref().
         */
        static new(object_path: string | null): DBusObjectSkeleton;
        _init(config?: DBusObjectSkeleton.ConstructorProperties): void;
    }

    namespace DBusProxy {
        // Signal callback interfaces

        /**
         * Signal callback interface for `g-properties-changed`
         */
        interface GPropertiesChangedSignalCallback {
            (
                $obj: DBusProxy,
                changed_properties: GLib.Variant,
                invalidated_properties: string[]
            ): void;
        }

        /**
         * Signal callback interface for `g-signal`
         */
        interface GSignalSignalCallback {
            (
                $obj: DBusProxy,
                sender_name: string | null,
                signal_name: string | null,
                parameters: GLib.Variant
            ): void;
        }

        // Constructor properties interface

        interface ConstructorProperties
            extends AsyncInitable.ConstructorProperties,
                DBusInterface.ConstructorProperties,
                Initable.ConstructorProperties,
                GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.DBusProxy

            /**
             * If this property is not %G_BUS_TYPE_NONE, then
             * #GDBusProxy:g-connection must be %NULL and will be set to the
             * #GDBusConnection obtained by calling g_bus_get() with the value
             * of this property.
             */
            g_bus_type?: BusType | null;
            /**
             * The #GDBusConnection the proxy is for.
             */
            g_connection?: DBusConnection | null;
            /**
             * The timeout to use if -1 (specifying default timeout) is passed
             * as `timeout_msec` in the g_dbus_proxy_call() and
             * g_dbus_proxy_call_sync() functions.
             *
             * This allows applications to set a proxy-wide timeout for all
             * remote method invocations on the proxy. If this property is -1,
             * the default timeout (typically 25 seconds) is used. If set to
             * %G_MAXINT, then no timeout is used.
             */
            g_default_timeout?: number | null;
            /**
             * Flags from the #GDBusProxyFlags enumeration.
             */
            g_flags?: DBusProxyFlags | null;
            /**
             * Ensure that interactions with this proxy conform to the given
             * interface. This is mainly to ensure that malformed data received
             * from the other peer is ignored. The given #GDBusInterfaceInfo is
             * said to be the "expected interface".
             *
             * The checks performed are:
             * - When completing a method call, if the type signature of
             *   the reply message isn't what's expected, the reply is
             *   discarded and the #GError is set to %G_IO_ERROR_INVALID_ARGUMENT.
             *
             * - Received signals that have a type signature mismatch are dropped and
             *   a warning is logged via g_warning().
             *
             * - Properties received via the initial `GetAll()` call or via the
             *   `::PropertiesChanged` signal (on the
             *   [org.freedesktop.DBus.Properties](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties)
             *   interface) or set using g_dbus_proxy_set_cached_property()
             *   with a type signature mismatch are ignored and a warning is
             *   logged via g_warning().
             *
             * Note that these checks are never done on methods, signals and
             * properties that are not referenced in the given
             * #GDBusInterfaceInfo, since extending a D-Bus interface on the
             * service-side is not considered an ABI break.
             */
            g_interface_info?: DBusInterfaceInfo | null;
            /**
             * The D-Bus interface name the proxy is for.
             */
            g_interface_name?: string | null;
            /**
             * The well-known or unique name that the proxy is for.
             */
            g_name?: string | null;
            /**
             * The object path the proxy is for.
             */
            g_object_path?: string | null;
        }
    }

    interface DBusProxy extends AsyncInitable, DBusInterface, Initable {
        // Own properties of Gio-2.0.Gio.DBusProxy
        [key: string]: any;

        /**
         * If this property is not %G_BUS_TYPE_NONE, then
         * #GDBusProxy:g-connection must be %NULL and will be set to the
         * #GDBusConnection obtained by calling g_bus_get() with the value
         * of this property.
         */
        readonly g_bus_type: BusType;
        /**
         * The #GDBusConnection the proxy is for.
         */
        readonly g_connection: DBusConnection;
        /**
         * The timeout to use if -1 (specifying default timeout) is passed
         * as `timeout_msec` in the g_dbus_proxy_call() and
         * g_dbus_proxy_call_sync() functions.
         *
         * This allows applications to set a proxy-wide timeout for all
         * remote method invocations on the proxy. If this property is -1,
         * the default timeout (typically 25 seconds) is used. If set to
         * %G_MAXINT, then no timeout is used.
         */
        g_default_timeout: number;
        /**
         * Flags from the #GDBusProxyFlags enumeration.
         */
        readonly g_flags: DBusProxyFlags;
        /**
         * Ensure that interactions with this proxy conform to the given
         * interface. This is mainly to ensure that malformed data received
         * from the other peer is ignored. The given #GDBusInterfaceInfo is
         * said to be the "expected interface".
         *
         * The checks performed are:
         * - When completing a method call, if the type signature of
         *   the reply message isn't what's expected, the reply is
         *   discarded and the #GError is set to %G_IO_ERROR_INVALID_ARGUMENT.
         *
         * - Received signals that have a type signature mismatch are dropped and
         *   a warning is logged via g_warning().
         *
         * - Properties received via the initial `GetAll()` call or via the
         *   `::PropertiesChanged` signal (on the
         *   [org.freedesktop.DBus.Properties](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties)
         *   interface) or set using g_dbus_proxy_set_cached_property()
         *   with a type signature mismatch are ignored and a warning is
         *   logged via g_warning().
         *
         * Note that these checks are never done on methods, signals and
         * properties that are not referenced in the given
         * #GDBusInterfaceInfo, since extending a D-Bus interface on the
         * service-side is not considered an ABI break.
         */
        g_interface_info: DBusInterfaceInfo;
        /**
         * The D-Bus interface name the proxy is for.
         */
        readonly g_interface_name: string | null;
        /**
         * The well-known or unique name that the proxy is for.
         */
        readonly g_name: string | null;
        /**
         * The unique name that owns #GDBusProxy:g-name or %NULL if no-one
         * currently owns that name. You may connect to #GObject::notify signal to
         * track changes to this property.
         */
        readonly g_name_owner: string | null;
        /**
         * The object path the proxy is for.
         */
        readonly g_object_path: string | null;

        // Owm methods of Gio-2.0.Gio.DBusProxy

        /**
         * Asynchronously invokes the `method_name` method on `proxy`.
         *
         * If `method_name` contains any dots, then `name` is split into interface and
         * method name parts. This allows using `proxy` for invoking methods on
         * other interfaces.
         *
         * If the #GDBusConnection associated with `proxy` is closed then
         * the operation will fail with %G_IO_ERROR_CLOSED. If
         * `cancellable` is canceled, the operation will fail with
         * %G_IO_ERROR_CANCELLED. If `parameters` contains a value not
         * compatible with the D-Bus protocol, the operation fails with
         * %G_IO_ERROR_INVALID_ARGUMENT.
         *
         * If the `parameters` #GVariant is floating, it is consumed. This allows
         * convenient 'inline' use of g_variant_new(), e.g.:
         *
         * ```c
         *  g_dbus_proxy_call (proxy,
         *                     "TwoStrings",
         *                     g_variant_new ("(ss)",
         *                                    "Thing One",
         *                                    "Thing Two"),
         *                     G_DBUS_CALL_FLAGS_NONE,
         *                     -1,
         *                     NULL,
         *                     (GAsyncReadyCallback) two_strings_done,
         *                     &data);
         * ```
         *
         *
         * If `proxy` has an expected interface (see
         * #GDBusProxy:g-interface-info) and `method_name` is referenced by it,
         * then the return value is checked against the return type.
         *
         * This is an asynchronous method. When the operation is finished,
         * `callback` will be invoked in the
         * [thread-default main context][g-main-context-push-thread-default]
         * of the thread you are calling this method from.
         * You can then call g_dbus_proxy_call_finish() to get the result of
         * the operation. See g_dbus_proxy_call_sync() for the synchronous
         * version of this method.
         *
         * If `callback` is %NULL then the D-Bus method call message will be sent with
         * the %G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set.
         * @param method_name Name of method to invoke.
         * @param parameters A #GVariant tuple with parameters for the signal or %NULL if not passing parameters.
         * @param flags Flags from the #GDBusCallFlags enumeration.
         * @param timeout_msec The timeout in milliseconds (with %G_MAXINT meaning                "infinite") or -1 to use the proxy default timeout.
         * @param cancellable A #GCancellable or %NULL.
         * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL if you don't care about the result of the method invocation.
         */
        call(
            method_name: string | null,
            parameters: GLib.Variant | null,
            flags: DBusCallFlags,
            timeout_msec: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes an operation started with g_dbus_proxy_call().
         * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback passed to g_dbus_proxy_call().
         * @returns %NULL if @error is set. Otherwise a #GVariant tuple with return values. Free with g_variant_unref().
         */
        call_finish(res: AsyncResult): GLib.Variant;
        /**
         * Synchronously invokes the `method_name` method on `proxy`.
         *
         * If `method_name` contains any dots, then `name` is split into interface and
         * method name parts. This allows using `proxy` for invoking methods on
         * other interfaces.
         *
         * If the #GDBusConnection associated with `proxy` is disconnected then
         * the operation will fail with %G_IO_ERROR_CLOSED. If
         * `cancellable` is canceled, the operation will fail with
         * %G_IO_ERROR_CANCELLED. If `parameters` contains a value not
         * compatible with the D-Bus protocol, the operation fails with
         * %G_IO_ERROR_INVALID_ARGUMENT.
         *
         * If the `parameters` #GVariant is floating, it is consumed. This allows
         * convenient 'inline' use of g_variant_new(), e.g.:
         *
         * ```c
         *  g_dbus_proxy_call_sync (proxy,
         *                          "TwoStrings",
         *                          g_variant_new ("(ss)",
         *                                         "Thing One",
         *                                         "Thing Two"),
         *                          G_DBUS_CALL_FLAGS_NONE,
         *                          -1,
         *                          NULL,
         *                          &error);
         * ```
         *
         *
         * The calling thread is blocked until a reply is received. See
         * g_dbus_proxy_call() for the asynchronous version of this
         * method.
         *
         * If `proxy` has an expected interface (see
         * #GDBusProxy:g-interface-info) and `method_name` is referenced by it,
         * then the return value is checked against the return type.
         * @param method_name Name of method to invoke.
         * @param parameters A #GVariant tuple with parameters for the signal              or %NULL if not passing parameters.
         * @param flags Flags from the #GDBusCallFlags enumeration.
         * @param timeout_msec The timeout in milliseconds (with %G_MAXINT meaning                "infinite") or -1 to use the proxy default timeout.
         * @param cancellable A #GCancellable or %NULL.
         * @returns %NULL if @error is set. Otherwise a #GVariant tuple with return values. Free with g_variant_unref().
         */
        call_sync(
            method_name: string | null,
            parameters: GLib.Variant | null,
            flags: DBusCallFlags,
            timeout_msec: number,
            cancellable: Cancellable | null
        ): GLib.Variant;
        /**
         * Like g_dbus_proxy_call() but also takes a #GUnixFDList object.
         *
         * This method is only available on UNIX.
         * @param method_name Name of method to invoke.
         * @param parameters A #GVariant tuple with parameters for the signal or %NULL if not passing parameters.
         * @param flags Flags from the #GDBusCallFlags enumeration.
         * @param timeout_msec The timeout in milliseconds (with %G_MAXINT meaning                "infinite") or -1 to use the proxy default timeout.
         * @param fd_list A #GUnixFDList or %NULL.
         * @param cancellable A #GCancellable or %NULL.
         * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL if you don't care about the result of the method invocation.
         */
        call_with_unix_fd_list(
            method_name: string | null,
            parameters: GLib.Variant | null,
            flags: DBusCallFlags,
            timeout_msec: number,
            fd_list: UnixFDList | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes an operation started with g_dbus_proxy_call_with_unix_fd_list().
         * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback passed to g_dbus_proxy_call_with_unix_fd_list().
         * @returns %NULL if @error is set. Otherwise a #GVariant tuple with return values. Free with g_variant_unref().
         */
        call_with_unix_fd_list_finish(
            res: AsyncResult
        ): [/* returnType */ GLib.Variant, /* out_fd_list */ UnixFDList];
        /**
         * Like g_dbus_proxy_call_sync() but also takes and returns #GUnixFDList objects.
         *
         * This method is only available on UNIX.
         * @param method_name Name of method to invoke.
         * @param parameters A #GVariant tuple with parameters for the signal              or %NULL if not passing parameters.
         * @param flags Flags from the #GDBusCallFlags enumeration.
         * @param timeout_msec The timeout in milliseconds (with %G_MAXINT meaning                "infinite") or -1 to use the proxy default timeout.
         * @param fd_list A #GUnixFDList or %NULL.
         * @param cancellable A #GCancellable or %NULL.
         * @returns %NULL if @error is set. Otherwise a #GVariant tuple with return values. Free with g_variant_unref().
         */
        call_with_unix_fd_list_sync(
            method_name: string | null,
            parameters: GLib.Variant | null,
            flags: DBusCallFlags,
            timeout_msec: number,
            fd_list: UnixFDList | null,
            cancellable: Cancellable | null
        ): [/* returnType */ GLib.Variant, /* out_fd_list */ UnixFDList];
        /**
         * Looks up the value for a property from the cache. This call does no
         * blocking IO.
         *
         * If `proxy` has an expected interface (see
         * #GDBusProxy:g-interface-info) and `property_name` is referenced by
         * it, then `value` is checked against the type of the property.
         * @param property_name Property name.
         * @returns A reference to the #GVariant instance    that holds the value for @property_name or %NULL if the value is not in    the cache. The returned reference must be freed with g_variant_unref().
         */
        get_cached_property(property_name: string | null): GLib.Variant | null;
        /**
         * Gets the names of all cached properties on `proxy`.
         * @returns A          %NULL-terminated array of strings or %NULL if          @proxy has no cached properties. Free the returned array with          g_strfreev().
         */
        get_cached_property_names(): string[] | null;
        /**
         * Gets the connection `proxy` is for.
         * @returns A #GDBusConnection owned by @proxy. Do not free.
         */
        get_connection(): DBusConnection;
        /**
         * Gets the timeout to use if -1 (specifying default timeout) is
         * passed as `timeout_msec` in the g_dbus_proxy_call() and
         * g_dbus_proxy_call_sync() functions.
         *
         * See the #GDBusProxy:g-default-timeout property for more details.
         * @returns Timeout to use for @proxy.
         */
        get_default_timeout(): number;
        /**
         * Gets the flags that `proxy` was constructed with.
         * @returns Flags from the #GDBusProxyFlags enumeration.
         */
        get_flags(): DBusProxyFlags;
        /**
         * Returns the #GDBusInterfaceInfo, if any, specifying the interface
         * that `proxy` conforms to. See the #GDBusProxy:g-interface-info
         * property for more details.
         * @returns A #GDBusInterfaceInfo or %NULL.    Do not unref the returned object, it is owned by @proxy.
         */
        get_interface_info(): DBusInterfaceInfo | null;
        /**
         * Gets the D-Bus interface name `proxy` is for.
         * @returns A string owned by @proxy. Do not free.
         */
        get_interface_name(): string | null;
        /**
         * Gets the name that `proxy` was constructed for.
         *
         * When connected to a message bus, this will usually be non-%NULL.
         * However, it may be %NULL for a proxy that communicates using a peer-to-peer
         * pattern.
         * @returns A string owned by @proxy. Do not free.
         */
        get_name(): string | null;
        /**
         * The unique name that owns the name that `proxy` is for or %NULL if
         * no-one currently owns that name. You may connect to the
         * #GObject::notify signal to track changes to the
         * #GDBusProxy:g-name-owner property.
         * @returns The name owner or %NULL if no name    owner exists. Free with g_free().
         */
        get_name_owner(): string | null;
        /**
         * Gets the object path `proxy` is for.
         * @returns A string owned by @proxy. Do not free.
         */
        get_object_path(): string | null;
        /**
         * If `value` is not %NULL, sets the cached value for the property with
         * name `property_name` to the value in `value`.
         *
         * If `value` is %NULL, then the cached value is removed from the
         * property cache.
         *
         * If `proxy` has an expected interface (see
         * #GDBusProxy:g-interface-info) and `property_name` is referenced by
         * it, then `value` is checked against the type of the property.
         *
         * If the `value` #GVariant is floating, it is consumed. This allows
         * convenient 'inline' use of g_variant_new(), e.g.
         *
         * ```c
         *  g_dbus_proxy_set_cached_property (proxy,
         *                                    "SomeProperty",
         *                                    g_variant_new ("(si)",
         *                                                  "A String",
         *                                                  42));
         * ```
         *
         *
         * Normally you will not need to use this method since `proxy`
         * is tracking changes using the
         * `org.freedesktop.DBus.Properties.PropertiesChanged`
         * D-Bus signal. However, for performance reasons an object may
         * decide to not use this signal for some properties and instead
         * use a proprietary out-of-band mechanism to transmit changes.
         *
         * As a concrete example, consider an object with a property
         * `ChatroomParticipants` which is an array of strings. Instead of
         * transmitting the same (long) array every time the property changes,
         * it is more efficient to only transmit the delta using e.g. signals
         * `ChatroomParticipantJoined(String name)` and
         * `ChatroomParticipantParted(String name)`.
         * @param property_name Property name.
         * @param value Value for the property or %NULL to remove it from the cache.
         */
        set_cached_property(
            property_name: string | null,
            value: GLib.Variant | null
        ): void;
        /**
         * Sets the timeout to use if -1 (specifying default timeout) is
         * passed as `timeout_msec` in the g_dbus_proxy_call() and
         * g_dbus_proxy_call_sync() functions.
         *
         * See the #GDBusProxy:g-default-timeout property for more details.
         * @param timeout_msec Timeout in milliseconds.
         */
        set_default_timeout(timeout_msec: number): void;
        /**
         * Ensure that interactions with `proxy` conform to the given
         * interface. See the #GDBusProxy:g-interface-info property for more
         * details.
         * @param info Minimum interface this proxy conforms to    or %NULL to unset.
         */
        set_interface_info(info: DBusInterfaceInfo | null): void;
        connectSignal<T = any[]>(
            name: string,
            callback: (
                proxy: DBusProxy,
                name: string,
                args: T
            ) => boolean | void
        ): number;
        disconnectSignal(id: number): void;

        // Own virtual methods of Gio-2.0.Gio.DBusProxy

        vfunc_g_properties_changed(
            changed_properties: GLib.Variant,
            invalidated_properties: string | null
        ): void;
        vfunc_g_signal(
            sender_name: string | null,
            signal_name: string | null,
            parameters: GLib.Variant
        ): void;

        // Own signals of Gio-2.0.Gio.DBusProxy

        connect(
            sigName: 'g-properties-changed',
            callback: DBusProxy.GPropertiesChangedSignalCallback
        ): number;
        connect_after(
            sigName: 'g-properties-changed',
            callback: DBusProxy.GPropertiesChangedSignalCallback
        ): number;
        emit(
            sigName: 'g-properties-changed',
            changed_properties: GLib.Variant,
            invalidated_properties: string[],
            ...args: any[]
        ): void;
        connect(
            sigName: 'g-signal',
            callback: DBusProxy.GSignalSignalCallback
        ): number;
        connect_after(
            sigName: 'g-signal',
            callback: DBusProxy.GSignalSignalCallback
        ): number;
        emit(
            sigName: 'g-signal',
            sender_name: string | null,
            signal_name: string | null,
            parameters: GLib.Variant,
            ...args: any[]
        ): void;

        // Class property signals of Gio-2.0.Gio.DBusProxy

        connect(
            sigName: 'notify::g-bus-type',
            callback: ($obj: DBusProxy, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::g-bus-type',
            callback: ($obj: DBusProxy, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::g-bus-type', ...args: any[]): void;
        connect(
            sigName: 'notify::g-connection',
            callback: ($obj: DBusProxy, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::g-connection',
            callback: ($obj: DBusProxy, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::g-connection', ...args: any[]): void;
        connect(
            sigName: 'notify::g-default-timeout',
            callback: ($obj: DBusProxy, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::g-default-timeout',
            callback: ($obj: DBusProxy, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::g-default-timeout', ...args: any[]): void;
        connect(
            sigName: 'notify::g-flags',
            callback: ($obj: DBusProxy, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::g-flags',
            callback: ($obj: DBusProxy, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::g-flags', ...args: any[]): void;
        connect(
            sigName: 'notify::g-interface-info',
            callback: ($obj: DBusProxy, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::g-interface-info',
            callback: ($obj: DBusProxy, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::g-interface-info', ...args: any[]): void;
        connect(
            sigName: 'notify::g-interface-name',
            callback: ($obj: DBusProxy, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::g-interface-name',
            callback: ($obj: DBusProxy, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::g-interface-name', ...args: any[]): void;
        connect(
            sigName: 'notify::g-name',
            callback: ($obj: DBusProxy, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::g-name',
            callback: ($obj: DBusProxy, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::g-name', ...args: any[]): void;
        connect(
            sigName: 'notify::g-name-owner',
            callback: ($obj: DBusProxy, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::g-name-owner',
            callback: ($obj: DBusProxy, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::g-name-owner', ...args: any[]): void;
        connect(
            sigName: 'notify::g-object-path',
            callback: ($obj: DBusProxy, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::g-object-path',
            callback: ($obj: DBusProxy, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::g-object-path', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GDBusProxy is a base class used for proxies to access a D-Bus
     * interface on a remote object. A #GDBusProxy can be constructed for
     * both well-known and unique names.
     *
     * By default, #GDBusProxy will cache all properties (and listen to
     * changes) of the remote object, and proxy all signals that get
     * emitted. This behaviour can be changed by passing suitable
     * #GDBusProxyFlags when the proxy is created. If the proxy is for a
     * well-known name, the property cache is flushed when the name owner
     * vanishes and reloaded when a name owner appears.
     *
     * The unique name owner of the proxy's name is tracked and can be read from
     * #GDBusProxy:g-name-owner. Connect to the #GObject::notify signal to
     * get notified of changes. Additionally, only signals and property
     * changes emitted from the current name owner are considered and
     * calls are always sent to the current name owner. This avoids a
     * number of race conditions when the name is lost by one owner and
     * claimed by another. However, if no name owner currently exists,
     * then calls will be sent to the well-known name which may result in
     * the message bus launching an owner (unless
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START is set).
     *
     * If the proxy is for a stateless D-Bus service, where the name owner may
     * be started and stopped between calls, the #GDBusProxy:g-name-owner tracking
     * of #GDBusProxy will cause the proxy to drop signal and property changes from
     * the service after it has restarted for the first time. When interacting
     * with a stateless D-Bus service, do not use #GDBusProxy  use direct D-Bus
     * method calls and signal connections.
     *
     * The generic #GDBusProxy::g-properties-changed and
     * #GDBusProxy::g-signal signals are not very convenient to work with.
     * Therefore, the recommended way of working with proxies is to subclass
     * #GDBusProxy, and have more natural properties and signals in your derived
     * class. This [example][gdbus-example-gdbus-codegen] shows how this can
     * easily be done using the [gdbus-codegen][gdbus-codegen] tool.
     *
     * A #GDBusProxy instance can be used from multiple threads but note
     * that all signals (e.g. #GDBusProxy::g-signal, #GDBusProxy::g-properties-changed
     * and #GObject::notify) are emitted in the
     * [thread-default main context][g-main-context-push-thread-default]
     * of the thread where the instance was constructed.
     *
     * An example using a proxy for a well-known name can be found in
     * [gdbus-example-watch-proxy.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-watch-proxy.c)
     * @class
     */
    class DBusProxy extends GObject.Object {
        // Own properties of Gio-2.0.Gio.DBusProxy

        static name: string;
        static $gtype: GObject.GType<DBusProxy>;

        // Constructors of Gio-2.0.Gio.DBusProxy

        constructor(config?: DBusProxy.ConstructorProperties);
        /**
         * Finishes creating a #GDBusProxy.
         * @constructor
         * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new().
         * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
         */
        static new_finish(res: AsyncResult): DBusProxy;
        /**
         * Finishes creating a #GDBusProxy.
         * @constructor
         * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new_for_bus().
         * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
         */
        static new_for_bus_finish(res: AsyncResult): DBusProxy;
        /**
         * Like g_dbus_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
         *
         * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
         * @constructor
         * @param bus_type A #GBusType.
         * @param flags Flags used when constructing the proxy.
         * @param info A #GDBusInterfaceInfo specifying the minimal interface        that `proxy` conforms to or %NULL.
         * @param name A bus name (well-known or unique).
         * @param object_path An object path.
         * @param interface_name A D-Bus interface name.
         * @param cancellable A #GCancellable or %NULL.
         * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
         */
        static new_for_bus_sync(
            bus_type: BusType,
            flags: DBusProxyFlags,
            info: DBusInterfaceInfo | null,
            name: string | null,
            object_path: string | null,
            interface_name: string | null,
            cancellable: Cancellable | null
        ): DBusProxy;
        /**
         * Creates a proxy for accessing `interface_name` on the remote object
         * at `object_path` owned by `name` at `connection` and synchronously
         * loads D-Bus properties unless the
         * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used.
         *
         * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
         * match rules for signals. Connect to the #GDBusProxy::g-signal signal
         * to handle signals from the remote object.
         *
         * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
         * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
         * guaranteed to return immediately without blocking.
         *
         * If `name` is a well-known name and the
         * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
         * flags aren't set and no name owner currently exists, the message bus
         * will be requested to launch a name owner for the name.
         *
         * This is a synchronous failable constructor. See g_dbus_proxy_new()
         * and g_dbus_proxy_new_finish() for the asynchronous version.
         *
         * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
         * @constructor
         * @param connection A #GDBusConnection.
         * @param flags Flags used when constructing the proxy.
         * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
         * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
         * @param object_path An object path.
         * @param interface_name A D-Bus interface name.
         * @param cancellable A #GCancellable or %NULL.
         * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
         */
        static new_sync(
            connection: DBusConnection,
            flags: DBusProxyFlags,
            info: DBusInterfaceInfo | null,
            name: string | null,
            object_path: string | null,
            interface_name: string | null,
            cancellable: Cancellable | null
        ): DBusProxy;
        _init(config?: DBusProxy.ConstructorProperties): void;
        /**
         * Creates a proxy for accessing `interface_name` on the remote object
         * at `object_path` owned by `name` at `connection` and asynchronously
         * loads D-Bus properties unless the
         * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
         * the #GDBusProxy::g-properties-changed signal to get notified about
         * property changes.
         *
         * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
         * match rules for signals. Connect to the #GDBusProxy::g-signal signal
         * to handle signals from the remote object.
         *
         * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
         * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
         * guaranteed to complete immediately without blocking.
         *
         * If `name` is a well-known name and the
         * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
         * flags aren't set and no name owner currently exists, the message bus
         * will be requested to launch a name owner for the name.
         *
         * This is a failable asynchronous constructor - when the proxy is
         * ready, `callback` will be invoked and you can use
         * g_dbus_proxy_new_finish() to get the result.
         *
         * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
         *
         * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
         * @param connection A #GDBusConnection.
         * @param flags Flags used when constructing the proxy.
         * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
         * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
         * @param object_path An object path.
         * @param interface_name A D-Bus interface name.
         * @param cancellable A #GCancellable or %NULL.
         * @param callback Callback function to invoke when the proxy is ready.
         */
        static new(
            connection: DBusConnection,
            flags: DBusProxyFlags,
            info: DBusInterfaceInfo | null,
            name: string | null,
            object_path: string | null,
            interface_name: string | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<DBusProxy> | null
        ): void;
        /**
         * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
         *
         * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
         * @param bus_type A #GBusType.
         * @param flags Flags used when constructing the proxy.
         * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
         * @param name A bus name (well-known or unique).
         * @param object_path An object path.
         * @param interface_name A D-Bus interface name.
         * @param cancellable A #GCancellable or %NULL.
         * @param callback Callback function to invoke when the proxy is ready.
         */
        static new_for_bus(
            bus_type: BusType,
            flags: DBusProxyFlags,
            info: DBusInterfaceInfo | null,
            name: string | null,
            object_path: string | null,
            interface_name: string | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<DBusProxy> | null
        ): void;
        static makeProxyWrapper<T>(
            interfaceXml: string
        ): (
            bus: DBusConnection,
            name: string,
            object: string,
            asyncCallback?: (
                initable: (T & DBusProxy) | null,
                error: unknown | null
            ) => void,
            cancellable?: Cancellable | null,
            flags?: DBusProxyFlags
        ) => T & DBusProxy;
    }

    namespace DBusServer {
        // Signal callback interfaces

        /**
         * Signal callback interface for `new-connection`
         */
        interface NewConnectionSignalCallback {
            ($obj: DBusServer, connection: DBusConnection): boolean;
        }

        // Constructor properties interface

        interface ConstructorProperties
            extends Initable.ConstructorProperties,
                GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.DBusServer

            /**
             * The D-Bus address to listen on.
             */
            address?: string | null;
            /**
             * A #GDBusAuthObserver object to assist in the authentication process or %NULL.
             */
            authentication_observer?: DBusAuthObserver | null;
            /**
             * Flags from the #GDBusServerFlags enumeration.
             */
            flags?: DBusServerFlags | null;
            /**
             * The GUID of the server.
             *
             * See #GDBusConnection:guid for more details.
             */
            guid?: string | null;
        }
    }

    interface DBusServer extends Initable {
        // Own properties of Gio-2.0.Gio.DBusServer

        /**
         * Whether the server is currently active.
         */
        readonly active: boolean;
        /**
         * The D-Bus address to listen on.
         */
        readonly address: string | null;
        /**
         * A #GDBusAuthObserver object to assist in the authentication process or %NULL.
         */
        readonly authentication_observer: DBusAuthObserver;
        /**
         * The D-Bus address that clients can use.
         */
        readonly client_address: string | null;
        /**
         * Flags from the #GDBusServerFlags enumeration.
         */
        readonly flags: DBusServerFlags;
        /**
         * The GUID of the server.
         *
         * See #GDBusConnection:guid for more details.
         */
        readonly guid: string | null;

        // Owm methods of Gio-2.0.Gio.DBusServer

        /**
         * Gets a
         * [D-Bus address](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses)
         * string that can be used by clients to connect to `server`.
         *
         * This is valid and non-empty if initializing the #GDBusServer succeeded.
         * @returns A D-Bus address string. Do not free, the string is owned by @server.
         */
        get_client_address(): string | null;
        /**
         * Gets the flags for `server`.
         * @returns A set of flags from the #GDBusServerFlags enumeration.
         */
        get_flags(): DBusServerFlags;
        /**
         * Gets the GUID for `server,` as provided to g_dbus_server_new_sync().
         * @returns A D-Bus GUID. Do not free this string, it is owned by @server.
         */
        get_guid(): string | null;
        /**
         * Gets whether `server` is active.
         * @returns %TRUE if server is active, %FALSE otherwise.
         */
        is_active(): boolean;
        /**
         * Starts `server`.
         */
        start(): void;
        /**
         * Stops `server`.
         */
        stop(): void;

        // Own signals of Gio-2.0.Gio.DBusServer

        connect(
            sigName: 'new-connection',
            callback: DBusServer.NewConnectionSignalCallback
        ): number;
        connect_after(
            sigName: 'new-connection',
            callback: DBusServer.NewConnectionSignalCallback
        ): number;
        emit(
            sigName: 'new-connection',
            connection: DBusConnection,
            ...args: any[]
        ): void;

        // Class property signals of Gio-2.0.Gio.DBusServer

        connect(
            sigName: 'notify::active',
            callback: ($obj: DBusServer, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::active',
            callback: ($obj: DBusServer, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::active', ...args: any[]): void;
        connect(
            sigName: 'notify::address',
            callback: ($obj: DBusServer, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::address',
            callback: ($obj: DBusServer, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::address', ...args: any[]): void;
        connect(
            sigName: 'notify::authentication-observer',
            callback: ($obj: DBusServer, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::authentication-observer',
            callback: ($obj: DBusServer, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::authentication-observer', ...args: any[]): void;
        connect(
            sigName: 'notify::client-address',
            callback: ($obj: DBusServer, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::client-address',
            callback: ($obj: DBusServer, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::client-address', ...args: any[]): void;
        connect(
            sigName: 'notify::flags',
            callback: ($obj: DBusServer, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::flags',
            callback: ($obj: DBusServer, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::flags', ...args: any[]): void;
        connect(
            sigName: 'notify::guid',
            callback: ($obj: DBusServer, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::guid',
            callback: ($obj: DBusServer, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::guid', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GDBusServer is a helper for listening to and accepting D-Bus
     * connections. This can be used to create a new D-Bus server, allowing two
     * peers to use the D-Bus protocol for their own specialized communication.
     * A server instance provided in this way will not perform message routing or
     * implement the org.freedesktop.DBus interface.
     *
     * To just export an object on a well-known name on a message bus, such as the
     * session or system bus, you should instead use g_bus_own_name().
     *
     * An example of peer-to-peer communication with GDBus can be found
     * in [gdbus-example-peer.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-peer.c).
     *
     * Note that a minimal #GDBusServer will accept connections from any
     * peer. In many use-cases it will be necessary to add a #GDBusAuthObserver
     * that only accepts connections that have successfully authenticated
     * as the same user that is running the #GDBusServer. Since GLib 2.68 this can
     * be achieved more simply by passing the
     * %G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER flag to the server.
     * @class
     */
    class DBusServer extends GObject.Object {
        // Own properties of Gio-2.0.Gio.DBusServer

        static name: string;
        static $gtype: GObject.GType<DBusServer>;

        // Constructors of Gio-2.0.Gio.DBusServer

        constructor(config?: DBusServer.ConstructorProperties);
        /**
         * Creates a new D-Bus server that listens on the first address in
         * `address` that works.
         *
         * Once constructed, you can use g_dbus_server_get_client_address() to
         * get a D-Bus address string that clients can use to connect.
         *
         * To have control over the available authentication mechanisms and
         * the users that are authorized to connect, it is strongly recommended
         * to provide a non-%NULL #GDBusAuthObserver.
         *
         * Connect to the #GDBusServer::new-connection signal to handle
         * incoming connections.
         *
         * The returned #GDBusServer isn't active - you have to start it with
         * g_dbus_server_start().
         *
         * #GDBusServer is used in this [example][gdbus-peer-to-peer].
         *
         * This is a synchronous failable constructor. There is currently no
         * asynchronous version.
         * @constructor
         * @param address A D-Bus address.
         * @param flags Flags from the #GDBusServerFlags enumeration.
         * @param guid A D-Bus GUID.
         * @param observer A #GDBusAuthObserver or %NULL.
         * @param cancellable A #GCancellable or %NULL.
         * @returns A #GDBusServer or %NULL if @error is set. Free with g_object_unref().
         */
        static new_sync(
            address: string | null,
            flags: DBusServerFlags,
            guid: string | null,
            observer: DBusAuthObserver | null,
            cancellable: Cancellable | null
        ): DBusServer;
        _init(config?: DBusServer.ConstructorProperties): void;
    }

    namespace DataInputStream {
        // Constructor properties interface

        interface ConstructorProperties
            extends Seekable.ConstructorProperties,
                BufferedInputStream.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.DataInputStream

            /**
             * The :byte-order property determines the byte ordering that
             * is used when reading multi-byte entities (such as integers)
             * from the stream.
             */
            byte_order?: DataStreamByteOrder | null;
            /**
             * The :newline-type property determines what is considered
             * as a line ending when reading complete lines from the stream.
             */
            newline_type?: DataStreamNewlineType | null;
        }
    }

    interface DataInputStream extends Seekable {
        // Own properties of Gio-2.0.Gio.DataInputStream

        /**
         * The :byte-order property determines the byte ordering that
         * is used when reading multi-byte entities (such as integers)
         * from the stream.
         */
        byte_order: DataStreamByteOrder;
        /**
         * The :newline-type property determines what is considered
         * as a line ending when reading complete lines from the stream.
         */
        newline_type: DataStreamNewlineType;

        // Own fields of Gio-2.0.Gio.DataInputStream

        parent_instance: BufferedInputStream &
            FilterInputStream &
            InputStream &
            GObject.Object &
            GObject.Object;

        // Owm methods of Gio-2.0.Gio.DataInputStream

        /**
         * Gets the byte order for the data input stream.
         * @returns the @stream's current #GDataStreamByteOrder.
         */
        get_byte_order(): DataStreamByteOrder;
        /**
         * Gets the current newline type for the `stream`.
         * @returns #GDataStreamNewlineType for the given @stream.
         */
        get_newline_type(): DataStreamNewlineType;
        /**
         * Reads an unsigned 8-bit/1-byte value from `stream`.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns an unsigned 8-bit/1-byte value read from the @stream or `0` if an error occurred.
         */
        read_byte(cancellable: Cancellable | null): number;
        /**
         * Reads a 16-bit/2-byte value from `stream`.
         *
         * In order to get the correct byte order for this read operation,
         * see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a signed 16-bit/2-byte value read from @stream or `0` if an error occurred.
         */
        read_int16(cancellable: Cancellable | null): number;
        /**
         * Reads a signed 32-bit/4-byte value from `stream`.
         *
         * In order to get the correct byte order for this read operation,
         * see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a signed 32-bit/4-byte value read from the @stream or `0` if an error occurred.
         */
        read_int32(cancellable: Cancellable | null): number;
        /**
         * Reads a 64-bit/8-byte value from `stream`.
         *
         * In order to get the correct byte order for this read operation,
         * see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a signed 64-bit/8-byte value read from @stream or `0` if an error occurred.
         */
        read_int64(cancellable: Cancellable | null): number;
        /**
         * Reads a line from the data input stream.  Note that no encoding
         * checks or conversion is performed; the input is not guaranteed to
         * be UTF-8, and may in fact have embedded NUL characters.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns   a NUL terminated byte array with the line that was read in  (without the newlines).  Set @length to a #gsize to get the length  of the read line.  On an error, it will return %NULL and @error  will be set. If there's no content to read, it will still return  %NULL, but @error won't be set.
         */
        read_line(
            cancellable: Cancellable | null
        ): [/* returnType */ Uint8Array | null, /* length */ number];
        /**
         * The asynchronous version of g_data_input_stream_read_line().  It is
         * an error to have two outstanding calls to this function.
         *
         * When the operation is finished, `callback` will be called. You
         * can then call g_data_input_stream_read_line_finish() to get
         * the result of the operation.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback callback to call when the request is satisfied.
         */
        read_line_async(
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of read_line_async

        /**
         * Promisified version of {@link read_line_async}
         *
         * The asynchronous version of g_data_input_stream_read_line().  It is
         * an error to have two outstanding calls to this function.
         *
         * When the operation is finished, `callback` will be called. You
         * can then call g_data_input_stream_read_line_finish() to get
         * the result of the operation.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns A Promise of:   a NUL-terminated byte array with the line that was read in  (without the newlines).  Set @length to a #gsize to get the length  of the read line.  On an error, it will return %NULL and @error  will be set. If there's no content to read, it will still return  %NULL, but @error won't be set.
         */
        read_line_async(
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise</* length */ number>;
        /**
         * Finish an asynchronous call started by
         * g_data_input_stream_read_line_async().  Note the warning about
         * string encoding in g_data_input_stream_read_line() applies here as
         * well.
         * @param result the #GAsyncResult that was provided to the callback.
         * @returns   a NUL-terminated byte array with the line that was read in  (without the newlines).  Set @length to a #gsize to get the length  of the read line.  On an error, it will return %NULL and @error  will be set. If there's no content to read, it will still return  %NULL, but @error won't be set.
         */
        read_line_finish(
            result: AsyncResult
        ): [/* returnType */ Uint8Array | null, /* length */ number];
        /**
         * Finish an asynchronous call started by
         * g_data_input_stream_read_line_async().
         * @param result the #GAsyncResult that was provided to the callback.
         * @returns a string with the line that  was read in (without the newlines).  Set @length to a #gsize to  get the length of the read line.  On an error, it will return  %NULL and @error will be set. For UTF-8 conversion errors, the set  error domain is %G_CONVERT_ERROR.  If there's no content to read,  it will still return %NULL, but @error won't be set.
         */
        read_line_finish_utf8(
            result: AsyncResult
        ): [/* returnType */ string | null, /* length */ number];
        /**
         * Reads a UTF-8 encoded line from the data input stream.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a NUL terminated UTF-8 string  with the line that was read in (without the newlines).  Set  @length to a #gsize to get the length of the read line.  On an  error, it will return %NULL and @error will be set.  For UTF-8  conversion errors, the set error domain is %G_CONVERT_ERROR.  If  there's no content to read, it will still return %NULL, but @error  won't be set.
         */
        read_line_utf8(
            cancellable: Cancellable | null
        ): [/* returnType */ string | null, /* length */ number];
        /**
         * Reads an unsigned 16-bit/2-byte value from `stream`.
         *
         * In order to get the correct byte order for this read operation,
         * see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns an unsigned 16-bit/2-byte value read from the @stream or `0` if an error occurred.
         */
        read_uint16(cancellable: Cancellable | null): number;
        /**
         * Reads an unsigned 32-bit/4-byte value from `stream`.
         *
         * In order to get the correct byte order for this read operation,
         * see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns an unsigned 32-bit/4-byte value read from the @stream or `0` if an error occurred.
         */
        read_uint32(cancellable: Cancellable | null): number;
        /**
         * Reads an unsigned 64-bit/8-byte value from `stream`.
         *
         * In order to get the correct byte order for this read operation,
         * see g_data_input_stream_get_byte_order().
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns an unsigned 64-bit/8-byte read from @stream or `0` if an error occurred.
         */
        read_uint64(cancellable: Cancellable | null): number;
        /**
         * Reads a string from the data input stream, up to the first
         * occurrence of any of the stop characters.
         *
         * Note that, in contrast to g_data_input_stream_read_until_async(),
         * this function consumes the stop character that it finds.
         *
         * Don't use this function in new code.  Its functionality is
         * inconsistent with g_data_input_stream_read_until_async().  Both
         * functions will be marked as deprecated in a future release.  Use
         * g_data_input_stream_read_upto() instead, but note that that function
         * does not consume the stop character.
         * @param stop_chars characters to terminate the read.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a string with the data that was read     before encountering any of the stop characters. Set @length to     a #gsize to get the length of the string. This function will     return %NULL on an error.
         */
        read_until(
            stop_chars: string | null,
            cancellable: Cancellable | null
        ): [/* returnType */ string | null, /* length */ number];
        /**
         * The asynchronous version of g_data_input_stream_read_until().
         * It is an error to have two outstanding calls to this function.
         *
         * Note that, in contrast to g_data_input_stream_read_until(),
         * this function does not consume the stop character that it finds.  You
         * must read it for yourself.
         *
         * When the operation is finished, `callback` will be called. You
         * can then call g_data_input_stream_read_until_finish() to get
         * the result of the operation.
         *
         * Don't use this function in new code.  Its functionality is
         * inconsistent with g_data_input_stream_read_until().  Both functions
         * will be marked as deprecated in a future release.  Use
         * g_data_input_stream_read_upto_async() instead.
         * @param stop_chars characters to terminate the read.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback callback to call when the request is satisfied.
         */
        read_until_async(
            stop_chars: string | null,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of read_until_async

        /**
         * Promisified version of {@link read_until_async}
         *
         * The asynchronous version of g_data_input_stream_read_until().
         * It is an error to have two outstanding calls to this function.
         *
         * Note that, in contrast to g_data_input_stream_read_until(),
         * this function does not consume the stop character that it finds.  You
         * must read it for yourself.
         *
         * When the operation is finished, `callback` will be called. You
         * can then call g_data_input_stream_read_until_finish() to get
         * the result of the operation.
         *
         * Don't use this function in new code.  Its functionality is
         * inconsistent with g_data_input_stream_read_until().  Both functions
         * will be marked as deprecated in a future release.  Use
         * g_data_input_stream_read_upto_async() instead.
         * @param stop_chars characters to terminate the read.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns A Promise of: a string with the data that was read     before encountering any of the stop characters. Set @length to     a #gsize to get the length of the string. This function will     return %NULL on an error.
         */
        read_until_async(
            stop_chars: string | null,
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise</* length */ number>;
        /**
         * Finish an asynchronous call started by
         * g_data_input_stream_read_until_async().
         * @param result the #GAsyncResult that was provided to the callback.
         * @returns a string with the data that was read     before encountering any of the stop characters. Set @length to     a #gsize to get the length of the string. This function will     return %NULL on an error.
         */
        read_until_finish(
            result: AsyncResult
        ): [/* returnType */ string | null, /* length */ number];
        /**
         * Reads a string from the data input stream, up to the first
         * occurrence of any of the stop characters.
         *
         * In contrast to g_data_input_stream_read_until(), this function
         * does not consume the stop character. You have to use
         * g_data_input_stream_read_byte() to get it before calling
         * g_data_input_stream_read_upto() again.
         *
         * Note that `stop_chars` may contain '\0' if `stop_chars_len` is
         * specified.
         *
         * The returned string will always be nul-terminated on success.
         * @param stop_chars characters to terminate the read
         * @param stop_chars_len length of `stop_chars`. May be -1 if `stop_chars` is     nul-terminated
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @returns a string with the data that was read     before encountering any of the stop characters. Set @length to     a #gsize to get the length of the string. This function will     return %NULL on an error
         */
        read_upto(
            stop_chars: string | null,
            stop_chars_len: number,
            cancellable: Cancellable | null
        ): [/* returnType */ string | null, /* length */ number];
        /**
         * The asynchronous version of g_data_input_stream_read_upto().
         * It is an error to have two outstanding calls to this function.
         *
         * In contrast to g_data_input_stream_read_until(), this function
         * does not consume the stop character. You have to use
         * g_data_input_stream_read_byte() to get it before calling
         * g_data_input_stream_read_upto() again.
         *
         * Note that `stop_chars` may contain '\0' if `stop_chars_len` is
         * specified.
         *
         * When the operation is finished, `callback` will be called. You
         * can then call g_data_input_stream_read_upto_finish() to get
         * the result of the operation.
         * @param stop_chars characters to terminate the read
         * @param stop_chars_len length of `stop_chars`. May be -1 if `stop_chars` is     nul-terminated
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback callback to call when the request is satisfied
         */
        read_upto_async(
            stop_chars: string | null,
            stop_chars_len: number,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of read_upto_async

        /**
         * Promisified version of {@link read_upto_async}
         *
         * The asynchronous version of g_data_input_stream_read_upto().
         * It is an error to have two outstanding calls to this function.
         *
         * In contrast to g_data_input_stream_read_until(), this function
         * does not consume the stop character. You have to use
         * g_data_input_stream_read_byte() to get it before calling
         * g_data_input_stream_read_upto() again.
         *
         * Note that `stop_chars` may contain '\0' if `stop_chars_len` is
         * specified.
         *
         * When the operation is finished, `callback` will be called. You
         * can then call g_data_input_stream_read_upto_finish() to get
         * the result of the operation.
         * @param stop_chars characters to terminate the read
         * @param stop_chars_len length of `stop_chars`. May be -1 if `stop_chars` is     nul-terminated
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @returns A Promise of: a string with the data that was read     before encountering any of the stop characters. Set @length to     a #gsize to get the length of the string. This function will     return %NULL on an error.
         */
        read_upto_async(
            stop_chars: string | null,
            stop_chars_len: number,
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise</* length */ number>;
        /**
         * Finish an asynchronous call started by
         * g_data_input_stream_read_upto_async().
         *
         * Note that this function does not consume the stop character. You
         * have to use g_data_input_stream_read_byte() to get it before calling
         * g_data_input_stream_read_upto_async() again.
         *
         * The returned string will always be nul-terminated on success.
         * @param result the #GAsyncResult that was provided to the callback
         * @returns a string with the data that was read     before encountering any of the stop characters. Set @length to     a #gsize to get the length of the string. This function will     return %NULL on an error.
         */
        read_upto_finish(
            result: AsyncResult
        ): [/* returnType */ string | null, /* length */ number];
        /**
         * This function sets the byte order for the given `stream`. All subsequent
         * reads from the `stream` will be read in the given `order`.
         * @param order a #GDataStreamByteOrder to set.
         */
        set_byte_order(order: DataStreamByteOrder): void;
        /**
         * Sets the newline type for the `stream`.
         *
         * Note that using G_DATA_STREAM_NEWLINE_TYPE_ANY is slightly unsafe. If a read
         * chunk ends in "CR" we must read an additional byte to know if this is "CR" or
         * "CR LF", and this might block if there is no more data available.
         * @param type the type of new line return as #GDataStreamNewlineType.
         */
        set_newline_type(type: DataStreamNewlineType): void;

        // Class property signals of Gio-2.0.Gio.DataInputStream

        connect(
            sigName: 'notify::byte-order',
            callback: ($obj: DataInputStream, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::byte-order',
            callback: ($obj: DataInputStream, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::byte-order', ...args: any[]): void;
        connect(
            sigName: 'notify::newline-type',
            callback: ($obj: DataInputStream, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::newline-type',
            callback: ($obj: DataInputStream, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::newline-type', ...args: any[]): void;
        connect(
            sigName: 'notify::buffer-size',
            callback: ($obj: DataInputStream, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::buffer-size',
            callback: ($obj: DataInputStream, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::buffer-size', ...args: any[]): void;
        connect(
            sigName: 'notify::close-base-stream',
            callback: ($obj: DataInputStream, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::close-base-stream',
            callback: ($obj: DataInputStream, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::close-base-stream', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * Data input stream implements #GInputStream and includes functions for
     * reading structured data directly from a binary input stream.
     * @class
     */
    class DataInputStream extends BufferedInputStream {
        // Own properties of Gio-2.0.Gio.DataInputStream

        static name: string;
        static $gtype: GObject.GType<DataInputStream>;

        // Constructors of Gio-2.0.Gio.DataInputStream

        constructor(config?: DataInputStream.ConstructorProperties);
        /**
         * Creates a new data input stream for the `base_stream`.
         * @constructor
         * @param base_stream a #GInputStream.
         * @returns a new #GDataInputStream.
         */
        constructor(base_stream: InputStream);
        /**
         * Creates a new data input stream for the `base_stream`.
         * @constructor
         * @param base_stream a #GInputStream.
         * @returns a new #GDataInputStream.
         */
        static new(base_stream: InputStream): DataInputStream;

        // Overloads of new

        /**
         * Creates a new #GInputStream from the given `base_stream,` with
         * a buffer set to the default size (4 kilobytes).
         * @constructor
         * @param base_stream a #GInputStream
         * @returns a #GInputStream for the given @base_stream.
         */
        static new(base_stream: InputStream): BufferedInputStream;
        _init(config?: DataInputStream.ConstructorProperties): void;
    }

    namespace DataOutputStream {
        // Constructor properties interface

        interface ConstructorProperties
            extends Seekable.ConstructorProperties,
                FilterOutputStream.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.DataOutputStream

            /**
             * Determines the byte ordering that is used when writing
             * multi-byte entities (such as integers) to the stream.
             */
            byte_order?: DataStreamByteOrder | null;
        }
    }

    interface DataOutputStream extends Seekable {
        // Own properties of Gio-2.0.Gio.DataOutputStream

        /**
         * Determines the byte ordering that is used when writing
         * multi-byte entities (such as integers) to the stream.
         */
        byte_order: DataStreamByteOrder;

        // Own fields of Gio-2.0.Gio.DataOutputStream

        parent_instance: FilterOutputStream &
            OutputStream &
            GObject.Object &
            GObject.Object;

        // Owm methods of Gio-2.0.Gio.DataOutputStream

        /**
         * Gets the byte order for the stream.
         * @returns the #GDataStreamByteOrder for the @stream.
         */
        get_byte_order(): DataStreamByteOrder;
        /**
         * Puts a byte into the output stream.
         * @param data a #guchar.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if @data was successfully added to the @stream.
         */
        put_byte(data: number, cancellable: Cancellable | null): boolean;
        /**
         * Puts a signed 16-bit integer into the output stream.
         * @param data a #gint16.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if @data was successfully added to the @stream.
         */
        put_int16(data: number, cancellable: Cancellable | null): boolean;
        /**
         * Puts a signed 32-bit integer into the output stream.
         * @param data a #gint32.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if @data was successfully added to the @stream.
         */
        put_int32(data: number, cancellable: Cancellable | null): boolean;
        /**
         * Puts a signed 64-bit integer into the stream.
         * @param data a #gint64.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if @data was successfully added to the @stream.
         */
        put_int64(data: number, cancellable: Cancellable | null): boolean;
        /**
         * Puts a string into the output stream.
         * @param str a string.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if @string was successfully added to the @stream.
         */
        put_string(
            str: string | null,
            cancellable: Cancellable | null
        ): boolean;
        /**
         * Puts an unsigned 16-bit integer into the output stream.
         * @param data a #guint16.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if @data was successfully added to the @stream.
         */
        put_uint16(data: number, cancellable: Cancellable | null): boolean;
        /**
         * Puts an unsigned 32-bit integer into the stream.
         * @param data a #guint32.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if @data was successfully added to the @stream.
         */
        put_uint32(data: number, cancellable: Cancellable | null): boolean;
        /**
         * Puts an unsigned 64-bit integer into the stream.
         * @param data a #guint64.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if @data was successfully added to the @stream.
         */
        put_uint64(data: number, cancellable: Cancellable | null): boolean;
        /**
         * Sets the byte order of the data output stream to `order`.
         * @param order a %GDataStreamByteOrder.
         */
        set_byte_order(order: DataStreamByteOrder): void;

        // Class property signals of Gio-2.0.Gio.DataOutputStream

        connect(
            sigName: 'notify::byte-order',
            callback: ($obj: DataOutputStream, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::byte-order',
            callback: ($obj: DataOutputStream, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::byte-order', ...args: any[]): void;
        connect(
            sigName: 'notify::close-base-stream',
            callback: ($obj: DataOutputStream, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::close-base-stream',
            callback: ($obj: DataOutputStream, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::close-base-stream', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * Data output stream implements #GOutputStream and includes functions for
     * writing data directly to an output stream.
     * @class
     */
    class DataOutputStream extends FilterOutputStream {
        // Own properties of Gio-2.0.Gio.DataOutputStream

        static name: string;
        static $gtype: GObject.GType<DataOutputStream>;

        // Constructors of Gio-2.0.Gio.DataOutputStream

        constructor(config?: DataOutputStream.ConstructorProperties);
        /**
         * Creates a new data output stream for `base_stream`.
         * @constructor
         * @param base_stream a #GOutputStream.
         * @returns #GDataOutputStream.
         */
        constructor(base_stream: OutputStream);
        /**
         * Creates a new data output stream for `base_stream`.
         * @constructor
         * @param base_stream a #GOutputStream.
         * @returns #GDataOutputStream.
         */
        static new(base_stream: OutputStream): DataOutputStream;
        _init(config?: DataOutputStream.ConstructorProperties): void;
    }

    namespace DebugControllerDBus {
        // Signal callback interfaces

        /**
         * Signal callback interface for `authorize`
         */
        interface AuthorizeSignalCallback {
            (
                $obj: DebugControllerDBus,
                invocation: DBusMethodInvocation
            ): boolean;
        }

        // Constructor properties interface

        interface ConstructorProperties
            extends DebugController.ConstructorProperties,
                Initable.ConstructorProperties,
                GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.DebugControllerDBus

            /**
             * The D-Bus connection to expose the debugging interface on.
             *
             * Typically this will be the same connection (to the system or session bus)
             * which the rest of the application or services D-Bus objects are registered
             * on.
             */
            connection?: DBusConnection | null;
        }
    }

    interface DebugControllerDBus extends DebugController, Initable {
        // Own properties of Gio-2.0.Gio.DebugControllerDBus

        /**
         * The D-Bus connection to expose the debugging interface on.
         *
         * Typically this will be the same connection (to the system or session bus)
         * which the rest of the application or services D-Bus objects are registered
         * on.
         */
        readonly connection: DBusConnection;

        // Own fields of Gio-2.0.Gio.DebugControllerDBus

        parent_instance: GObject.Object;

        // Owm methods of Gio-2.0.Gio.DebugControllerDBus

        /**
         * Stop the debug controller, unregistering its object from the bus.
         *
         * Any pending method calls to the object will complete successfully, but new
         * ones will return an error. This method will block until all pending
         * #GDebugControllerDBus::authorize signals have been handled. This is expected
         * to not take long, as it will just be waiting for threads to join. If any
         * #GDebugControllerDBus::authorize signal handlers are still executing in other
         * threads, this will block until after they have returned.
         *
         * This method will be called automatically when the final reference to the
         * #GDebugControllerDBus is dropped. You may want to call it explicitly to know
         * when the controller has been fully removed from the bus, or to break
         * reference count cycles.
         *
         * Calling this method from within a #GDebugControllerDBus::authorize signal
         * handler will cause a deadlock and must not be done.
         */
        stop(): void;

        // Own virtual methods of Gio-2.0.Gio.DebugControllerDBus

        vfunc_authorize(invocation: DBusMethodInvocation): boolean;

        // Own signals of Gio-2.0.Gio.DebugControllerDBus

        connect(
            sigName: 'authorize',
            callback: DebugControllerDBus.AuthorizeSignalCallback
        ): number;
        connect_after(
            sigName: 'authorize',
            callback: DebugControllerDBus.AuthorizeSignalCallback
        ): number;
        emit(
            sigName: 'authorize',
            invocation: DBusMethodInvocation,
            ...args: any[]
        ): void;

        // Class property signals of Gio-2.0.Gio.DebugControllerDBus

        connect(
            sigName: 'notify::connection',
            callback: (
                $obj: DebugControllerDBus,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::connection',
            callback: (
                $obj: DebugControllerDBus,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::connection', ...args: any[]): void;
        connect(
            sigName: 'notify::debug-enabled',
            callback: (
                $obj: DebugControllerDBus,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::debug-enabled',
            callback: (
                $obj: DebugControllerDBus,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::debug-enabled', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GDebugControllerDBus is an implementation of #GDebugController which exposes
     * debug settings as a D-Bus object.
     *
     * It is a #GInitable object, and will register an object at
     * `/org/gtk/Debugging` on the bus given as
     * #GDebugControllerDBus:connection once its initialized. The object will be
     * unregistered when the last reference to the #GDebugControllerDBus is dropped.
     *
     * This D-Bus object can be used by remote processes to enable or disable debug
     * output in this process. Remote processes calling
     * `org.gtk.Debugging.SetDebugEnabled()` will affect the value of
     * #GDebugController:debug-enabled and, by default, g_log_get_debug_enabled().
     * default.
     *
     * By default, no processes are allowed to call `SetDebugEnabled()` unless a
     * #GDebugControllerDBus::authorize signal handler is installed. This is because
     * the process may be privileged, or might expose sensitive information in its
     * debug output. You may want to restrict the ability to enable debug output to
     * privileged users or processes.
     *
     * One option is to install a D-Bus security policy which restricts access to
     * `SetDebugEnabled()`, installing something like the following in
     * `$datadir/dbus-1/system.d/`:
     *
     * ```<!-- language="XML" -->
     * <?xml version="1.0"?> <!--*-nxml-*-->
     * <!DOCTYPE busconfig PUBLIC "-//freedesktop//DTD D-BUS Bus Configuration 1.0//EN"
     *      "http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd">
     * <busconfig>
     *   <policy user="root">
     *     <allow send_destination="com.example.MyService" send_interface="org.gtk.Debugging"/>
     *   </policy>
     *   <policy context="default">
     *     <deny send_destination="com.example.MyService" send_interface="org.gtk.Debugging"/>
     *   </policy>
     * </busconfig>
     * ```
     *
     *
     * This will prevent the `SetDebugEnabled()` method from being called by all
     * except root. It will not prevent the `DebugEnabled` property from being read,
     * as its accessed through the `org.freedesktop.DBus.Properties` interface.
     *
     * Another option is to use polkit to allow or deny requests on a case-by-case
     * basis, allowing for the possibility of dynamic authorisation. To do this,
     * connect to the #GDebugControllerDBus::authorize signal and query polkit in
     * it:
     *
     * ```c
     *   g_autoptr(GError) child_error = NULL;
     *   g_autoptr(GDBusConnection) connection = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, NULL);
     *   gulong debug_controller_authorize_id = 0;
     *
     *   // Set up the debug controller.
     *   debug_controller = G_DEBUG_CONTROLLER (g_debug_controller_dbus_new (priv->connection, NULL, &child_error));
     *   if (debug_controller == NULL)
     *     {
     *       g_error ("Could not register debug controller on bus: %s"),
     *                child_error->message);
     *     }
     *
     *   debug_controller_authorize_id = g_signal_connect (debug_controller,
     *                                                     "authorize",
     *                                                     G_CALLBACK (debug_controller_authorize_cb),
     *                                                     self);
     *
     *   static gboolean
     *   debug_controller_authorize_cb (GDebugControllerDBus  *debug_controller,
     *                                  GDBusMethodInvocation *invocation,
     *                                  gpointer               user_data)
     *   {
     *     g_autoptr(PolkitAuthority) authority = NULL;
     *     g_autoptr(PolkitSubject) subject = NULL;
     *     g_autoptr(PolkitAuthorizationResult) auth_result = NULL;
     *     g_autoptr(GError) local_error = NULL;
     *     GDBusMessage *message;
     *     GDBusMessageFlags message_flags;
     *     PolkitCheckAuthorizationFlags flags = POLKIT_CHECK_AUTHORIZATION_FLAGS_NONE;
     *
     *     message = g_dbus_method_invocation_get_message (invocation);
     *     message_flags = g_dbus_message_get_flags (message);
     *
     *     authority = polkit_authority_get_sync (NULL, &local_error);
     *     if (authority == NULL)
     *       {
     *         g_warning ("Failed to get polkit authority: %s", local_error->message);
     *         return FALSE;
     *       }
     *
     *     if (message_flags & G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION)
     *       flags |= POLKIT_CHECK_AUTHORIZATION_FLAGS_ALLOW_USER_INTERACTION;
     *
     *     subject = polkit_system_bus_name_new (g_dbus_method_invocation_get_sender (invocation));
     *
     *     auth_result = polkit_authority_check_authorization_sync (authority,
     *                                                              subject,
     *                                                              "com.example.MyService.set-debug-enabled",
     *                                                              NULL,
     *                                                              flags,
     *                                                              NULL,
     *                                                              &local_error);
     *     if (auth_result == NULL)
     *       {
     *         g_warning ("Failed to get check polkit authorization: %s", local_error->message);
     *         return FALSE;
     *       }
     *
     *     return polkit_authorization_result_get_is_authorized (auth_result);
     *   }
     * ```
     *
     * @class
     */
    class DebugControllerDBus extends GObject.Object {
        // Own properties of Gio-2.0.Gio.DebugControllerDBus

        static name: string;
        static $gtype: GObject.GType<DebugControllerDBus>;

        // Constructors of Gio-2.0.Gio.DebugControllerDBus

        constructor(config?: DebugControllerDBus.ConstructorProperties);
        /**
         * Create a new #GDebugControllerDBus and synchronously initialize it.
         *
         * Initializing the object will export the debug object on `connection`. The
         * object will remain registered until the last reference to the
         * #GDebugControllerDBus is dropped.
         *
         * Initialization may fail if registering the object on `connection` fails.
         * @constructor
         * @param connection a #GDBusConnection to register the debug object on
         * @param cancellable a #GCancellable, or %NULL
         * @returns a new #GDebugControllerDBus, or %NULL   on failure
         */
        constructor(
            connection: DBusConnection,
            cancellable: Cancellable | null
        );
        /**
         * Create a new #GDebugControllerDBus and synchronously initialize it.
         *
         * Initializing the object will export the debug object on `connection`. The
         * object will remain registered until the last reference to the
         * #GDebugControllerDBus is dropped.
         *
         * Initialization may fail if registering the object on `connection` fails.
         * @constructor
         * @param connection a #GDBusConnection to register the debug object on
         * @param cancellable a #GCancellable, or %NULL
         * @returns a new #GDebugControllerDBus, or %NULL   on failure
         */
        static new(
            connection: DBusConnection,
            cancellable: Cancellable | null
        ): DebugControllerDBus;
        _init(config?: DebugControllerDBus.ConstructorProperties): void;
    }

    namespace DesktopAppInfo {
        // Constructor properties interface

        interface ConstructorProperties
            extends AppInfo.ConstructorProperties,
                GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.DesktopAppInfo

            /**
             * The origin filename of this #GDesktopAppInfo
             */
            filename?: string | null;
        }
    }

    interface DesktopAppInfo extends AppInfo {
        // Own properties of Gio-2.0.Gio.DesktopAppInfo

        /**
         * The origin filename of this #GDesktopAppInfo
         */
        readonly filename: string | null;

        // Owm methods of Gio-2.0.Gio.DesktopAppInfo

        /**
         * Gets the user-visible display name of the "additional application
         * action" specified by `action_name`.
         *
         * This corresponds to the "Name" key within the keyfile group for the
         * action.
         * @param action_name the name of the action as from   g_desktop_app_info_list_actions()
         * @returns the locale-specific action name
         */
        get_action_name(action_name: string | null): string | null;
        /**
         * Looks up a boolean value in the keyfile backing `info`.
         *
         * The `key` is looked up in the "Desktop Entry" group.
         * @param key the key to look up
         * @returns the boolean value, or %FALSE if the key     is not found
         */
        get_boolean(key: string | null): boolean;
        /**
         * Gets the categories from the desktop file.
         * @returns The unparsed Categories key from the desktop file;     i.e. no attempt is made to split it by ';' or validate it.
         */
        get_categories(): string | null;
        /**
         * When `info` was created from a known filename, return it.  In some
         * situations such as the #GDesktopAppInfo returned from
         * g_desktop_app_info_new_from_keyfile(), this function will return %NULL.
         * @returns The full path to the file for @info,     or %NULL if not known.
         */
        get_filename(): string | null;
        /**
         * Gets the generic name from the desktop file.
         * @returns The value of the GenericName key
         */
        get_generic_name(): string | null;
        /**
         * A desktop file is hidden if the Hidden key in it is
         * set to True.
         * @returns %TRUE if hidden, %FALSE otherwise.
         */
        get_is_hidden(): boolean;
        /**
         * Gets the keywords from the desktop file.
         * @returns The value of the Keywords key
         */
        get_keywords(): string[];
        /**
         * Looks up a localized string value in the keyfile backing `info`
         * translated to the current locale.
         *
         * The `key` is looked up in the "Desktop Entry" group.
         * @param key the key to look up
         * @returns a newly allocated string, or %NULL if the key     is not found
         */
        get_locale_string(key: string | null): string | null;
        /**
         * Gets the value of the NoDisplay key, which helps determine if the
         * application info should be shown in menus. See
         * %G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY and g_app_info_should_show().
         * @returns The value of the NoDisplay key
         */
        get_nodisplay(): boolean;
        /**
         * Checks if the application info should be shown in menus that list available
         * applications for a specific name of the desktop, based on the
         * `OnlyShowIn` and `NotShowIn` keys.
         *
         * `desktop_env` should typically be given as %NULL, in which case the
         * `XDG_CURRENT_DESKTOP` environment variable is consulted.  If you want
         * to override the default mechanism then you may specify `desktop_env,`
         * but this is not recommended.
         *
         * Note that g_app_info_should_show() for `info` will include this check (with
         * %NULL for `desktop_env)` as well as additional checks.
         * @param desktop_env a string specifying a desktop name
         * @returns %TRUE if the @info should be shown in @desktop_env according to the `OnlyShowIn` and `NotShowIn` keys, %FALSE otherwise.
         */
        get_show_in(desktop_env: string | null): boolean;
        /**
         * Retrieves the StartupWMClass field from `info`. This represents the
         * WM_CLASS property of the main window of the application, if launched
         * through `info`.
         * @returns the startup WM class, or %NULL if none is set in the desktop file.
         */
        get_startup_wm_class(): string | null;
        /**
         * Looks up a string value in the keyfile backing `info`.
         *
         * The `key` is looked up in the "Desktop Entry" group.
         * @param key the key to look up
         * @returns a newly allocated string, or %NULL if the key     is not found
         */
        get_string(key: string | null): string | null;
        /**
         * Looks up a string list value in the keyfile backing `info`.
         *
         * The `key` is looked up in the "Desktop Entry" group.
         * @param key the key to look up
         * @returns   a %NULL-terminated string array or %NULL if the specified  key cannot be found. The array should be freed with g_strfreev().
         */
        get_string_list(key: string | null): string[];
        /**
         * Returns whether `key` exists in the "Desktop Entry" group
         * of the keyfile backing `info`.
         * @param key the key to look up
         * @returns %TRUE if the @key exists
         */
        has_key(key: string | null): boolean;
        /**
         * Activates the named application action.
         *
         * You may only call this function on action names that were
         * returned from g_desktop_app_info_list_actions().
         *
         * Note that if the main entry of the desktop file indicates that the
         * application supports startup notification, and `launch_context` is
         * non-%NULL, then startup notification will be used when activating the
         * action (and as such, invocation of the action on the receiving side
         * must signal the end of startup notification when it is completed).
         * This is the expected behaviour of applications declaring additional
         * actions, as per the desktop file specification.
         *
         * As with g_app_info_launch() there is no way to detect failures that
         * occur while using this function.
         * @param action_name the name of the action as from   g_desktop_app_info_list_actions()
         * @param launch_context a #GAppLaunchContext
         */
        launch_action(
            action_name: string | null,
            launch_context: AppLaunchContext | null
        ): void;
        /**
         * This function performs the equivalent of g_app_info_launch_uris(),
         * but is intended primarily for operating system components that
         * launch applications.  Ordinary applications should use
         * g_app_info_launch_uris().
         *
         * If the application is launched via GSpawn, then `spawn_flags,` `user_setup`
         * and `user_setup_data` are used for the call to g_spawn_async().
         * Additionally, `pid_callback` (with `pid_callback_data)` will be called to
         * inform about the PID of the created process. See g_spawn_async_with_pipes()
         * for information on certain parameter conditions that can enable an
         * optimized posix_spawn() codepath to be used.
         *
         * If application launching occurs via some other mechanism (eg: D-Bus
         * activation) then `spawn_flags,` `user_setup,` `user_setup_data,`
         * `pid_callback` and `pid_callback_data` are ignored.
         * @param uris List of URIs
         * @param launch_context a #GAppLaunchContext
         * @param spawn_flags #GSpawnFlags, used for each process
         * @returns %TRUE on successful launch, %FALSE otherwise.
         */
        launch_uris_as_manager(
            uris: string[],
            launch_context: AppLaunchContext | null,
            spawn_flags: GLib.SpawnFlags
        ): boolean;
        /**
         * Equivalent to g_desktop_app_info_launch_uris_as_manager() but allows
         * you to pass in file descriptors for the stdin, stdout and stderr streams
         * of the launched process.
         *
         * If application launching occurs via some non-spawn mechanism (e.g. D-Bus
         * activation) then `stdin_fd,` `stdout_fd` and `stderr_fd` are ignored.
         * @param uris List of URIs
         * @param launch_context a #GAppLaunchContext
         * @param spawn_flags #GSpawnFlags, used for each process
         * @param user_setup a #GSpawnChildSetupFunc, used once     for each process.
         * @param pid_callback Callback for child processes
         * @param stdin_fd file descriptor to use for child's stdin, or -1
         * @param stdout_fd file descriptor to use for child's stdout, or -1
         * @param stderr_fd file descriptor to use for child's stderr, or -1
         * @returns %TRUE on successful launch, %FALSE otherwise.
         */
        launch_uris_as_manager_with_fds(
            uris: string[],
            launch_context: AppLaunchContext | null,
            spawn_flags: GLib.SpawnFlags,
            user_setup: GLib.SpawnChildSetupFunc | null,
            pid_callback: DesktopAppLaunchCallback | null,
            stdin_fd: number,
            stdout_fd: number,
            stderr_fd: number
        ): boolean;
        /**
         * Returns the list of "additional application actions" supported on the
         * desktop file, as per the desktop file specification.
         *
         * As per the specification, this is the list of actions that are
         * explicitly listed in the "Actions" key of the [Desktop Entry] group.
         * @returns a list of strings, always non-%NULL
         */
        list_actions(): string[];

        // Class property signals of Gio-2.0.Gio.DesktopAppInfo

        connect(
            sigName: 'notify::filename',
            callback: ($obj: DesktopAppInfo, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::filename',
            callback: ($obj: DesktopAppInfo, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::filename', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GDesktopAppInfo is an implementation of #GAppInfo based on
     * desktop files.
     *
     * Note that `<gio/gdesktopappinfo.h>` belongs to the UNIX-specific
     * GIO interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config
     * file when using it.
     * @class
     */
    class DesktopAppInfo extends GObject.Object {
        // Own properties of Gio-2.0.Gio.DesktopAppInfo

        static name: string;
        static $gtype: GObject.GType<DesktopAppInfo>;

        // Constructors of Gio-2.0.Gio.DesktopAppInfo

        constructor(config?: DesktopAppInfo.ConstructorProperties);
        /**
         * Creates a new #GDesktopAppInfo based on a desktop file id.
         *
         * A desktop file id is the basename of the desktop file, including the
         * .desktop extension. GIO is looking for a desktop file with this name
         * in the `applications` subdirectories of the XDG
         * data directories (i.e. the directories specified in the `XDG_DATA_HOME`
         * and `XDG_DATA_DIRS` environment variables). GIO also supports the
         * prefix-to-subdirectory mapping that is described in the
         * [Menu Spec](http://standards.freedesktop.org/menu-spec/latest/)
         * (i.e. a desktop id of kde-foo.desktop will match
         * `/usr/share/applications/kde/foo.desktop`).
         * @constructor
         * @param desktop_id the desktop file id
         * @returns a new #GDesktopAppInfo, or %NULL if no desktop     file with that id exists.
         */
        constructor(desktop_id: string | null);
        /**
         * Creates a new #GDesktopAppInfo based on a desktop file id.
         *
         * A desktop file id is the basename of the desktop file, including the
         * .desktop extension. GIO is looking for a desktop file with this name
         * in the `applications` subdirectories of the XDG
         * data directories (i.e. the directories specified in the `XDG_DATA_HOME`
         * and `XDG_DATA_DIRS` environment variables). GIO also supports the
         * prefix-to-subdirectory mapping that is described in the
         * [Menu Spec](http://standards.freedesktop.org/menu-spec/latest/)
         * (i.e. a desktop id of kde-foo.desktop will match
         * `/usr/share/applications/kde/foo.desktop`).
         * @constructor
         * @param desktop_id the desktop file id
         * @returns a new #GDesktopAppInfo, or %NULL if no desktop     file with that id exists.
         */
        static new(desktop_id: string | null): DesktopAppInfo;
        /**
         * Creates a new #GDesktopAppInfo.
         * @constructor
         * @param filename the path of a desktop file, in the GLib      filename encoding
         * @returns a new #GDesktopAppInfo or %NULL on error.
         */
        static new_from_filename(filename: string): DesktopAppInfo;
        /**
         * Creates a new #GDesktopAppInfo.
         * @constructor
         * @param key_file an opened #GKeyFile
         * @returns a new #GDesktopAppInfo or %NULL on error.
         */
        static new_from_keyfile(key_file: GLib.KeyFile): DesktopAppInfo;
        _init(config?: DesktopAppInfo.ConstructorProperties): void;
        /**
         * Gets all applications that implement `interface`.
         *
         * An application implements an interface if that interface is listed in
         * the Implements= line of the desktop file of the application.
         * @param interface the name of the interface
         * @returns a list of #GDesktopAppInfo objects.
         */
        static get_implementations(interface: string | null): DesktopAppInfo[];
        /**
         * Searches desktop files for ones that match `search_string`.
         *
         * The return value is an array of strvs.  Each strv contains a list of
         * applications that matched `search_string` with an equal score.  The
         * outer list is sorted by score so that the first strv contains the
         * best-matching applications, and so on.
         * The algorithm for determining matches is undefined and may change at
         * any time.
         *
         * None of the search results are subjected to the normal validation
         * checks performed by g_desktop_app_info_new() (for example, checking that
         * the executable referenced by a result exists), and so it is possible for
         * g_desktop_app_info_new() to return %NULL when passed an app ID returned by
         * this function. It is expected that calling code will do this when
         * subsequently creating a #GDesktopAppInfo for each result.
         * @param search_string the search string to use
         * @returns a   list of strvs.  Free each item with g_strfreev() and free the outer   list with g_free().
         */
        static search(search_string: string | null): string[];
        /**
         * Sets the name of the desktop that the application is running in.
         * This is used by g_app_info_should_show() and
         * g_desktop_app_info_get_show_in() to evaluate the
         * `OnlyShowIn` and `NotShowIn`
         * desktop entry fields.
         *
         * Should be called only once; subsequent calls are ignored.
         * @param desktop_env a string specifying what desktop this is
         */
        static set_desktop_env(desktop_env: string | null): void;
    }

    namespace Emblem {
        // Constructor properties interface

        interface ConstructorProperties
            extends Icon.ConstructorProperties,
                GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.Emblem

            icon?: GObject.Object | null;
            origin?: EmblemOrigin | null;
        }
    }

    interface Emblem extends Icon {
        // Own properties of Gio-2.0.Gio.Emblem

        readonly icon: GObject.Object;
        readonly origin: EmblemOrigin;

        // Owm methods of Gio-2.0.Gio.Emblem

        /**
         * Gives back the icon from `emblem`.
         * @returns a #GIcon. The returned object belongs to          the emblem and should not be modified or freed.
         */
        get_icon(): Icon;
        /**
         * Gets the origin of the emblem.
         * @returns the origin of the emblem
         */
        get_origin(): EmblemOrigin;

        // Class property signals of Gio-2.0.Gio.Emblem

        connect(
            sigName: 'notify::icon',
            callback: ($obj: Emblem, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::icon',
            callback: ($obj: Emblem, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::icon', ...args: any[]): void;
        connect(
            sigName: 'notify::origin',
            callback: ($obj: Emblem, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::origin',
            callback: ($obj: Emblem, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::origin', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GEmblem is an implementation of #GIcon that supports
     * having an emblem, which is an icon with additional properties.
     * It can than be added to a #GEmblemedIcon.
     *
     * Currently, only metainformation about the emblem's origin is
     * supported. More may be added in the future.
     * @class
     */
    class Emblem extends GObject.Object {
        // Own properties of Gio-2.0.Gio.Emblem

        static name: string;
        static $gtype: GObject.GType<Emblem>;

        // Constructors of Gio-2.0.Gio.Emblem

        constructor(config?: Emblem.ConstructorProperties);
        /**
         * Creates a new emblem for `icon`.
         * @constructor
         * @param icon a GIcon containing the icon.
         * @returns a new #GEmblem.
         */
        constructor(icon: Icon);
        /**
         * Creates a new emblem for `icon`.
         * @constructor
         * @param icon a GIcon containing the icon.
         * @returns a new #GEmblem.
         */
        static new(icon: Icon): Emblem;
        /**
         * Creates a new emblem for `icon`.
         * @constructor
         * @param icon a GIcon containing the icon.
         * @param origin a GEmblemOrigin enum defining the emblem's origin
         * @returns a new #GEmblem.
         */
        static new_with_origin(icon: Icon, origin: EmblemOrigin): Emblem;
        _init(config?: Emblem.ConstructorProperties): void;
    }

    namespace EmblemedIcon {
        // Constructor properties interface

        interface ConstructorProperties
            extends Icon.ConstructorProperties,
                GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.EmblemedIcon

            gicon?: Icon | null;
        }
    }

    interface EmblemedIcon extends Icon {
        // Own properties of Gio-2.0.Gio.EmblemedIcon

        readonly gicon: Icon;

        // Own fields of Gio-2.0.Gio.EmblemedIcon

        parent_instance: GObject.Object;

        // Owm methods of Gio-2.0.Gio.EmblemedIcon

        /**
         * Adds `emblem` to the #GList of #GEmblems.
         * @param emblem a #GEmblem
         */
        add_emblem(emblem: Emblem): void;
        /**
         * Removes all the emblems from `icon`.
         */
        clear_emblems(): void;
        /**
         * Gets the list of emblems for the `icon`.
         * @returns a #GList of     #GEmblems that is owned by @emblemed
         */
        get_emblems(): Emblem[];
        /**
         * Gets the main icon for `emblemed`.
         * @returns a #GIcon that is owned by @emblemed
         */
        get_icon(): Icon;

        // Class property signals of Gio-2.0.Gio.EmblemedIcon

        connect(
            sigName: 'notify::gicon',
            callback: ($obj: EmblemedIcon, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::gicon',
            callback: ($obj: EmblemedIcon, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::gicon', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GEmblemedIcon is an implementation of #GIcon that supports
     * adding an emblem to an icon. Adding multiple emblems to an
     * icon is ensured via g_emblemed_icon_add_emblem().
     *
     * Note that #GEmblemedIcon allows no control over the position
     * of the emblems. See also #GEmblem for more information.
     * @class
     */
    class EmblemedIcon extends GObject.Object {
        // Own properties of Gio-2.0.Gio.EmblemedIcon

        static name: string;
        static $gtype: GObject.GType<EmblemedIcon>;

        // Constructors of Gio-2.0.Gio.EmblemedIcon

        constructor(config?: EmblemedIcon.ConstructorProperties);
        /**
         * Creates a new emblemed icon for `icon` with the emblem `emblem`.
         * @constructor
         * @param icon a #GIcon
         * @param emblem a #GEmblem, or %NULL
         * @returns a new #GIcon
         */
        constructor(icon: Icon, emblem: Emblem | null);
        /**
         * Creates a new emblemed icon for `icon` with the emblem `emblem`.
         * @constructor
         * @param icon a #GIcon
         * @param emblem a #GEmblem, or %NULL
         * @returns a new #GIcon
         */
        static new(icon: Icon, emblem: Emblem | null): EmblemedIcon;
        _init(config?: EmblemedIcon.ConstructorProperties): void;
    }

    namespace FileEnumerator {
        // Constructor properties interface

        interface ConstructorProperties
            extends GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.FileEnumerator

            container?: File | null;
        }
    }

    interface FileEnumerator {
        // Own properties of Gio-2.0.Gio.FileEnumerator

        readonly container: File;

        // Own fields of Gio-2.0.Gio.FileEnumerator

        parent_instance: GObject.Object;

        // Owm methods of Gio-2.0.Gio.FileEnumerator

        /**
         * Releases all resources used by this enumerator, making the
         * enumerator return %G_IO_ERROR_CLOSED on all calls.
         *
         * This will be automatically called when the last reference
         * is dropped, but you might want to call this function to make
         * sure resources are released as early as possible.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns #TRUE on success or #FALSE on error.
         */
        close(cancellable: Cancellable | null): boolean;
        /**
         * Asynchronously closes the file enumerator.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned in
         * g_file_enumerator_close_finish().
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        close_async(
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of close_async

        /**
         * Promisified version of {@link close_async}
         *
         * Asynchronously closes the file enumerator.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned in
         * g_file_enumerator_close_finish().
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns A Promise of: %TRUE if the close operation has finished successfully.
         */
        close_async(
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<boolean>;
        /**
         * Finishes closing a file enumerator, started from g_file_enumerator_close_async().
         *
         * If the file enumerator was already closed when g_file_enumerator_close_async()
         * was called, then this function will report %G_IO_ERROR_CLOSED in `error,` and
         * return %FALSE. If the file enumerator had pending operation when the close
         * operation was started, then this function will report %G_IO_ERROR_PENDING, and
         * return %FALSE.  If `cancellable` was not %NULL, then the operation may have been
         * cancelled by triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %FALSE will be
         * returned.
         * @param result a #GAsyncResult.
         * @returns %TRUE if the close operation has finished successfully.
         */
        close_finish(result: AsyncResult): boolean;
        /**
         * Return a new #GFile which refers to the file named by `info` in the source
         * directory of `enumerator`.  This function is primarily intended to be used
         * inside loops with g_file_enumerator_next_file().
         *
         * To use this, %G_FILE_ATTRIBUTE_STANDARD_NAME must have been listed in the
         * attributes list used when creating the #GFileEnumerator.
         *
         * This is a convenience method that's equivalent to:
         *
         * ```c
         *   gchar *name = g_file_info_get_name (info);
         *   GFile *child = g_file_get_child (g_file_enumerator_get_container (enumr),
         *                                    name);
         * ```
         *
         * @param info a #GFileInfo gotten from g_file_enumerator_next_file()   or the async equivalents.
         * @returns a #GFile for the #GFileInfo passed it.
         */
        get_child(info: FileInfo): File;
        /**
         * Get the #GFile container which is being enumerated.
         * @returns the #GFile which is being enumerated.
         */
        get_container(): File;
        /**
         * Checks if the file enumerator has pending operations.
         * @returns %TRUE if the @enumerator has pending operations.
         */
        has_pending(): boolean;
        /**
         * Checks if the file enumerator has been closed.
         * @returns %TRUE if the @enumerator is closed.
         */
        is_closed(): boolean;
        /**
         * This is a version of g_file_enumerator_next_file() that's easier to
         * use correctly from C programs.  With g_file_enumerator_next_file(),
         * the gboolean return value signifies "end of iteration or error", which
         * requires allocation of a temporary #GError.
         *
         * In contrast, with this function, a %FALSE return from
         * g_file_enumerator_iterate() *always* means
         * "error".  End of iteration is signaled by `out_info` or `out_child` being %NULL.
         *
         * Another crucial difference is that the references for `out_info` and
         * `out_child` are owned by `direnum` (they are cached as hidden
         * properties).  You must not unref them in your own code.  This makes
         * memory management significantly easier for C code in combination
         * with loops.
         *
         * Finally, this function optionally allows retrieving a #GFile as
         * well.
         *
         * You must specify at least one of `out_info` or `out_child`.
         *
         * The code pattern for correctly using g_file_enumerator_iterate() from C
         * is:
         *
         *
         * ```
         * direnum = g_file_enumerate_children (file, ...);
         * while (TRUE)
         *   {
         *     GFileInfo *info;
         *     if (!g_file_enumerator_iterate (direnum, &info, NULL, cancellable, error))
         *       goto out;
         *     if (!info)
         *       break;
         *     ... do stuff with "info"; do not unref it! ...
         *   }
         *
         * out:
         *   g_object_unref (direnum); // Note: frees the last `info`
         * ```
         *
         * @param cancellable a #GCancellable
         */
        iterate(
            cancellable: Cancellable | null
        ): [
            /* returnType */ boolean,
            /* out_info */ FileInfo,
            /* out_child */ File
        ];
        /**
         * Returns information for the next file in the enumerated object.
         * Will block until the information is available. The #GFileInfo
         * returned from this function will contain attributes that match the
         * attribute string that was passed when the #GFileEnumerator was created.
         *
         * See the documentation of #GFileEnumerator for information about the
         * order of returned files.
         *
         * On error, returns %NULL and sets `error` to the error. If the
         * enumerator is at the end, %NULL will be returned and `error` will
         * be unset.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns A #GFileInfo or %NULL on error    or end of enumerator.  Free the returned object with    g_object_unref() when no longer needed.
         */
        next_file(cancellable: Cancellable | null): FileInfo | null;
        /**
         * Request information for a number of files from the enumerator asynchronously.
         * When all I/O for the operation is finished the `callback` will be called with
         * the requested information.
         *
         * See the documentation of #GFileEnumerator for information about the
         * order of returned files.
         *
         * Once the end of the enumerator is reached, or if an error occurs, the
         * `callback` will be called with an empty list. In this case, the previous call
         * to g_file_enumerator_next_files_async() will typically have returned fewer
         * than `num_files` items.
         *
         * If a request is cancelled the callback will be called with
         * %G_IO_ERROR_CANCELLED.
         *
         * This leads to the following pseudo-code usage:
         *
         * ```
         * g_autoptr(GFile) dir = get_directory ();
         * g_autoptr(GFileEnumerator) enumerator = NULL;
         * g_autolist(GFileInfo) files = NULL;
         * g_autoptr(GError) local_error = NULL;
         *
         * enumerator = yield g_file_enumerate_children_async (dir,
         *                                                     G_FILE_ATTRIBUTE_STANDARD_NAME ","
         *                                                     G_FILE_ATTRIBUTE_STANDARD_TYPE,
         *                                                     G_FILE_QUERY_INFO_NONE,
         *                                                     G_PRIORITY_DEFAULT,
         *                                                     cancellable,
         *                                                     ,
         *                                                     &local_error);
         * if (enumerator == NULL)
         *   g_error ("Error enumerating: %s", local_error->message);
         *
         * // Loop until no files are returned, either because the end of the enumerator
         * // has been reached, or an error was returned.
         * do
         *   {
         *     files = yield g_file_enumerator_next_files_async (enumerator,
         *                                                       5,  // number of files to request
         *                                                       G_PRIORITY_DEFAULT,
         *                                                       cancellable,
         *                                                       ,
         *                                                       &local_error);
         *
         *     // Process the returned files, but dont assume that exactly 5 were returned.
         *     for (GList *l = files; l != NULL; l = l->next)
         *       {
         *         GFileInfo *info = l->data;
         *         handle_file_info (info);
         *       }
         *   }
         * while (files != NULL);
         *
         * if (local_error != NULL &&
         *     !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
         *   g_error ("Error while enumerating: %s", local_error->message);
         * ```
         *
         *
         * During an async request no other sync and async calls are allowed, and will
         * result in %G_IO_ERROR_PENDING errors.
         *
         * Any outstanding I/O request with higher priority (lower numerical value) will
         * be executed before an outstanding request with lower priority. Default
         * priority is %G_PRIORITY_DEFAULT.
         * @param num_files the number of file info objects to request
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        next_files_async(
            num_files: number,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of next_files_async

        /**
         * Promisified version of {@link next_files_async}
         *
         * Request information for a number of files from the enumerator asynchronously.
         * When all I/O for the operation is finished the `callback` will be called with
         * the requested information.
         *
         * See the documentation of #GFileEnumerator for information about the
         * order of returned files.
         *
         * Once the end of the enumerator is reached, or if an error occurs, the
         * `callback` will be called with an empty list. In this case, the previous call
         * to g_file_enumerator_next_files_async() will typically have returned fewer
         * than `num_files` items.
         *
         * If a request is cancelled the callback will be called with
         * %G_IO_ERROR_CANCELLED.
         *
         * This leads to the following pseudo-code usage:
         *
         * ```
         * g_autoptr(GFile) dir = get_directory ();
         * g_autoptr(GFileEnumerator) enumerator = NULL;
         * g_autolist(GFileInfo) files = NULL;
         * g_autoptr(GError) local_error = NULL;
         *
         * enumerator = yield g_file_enumerate_children_async (dir,
         *                                                     G_FILE_ATTRIBUTE_STANDARD_NAME ","
         *                                                     G_FILE_ATTRIBUTE_STANDARD_TYPE,
         *                                                     G_FILE_QUERY_INFO_NONE,
         *                                                     G_PRIORITY_DEFAULT,
         *                                                     cancellable,
         *                                                     ,
         *                                                     &local_error);
         * if (enumerator == NULL)
         *   g_error ("Error enumerating: %s", local_error->message);
         *
         * // Loop until no files are returned, either because the end of the enumerator
         * // has been reached, or an error was returned.
         * do
         *   {
         *     files = yield g_file_enumerator_next_files_async (enumerator,
         *                                                       5,  // number of files to request
         *                                                       G_PRIORITY_DEFAULT,
         *                                                       cancellable,
         *                                                       ,
         *                                                       &local_error);
         *
         *     // Process the returned files, but dont assume that exactly 5 were returned.
         *     for (GList *l = files; l != NULL; l = l->next)
         *       {
         *         GFileInfo *info = l->data;
         *         handle_file_info (info);
         *       }
         *   }
         * while (files != NULL);
         *
         * if (local_error != NULL &&
         *     !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
         *   g_error ("Error while enumerating: %s", local_error->message);
         * ```
         *
         *
         * During an async request no other sync and async calls are allowed, and will
         * result in %G_IO_ERROR_PENDING errors.
         *
         * Any outstanding I/O request with higher priority (lower numerical value) will
         * be executed before an outstanding request with lower priority. Default
         * priority is %G_PRIORITY_DEFAULT.
         * @param num_files the number of file info objects to request
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns A Promise of: a #GList of #GFileInfos. You must free the list with     g_list_free() and unref the infos with g_object_unref() when you're     done with them.
         */
        next_files_async(
            num_files: number,
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<FileInfo[]>;
        /**
         * Finishes the asynchronous operation started with g_file_enumerator_next_files_async().
         * @param result a #GAsyncResult.
         * @returns a #GList of #GFileInfos. You must free the list with     g_list_free() and unref the infos with g_object_unref() when you're     done with them.
         */
        next_files_finish(result: AsyncResult): FileInfo[];
        /**
         * Sets the file enumerator as having pending operations.
         * @param pending a boolean value.
         */
        set_pending(pending: boolean): void;

        // Own virtual methods of Gio-2.0.Gio.FileEnumerator

        /**
         * Asynchronously closes the file enumerator.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned in
         * g_file_enumerator_close_finish().
         * @virtual
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_close_async(
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes closing a file enumerator, started from g_file_enumerator_close_async().
         *
         * If the file enumerator was already closed when g_file_enumerator_close_async()
         * was called, then this function will report %G_IO_ERROR_CLOSED in `error,` and
         * return %FALSE. If the file enumerator had pending operation when the close
         * operation was started, then this function will report %G_IO_ERROR_PENDING, and
         * return %FALSE.  If `cancellable` was not %NULL, then the operation may have been
         * cancelled by triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %FALSE will be
         * returned.
         * @virtual
         * @param result a #GAsyncResult.
         * @returns %TRUE if the close operation has finished successfully.
         */
        vfunc_close_finish(result: AsyncResult): boolean;
        vfunc_close_fn(cancellable: Cancellable | null): boolean;
        /**
         * Returns information for the next file in the enumerated object.
         * Will block until the information is available. The #GFileInfo
         * returned from this function will contain attributes that match the
         * attribute string that was passed when the #GFileEnumerator was created.
         *
         * See the documentation of #GFileEnumerator for information about the
         * order of returned files.
         *
         * On error, returns %NULL and sets `error` to the error. If the
         * enumerator is at the end, %NULL will be returned and `error` will
         * be unset.
         * @virtual
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns A #GFileInfo or %NULL on error    or end of enumerator.  Free the returned object with    g_object_unref() when no longer needed.
         */
        vfunc_next_file(cancellable: Cancellable | null): FileInfo | null;
        /**
         * Request information for a number of files from the enumerator asynchronously.
         * When all I/O for the operation is finished the `callback` will be called with
         * the requested information.
         *
         * See the documentation of #GFileEnumerator for information about the
         * order of returned files.
         *
         * Once the end of the enumerator is reached, or if an error occurs, the
         * `callback` will be called with an empty list. In this case, the previous call
         * to g_file_enumerator_next_files_async() will typically have returned fewer
         * than `num_files` items.
         *
         * If a request is cancelled the callback will be called with
         * %G_IO_ERROR_CANCELLED.
         *
         * This leads to the following pseudo-code usage:
         *
         * ```
         * g_autoptr(GFile) dir = get_directory ();
         * g_autoptr(GFileEnumerator) enumerator = NULL;
         * g_autolist(GFileInfo) files = NULL;
         * g_autoptr(GError) local_error = NULL;
         *
         * enumerator = yield g_file_enumerate_children_async (dir,
         *                                                     G_FILE_ATTRIBUTE_STANDARD_NAME ","
         *                                                     G_FILE_ATTRIBUTE_STANDARD_TYPE,
         *                                                     G_FILE_QUERY_INFO_NONE,
         *                                                     G_PRIORITY_DEFAULT,
         *                                                     cancellable,
         *                                                     ,
         *                                                     &local_error);
         * if (enumerator == NULL)
         *   g_error ("Error enumerating: %s", local_error->message);
         *
         * // Loop until no files are returned, either because the end of the enumerator
         * // has been reached, or an error was returned.
         * do
         *   {
         *     files = yield g_file_enumerator_next_files_async (enumerator,
         *                                                       5,  // number of files to request
         *                                                       G_PRIORITY_DEFAULT,
         *                                                       cancellable,
         *                                                       ,
         *                                                       &local_error);
         *
         *     // Process the returned files, but dont assume that exactly 5 were returned.
         *     for (GList *l = files; l != NULL; l = l->next)
         *       {
         *         GFileInfo *info = l->data;
         *         handle_file_info (info);
         *       }
         *   }
         * while (files != NULL);
         *
         * if (local_error != NULL &&
         *     !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
         *   g_error ("Error while enumerating: %s", local_error->message);
         * ```
         *
         *
         * During an async request no other sync and async calls are allowed, and will
         * result in %G_IO_ERROR_PENDING errors.
         *
         * Any outstanding I/O request with higher priority (lower numerical value) will
         * be executed before an outstanding request with lower priority. Default
         * priority is %G_PRIORITY_DEFAULT.
         * @virtual
         * @param num_files the number of file info objects to request
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_next_files_async(
            num_files: number,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes the asynchronous operation started with g_file_enumerator_next_files_async().
         * @virtual
         * @param result a #GAsyncResult.
         * @returns a #GList of #GFileInfos. You must free the list with     g_list_free() and unref the infos with g_object_unref() when you're     done with them.
         */
        vfunc_next_files_finish(result: AsyncResult): FileInfo[];

        // Class property signals of Gio-2.0.Gio.FileEnumerator

        connect(
            sigName: 'notify::container',
            callback: ($obj: FileEnumerator, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::container',
            callback: ($obj: FileEnumerator, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::container', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GFileEnumerator allows you to operate on a set of #GFiles,
     * returning a #GFileInfo structure for each file enumerated (e.g.
     * g_file_enumerate_children() will return a #GFileEnumerator for each
     * of the children within a directory).
     *
     * To get the next file's information from a #GFileEnumerator, use
     * g_file_enumerator_next_file() or its asynchronous version,
     * g_file_enumerator_next_files_async(). Note that the asynchronous
     * version will return a list of #GFileInfos, whereas the
     * synchronous will only return the next file in the enumerator.
     *
     * The ordering of returned files is unspecified for non-Unix
     * platforms; for more information, see g_dir_read_name().  On Unix,
     * when operating on local files, returned files will be sorted by
     * inode number.  Effectively you can assume that the ordering of
     * returned files will be stable between successive calls (and
     * applications) assuming the directory is unchanged.
     *
     * If your application needs a specific ordering, such as by name or
     * modification time, you will have to implement that in your
     * application code.
     *
     * To close a #GFileEnumerator, use g_file_enumerator_close(), or
     * its asynchronous version, g_file_enumerator_close_async(). Once
     * a #GFileEnumerator is closed, no further actions may be performed
     * on it, and it should be freed with g_object_unref().
     * @class
     */
    class FileEnumerator extends GObject.Object {
        // Own properties of Gio-2.0.Gio.FileEnumerator

        static name: string;
        static $gtype: GObject.GType<FileEnumerator>;

        // Constructors of Gio-2.0.Gio.FileEnumerator

        constructor(config?: FileEnumerator.ConstructorProperties);
        _init(config?: FileEnumerator.ConstructorProperties): void;
    }

    namespace FileIOStream {
        // Constructor properties interface

        interface ConstructorProperties
            extends Seekable.ConstructorProperties,
                IOStream.ConstructorProperties {}
    }

    interface FileIOStream extends Seekable {
        // Own fields of Gio-2.0.Gio.FileIOStream

        parent_instance: IOStream & GObject.Object;

        // Owm methods of Gio-2.0.Gio.FileIOStream

        /**
         * Gets the entity tag for the file when it has been written.
         * This must be called after the stream has been written
         * and closed, as the etag can change while writing.
         * @returns the entity tag for the stream.
         */
        get_etag(): string | null;
        /**
         * Queries a file io stream for the given `attributes`.
         * This function blocks while querying the stream. For the asynchronous
         * version of this function, see g_file_io_stream_query_info_async().
         * While the stream is blocked, the stream will set the pending flag
         * internally, and any other operations on the stream will fail with
         * %G_IO_ERROR_PENDING.
         *
         * Can fail if the stream was already closed (with `error` being set to
         * %G_IO_ERROR_CLOSED), the stream has pending operations (with `error` being
         * set to %G_IO_ERROR_PENDING), or if querying info is not supported for
         * the stream's interface (with `error` being set to %G_IO_ERROR_NOT_SUPPORTED). I
         * all cases of failure, %NULL will be returned.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
         * be returned.
         * @param attributes a file attribute query string.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a #GFileInfo for the @stream, or %NULL on error.
         */
        query_info(
            attributes: string | null,
            cancellable: Cancellable | null
        ): FileInfo;
        /**
         * Asynchronously queries the `stream` for a #GFileInfo. When completed,
         * `callback` will be called with a #GAsyncResult which can be used to
         * finish the operation with g_file_io_stream_query_info_finish().
         *
         * For the synchronous version of this function, see
         * g_file_io_stream_query_info().
         * @param attributes a file attribute query string.
         * @param io_priority the [I/O priority][gio-GIOScheduler] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        query_info_async(
            attributes: string | null,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of query_info_async

        /**
         * Promisified version of {@link query_info_async}
         *
         * Asynchronously queries the `stream` for a #GFileInfo. When completed,
         * `callback` will be called with a #GAsyncResult which can be used to
         * finish the operation with g_file_io_stream_query_info_finish().
         *
         * For the synchronous version of this function, see
         * g_file_io_stream_query_info().
         * @param attributes a file attribute query string.
         * @param io_priority the [I/O priority][gio-GIOScheduler] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns A Promise of: A #GFileInfo for the finished query.
         */
        query_info_async(
            attributes: string | null,
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<FileInfo>;
        /**
         * Finalizes the asynchronous query started
         * by g_file_io_stream_query_info_async().
         * @param result a #GAsyncResult.
         * @returns A #GFileInfo for the finished query.
         */
        query_info_finish(result: AsyncResult): FileInfo;

        // Own virtual methods of Gio-2.0.Gio.FileIOStream

        vfunc_can_seek(): boolean;
        vfunc_can_truncate(): boolean;
        /**
         * Gets the entity tag for the file when it has been written.
         * This must be called after the stream has been written
         * and closed, as the etag can change while writing.
         * @virtual
         * @returns the entity tag for the stream.
         */
        vfunc_get_etag(): string | null;
        /**
         * Queries a file io stream for the given `attributes`.
         * This function blocks while querying the stream. For the asynchronous
         * version of this function, see g_file_io_stream_query_info_async().
         * While the stream is blocked, the stream will set the pending flag
         * internally, and any other operations on the stream will fail with
         * %G_IO_ERROR_PENDING.
         *
         * Can fail if the stream was already closed (with `error` being set to
         * %G_IO_ERROR_CLOSED), the stream has pending operations (with `error` being
         * set to %G_IO_ERROR_PENDING), or if querying info is not supported for
         * the stream's interface (with `error` being set to %G_IO_ERROR_NOT_SUPPORTED). I
         * all cases of failure, %NULL will be returned.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
         * be returned.
         * @virtual
         * @param attributes a file attribute query string.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a #GFileInfo for the @stream, or %NULL on error.
         */
        vfunc_query_info(
            attributes: string | null,
            cancellable: Cancellable | null
        ): FileInfo;
        /**
         * Asynchronously queries the `stream` for a #GFileInfo. When completed,
         * `callback` will be called with a #GAsyncResult which can be used to
         * finish the operation with g_file_io_stream_query_info_finish().
         *
         * For the synchronous version of this function, see
         * g_file_io_stream_query_info().
         * @virtual
         * @param attributes a file attribute query string.
         * @param io_priority the [I/O priority][gio-GIOScheduler] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_query_info_async(
            attributes: string | null,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finalizes the asynchronous query started
         * by g_file_io_stream_query_info_async().
         * @virtual
         * @param result a #GAsyncResult.
         * @returns A #GFileInfo for the finished query.
         */
        vfunc_query_info_finish(result: AsyncResult): FileInfo;
        vfunc_seek(
            offset: number,
            type: GLib.SeekType,
            cancellable: Cancellable | null
        ): boolean;
        vfunc_tell(): number;
        vfunc_truncate_fn(
            size: number,
            cancellable: Cancellable | null
        ): boolean;

        // Class property signals of Gio-2.0.Gio.FileIOStream

        connect(
            sigName: 'notify::closed',
            callback: ($obj: FileIOStream, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::closed',
            callback: ($obj: FileIOStream, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::closed', ...args: any[]): void;
        connect(
            sigName: 'notify::input-stream',
            callback: ($obj: FileIOStream, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::input-stream',
            callback: ($obj: FileIOStream, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::input-stream', ...args: any[]): void;
        connect(
            sigName: 'notify::output-stream',
            callback: ($obj: FileIOStream, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::output-stream',
            callback: ($obj: FileIOStream, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::output-stream', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * GFileIOStream provides io streams that both read and write to the same
     * file handle.
     *
     * GFileIOStream implements #GSeekable, which allows the io
     * stream to jump to arbitrary positions in the file and to truncate
     * the file, provided the filesystem of the file supports these
     * operations.
     *
     * To find the position of a file io stream, use
     * g_seekable_tell().
     *
     * To find out if a file io stream supports seeking, use g_seekable_can_seek().
     * To position a file io stream, use g_seekable_seek().
     * To find out if a file io stream supports truncating, use
     * g_seekable_can_truncate(). To truncate a file io
     * stream, use g_seekable_truncate().
     *
     * The default implementation of all the #GFileIOStream operations
     * and the implementation of #GSeekable just call into the same operations
     * on the output stream.
     * @class
     */
    class FileIOStream extends IOStream {
        // Own properties of Gio-2.0.Gio.FileIOStream

        static name: string;
        static $gtype: GObject.GType<FileIOStream>;

        // Constructors of Gio-2.0.Gio.FileIOStream

        constructor(config?: FileIOStream.ConstructorProperties);
        _init(config?: FileIOStream.ConstructorProperties): void;
    }

    namespace FileIcon {
        // Constructor properties interface

        interface ConstructorProperties
            extends Icon.ConstructorProperties,
                LoadableIcon.ConstructorProperties,
                GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.FileIcon

            /**
             * The file containing the icon.
             */
            file?: File | null;
        }
    }

    interface FileIcon extends Icon, LoadableIcon {
        // Own properties of Gio-2.0.Gio.FileIcon

        /**
         * The file containing the icon.
         */
        readonly file: File;

        // Owm methods of Gio-2.0.Gio.FileIcon

        /**
         * Gets the #GFile associated with the given `icon`.
         * @returns a #GFile.
         */
        get_file(): File;

        // Class property signals of Gio-2.0.Gio.FileIcon

        connect(
            sigName: 'notify::file',
            callback: ($obj: FileIcon, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::file',
            callback: ($obj: FileIcon, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::file', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GFileIcon specifies an icon by pointing to an image file
     * to be used as icon.
     * @class
     */
    class FileIcon extends GObject.Object {
        // Own properties of Gio-2.0.Gio.FileIcon

        static name: string;
        static $gtype: GObject.GType<FileIcon>;

        // Constructors of Gio-2.0.Gio.FileIcon

        constructor(config?: FileIcon.ConstructorProperties);
        /**
         * Creates a new icon for a file.
         * @constructor
         * @param file a #GFile.
         * @returns a #GIcon for the given   @file, or %NULL on error.
         */
        constructor(file: File);
        /**
         * Creates a new icon for a file.
         * @constructor
         * @param file a #GFile.
         * @returns a #GIcon for the given   @file, or %NULL on error.
         */
        static new(file: File): FileIcon;
        _init(config?: FileIcon.ConstructorProperties): void;
    }

    namespace FileInfo {
        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface FileInfo {
        // Owm methods of Gio-2.0.Gio.FileInfo

        /**
         * Clears the status information from `info`.
         */
        clear_status(): void;
        /**
         * First clears all of the [GFileAttribute][gio-GFileAttribute] of `dest_info,`
         * and then copies all of the file attributes from `src_info` to `dest_info`.
         * @param dest_info destination to copy attributes to.
         */
        copy_into(dest_info: FileInfo): void;
        /**
         * Duplicates a file info structure.
         * @returns a duplicate #GFileInfo of @other.
         */
        dup(): FileInfo;
        /**
         * Gets the access time of the current `info` and returns it as a
         * #GDateTime.
         *
         * It is an error to call this if the #GFileInfo does not contain
         * %G_FILE_ATTRIBUTE_TIME_ACCESS. If %G_FILE_ATTRIBUTE_TIME_ACCESS_USEC is
         * provided, the resulting #GDateTime will additionally have microsecond
         * precision.
         *
         * If nanosecond precision is needed, %G_FILE_ATTRIBUTE_TIME_ACCESS_NSEC must
         * be queried separately using g_file_info_get_attribute_uint32().
         * @returns access time, or %NULL if unknown
         */
        get_access_date_time(): GLib.DateTime | null;
        /**
         * Gets the value of an attribute, formatted as a string.
         * This escapes things as needed to make the string valid
         * UTF-8.
         * @param attribute a file attribute key.
         * @returns a UTF-8 string associated with the given @attribute, or    %NULL if the attribute wasnt set.    When you're done with the string it must be freed with g_free().
         */
        get_attribute_as_string(attribute: string | null): string | null;
        /**
         * Gets the value of a boolean attribute. If the attribute does not
         * contain a boolean value, %FALSE will be returned.
         * @param attribute a file attribute key.
         * @returns the boolean value contained within the attribute.
         */
        get_attribute_boolean(attribute: string | null): boolean;
        /**
         * Gets the value of a byte string attribute. If the attribute does
         * not contain a byte string, %NULL will be returned.
         * @param attribute a file attribute key.
         * @returns the contents of the @attribute value as a byte string, or %NULL otherwise.
         */
        get_attribute_byte_string(attribute: string | null): string | null;
        /**
         * Gets the attribute type, value and status for an attribute key.
         * @param attribute a file attribute key
         * @returns %TRUE if @info has an attribute named @attribute,      %FALSE otherwise.
         */
        get_attribute_data(
            attribute: string | null
        ): [
            /* returnType */ boolean,
            /* type */ FileAttributeType,
            /* value_pp */ any,
            /* status */ FileAttributeStatus
        ];
        /**
         * Gets the value of a byte string attribute as a file path.
         *
         * If the attribute does not contain a byte string, `NULL` will be returned.
         *
         * This function is meant to be used by language bindings that have specific
         * handling for Unix paths.
         * @param attribute a file attribute key.
         * @returns the contents of the @attribute value as a file path, or %NULL otherwise.
         */
        get_attribute_file_path(attribute: string | null): string | null;
        /**
         * Gets a signed 32-bit integer contained within the attribute. If the
         * attribute does not contain a signed 32-bit integer, or is invalid,
         * 0 will be returned.
         * @param attribute a file attribute key.
         * @returns a signed 32-bit integer from the attribute.
         */
        get_attribute_int32(attribute: string | null): number;
        /**
         * Gets a signed 64-bit integer contained within the attribute. If the
         * attribute does not contain a signed 64-bit integer, or is invalid,
         * 0 will be returned.
         * @param attribute a file attribute key.
         * @returns a signed 64-bit integer from the attribute.
         */
        get_attribute_int64(attribute: string | null): number;
        /**
         * Gets the value of a #GObject attribute. If the attribute does
         * not contain a #GObject, %NULL will be returned.
         * @param attribute a file attribute key.
         * @returns a #GObject associated with the given @attribute, or %NULL otherwise.
         */
        get_attribute_object(attribute: string | null): GObject.Object | null;
        /**
         * Gets the attribute status for an attribute key.
         * @param attribute a file attribute key
         * @returns a #GFileAttributeStatus for the given @attribute, or    %G_FILE_ATTRIBUTE_STATUS_UNSET if the key is invalid.
         */
        get_attribute_status(attribute: string | null): FileAttributeStatus;
        /**
         * Gets the value of a string attribute. If the attribute does
         * not contain a string, %NULL will be returned.
         * @param attribute a file attribute key.
         * @returns the contents of the @attribute value as a UTF-8 string, or %NULL otherwise.
         */
        get_attribute_string(attribute: string | null): string | null;
        /**
         * Gets the value of a stringv attribute. If the attribute does
         * not contain a stringv, %NULL will be returned.
         * @param attribute a file attribute key.
         * @returns the contents of the @attribute value as a stringv, or %NULL otherwise. Do not free. These returned strings are UTF-8.
         */
        get_attribute_stringv(attribute: string | null): string[] | null;
        /**
         * Gets the attribute type for an attribute key.
         * @param attribute a file attribute key.
         * @returns a #GFileAttributeType for the given @attribute, or %G_FILE_ATTRIBUTE_TYPE_INVALID if the key is not set.
         */
        get_attribute_type(attribute: string | null): FileAttributeType;
        /**
         * Gets an unsigned 32-bit integer contained within the attribute. If the
         * attribute does not contain an unsigned 32-bit integer, or is invalid,
         * 0 will be returned.
         * @param attribute a file attribute key.
         * @returns an unsigned 32-bit integer from the attribute.
         */
        get_attribute_uint32(attribute: string | null): number;
        /**
         * Gets a unsigned 64-bit integer contained within the attribute. If the
         * attribute does not contain an unsigned 64-bit integer, or is invalid,
         * 0 will be returned.
         * @param attribute a file attribute key.
         * @returns a unsigned 64-bit integer from the attribute.
         */
        get_attribute_uint64(attribute: string | null): number;
        /**
         * Gets the file's content type.
         *
         * It is an error to call this if the #GFileInfo does not contain
         * %G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE.
         * @returns a string containing the file's content type, or %NULL if unknown.
         */
        get_content_type(): string | null;
        /**
         * Gets the creation time of the current `info` and returns it as a
         * #GDateTime.
         *
         * It is an error to call this if the #GFileInfo does not contain
         * %G_FILE_ATTRIBUTE_TIME_CREATED. If %G_FILE_ATTRIBUTE_TIME_CREATED_USEC is
         * provided, the resulting #GDateTime will additionally have microsecond
         * precision.
         *
         * If nanosecond precision is needed, %G_FILE_ATTRIBUTE_TIME_CREATED_NSEC must
         * be queried separately using g_file_info_get_attribute_uint32().
         * @returns creation time, or %NULL if unknown
         */
        get_creation_date_time(): GLib.DateTime | null;
        /**
         * Returns the #GDateTime representing the deletion date of the file, as
         * available in %G_FILE_ATTRIBUTE_TRASH_DELETION_DATE. If the
         * %G_FILE_ATTRIBUTE_TRASH_DELETION_DATE attribute is unset, %NULL is returned.
         * @returns a #GDateTime, or %NULL.
         */
        get_deletion_date(): GLib.DateTime | null;
        /**
         * Gets a display name for a file. This is guaranteed to always be set.
         *
         * It is an error to call this if the #GFileInfo does not contain
         * %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME.
         * @returns a string containing the display name.
         */
        get_display_name(): string | null;
        /**
         * Gets the edit name for a file.
         *
         * It is an error to call this if the #GFileInfo does not contain
         * %G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME.
         * @returns a string containing the edit name.
         */
        get_edit_name(): string | null;
        /**
         * Gets the [entity tag][gfile-etag] for a given
         * #GFileInfo. See %G_FILE_ATTRIBUTE_ETAG_VALUE.
         *
         * It is an error to call this if the #GFileInfo does not contain
         * %G_FILE_ATTRIBUTE_ETAG_VALUE.
         * @returns a string containing the value of the "etag:value" attribute.
         */
        get_etag(): string | null;
        /**
         * Gets a file's type (whether it is a regular file, symlink, etc).
         * This is different from the file's content type, see g_file_info_get_content_type().
         *
         * It is an error to call this if the #GFileInfo does not contain
         * %G_FILE_ATTRIBUTE_STANDARD_TYPE.
         * @returns a #GFileType for the given file.
         */
        get_file_type(): FileType;
        /**
         * Gets the icon for a file.
         *
         * It is an error to call this if the #GFileInfo does not contain
         * %G_FILE_ATTRIBUTE_STANDARD_ICON.
         * @returns #GIcon for the given @info.
         */
        get_icon(): Icon | null;
        /**
         * Checks if a file is a backup file.
         *
         * It is an error to call this if the #GFileInfo does not contain
         * %G_FILE_ATTRIBUTE_STANDARD_IS_BACKUP.
         * @returns %TRUE if file is a backup file, %FALSE otherwise.
         */
        get_is_backup(): boolean;
        /**
         * Checks if a file is hidden.
         *
         * It is an error to call this if the #GFileInfo does not contain
         * %G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN.
         * @returns %TRUE if the file is a hidden file, %FALSE otherwise.
         */
        get_is_hidden(): boolean;
        /**
         * Checks if a file is a symlink.
         *
         * It is an error to call this if the #GFileInfo does not contain
         * %G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK.
         * @returns %TRUE if the given @info is a symlink.
         */
        get_is_symlink(): boolean;
        /**
         * Gets the modification time of the current `info` and returns it as a
         * #GDateTime.
         *
         * It is an error to call this if the #GFileInfo does not contain
         * %G_FILE_ATTRIBUTE_TIME_MODIFIED. If %G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC is
         * provided, the resulting #GDateTime will additionally have microsecond
         * precision.
         *
         * If nanosecond precision is needed, %G_FILE_ATTRIBUTE_TIME_MODIFIED_NSEC must
         * be queried separately using g_file_info_get_attribute_uint32().
         * @returns modification time, or %NULL if unknown
         */
        get_modification_date_time(): GLib.DateTime | null;
        /**
         * Gets the modification time of the current `info` and sets it
         * in `result`.
         *
         * It is an error to call this if the #GFileInfo does not contain
         * %G_FILE_ATTRIBUTE_TIME_MODIFIED. If %G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC is
         * provided it will be used too.
         */
        get_modification_time(): /* result */ GLib.TimeVal;
        /**
         * Gets the name for a file. This is guaranteed to always be set.
         *
         * It is an error to call this if the #GFileInfo does not contain
         * %G_FILE_ATTRIBUTE_STANDARD_NAME.
         * @returns a string containing the file name.
         */
        get_name(): string;
        /**
         * Gets the file's size (in bytes). The size is retrieved through the value of
         * the %G_FILE_ATTRIBUTE_STANDARD_SIZE attribute and is converted
         * from #guint64 to #goffset before returning the result.
         *
         * It is an error to call this if the #GFileInfo does not contain
         * %G_FILE_ATTRIBUTE_STANDARD_SIZE.
         * @returns a #goffset containing the file's size (in bytes).
         */
        get_size(): number;
        /**
         * Gets the value of the sort_order attribute from the #GFileInfo.
         * See %G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
         *
         * It is an error to call this if the #GFileInfo does not contain
         * %G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
         * @returns a #gint32 containing the value of the "standard::sort_order" attribute.
         */
        get_sort_order(): number;
        /**
         * Gets the symbolic icon for a file.
         *
         * It is an error to call this if the #GFileInfo does not contain
         * %G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON.
         * @returns #GIcon for the given @info.
         */
        get_symbolic_icon(): Icon | null;
        /**
         * Gets the symlink target for a given #GFileInfo.
         *
         * It is an error to call this if the #GFileInfo does not contain
         * %G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET.
         * @returns a string containing the symlink target.
         */
        get_symlink_target(): string | null;
        /**
         * Checks if a file info structure has an attribute named `attribute`.
         * @param attribute a file attribute key.
         * @returns %TRUE if @info has an attribute named @attribute,     %FALSE otherwise.
         */
        has_attribute(attribute: string | null): boolean;
        /**
         * Checks if a file info structure has an attribute in the
         * specified `name_space`.
         * @param name_space a file attribute namespace.
         * @returns %TRUE if @info has an attribute in @name_space,     %FALSE otherwise.
         */
        has_namespace(name_space: string | null): boolean;
        /**
         * Lists the file info structure's attributes.
         * @param name_space a file attribute key's namespace, or %NULL to list   all attributes.
         * @returns a null-terminated array of strings of all of the possible attribute types for the given @name_space, or %NULL on error.
         */
        list_attributes(name_space: string | null): string[] | null;
        /**
         * Removes all cases of `attribute` from `info` if it exists.
         * @param attribute a file attribute key.
         */
        remove_attribute(attribute: string | null): void;
        /**
         * Sets the %G_FILE_ATTRIBUTE_TIME_ACCESS and
         * %G_FILE_ATTRIBUTE_TIME_ACCESS_USEC attributes in the file info to the
         * given date/time value.
         *
         * %G_FILE_ATTRIBUTE_TIME_ACCESS_NSEC will be cleared.
         * @param atime a #GDateTime.
         */
        set_access_date_time(atime: GLib.DateTime): void;
        /**
         * Sets the `attribute` to contain the given value, if possible. To unset the
         * attribute, use %G_FILE_ATTRIBUTE_TYPE_INVALID for `type`.
         * @param attribute a file attribute key.
         * @param type a #GFileAttributeType
         * @param value_p pointer to the value
         */
        set_attribute(
            attribute: string | null,
            type: FileAttributeType,
            value_p: any
        ): void;
        /**
         * Sets the `attribute` to contain the given `attr_value,`
         * if possible.
         * @param attribute a file attribute key.
         * @param attr_value a boolean value.
         */
        set_attribute_boolean(
            attribute: string | null,
            attr_value: boolean
        ): void;
        /**
         * Sets the `attribute` to contain the given `attr_value,`
         * if possible.
         * @param attribute a file attribute key.
         * @param attr_value a byte string.
         */
        set_attribute_byte_string(
            attribute: string | null,
            attr_value: string | null
        ): void;
        /**
         * Sets the `attribute` to contain the given `attr_value,`
         * if possible.
         *
         * This function is meant to be used by language bindings that have specific
         * handling for Unix paths.
         * @param attribute a file attribute key.
         * @param attr_value a file path.
         */
        set_attribute_file_path(
            attribute: string | null,
            attr_value: string
        ): void;
        /**
         * Sets the `attribute` to contain the given `attr_value,`
         * if possible.
         * @param attribute a file attribute key.
         * @param attr_value a signed 32-bit integer
         */
        set_attribute_int32(attribute: string | null, attr_value: number): void;
        /**
         * Sets the `attribute` to contain the given `attr_value,`
         * if possible.
         * @param attribute attribute name to set.
         * @param attr_value int64 value to set attribute to.
         */
        set_attribute_int64(attribute: string | null, attr_value: number): void;
        /**
         * Sets `mask` on `info` to match specific attribute types.
         * @param mask a #GFileAttributeMatcher.
         */
        set_attribute_mask(mask: FileAttributeMatcher): void;
        /**
         * Sets the `attribute` to contain the given `attr_value,`
         * if possible.
         * @param attribute a file attribute key.
         * @param attr_value a #GObject.
         */
        set_attribute_object(
            attribute: string | null,
            attr_value: GObject.Object
        ): void;
        /**
         * Sets the attribute status for an attribute key. This is only
         * needed by external code that implement g_file_set_attributes_from_info()
         * or similar functions.
         *
         * The attribute must exist in `info` for this to work. Otherwise %FALSE
         * is returned and `info` is unchanged.
         * @param attribute a file attribute key
         * @param status a #GFileAttributeStatus
         * @returns %TRUE if the status was changed, %FALSE if the key was not set.
         */
        set_attribute_status(
            attribute: string | null,
            status: FileAttributeStatus
        ): boolean;
        /**
         * Sets the `attribute` to contain the given `attr_value,`
         * if possible.
         * @param attribute a file attribute key.
         * @param attr_value a UTF-8 string.
         */
        set_attribute_string(
            attribute: string | null,
            attr_value: string | null
        ): void;
        /**
         * Sets the `attribute` to contain the given `attr_value,`
         * if possible.
         *
         * Sinze: 2.22
         * @param attribute a file attribute key
         * @param attr_value a %NULL   terminated array of UTF-8 strings.
         */
        set_attribute_stringv(
            attribute: string | null,
            attr_value: string[]
        ): void;
        /**
         * Sets the `attribute` to contain the given `attr_value,`
         * if possible.
         * @param attribute a file attribute key.
         * @param attr_value an unsigned 32-bit integer.
         */
        set_attribute_uint32(
            attribute: string | null,
            attr_value: number
        ): void;
        /**
         * Sets the `attribute` to contain the given `attr_value,`
         * if possible.
         * @param attribute a file attribute key.
         * @param attr_value an unsigned 64-bit integer.
         */
        set_attribute_uint64(
            attribute: string | null,
            attr_value: number
        ): void;
        /**
         * Sets the content type attribute for a given #GFileInfo.
         * See %G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE.
         * @param content_type a content type. See [GContentType][gio-GContentType]
         */
        set_content_type(content_type: string | null): void;
        /**
         * Sets the %G_FILE_ATTRIBUTE_TIME_CREATED and
         * %G_FILE_ATTRIBUTE_TIME_CREATED_USEC attributes in the file info to the
         * given date/time value.
         *
         * %G_FILE_ATTRIBUTE_TIME_CREATED_NSEC will be cleared.
         * @param creation_time a #GDateTime.
         */
        set_creation_date_time(creation_time: GLib.DateTime): void;
        /**
         * Sets the display name for the current #GFileInfo.
         * See %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME.
         * @param display_name a string containing a display name.
         */
        set_display_name(display_name: string | null): void;
        /**
         * Sets the edit name for the current file.
         * See %G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME.
         * @param edit_name a string containing an edit name.
         */
        set_edit_name(edit_name: string | null): void;
        /**
         * Sets the file type in a #GFileInfo to `type`.
         * See %G_FILE_ATTRIBUTE_STANDARD_TYPE.
         * @param type a #GFileType.
         */
        set_file_type(type: FileType): void;
        /**
         * Sets the icon for a given #GFileInfo.
         * See %G_FILE_ATTRIBUTE_STANDARD_ICON.
         * @param icon a #GIcon.
         */
        set_icon(icon: Icon): void;
        /**
         * Sets the "is_hidden" attribute in a #GFileInfo according to `is_hidden`.
         * See %G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN.
         * @param is_hidden a #gboolean.
         */
        set_is_hidden(is_hidden: boolean): void;
        /**
         * Sets the "is_symlink" attribute in a #GFileInfo according to `is_symlink`.
         * See %G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK.
         * @param is_symlink a #gboolean.
         */
        set_is_symlink(is_symlink: boolean): void;
        /**
         * Sets the %G_FILE_ATTRIBUTE_TIME_MODIFIED and
         * %G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC attributes in the file info to the
         * given date/time value.
         *
         * %G_FILE_ATTRIBUTE_TIME_MODIFIED_NSEC will be cleared.
         * @param mtime a #GDateTime.
         */
        set_modification_date_time(mtime: GLib.DateTime): void;
        /**
         * Sets the %G_FILE_ATTRIBUTE_TIME_MODIFIED and
         * %G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC attributes in the file info to the
         * given time value.
         *
         * %G_FILE_ATTRIBUTE_TIME_MODIFIED_NSEC will be cleared.
         * @param mtime a #GTimeVal.
         */
        set_modification_time(mtime: GLib.TimeVal): void;
        /**
         * Sets the name attribute for the current #GFileInfo.
         * See %G_FILE_ATTRIBUTE_STANDARD_NAME.
         * @param name a string containing a name.
         */
        set_name(name: string): void;
        /**
         * Sets the %G_FILE_ATTRIBUTE_STANDARD_SIZE attribute in the file info
         * to the given size.
         * @param size a #goffset containing the file's size.
         */
        set_size(size: number): void;
        /**
         * Sets the sort order attribute in the file info structure. See
         * %G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
         * @param sort_order a sort order integer.
         */
        set_sort_order(sort_order: number): void;
        /**
         * Sets the symbolic icon for a given #GFileInfo.
         * See %G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON.
         * @param icon a #GIcon.
         */
        set_symbolic_icon(icon: Icon): void;
        /**
         * Sets the %G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET attribute in the file info
         * to the given symlink target.
         * @param symlink_target a static string containing a path to a symlink target.
         */
        set_symlink_target(symlink_target: string): void;
        /**
         * Unsets a mask set by g_file_info_set_attribute_mask(), if one
         * is set.
         */
        unset_attribute_mask(): void;

        // Class property signals of Gio-2.0.Gio.FileInfo

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * Functionality for manipulating basic metadata for files. #GFileInfo
     * implements methods for getting information that all files should
     * contain, and allows for manipulation of extended attributes.
     *
     * See [GFileAttribute][gio-GFileAttribute] for more information on how
     * GIO handles file attributes.
     *
     * To obtain a #GFileInfo for a #GFile, use g_file_query_info() (or its
     * async variant). To obtain a #GFileInfo for a file input or output
     * stream, use g_file_input_stream_query_info() or
     * g_file_output_stream_query_info() (or their async variants).
     *
     * To change the actual attributes of a file, you should then set the
     * attribute in the #GFileInfo and call g_file_set_attributes_from_info()
     * or g_file_set_attributes_async() on a GFile.
     *
     * However, not all attributes can be changed in the file. For instance,
     * the actual size of a file cannot be changed via g_file_info_set_size().
     * You may call g_file_query_settable_attributes() and
     * g_file_query_writable_namespaces() to discover the settable attributes
     * of a particular file at runtime.
     *
     * The direct accessors, such as g_file_info_get_name(), are slightly more
     * optimized than the generic attribute accessors, such as
     * g_file_info_get_attribute_byte_string().This optimization will matter
     * only if calling the API in a tight loop.
     *
     * It is an error to call these accessors without specifying their required file
     * attributes when creating the #GFileInfo. Use g_file_info_has_attribute() or
     * g_file_info_list_attributes() to check what attributes are specified for a
     * #GFileInfo.
     *
     * #GFileAttributeMatcher allows for searching through a #GFileInfo for
     * attributes.
     * @class
     */
    class FileInfo extends GObject.Object {
        // Own properties of Gio-2.0.Gio.FileInfo

        static name: string;
        static $gtype: GObject.GType<FileInfo>;

        // Constructors of Gio-2.0.Gio.FileInfo

        constructor(config?: FileInfo.ConstructorProperties);
        /**
         * Creates a new file info structure.
         * @constructor
         * @returns a #GFileInfo.
         */
        constructor();
        /**
         * Creates a new file info structure.
         * @constructor
         * @returns a #GFileInfo.
         */
        static new(): FileInfo;
        _init(config?: FileInfo.ConstructorProperties): void;
    }

    namespace FileInputStream {
        // Constructor properties interface

        interface ConstructorProperties
            extends Seekable.ConstructorProperties,
                InputStream.ConstructorProperties {}
    }

    interface FileInputStream extends Seekable {
        // Own fields of Gio-2.0.Gio.FileInputStream

        parent_instance: InputStream & GObject.Object;

        // Owm methods of Gio-2.0.Gio.FileInputStream

        /**
         * Queries a file input stream the given `attributes`. This function blocks
         * while querying the stream. For the asynchronous (non-blocking) version
         * of this function, see g_file_input_stream_query_info_async(). While the
         * stream is blocked, the stream will set the pending flag internally, and
         * any other operations on the stream will fail with %G_IO_ERROR_PENDING.
         * @param attributes a file attribute query string.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a #GFileInfo, or %NULL on error.
         */
        query_info(
            attributes: string | null,
            cancellable: Cancellable | null
        ): FileInfo;
        /**
         * Queries the stream information asynchronously.
         * When the operation is finished `callback` will be called.
         * You can then call g_file_input_stream_query_info_finish()
         * to get the result of the operation.
         *
         * For the synchronous version of this function,
         * see g_file_input_stream_query_info().
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be set
         * @param attributes a file attribute query string.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        query_info_async(
            attributes: string | null,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of query_info_async

        /**
         * Promisified version of {@link query_info_async}
         *
         * Queries the stream information asynchronously.
         * When the operation is finished `callback` will be called.
         * You can then call g_file_input_stream_query_info_finish()
         * to get the result of the operation.
         *
         * For the synchronous version of this function,
         * see g_file_input_stream_query_info().
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be set
         * @param attributes a file attribute query string.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns A Promise of: #GFileInfo.
         */
        query_info_async(
            attributes: string | null,
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<FileInfo>;
        /**
         * Finishes an asynchronous info query operation.
         * @param result a #GAsyncResult.
         * @returns #GFileInfo.
         */
        query_info_finish(result: AsyncResult): FileInfo;

        // Own virtual methods of Gio-2.0.Gio.FileInputStream

        vfunc_can_seek(): boolean;
        /**
         * Queries a file input stream the given `attributes`. This function blocks
         * while querying the stream. For the asynchronous (non-blocking) version
         * of this function, see g_file_input_stream_query_info_async(). While the
         * stream is blocked, the stream will set the pending flag internally, and
         * any other operations on the stream will fail with %G_IO_ERROR_PENDING.
         * @virtual
         * @param attributes a file attribute query string.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a #GFileInfo, or %NULL on error.
         */
        vfunc_query_info(
            attributes: string | null,
            cancellable: Cancellable | null
        ): FileInfo;
        /**
         * Queries the stream information asynchronously.
         * When the operation is finished `callback` will be called.
         * You can then call g_file_input_stream_query_info_finish()
         * to get the result of the operation.
         *
         * For the synchronous version of this function,
         * see g_file_input_stream_query_info().
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be set
         * @virtual
         * @param attributes a file attribute query string.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_query_info_async(
            attributes: string | null,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes an asynchronous info query operation.
         * @virtual
         * @param result a #GAsyncResult.
         * @returns #GFileInfo.
         */
        vfunc_query_info_finish(result: AsyncResult): FileInfo;
        vfunc_seek(
            offset: number,
            type: GLib.SeekType,
            cancellable: Cancellable | null
        ): boolean;
        vfunc_tell(): number;

        // Class property signals of Gio-2.0.Gio.FileInputStream

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * GFileInputStream provides input streams that take their
     * content from a file.
     *
     * GFileInputStream implements #GSeekable, which allows the input
     * stream to jump to arbitrary positions in the file, provided the
     * filesystem of the file allows it. To find the position of a file
     * input stream, use g_seekable_tell(). To find out if a file input
     * stream supports seeking, use g_seekable_can_seek().
     * To position a file input stream, use g_seekable_seek().
     * @class
     */
    class FileInputStream extends InputStream {
        // Own properties of Gio-2.0.Gio.FileInputStream

        static name: string;
        static $gtype: GObject.GType<FileInputStream>;

        // Constructors of Gio-2.0.Gio.FileInputStream

        constructor(config?: FileInputStream.ConstructorProperties);
        _init(config?: FileInputStream.ConstructorProperties): void;
    }

    namespace FileMonitor {
        // Signal callback interfaces

        /**
         * Signal callback interface for `changed`
         */
        interface ChangedSignalCallback {
            (
                $obj: FileMonitor,
                file: File,
                other_file: File | null,
                event_type: FileMonitorEvent
            ): void;
        }

        // Constructor properties interface

        interface ConstructorProperties
            extends GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.FileMonitor

            rate_limit?: number | null;
        }
    }

    interface FileMonitor {
        // Own properties of Gio-2.0.Gio.FileMonitor

        readonly cancelled: boolean;
        rate_limit: number;

        // Own fields of Gio-2.0.Gio.FileMonitor

        parent_instance: GObject.Object;

        // Owm methods of Gio-2.0.Gio.FileMonitor

        /**
         * Cancels a file monitor.
         * @returns always %TRUE
         */
        cancel(): boolean;
        /**
         * Emits the #GFileMonitor::changed signal if a change
         * has taken place. Should be called from file monitor
         * implementations only.
         *
         * Implementations are responsible to call this method from the
         * [thread-default main context][g-main-context-push-thread-default] of the
         * thread that the monitor was created in.
         * @param child a #GFile.
         * @param other_file a #GFile.
         * @param event_type a set of #GFileMonitorEvent flags.
         */
        emit_event(
            child: File,
            other_file: File,
            event_type: FileMonitorEvent
        ): void;
        /**
         * Returns whether the monitor is canceled.
         * @returns %TRUE if monitor is canceled. %FALSE otherwise.
         */
        is_cancelled(): boolean;
        /**
         * Sets the rate limit to which the `monitor` will report
         * consecutive change events to the same file.
         * @param limit_msecs a non-negative integer with the limit in milliseconds     to poll for changes
         */
        set_rate_limit(limit_msecs: number): void;

        // Own virtual methods of Gio-2.0.Gio.FileMonitor

        /**
         * Cancels a file monitor.
         * @virtual
         * @returns always %TRUE
         */
        vfunc_cancel(): boolean;
        vfunc_changed(
            file: File,
            other_file: File,
            event_type: FileMonitorEvent
        ): void;

        // Own signals of Gio-2.0.Gio.FileMonitor

        connect(
            sigName: 'changed',
            callback: FileMonitor.ChangedSignalCallback
        ): number;
        connect_after(
            sigName: 'changed',
            callback: FileMonitor.ChangedSignalCallback
        ): number;
        emit(
            sigName: 'changed',
            file: File,
            other_file: File | null,
            event_type: FileMonitorEvent,
            ...args: any[]
        ): void;

        // Class property signals of Gio-2.0.Gio.FileMonitor

        connect(
            sigName: 'notify::cancelled',
            callback: ($obj: FileMonitor, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::cancelled',
            callback: ($obj: FileMonitor, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::cancelled', ...args: any[]): void;
        connect(
            sigName: 'notify::rate-limit',
            callback: ($obj: FileMonitor, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::rate-limit',
            callback: ($obj: FileMonitor, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::rate-limit', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * Monitors a file or directory for changes.
     *
     * To obtain a #GFileMonitor for a file or directory, use
     * g_file_monitor(), g_file_monitor_file(), or
     * g_file_monitor_directory().
     *
     * To get informed about changes to the file or directory you are
     * monitoring, connect to the #GFileMonitor::changed signal. The
     * signal will be emitted in the
     * [thread-default main context][g-main-context-push-thread-default]
     * of the thread that the monitor was created in
     * (though if the global default main context is blocked, this may
     * cause notifications to be blocked even if the thread-default
     * context is still running).
     * @class
     */
    class FileMonitor extends GObject.Object {
        // Own properties of Gio-2.0.Gio.FileMonitor

        static name: string;
        static $gtype: GObject.GType<FileMonitor>;

        // Constructors of Gio-2.0.Gio.FileMonitor

        constructor(config?: FileMonitor.ConstructorProperties);
        _init(config?: FileMonitor.ConstructorProperties): void;
    }

    namespace FileOutputStream {
        // Constructor properties interface

        interface ConstructorProperties
            extends Seekable.ConstructorProperties,
                OutputStream.ConstructorProperties {}
    }

    interface FileOutputStream extends Seekable {
        // Own fields of Gio-2.0.Gio.FileOutputStream

        parent_instance: OutputStream & GObject.Object;

        // Owm methods of Gio-2.0.Gio.FileOutputStream

        /**
         * Gets the entity tag for the file when it has been written.
         * This must be called after the stream has been written
         * and closed, as the etag can change while writing.
         * @returns the entity tag for the stream.
         */
        get_etag(): string | null;
        /**
         * Queries a file output stream for the given `attributes`.
         * This function blocks while querying the stream. For the asynchronous
         * version of this function, see g_file_output_stream_query_info_async().
         * While the stream is blocked, the stream will set the pending flag
         * internally, and any other operations on the stream will fail with
         * %G_IO_ERROR_PENDING.
         *
         * Can fail if the stream was already closed (with `error` being set to
         * %G_IO_ERROR_CLOSED), the stream has pending operations (with `error` being
         * set to %G_IO_ERROR_PENDING), or if querying info is not supported for
         * the stream's interface (with `error` being set to %G_IO_ERROR_NOT_SUPPORTED). In
         * all cases of failure, %NULL will be returned.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
         * be returned.
         * @param attributes a file attribute query string.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a #GFileInfo for the @stream, or %NULL on error.
         */
        query_info(
            attributes: string | null,
            cancellable: Cancellable | null
        ): FileInfo;
        /**
         * Asynchronously queries the `stream` for a #GFileInfo. When completed,
         * `callback` will be called with a #GAsyncResult which can be used to
         * finish the operation with g_file_output_stream_query_info_finish().
         *
         * For the synchronous version of this function, see
         * g_file_output_stream_query_info().
         * @param attributes a file attribute query string.
         * @param io_priority the [I/O priority][gio-GIOScheduler] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback callback to call when the request is satisfied
         */
        query_info_async(
            attributes: string | null,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of query_info_async

        /**
         * Promisified version of {@link query_info_async}
         *
         * Asynchronously queries the `stream` for a #GFileInfo. When completed,
         * `callback` will be called with a #GAsyncResult which can be used to
         * finish the operation with g_file_output_stream_query_info_finish().
         *
         * For the synchronous version of this function, see
         * g_file_output_stream_query_info().
         * @param attributes a file attribute query string.
         * @param io_priority the [I/O priority][gio-GIOScheduler] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns A Promise of: A #GFileInfo for the finished query.
         */
        query_info_async(
            attributes: string | null,
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<FileInfo>;
        /**
         * Finalizes the asynchronous query started
         * by g_file_output_stream_query_info_async().
         * @param result a #GAsyncResult.
         * @returns A #GFileInfo for the finished query.
         */
        query_info_finish(result: AsyncResult): FileInfo;

        // Own virtual methods of Gio-2.0.Gio.FileOutputStream

        vfunc_can_seek(): boolean;
        vfunc_can_truncate(): boolean;
        /**
         * Gets the entity tag for the file when it has been written.
         * This must be called after the stream has been written
         * and closed, as the etag can change while writing.
         * @virtual
         * @returns the entity tag for the stream.
         */
        vfunc_get_etag(): string | null;
        /**
         * Queries a file output stream for the given `attributes`.
         * This function blocks while querying the stream. For the asynchronous
         * version of this function, see g_file_output_stream_query_info_async().
         * While the stream is blocked, the stream will set the pending flag
         * internally, and any other operations on the stream will fail with
         * %G_IO_ERROR_PENDING.
         *
         * Can fail if the stream was already closed (with `error` being set to
         * %G_IO_ERROR_CLOSED), the stream has pending operations (with `error` being
         * set to %G_IO_ERROR_PENDING), or if querying info is not supported for
         * the stream's interface (with `error` being set to %G_IO_ERROR_NOT_SUPPORTED). In
         * all cases of failure, %NULL will be returned.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
         * be returned.
         * @virtual
         * @param attributes a file attribute query string.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a #GFileInfo for the @stream, or %NULL on error.
         */
        vfunc_query_info(
            attributes: string | null,
            cancellable: Cancellable | null
        ): FileInfo;
        /**
         * Asynchronously queries the `stream` for a #GFileInfo. When completed,
         * `callback` will be called with a #GAsyncResult which can be used to
         * finish the operation with g_file_output_stream_query_info_finish().
         *
         * For the synchronous version of this function, see
         * g_file_output_stream_query_info().
         * @virtual
         * @param attributes a file attribute query string.
         * @param io_priority the [I/O priority][gio-GIOScheduler] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback callback to call when the request is satisfied
         */
        vfunc_query_info_async(
            attributes: string | null,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finalizes the asynchronous query started
         * by g_file_output_stream_query_info_async().
         * @virtual
         * @param result a #GAsyncResult.
         * @returns A #GFileInfo for the finished query.
         */
        vfunc_query_info_finish(result: AsyncResult): FileInfo;
        vfunc_seek(
            offset: number,
            type: GLib.SeekType,
            cancellable: Cancellable | null
        ): boolean;
        vfunc_tell(): number;
        vfunc_truncate_fn(
            size: number,
            cancellable: Cancellable | null
        ): boolean;

        // Class property signals of Gio-2.0.Gio.FileOutputStream

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * GFileOutputStream provides output streams that write their
     * content to a file.
     *
     * GFileOutputStream implements #GSeekable, which allows the output
     * stream to jump to arbitrary positions in the file and to truncate
     * the file, provided the filesystem of the file supports these
     * operations.
     *
     * To find the position of a file output stream, use g_seekable_tell().
     * To find out if a file output stream supports seeking, use
     * g_seekable_can_seek().To position a file output stream, use
     * g_seekable_seek(). To find out if a file output stream supports
     * truncating, use g_seekable_can_truncate(). To truncate a file output
     * stream, use g_seekable_truncate().
     * @class
     */
    class FileOutputStream extends OutputStream {
        // Own properties of Gio-2.0.Gio.FileOutputStream

        static name: string;
        static $gtype: GObject.GType<FileOutputStream>;

        // Constructors of Gio-2.0.Gio.FileOutputStream

        constructor(config?: FileOutputStream.ConstructorProperties);
        _init(config?: FileOutputStream.ConstructorProperties): void;
    }

    namespace FilenameCompleter {
        // Signal callback interfaces

        /**
         * Signal callback interface for `got-completion-data`
         */
        interface GotCompletionDataSignalCallback {
            ($obj: FilenameCompleter): void;
        }

        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface FilenameCompleter {
        // Owm methods of Gio-2.0.Gio.FilenameCompleter

        /**
         * Obtains a completion for `initial_text` from `completer`.
         * @param initial_text text to be completed.
         * @returns a completed string, or %NULL if no     completion exists. This string is not owned by GIO, so remember to g_free()     it when finished.
         */
        get_completion_suffix(initial_text: string | null): string | null;
        /**
         * Gets an array of completion strings for a given initial text.
         * @param initial_text text to be completed.
         * @returns array of strings with possible completions for @initial_text. This array must be freed by g_strfreev() when finished.
         */
        get_completions(initial_text: string | null): string[];
        /**
         * If `dirs_only` is %TRUE, `completer` will only
         * complete directory names, and not file names.
         * @param dirs_only a #gboolean.
         */
        set_dirs_only(dirs_only: boolean): void;

        // Own virtual methods of Gio-2.0.Gio.FilenameCompleter

        vfunc_got_completion_data(): void;

        // Own signals of Gio-2.0.Gio.FilenameCompleter

        connect(
            sigName: 'got-completion-data',
            callback: FilenameCompleter.GotCompletionDataSignalCallback
        ): number;
        connect_after(
            sigName: 'got-completion-data',
            callback: FilenameCompleter.GotCompletionDataSignalCallback
        ): number;
        emit(sigName: 'got-completion-data', ...args: any[]): void;

        // Class property signals of Gio-2.0.Gio.FilenameCompleter

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * Completes partial file and directory names given a partial string by
     * looking in the file system for clues. Can return a list of possible
     * completion strings for widget implementations.
     * @class
     */
    class FilenameCompleter extends GObject.Object {
        // Own properties of Gio-2.0.Gio.FilenameCompleter

        static name: string;
        static $gtype: GObject.GType<FilenameCompleter>;

        // Constructors of Gio-2.0.Gio.FilenameCompleter

        constructor(config?: FilenameCompleter.ConstructorProperties);
        /**
         * Creates a new filename completer.
         * @constructor
         * @returns a #GFilenameCompleter.
         */
        constructor();
        /**
         * Creates a new filename completer.
         * @constructor
         * @returns a #GFilenameCompleter.
         */
        static new(): FilenameCompleter;
        _init(config?: FilenameCompleter.ConstructorProperties): void;
    }

    namespace FilterInputStream {
        // Constructor properties interface

        interface ConstructorProperties
            extends InputStream.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.FilterInputStream

            base_stream?: InputStream | null;
            close_base_stream?: boolean | null;
        }
    }

    interface FilterInputStream {
        // Own properties of Gio-2.0.Gio.FilterInputStream

        close_base_stream: boolean;

        // Own fields of Gio-2.0.Gio.FilterInputStream

        parent_instance: InputStream & GObject.Object;
        base_stream: InputStream;

        // Owm methods of Gio-2.0.Gio.FilterInputStream

        /**
         * Gets the base stream for the filter stream.
         * @returns a #GInputStream.
         */
        get_base_stream(): InputStream;
        /**
         * Returns whether the base stream will be closed when `stream` is
         * closed.
         * @returns %TRUE if the base stream will be closed.
         */
        get_close_base_stream(): boolean;
        /**
         * Sets whether the base stream will be closed when `stream` is closed.
         * @param close_base %TRUE to close the base stream.
         */
        set_close_base_stream(close_base: boolean): void;

        // Class property signals of Gio-2.0.Gio.FilterInputStream

        connect(
            sigName: 'notify::close-base-stream',
            callback: (
                $obj: FilterInputStream,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::close-base-stream',
            callback: (
                $obj: FilterInputStream,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::close-base-stream', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * Base class for input stream implementations that perform some
     * kind of filtering operation on a base stream. Typical examples
     * of filtering operations are character set conversion, compression
     * and byte order flipping.
     * @class
     */
    class FilterInputStream extends InputStream {
        // Own properties of Gio-2.0.Gio.FilterInputStream

        static name: string;
        static $gtype: GObject.GType<FilterInputStream>;

        // Constructors of Gio-2.0.Gio.FilterInputStream

        constructor(config?: FilterInputStream.ConstructorProperties);
        _init(config?: FilterInputStream.ConstructorProperties): void;
    }

    namespace FilterOutputStream {
        // Constructor properties interface

        interface ConstructorProperties
            extends OutputStream.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.FilterOutputStream

            base_stream?: OutputStream | null;
            close_base_stream?: boolean | null;
        }
    }

    interface FilterOutputStream {
        // Own properties of Gio-2.0.Gio.FilterOutputStream

        readonly close_base_stream: boolean;

        // Own fields of Gio-2.0.Gio.FilterOutputStream

        parent_instance: OutputStream & GObject.Object;
        base_stream: OutputStream;

        // Owm methods of Gio-2.0.Gio.FilterOutputStream

        /**
         * Gets the base stream for the filter stream.
         * @returns a #GOutputStream.
         */
        get_base_stream(): OutputStream;
        /**
         * Returns whether the base stream will be closed when `stream` is
         * closed.
         * @returns %TRUE if the base stream will be closed.
         */
        get_close_base_stream(): boolean;
        /**
         * Sets whether the base stream will be closed when `stream` is closed.
         * @param close_base %TRUE to close the base stream.
         */
        set_close_base_stream(close_base: boolean): void;

        // Class property signals of Gio-2.0.Gio.FilterOutputStream

        connect(
            sigName: 'notify::close-base-stream',
            callback: (
                $obj: FilterOutputStream,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::close-base-stream',
            callback: (
                $obj: FilterOutputStream,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::close-base-stream', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * Base class for output stream implementations that perform some
     * kind of filtering operation on a base stream. Typical examples
     * of filtering operations are character set conversion, compression
     * and byte order flipping.
     * @class
     */
    class FilterOutputStream extends OutputStream {
        // Own properties of Gio-2.0.Gio.FilterOutputStream

        static name: string;
        static $gtype: GObject.GType<FilterOutputStream>;

        // Constructors of Gio-2.0.Gio.FilterOutputStream

        constructor(config?: FilterOutputStream.ConstructorProperties);
        _init(config?: FilterOutputStream.ConstructorProperties): void;
    }

    namespace IOModule {
        // Constructor properties interface

        interface ConstructorProperties
            extends GObject.TypePlugin.ConstructorProperties,
                GObject.TypeModule.ConstructorProperties {}
    }

    interface IOModule extends GObject.TypePlugin {
        // Conflicting methods

        /**
         * Calls the `use_plugin` function from the #GTypePluginClass of
         * `plugin`.  There should be no need to use this function outside of
         * the GObject type system itself.
         */
        use(): void;
        /**
         * Increases the use count of a #GTypeModule by one. If the
         * use count was zero before, the plugin will be loaded.
         * If loading the plugin fails, the use count is reset to
         * its prior value.
         * @returns %FALSE if the plugin needed to be loaded and  loading the plugin failed.
         */
        use(): boolean;

        // Overloads of use

        /**
         * Calls the `use_plugin` function from the #GTypePluginClass of
         * `plugin`.  There should be no need to use this function outside of
         * the GObject type system itself.
         */
        use(): void;

        // Class property signals of Gio-2.0.Gio.IOModule

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * Provides an interface and default functions for loading and unloading
     * modules. This is used internally to make GIO extensible, but can also
     * be used by others to implement module loading.
     * @class
     */
    class IOModule extends GObject.TypeModule {
        // Own properties of Gio-2.0.Gio.IOModule

        static name: string;
        static $gtype: GObject.GType<IOModule>;

        // Constructors of Gio-2.0.Gio.IOModule

        constructor(config?: IOModule.ConstructorProperties);
        /**
         * Creates a new GIOModule that will load the specific
         * shared library when in use.
         * @constructor
         * @param filename filename of the shared library module.
         * @returns a #GIOModule from given @filename, or %NULL on error.
         */
        constructor(filename: string);
        /**
         * Creates a new GIOModule that will load the specific
         * shared library when in use.
         * @constructor
         * @param filename filename of the shared library module.
         * @returns a #GIOModule from given @filename, or %NULL on error.
         */
        static new(filename: string): IOModule;
        _init(config?: IOModule.ConstructorProperties): void;
        /**
         * Optional API for GIO modules to implement.
         *
         * Should return a list of all the extension points that may be
         * implemented in this module.
         *
         * This method will not be called in normal use, however it may be
         * called when probing existing modules and recording which extension
         * points that this model is used for. This means we won't have to
         * load and initialize this module unless its needed.
         *
         * If this function is not implemented by the module the module will
         * always be loaded, initialized and then unloaded on application
         * startup so that it can register its extension points during init.
         *
         * Note that a module need not actually implement all the extension
         * points that g_io_module_query() returns, since the exact list of
         * extension may depend on runtime issues. However all extension
         * points actually implemented must be returned by g_io_module_query()
         * (if defined).
         *
         * When installing a module that implements g_io_module_query() you must
         * run gio-querymodules in order to build the cache files required for
         * lazy loading.
         *
         * Since 2.56, this function should be named `g_io_<modulename>_query`, where
         * `modulename` is the plugins filename with the `lib` or `libgio` prefix and
         * everything after the first dot removed, and with `-` replaced with `_`
         * throughout. For example, `libgiognutls-helper.so` becomes `gnutls_helper`.
         * Using the new symbol names avoids name clashes when building modules
         * statically. The old symbol names continue to be supported, but cannot be used
         * for static builds.
         * @returns A %NULL-terminated array of strings,     listing the supported extension points of the module. The array     must be suitable for freeing with g_strfreev().
         */
        static query(): string[];
    }

    namespace IOStream {
        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface IOStream {
        // Own properties of Gio-2.0.Gio.IOStream

        readonly closed: boolean;
        readonly input_stream: InputStream;
        readonly output_stream: OutputStream;

        // Own fields of Gio-2.0.Gio.IOStream

        parent_instance: GObject.Object;

        // Owm methods of Gio-2.0.Gio.IOStream

        /**
         * Clears the pending flag on `stream`.
         */
        clear_pending(): void;
        /**
         * Closes the stream, releasing resources related to it. This will also
         * close the individual input and output streams, if they are not already
         * closed.
         *
         * Once the stream is closed, all other operations will return
         * %G_IO_ERROR_CLOSED. Closing a stream multiple times will not
         * return an error.
         *
         * Closing a stream will automatically flush any outstanding buffers
         * in the stream.
         *
         * Streams will be automatically closed when the last reference
         * is dropped, but you might want to call this function to make sure
         * resources are released as early as possible.
         *
         * Some streams might keep the backing store of the stream (e.g. a file
         * descriptor) open after the stream is closed. See the documentation for
         * the individual stream for details.
         *
         * On failure the first error that happened will be reported, but the
         * close operation will finish as much as possible. A stream that failed
         * to close will still return %G_IO_ERROR_CLOSED for all operations.
         * Still, it is important to check and report the error to the user,
         * otherwise there might be a loss of data as all data might not be written.
         *
         * If `cancellable` is not NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * Cancelling a close will still leave the stream closed, but some streams
         * can use a faster close that doesn't block to e.g. check errors.
         *
         * The default implementation of this method just calls close on the
         * individual input/output streams.
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @returns %TRUE on success, %FALSE on failure
         */
        close(cancellable: Cancellable | null): boolean;
        /**
         * Requests an asynchronous close of the stream, releasing resources
         * related to it. When the operation is finished `callback` will be
         * called. You can then call g_io_stream_close_finish() to get
         * the result of the operation.
         *
         * For behaviour details see g_io_stream_close().
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         * @param io_priority the io priority of the request
         * @param cancellable optional cancellable object
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        close_async(
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of close_async

        /**
         * Promisified version of {@link close_async}
         *
         * Requests an asynchronous close of the stream, releasing resources
         * related to it. When the operation is finished `callback` will be
         * called. You can then call g_io_stream_close_finish() to get
         * the result of the operation.
         *
         * For behaviour details see g_io_stream_close().
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         * @param io_priority the io priority of the request
         * @param cancellable optional cancellable object
         * @returns A Promise of: %TRUE if stream was successfully closed, %FALSE otherwise.
         */
        close_async(
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<boolean>;
        /**
         * Closes a stream.
         * @param result a #GAsyncResult
         * @returns %TRUE if stream was successfully closed, %FALSE otherwise.
         */
        close_finish(result: AsyncResult): boolean;
        /**
         * Gets the input stream for this object. This is used
         * for reading.
         * @returns a #GInputStream, owned by the #GIOStream. Do not free.
         */
        get_input_stream(): InputStream;
        /**
         * Gets the output stream for this object. This is used for
         * writing.
         * @returns a #GOutputStream, owned by the #GIOStream. Do not free.
         */
        get_output_stream(): OutputStream;
        /**
         * Checks if a stream has pending actions.
         * @returns %TRUE if @stream has pending actions.
         */
        has_pending(): boolean;
        /**
         * Checks if a stream is closed.
         * @returns %TRUE if the stream is closed.
         */
        is_closed(): boolean;
        /**
         * Sets `stream` to have actions pending. If the pending flag is
         * already set or `stream` is closed, it will return %FALSE and set
         * `error`.
         * @returns %TRUE if pending was previously unset and is now set.
         */
        set_pending(): boolean;
        /**
         * Asynchronously splice the output stream of `stream1` to the input stream of
         * `stream2`, and splice the output stream of `stream2` to the input stream of
         * `stream1`.
         *
         * When the operation is finished `callback` will be called.
         * You can then call g_io_stream_splice_finish() to get the
         * result of the operation.
         * @param stream2 a #GIOStream.
         * @param flags a set of #GIOStreamSpliceFlags.
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        splice_async(
            stream2: IOStream,
            flags: IOStreamSpliceFlags,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Own virtual methods of Gio-2.0.Gio.IOStream

        /**
         * Requests an asynchronous close of the stream, releasing resources
         * related to it. When the operation is finished `callback` will be
         * called. You can then call g_io_stream_close_finish() to get
         * the result of the operation.
         *
         * For behaviour details see g_io_stream_close().
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         * @virtual
         * @param io_priority the io priority of the request
         * @param cancellable optional cancellable object
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_close_async(
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Closes a stream.
         * @virtual
         * @param result a #GAsyncResult
         * @returns %TRUE if stream was successfully closed, %FALSE otherwise.
         */
        vfunc_close_finish(result: AsyncResult): boolean;
        vfunc_close_fn(cancellable: Cancellable | null): boolean;
        /**
         * Gets the input stream for this object. This is used
         * for reading.
         * @virtual
         * @returns a #GInputStream, owned by the #GIOStream. Do not free.
         */
        vfunc_get_input_stream(): InputStream;
        /**
         * Gets the output stream for this object. This is used for
         * writing.
         * @virtual
         * @returns a #GOutputStream, owned by the #GIOStream. Do not free.
         */
        vfunc_get_output_stream(): OutputStream;

        // Class property signals of Gio-2.0.Gio.IOStream

        connect(
            sigName: 'notify::closed',
            callback: ($obj: IOStream, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::closed',
            callback: ($obj: IOStream, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::closed', ...args: any[]): void;
        connect(
            sigName: 'notify::input-stream',
            callback: ($obj: IOStream, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::input-stream',
            callback: ($obj: IOStream, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::input-stream', ...args: any[]): void;
        connect(
            sigName: 'notify::output-stream',
            callback: ($obj: IOStream, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::output-stream',
            callback: ($obj: IOStream, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::output-stream', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * GIOStream represents an object that has both read and write streams.
     * Generally the two streams act as separate input and output streams,
     * but they share some common resources and state. For instance, for
     * seekable streams, both streams may use the same position.
     *
     * Examples of #GIOStream objects are #GSocketConnection, which represents
     * a two-way network connection; and #GFileIOStream, which represents a
     * file handle opened in read-write mode.
     *
     * To do the actual reading and writing you need to get the substreams
     * with g_io_stream_get_input_stream() and g_io_stream_get_output_stream().
     *
     * The #GIOStream object owns the input and the output streams, not the other
     * way around, so keeping the substreams alive will not keep the #GIOStream
     * object alive. If the #GIOStream object is freed it will be closed, thus
     * closing the substreams, so even if the substreams stay alive they will
     * always return %G_IO_ERROR_CLOSED for all operations.
     *
     * To close a stream use g_io_stream_close() which will close the common
     * stream object and also the individual substreams. You can also close
     * the substreams themselves. In most cases this only marks the
     * substream as closed, so further I/O on it fails but common state in the
     * #GIOStream may still be open. However, some streams may support
     * "half-closed" states where one direction of the stream is actually shut down.
     *
     * Operations on #GIOStreams cannot be started while another operation on the
     * #GIOStream or its substreams is in progress. Specifically, an application can
     * read from the #GInputStream and write to the #GOutputStream simultaneously
     * (either in separate threads, or as asynchronous operations in the same
     * thread), but an application cannot start any #GIOStream operation while there
     * is a #GIOStream, #GInputStream or #GOutputStream operation in progress, and
     * an application cant start any #GInputStream or #GOutputStream operation
     * while there is a #GIOStream operation in progress.
     *
     * This is a product of individual stream operations being associated with a
     * given #GMainContext (the thread-default context at the time the operation was
     * started), rather than entire streams being associated with a single
     * #GMainContext.
     *
     * GIO may run operations on #GIOStreams from other (worker) threads, and this
     * may be exposed to application code in the behaviour of wrapper streams, such
     * as #GBufferedInputStream or #GTlsConnection. With such wrapper APIs,
     * application code may only run operations on the base (wrapped) stream when
     * the wrapper stream is idle. Note that the semantics of such operations may
     * not be well-defined due to the state the wrapper stream leaves the base
     * stream in (though they are guaranteed not to crash).
     * @class
     */
    class IOStream extends GObject.Object {
        // Own properties of Gio-2.0.Gio.IOStream

        static name: string;
        static $gtype: GObject.GType<IOStream>;

        // Constructors of Gio-2.0.Gio.IOStream

        constructor(config?: IOStream.ConstructorProperties);
        _init(config?: IOStream.ConstructorProperties): void;
        /**
         * Finishes an asynchronous io stream splice operation.
         * @param result a #GAsyncResult.
         * @returns %TRUE on success, %FALSE otherwise.
         */
        static splice_finish(result: AsyncResult): boolean;
    }

    namespace InetAddress {
        // Constructor properties interface

        interface ConstructorProperties
            extends GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.InetAddress

            bytes?: any | null;
            family?: SocketFamily | null;
        }
    }

    interface InetAddress {
        // Own properties of Gio-2.0.Gio.InetAddress

        readonly bytes: any;
        readonly family: SocketFamily;
        /**
         * Whether this is the "any" address for its family.
         * See g_inet_address_get_is_any().
         */
        readonly is_any: boolean;
        /**
         * Whether this is a link-local address.
         * See g_inet_address_get_is_link_local().
         */
        readonly is_link_local: boolean;
        /**
         * Whether this is the loopback address for its family.
         * See g_inet_address_get_is_loopback().
         */
        readonly is_loopback: boolean;
        /**
         * Whether this is a global multicast address.
         * See g_inet_address_get_is_mc_global().
         */
        readonly is_mc_global: boolean;
        /**
         * Whether this is a link-local multicast address.
         * See g_inet_address_get_is_mc_link_local().
         */
        readonly is_mc_link_local: boolean;
        /**
         * Whether this is a node-local multicast address.
         * See g_inet_address_get_is_mc_node_local().
         */
        readonly is_mc_node_local: boolean;
        /**
         * Whether this is an organization-local multicast address.
         * See g_inet_address_get_is_mc_org_local().
         */
        readonly is_mc_org_local: boolean;
        /**
         * Whether this is a site-local multicast address.
         * See g_inet_address_get_is_mc_site_local().
         */
        readonly is_mc_site_local: boolean;
        /**
         * Whether this is a multicast address.
         * See g_inet_address_get_is_multicast().
         */
        readonly is_multicast: boolean;
        /**
         * Whether this is a site-local address.
         * See g_inet_address_get_is_loopback().
         */
        readonly is_site_local: boolean;

        // Own fields of Gio-2.0.Gio.InetAddress

        parent_instance: GObject.Object;

        // Owm methods of Gio-2.0.Gio.InetAddress

        /**
         * Checks if two #GInetAddress instances are equal, e.g. the same address.
         * @param other_address Another #GInetAddress.
         * @returns %TRUE if @address and @other_address are equal, %FALSE otherwise.
         */
        equal(other_address: InetAddress): boolean;
        /**
         * Gets `address'`s family
         * @returns @address's family
         */
        get_family(): SocketFamily;
        /**
         * Tests whether `address` is the "any" address for its family.
         * @returns %TRUE if @address is the "any" address for its family.
         */
        get_is_any(): boolean;
        /**
         * Tests whether `address` is a link-local address (that is, if it
         * identifies a host on a local network that is not connected to the
         * Internet).
         * @returns %TRUE if @address is a link-local address.
         */
        get_is_link_local(): boolean;
        /**
         * Tests whether `address` is the loopback address for its family.
         * @returns %TRUE if @address is the loopback address for its family.
         */
        get_is_loopback(): boolean;
        /**
         * Tests whether `address` is a global multicast address.
         * @returns %TRUE if @address is a global multicast address.
         */
        get_is_mc_global(): boolean;
        /**
         * Tests whether `address` is a link-local multicast address.
         * @returns %TRUE if @address is a link-local multicast address.
         */
        get_is_mc_link_local(): boolean;
        /**
         * Tests whether `address` is a node-local multicast address.
         * @returns %TRUE if @address is a node-local multicast address.
         */
        get_is_mc_node_local(): boolean;
        /**
         * Tests whether `address` is an organization-local multicast address.
         * @returns %TRUE if @address is an organization-local multicast address.
         */
        get_is_mc_org_local(): boolean;
        /**
         * Tests whether `address` is a site-local multicast address.
         * @returns %TRUE if @address is a site-local multicast address.
         */
        get_is_mc_site_local(): boolean;
        /**
         * Tests whether `address` is a multicast address.
         * @returns %TRUE if @address is a multicast address.
         */
        get_is_multicast(): boolean;
        /**
         * Tests whether `address` is a site-local address such as 10.0.0.1
         * (that is, the address identifies a host on a local network that can
         * not be reached directly from the Internet, but which may have
         * outgoing Internet connectivity via a NAT or firewall).
         * @returns %TRUE if @address is a site-local address.
         */
        get_is_site_local(): boolean;
        /**
         * Gets the size of the native raw binary address for `address`. This
         * is the size of the data that you get from g_inet_address_to_bytes().
         * @returns the number of bytes used for the native version of @address.
         */
        get_native_size(): number;
        /**
         * Converts `address` to string form.
         * @returns a representation of @address as a string, which should be freed after use.
         */
        to_string(): string | null;

        // Own virtual methods of Gio-2.0.Gio.InetAddress

        /**
         * Converts `address` to string form.
         * @virtual
         * @returns a representation of @address as a string, which should be freed after use.
         */
        vfunc_to_string(): string | null;

        // Class property signals of Gio-2.0.Gio.InetAddress

        connect(
            sigName: 'notify::bytes',
            callback: ($obj: InetAddress, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::bytes',
            callback: ($obj: InetAddress, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::bytes', ...args: any[]): void;
        connect(
            sigName: 'notify::family',
            callback: ($obj: InetAddress, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::family',
            callback: ($obj: InetAddress, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::family', ...args: any[]): void;
        connect(
            sigName: 'notify::is-any',
            callback: ($obj: InetAddress, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::is-any',
            callback: ($obj: InetAddress, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::is-any', ...args: any[]): void;
        connect(
            sigName: 'notify::is-link-local',
            callback: ($obj: InetAddress, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::is-link-local',
            callback: ($obj: InetAddress, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::is-link-local', ...args: any[]): void;
        connect(
            sigName: 'notify::is-loopback',
            callback: ($obj: InetAddress, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::is-loopback',
            callback: ($obj: InetAddress, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::is-loopback', ...args: any[]): void;
        connect(
            sigName: 'notify::is-mc-global',
            callback: ($obj: InetAddress, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::is-mc-global',
            callback: ($obj: InetAddress, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::is-mc-global', ...args: any[]): void;
        connect(
            sigName: 'notify::is-mc-link-local',
            callback: ($obj: InetAddress, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::is-mc-link-local',
            callback: ($obj: InetAddress, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::is-mc-link-local', ...args: any[]): void;
        connect(
            sigName: 'notify::is-mc-node-local',
            callback: ($obj: InetAddress, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::is-mc-node-local',
            callback: ($obj: InetAddress, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::is-mc-node-local', ...args: any[]): void;
        connect(
            sigName: 'notify::is-mc-org-local',
            callback: ($obj: InetAddress, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::is-mc-org-local',
            callback: ($obj: InetAddress, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::is-mc-org-local', ...args: any[]): void;
        connect(
            sigName: 'notify::is-mc-site-local',
            callback: ($obj: InetAddress, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::is-mc-site-local',
            callback: ($obj: InetAddress, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::is-mc-site-local', ...args: any[]): void;
        connect(
            sigName: 'notify::is-multicast',
            callback: ($obj: InetAddress, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::is-multicast',
            callback: ($obj: InetAddress, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::is-multicast', ...args: any[]): void;
        connect(
            sigName: 'notify::is-site-local',
            callback: ($obj: InetAddress, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::is-site-local',
            callback: ($obj: InetAddress, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::is-site-local', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GInetAddress represents an IPv4 or IPv6 internet address. Use
     * g_resolver_lookup_by_name() or g_resolver_lookup_by_name_async() to
     * look up the #GInetAddress for a hostname. Use
     * g_resolver_lookup_by_address() or
     * g_resolver_lookup_by_address_async() to look up the hostname for a
     * #GInetAddress.
     *
     * To actually connect to a remote host, you will need a
     * #GInetSocketAddress (which includes a #GInetAddress as well as a
     * port number).
     * @class
     */
    class InetAddress extends GObject.Object {
        // Own properties of Gio-2.0.Gio.InetAddress

        static name: string;
        static $gtype: GObject.GType<InetAddress>;

        // Constructors of Gio-2.0.Gio.InetAddress

        constructor(config?: InetAddress.ConstructorProperties);
        /**
         * Creates a #GInetAddress for the "any" address (unassigned/"don't
         * care") for `family`.
         * @constructor
         * @param family the address family
         * @returns a new #GInetAddress corresponding to the "any" address for @family.     Free the returned object with g_object_unref().
         */
        static new_any(family: SocketFamily): InetAddress;
        /**
         * Creates a new #GInetAddress from the given `family` and `bytes`.
         * `bytes` should be 4 bytes for %G_SOCKET_FAMILY_IPV4 and 16 bytes for
         * %G_SOCKET_FAMILY_IPV6.
         * @constructor
         * @param bytes raw address data
         * @param family the address family of `bytes`
         * @returns a new #GInetAddress corresponding to @family and @bytes.     Free the returned object with g_object_unref().
         */
        static new_from_bytes(
            bytes: Uint8Array,
            family: SocketFamily
        ): InetAddress;
        /**
         * Parses `string` as an IP address and creates a new #GInetAddress.
         * @constructor
         * @param string a string representation of an IP address
         * @returns a new #GInetAddress corresponding to @string, or %NULL if @string could not be parsed.     Free the returned object with g_object_unref().
         */
        static new_from_string(string: string | null): InetAddress;
        /**
         * Creates a #GInetAddress for the loopback address for `family`.
         * @constructor
         * @param family the address family
         * @returns a new #GInetAddress corresponding to the loopback address for @family.     Free the returned object with g_object_unref().
         */
        static new_loopback(family: SocketFamily): InetAddress;
        _init(config?: InetAddress.ConstructorProperties): void;
    }

    namespace InetAddressMask {
        // Constructor properties interface

        interface ConstructorProperties
            extends Initable.ConstructorProperties,
                GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.InetAddressMask

            address?: InetAddress | null;
            length?: number | null;
        }
    }

    interface InetAddressMask extends Initable {
        // Own properties of Gio-2.0.Gio.InetAddressMask

        address: InetAddress;
        readonly family: SocketFamily;
        length: number;

        // Own fields of Gio-2.0.Gio.InetAddressMask

        parent_instance: GObject.Object;

        // Owm methods of Gio-2.0.Gio.InetAddressMask

        /**
         * Tests if `mask` and `mask2` are the same mask.
         * @param mask2 another #GInetAddressMask
         * @returns whether @mask and @mask2 are the same mask
         */
        equal(mask2: InetAddressMask): boolean;
        /**
         * Gets `mask'`s base address
         * @returns @mask's base address
         */
        get_address(): InetAddress;
        /**
         * Gets the #GSocketFamily of `mask'`s address
         * @returns the #GSocketFamily of @mask's address
         */
        get_family(): SocketFamily;
        /**
         * Gets `mask'`s length
         * @returns @mask's length
         */
        get_length(): number;
        /**
         * Tests if `address` falls within the range described by `mask`.
         * @param address a #GInetAddress
         * @returns whether @address falls within the range described by @mask.
         */
        matches(address: InetAddress): boolean;
        /**
         * Converts `mask` back to its corresponding string form.
         * @returns a string corresponding to @mask.
         */
        to_string(): string | null;

        // Class property signals of Gio-2.0.Gio.InetAddressMask

        connect(
            sigName: 'notify::address',
            callback: ($obj: InetAddressMask, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::address',
            callback: ($obj: InetAddressMask, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::address', ...args: any[]): void;
        connect(
            sigName: 'notify::family',
            callback: ($obj: InetAddressMask, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::family',
            callback: ($obj: InetAddressMask, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::family', ...args: any[]): void;
        connect(
            sigName: 'notify::length',
            callback: ($obj: InetAddressMask, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::length',
            callback: ($obj: InetAddressMask, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::length', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GInetAddressMask represents a range of IPv4 or IPv6 addresses
     * described by a base address and a length indicating how many bits
     * of the base address are relevant for matching purposes. These are
     * often given in string form. Eg, "10.0.0.0/8", or "fe80::/10".
     * @class
     */
    class InetAddressMask extends GObject.Object {
        // Own properties of Gio-2.0.Gio.InetAddressMask

        static name: string;
        static $gtype: GObject.GType<InetAddressMask>;

        // Constructors of Gio-2.0.Gio.InetAddressMask

        constructor(config?: InetAddressMask.ConstructorProperties);
        /**
         * Creates a new #GInetAddressMask representing all addresses whose
         * first `length` bits match `addr`.
         * @constructor
         * @param addr a #GInetAddress
         * @param length number of bits of `addr` to use
         * @returns a new #GInetAddressMask, or %NULL on error
         */
        constructor(addr: InetAddress, length: number);
        /**
         * Creates a new #GInetAddressMask representing all addresses whose
         * first `length` bits match `addr`.
         * @constructor
         * @param addr a #GInetAddress
         * @param length number of bits of `addr` to use
         * @returns a new #GInetAddressMask, or %NULL on error
         */
        static new(addr: InetAddress, length: number): InetAddressMask;
        /**
         * Parses `mask_string` as an IP address and (optional) length, and
         * creates a new #GInetAddressMask. The length, if present, is
         * delimited by a "/". If it is not present, then the length is
         * assumed to be the full length of the address.
         * @constructor
         * @param mask_string an IP address or address/length string
         * @returns a new #GInetAddressMask corresponding to @string, or %NULL on error.
         */
        static new_from_string(mask_string: string | null): InetAddressMask;
        _init(config?: InetAddressMask.ConstructorProperties): void;
    }

    namespace InetSocketAddress {
        // Constructor properties interface

        interface ConstructorProperties
            extends SocketConnectable.ConstructorProperties,
                SocketAddress.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.InetSocketAddress

            address?: InetAddress | null;
            /**
             * The `sin6_flowinfo` field, for IPv6 addresses.
             */
            flowinfo?: number | null;
            port?: number | null;
            scope_id?: number | null;
        }
    }

    interface InetSocketAddress extends SocketConnectable {
        // Own properties of Gio-2.0.Gio.InetSocketAddress

        readonly address: InetAddress;
        /**
         * The `sin6_flowinfo` field, for IPv6 addresses.
         */
        readonly flowinfo: number;
        readonly port: number;
        readonly scope_id: number;

        // Own fields of Gio-2.0.Gio.InetSocketAddress

        parent_instance: SocketAddress & GObject.Object;

        // Owm methods of Gio-2.0.Gio.InetSocketAddress

        /**
         * Gets `address'`s #GInetAddress.
         * @returns the #GInetAddress for @address, which must be g_object_ref()'d if it will be stored
         */
        get_address(): InetAddress;
        /**
         * Gets the `sin6_flowinfo` field from `address,`
         * which must be an IPv6 address.
         * @returns the flowinfo field
         */
        get_flowinfo(): number;
        /**
         * Gets `address'`s port.
         * @returns the port for @address
         */
        get_port(): number;
        /**
         * Gets the `sin6_scope_id` field from `address,`
         * which must be an IPv6 address.
         * @returns the scope id field
         */
        get_scope_id(): number;

        // Class property signals of Gio-2.0.Gio.InetSocketAddress

        connect(
            sigName: 'notify::address',
            callback: (
                $obj: InetSocketAddress,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::address',
            callback: (
                $obj: InetSocketAddress,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::address', ...args: any[]): void;
        connect(
            sigName: 'notify::flowinfo',
            callback: (
                $obj: InetSocketAddress,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::flowinfo',
            callback: (
                $obj: InetSocketAddress,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::flowinfo', ...args: any[]): void;
        connect(
            sigName: 'notify::port',
            callback: (
                $obj: InetSocketAddress,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::port',
            callback: (
                $obj: InetSocketAddress,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::port', ...args: any[]): void;
        connect(
            sigName: 'notify::scope-id',
            callback: (
                $obj: InetSocketAddress,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::scope-id',
            callback: (
                $obj: InetSocketAddress,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::scope-id', ...args: any[]): void;
        connect(
            sigName: 'notify::family',
            callback: (
                $obj: InetSocketAddress,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::family',
            callback: (
                $obj: InetSocketAddress,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::family', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * An IPv4 or IPv6 socket address; that is, the combination of a
     * #GInetAddress and a port number.
     * @class
     */
    class InetSocketAddress extends SocketAddress {
        // Own properties of Gio-2.0.Gio.InetSocketAddress

        static name: string;
        static $gtype: GObject.GType<InetSocketAddress>;

        // Constructors of Gio-2.0.Gio.InetSocketAddress

        constructor(config?: InetSocketAddress.ConstructorProperties);
        /**
         * Creates a new #GInetSocketAddress for `address` and `port`.
         * @constructor
         * @param address a #GInetAddress
         * @param port a port number
         * @returns a new #GInetSocketAddress
         */
        constructor(address: InetAddress, port: number);
        /**
         * Creates a new #GInetSocketAddress for `address` and `port`.
         * @constructor
         * @param address a #GInetAddress
         * @param port a port number
         * @returns a new #GInetSocketAddress
         */
        static new(address: InetAddress, port: number): InetSocketAddress;
        /**
         * Creates a new #GInetSocketAddress for `address` and `port`.
         *
         * If `address` is an IPv6 address, it can also contain a scope ID
         * (separated from the address by a `%`).
         * @constructor
         * @param address the string form of an IP address
         * @param port a port number
         * @returns a new #GInetSocketAddress, or %NULL if @address cannot be parsed.
         */
        static new_from_string(
            address: string | null,
            port: number
        ): InetSocketAddress;
        _init(config?: InetSocketAddress.ConstructorProperties): void;
    }

    namespace InputStream {
        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface InputStream {
        // Own fields of Gio-2.0.Gio.InputStream

        parent_instance: GObject.Object;

        // Owm methods of Gio-2.0.Gio.InputStream

        /**
         * Clears the pending flag on `stream`.
         */
        clear_pending(): void;
        /**
         * Closes the stream, releasing resources related to it.
         *
         * Once the stream is closed, all other operations will return %G_IO_ERROR_CLOSED.
         * Closing a stream multiple times will not return an error.
         *
         * Streams will be automatically closed when the last reference
         * is dropped, but you might want to call this function to make sure
         * resources are released as early as possible.
         *
         * Some streams might keep the backing store of the stream (e.g. a file descriptor)
         * open after the stream is closed. See the documentation for the individual
         * stream for details.
         *
         * On failure the first error that happened will be reported, but the close
         * operation will finish as much as possible. A stream that failed to
         * close will still return %G_IO_ERROR_CLOSED for all operations. Still, it
         * is important to check and report the error to the user.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * Cancelling a close will still leave the stream closed, but some streams
         * can use a faster close that doesn't block to e.g. check errors.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE on success, %FALSE on failure
         */
        close(cancellable: Cancellable | null): boolean;
        /**
         * Requests an asynchronous closes of the stream, releasing resources related to it.
         * When the operation is finished `callback` will be called.
         * You can then call g_input_stream_close_finish() to get the result of the
         * operation.
         *
         * For behaviour details see g_input_stream_close().
         *
         * The asynchronous methods have a default fallback that uses threads to implement
         * asynchronicity, so they are optional for inheriting classes. However, if you
         * override one you must override all.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional cancellable object
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        close_async(
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of close_async

        /**
         * Promisified version of {@link close_async}
         *
         * Requests an asynchronous closes of the stream, releasing resources related to it.
         * When the operation is finished `callback` will be called.
         * You can then call g_input_stream_close_finish() to get the result of the
         * operation.
         *
         * For behaviour details see g_input_stream_close().
         *
         * The asynchronous methods have a default fallback that uses threads to implement
         * asynchronicity, so they are optional for inheriting classes. However, if you
         * override one you must override all.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional cancellable object
         * @returns A Promise of: %TRUE if the stream was closed successfully.
         */
        close_async(
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<boolean>;
        /**
         * Finishes closing a stream asynchronously, started from g_input_stream_close_async().
         * @param result a #GAsyncResult.
         * @returns %TRUE if the stream was closed successfully.
         */
        close_finish(result: AsyncResult): boolean;
        /**
         * Checks if an input stream has pending actions.
         * @returns %TRUE if @stream has pending actions.
         */
        has_pending(): boolean;
        /**
         * Checks if an input stream is closed.
         * @returns %TRUE if the stream is closed.
         */
        is_closed(): boolean;
        /**
         * Tries to read `count` bytes from the stream into the buffer starting at
         * `buffer`. Will block during this read.
         *
         * If count is zero returns zero and does nothing. A value of `count`
         * larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes read into the buffer is returned.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. near the end of a file. Zero is returned on end of file
         * (or if `count` is zero),  but never otherwise.
         *
         * The returned `buffer` is not a nul-terminated string, it can contain nul bytes
         * at any position, and this function doesn't nul-terminate the `buffer`.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         *
         * On error -1 is returned and `error` is set accordingly.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns Number of bytes read, or -1 on error, or 0 on end of file.
         */
        read(
            cancellable: Cancellable | null
        ): [/* returnType */ number, /* buffer */ Uint8Array];
        /**
         * Tries to read `count` bytes from the stream into the buffer starting at
         * `buffer`. Will block during this read.
         *
         * This function is similar to g_input_stream_read(), except it tries to
         * read as many bytes as requested, only stopping on an error or end of stream.
         *
         * On a successful read of `count` bytes, or if we reached the end of the
         * stream,  %TRUE is returned, and `bytes_read` is set to the number of bytes
         * read into `buffer`.
         *
         * If there is an error during the operation %FALSE is returned and `error`
         * is set to indicate the error status.
         *
         * As a special exception to the normal conventions for functions that
         * use #GError, if this function returns %FALSE (and sets `error)` then
         * `bytes_read` will be set to the number of bytes that were successfully
         * read before the error was encountered.  This functionality is only
         * available from C.  If you need it from another language then you must
         * write your own loop around g_input_stream_read().
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE on success, %FALSE if there was an error
         */
        read_all(
            cancellable: Cancellable | null
        ): [
            /* returnType */ boolean,
            /* buffer */ Uint8Array,
            /* bytes_read */ number
        ];
        /**
         * Request an asynchronous read of `count` bytes from the stream into the
         * buffer starting at `buffer`.
         *
         * This is the asynchronous equivalent of g_input_stream_read_all().
         *
         * Call g_input_stream_read_all_finish() to collect the result.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        read_all_async(
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): /* buffer */ Uint8Array;

        // Overloads of read_all_async

        /**
         * Promisified version of {@link read_all_async}
         *
         * Request an asynchronous read of `count` bytes from the stream into the
         * buffer starting at `buffer`.
         *
         * This is the asynchronous equivalent of g_input_stream_read_all().
         *
         * Call g_input_stream_read_all_finish() to collect the result.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @returns A Promise of: %TRUE on success, %FALSE if there was an error
         */
        read_all_async(
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise</* bytes_read */ number>;
        /**
         * Finishes an asynchronous stream read operation started with
         * g_input_stream_read_all_async().
         *
         * As a special exception to the normal conventions for functions that
         * use #GError, if this function returns %FALSE (and sets `error)` then
         * `bytes_read` will be set to the number of bytes that were successfully
         * read before the error was encountered.  This functionality is only
         * available from C.  If you need it from another language then you must
         * write your own loop around g_input_stream_read_async().
         * @param result a #GAsyncResult
         * @returns %TRUE on success, %FALSE if there was an error
         */
        read_all_finish(
            result: AsyncResult
        ): [/* returnType */ boolean, /* bytes_read */ number];
        /**
         * Request an asynchronous read of `count` bytes from the stream into the buffer
         * starting at `buffer`. When the operation is finished `callback` will be called.
         * You can then call g_input_stream_read_finish() to get the result of the
         * operation.
         *
         * During an async request no other sync and async calls are allowed on `stream,` and will
         * result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes read into the buffer will be passed to the
         * callback. It is not an error if this is not the same as the requested size, as it
         * can happen e.g. near the end of a file, but generally we try to read
         * as many bytes as requested. Zero is returned on end of file
         * (or if `count` is zero),  but never otherwise.
         *
         * Any outstanding i/o request with higher priority (lower numerical value) will
         * be executed before an outstanding request with lower priority. Default
         * priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads to implement
         * asynchronicity, so they are optional for inheriting classes. However, if you
         * override one you must override all.
         * @param io_priority the [I/O priority][io-priority] of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        read_async(
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): /* buffer */ Uint8Array;

        // Overloads of read_async

        /**
         * Promisified version of {@link read_async}
         *
         * Request an asynchronous read of `count` bytes from the stream into the buffer
         * starting at `buffer`. When the operation is finished `callback` will be called.
         * You can then call g_input_stream_read_finish() to get the result of the
         * operation.
         *
         * During an async request no other sync and async calls are allowed on `stream,` and will
         * result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes read into the buffer will be passed to the
         * callback. It is not an error if this is not the same as the requested size, as it
         * can happen e.g. near the end of a file, but generally we try to read
         * as many bytes as requested. Zero is returned on end of file
         * (or if `count` is zero),  but never otherwise.
         *
         * Any outstanding i/o request with higher priority (lower numerical value) will
         * be executed before an outstanding request with lower priority. Default
         * priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads to implement
         * asynchronicity, so they are optional for inheriting classes. However, if you
         * override one you must override all.
         * @param io_priority the [I/O priority][io-priority] of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns A Promise of: number of bytes read in, or -1 on error, or 0 on end of file.
         */
        read_async(
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<number>;
        /**
         * Like g_input_stream_read(), this tries to read `count` bytes from
         * the stream in a blocking fashion. However, rather than reading into
         * a user-supplied buffer, this will create a new #GBytes containing
         * the data that was read. This may be easier to use from language
         * bindings.
         *
         * If count is zero, returns a zero-length #GBytes and does nothing. A
         * value of `count` larger than %G_MAXSSIZE will cause a
         * %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, a new #GBytes is returned. It is not an error if the
         * size of this object is not the same as the requested size, as it
         * can happen e.g. near the end of a file. A zero-length #GBytes is
         * returned on end of file (or if `count` is zero), but never
         * otherwise.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         *
         * On error %NULL is returned and `error` is set accordingly.
         * @param count maximum number of bytes that will be read from the stream. Common values include 4096 and 8192.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a new #GBytes, or %NULL on error
         */
        read_bytes(count: number, cancellable: Cancellable | null): GLib.Bytes;
        /**
         * Request an asynchronous read of `count` bytes from the stream into a
         * new #GBytes. When the operation is finished `callback` will be
         * called. You can then call g_input_stream_read_bytes_finish() to get the
         * result of the operation.
         *
         * During an async request no other sync and async calls are allowed
         * on `stream,` and will result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a
         * %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the new #GBytes will be passed to the callback. It is
         * not an error if this is smaller than the requested size, as it can
         * happen e.g. near the end of a file, but generally we try to read as
         * many bytes as requested. Zero is returned on end of file (or if
         * `count` is zero), but never otherwise.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         * @param count the number of bytes that will be read from the stream
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        read_bytes_async(
            count: number,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of read_bytes_async

        /**
         * Promisified version of {@link read_bytes_async}
         *
         * Request an asynchronous read of `count` bytes from the stream into a
         * new #GBytes. When the operation is finished `callback` will be
         * called. You can then call g_input_stream_read_bytes_finish() to get the
         * result of the operation.
         *
         * During an async request no other sync and async calls are allowed
         * on `stream,` and will result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a
         * %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the new #GBytes will be passed to the callback. It is
         * not an error if this is smaller than the requested size, as it can
         * happen e.g. near the end of a file, but generally we try to read as
         * many bytes as requested. Zero is returned on end of file (or if
         * `count` is zero), but never otherwise.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         * @param count the number of bytes that will be read from the stream
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns A Promise of: the newly-allocated #GBytes, or %NULL on error
         */
        read_bytes_async(
            count: number,
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<GLib.Bytes>;
        /**
         * Finishes an asynchronous stream read-into-#GBytes operation.
         * @param result a #GAsyncResult.
         * @returns the newly-allocated #GBytes, or %NULL on error
         */
        read_bytes_finish(result: AsyncResult): GLib.Bytes;
        /**
         * Finishes an asynchronous stream read operation.
         * @param result a #GAsyncResult.
         * @returns number of bytes read in, or -1 on error, or 0 on end of file.
         */
        read_finish(result: AsyncResult): number;
        /**
         * Sets `stream` to have actions pending. If the pending flag is
         * already set or `stream` is closed, it will return %FALSE and set
         * `error`.
         * @returns %TRUE if pending was previously unset and is now set.
         */
        set_pending(): boolean;
        /**
         * Tries to skip `count` bytes from the stream. Will block during the operation.
         *
         * This is identical to g_input_stream_read(), from a behaviour standpoint,
         * but the bytes that are skipped are not returned to the user. Some
         * streams have an implementation that is more efficient than reading the data.
         *
         * This function is optional for inherited classes, as the default implementation
         * emulates it using read.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         * @param count the number of bytes that will be skipped from the stream
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns Number of bytes skipped, or -1 on error
         */
        skip(count: number, cancellable: Cancellable | null): number;
        /**
         * Request an asynchronous skip of `count` bytes from the stream.
         * When the operation is finished `callback` will be called.
         * You can then call g_input_stream_skip_finish() to get the result
         * of the operation.
         *
         * During an async request no other sync and async calls are allowed,
         * and will result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes skipped will be passed to the callback.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. near the end of a file, but generally we try to skip
         * as many bytes as requested. Zero is returned on end of file
         * (or if `count` is zero), but never otherwise.
         *
         * Any outstanding i/o request with higher priority (lower numerical value)
         * will be executed before an outstanding request with lower priority.
         * Default priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads to
         * implement asynchronicity, so they are optional for inheriting classes.
         * However, if you override one, you must override all.
         * @param count the number of bytes that will be skipped from the stream
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        skip_async(
            count: number,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of skip_async

        /**
         * Promisified version of {@link skip_async}
         *
         * Request an asynchronous skip of `count` bytes from the stream.
         * When the operation is finished `callback` will be called.
         * You can then call g_input_stream_skip_finish() to get the result
         * of the operation.
         *
         * During an async request no other sync and async calls are allowed,
         * and will result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes skipped will be passed to the callback.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. near the end of a file, but generally we try to skip
         * as many bytes as requested. Zero is returned on end of file
         * (or if `count` is zero), but never otherwise.
         *
         * Any outstanding i/o request with higher priority (lower numerical value)
         * will be executed before an outstanding request with lower priority.
         * Default priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads to
         * implement asynchronicity, so they are optional for inheriting classes.
         * However, if you override one, you must override all.
         * @param count the number of bytes that will be skipped from the stream
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns A Promise of: the size of the bytes skipped, or `-1` on error.
         */
        skip_async(
            count: number,
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<number>;
        /**
         * Finishes a stream skip operation.
         * @param result a #GAsyncResult.
         * @returns the size of the bytes skipped, or `-1` on error.
         */
        skip_finish(result: AsyncResult): number;

        // Own virtual methods of Gio-2.0.Gio.InputStream

        /**
         * Requests an asynchronous closes of the stream, releasing resources related to it.
         * When the operation is finished `callback` will be called.
         * You can then call g_input_stream_close_finish() to get the result of the
         * operation.
         *
         * For behaviour details see g_input_stream_close().
         *
         * The asynchronous methods have a default fallback that uses threads to implement
         * asynchronicity, so they are optional for inheriting classes. However, if you
         * override one you must override all.
         * @virtual
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional cancellable object
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_close_async(
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes closing a stream asynchronously, started from g_input_stream_close_async().
         * @virtual
         * @param result a #GAsyncResult.
         * @returns %TRUE if the stream was closed successfully.
         */
        vfunc_close_finish(result: AsyncResult): boolean;
        vfunc_close_fn(cancellable: Cancellable | null): boolean;
        /**
         * Request an asynchronous read of `count` bytes from the stream into the buffer
         * starting at `buffer`. When the operation is finished `callback` will be called.
         * You can then call g_input_stream_read_finish() to get the result of the
         * operation.
         *
         * During an async request no other sync and async calls are allowed on `stream,` and will
         * result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes read into the buffer will be passed to the
         * callback. It is not an error if this is not the same as the requested size, as it
         * can happen e.g. near the end of a file, but generally we try to read
         * as many bytes as requested. Zero is returned on end of file
         * (or if `count` is zero),  but never otherwise.
         *
         * Any outstanding i/o request with higher priority (lower numerical value) will
         * be executed before an outstanding request with lower priority. Default
         * priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads to implement
         * asynchronicity, so they are optional for inheriting classes. However, if you
         * override one you must override all.
         * @virtual
         * @param io_priority the [I/O priority][io-priority] of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_read_async(
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): /* buffer */ Uint8Array | null;
        /**
         * Finishes an asynchronous stream read operation.
         * @virtual
         * @param result a #GAsyncResult.
         * @returns number of bytes read in, or -1 on error, or 0 on end of file.
         */
        vfunc_read_finish(result: AsyncResult): number;
        vfunc_read_fn(
            buffer: any | null,
            count: number,
            cancellable: Cancellable | null
        ): number;
        /**
         * Tries to skip `count` bytes from the stream. Will block during the operation.
         *
         * This is identical to g_input_stream_read(), from a behaviour standpoint,
         * but the bytes that are skipped are not returned to the user. Some
         * streams have an implementation that is more efficient than reading the data.
         *
         * This function is optional for inherited classes, as the default implementation
         * emulates it using read.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         * @virtual
         * @param count the number of bytes that will be skipped from the stream
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns Number of bytes skipped, or -1 on error
         */
        vfunc_skip(count: number, cancellable: Cancellable | null): number;
        /**
         * Request an asynchronous skip of `count` bytes from the stream.
         * When the operation is finished `callback` will be called.
         * You can then call g_input_stream_skip_finish() to get the result
         * of the operation.
         *
         * During an async request no other sync and async calls are allowed,
         * and will result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes skipped will be passed to the callback.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. near the end of a file, but generally we try to skip
         * as many bytes as requested. Zero is returned on end of file
         * (or if `count` is zero), but never otherwise.
         *
         * Any outstanding i/o request with higher priority (lower numerical value)
         * will be executed before an outstanding request with lower priority.
         * Default priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads to
         * implement asynchronicity, so they are optional for inheriting classes.
         * However, if you override one, you must override all.
         * @virtual
         * @param count the number of bytes that will be skipped from the stream
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_skip_async(
            count: number,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes a stream skip operation.
         * @virtual
         * @param result a #GAsyncResult.
         * @returns the size of the bytes skipped, or `-1` on error.
         */
        vfunc_skip_finish(result: AsyncResult): number;

        // Class property signals of Gio-2.0.Gio.InputStream

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GInputStream has functions to read from a stream (g_input_stream_read()),
     * to close a stream (g_input_stream_close()) and to skip some content
     * (g_input_stream_skip()).
     *
     * To copy the content of an input stream to an output stream without
     * manually handling the reads and writes, use g_output_stream_splice().
     *
     * See the documentation for #GIOStream for details of thread safety of
     * streaming APIs.
     *
     * All of these functions have async variants too.
     * @interface
     */
    class InputStream extends GObject.Object {
        // Own properties of Gio-2.0.Gio.InputStream

        static name: string;
        static $gtype: GObject.GType<InputStream>;

        // Constructors of Gio-2.0.Gio.InputStream

        constructor(config?: InputStream.ConstructorProperties);
        _init(config?: InputStream.ConstructorProperties): void;
    }

    namespace ListStore {
        // Constructor properties interface

        interface ConstructorProperties
            extends ListModel.ConstructorProperties,
                GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.ListStore

            /**
             * The type of items contained in this list store. Items must be
             * subclasses of #GObject.
             */
            item_type?: GObject.GType | null;
        }
    }

    interface ListStore<A extends GObject.Object = GObject.Object>
        extends ListModel {
        // Own properties of Gio-2.0.Gio.ListStore

        /**
         * The type of items contained in this list store. Items must be
         * subclasses of #GObject.
         */
        readonly item_type: GObject.GType;
        /**
         * The number of items contained in this list store.
         */
        readonly n_items: number;

        // Owm methods of Gio-2.0.Gio.ListStore

        /**
         * Appends `item` to `store`. `item` must be of type #GListStore:item-type.
         *
         * This function takes a ref on `item`.
         *
         * Use g_list_store_splice() to append multiple items at the same time
         * efficiently.
         * @param item the new item
         */
        append(item: GObject.Object): void;
        /**
         * Looks up the given `item` in the list store by looping over the items until
         * the first occurrence of `item`. If `item` was not found, then `position` will
         * not be set, and this method will return %FALSE.
         *
         * If you need to compare the two items with a custom comparison function, use
         * g_list_store_find_with_equal_func() with a custom #GEqualFunc instead.
         * @param item an item
         * @returns Whether @store contains @item. If it was found, @position will be set to the position where @item occurred for the first time.
         */
        find(
            item: GObject.Object
        ): [/* returnType */ boolean, /* position */ number];
        /**
         * Looks up the given `item` in the list store by looping over the items and
         * comparing them with `equal_func` until the first occurrence of `item` which
         * matches. If `item` was not found, then `position` will not be set, and this
         * method will return %FALSE.
         *
         * `item` is always passed as second parameter to `equal_func`.
         *
         * Since GLib 2.76 it is possible to pass `NULL` for `item`.
         * @param item an item
         * @param equal_func A custom equality check function
         * @returns Whether @store contains @item. If it was found, @position will be set to the position where @item occurred for the first time.
         */
        find_with_equal_func(
            item: GObject.Object | null,
            equal_func: GLib.EqualFunc
        ): [/* returnType */ boolean, /* position */ number];
        /**
         * Like g_list_store_find_with_equal_func() but with an additional `user_data`
         * that is passed to `equal_func`.
         *
         * `item` is always passed as second parameter to `equal_func`.
         *
         * Since GLib 2.76 it is possible to pass `NULL` for `item`.
         * @param item an item
         * @param equal_func A custom equality check function
         * @returns Whether @store contains @item. If it was found, @position will be set to the position where @item occurred for the first time.
         */
        find_with_equal_func_full(
            item: GObject.Object | null,
            equal_func: GLib.EqualFuncFull
        ): [/* returnType */ boolean, /* position */ number];
        /**
         * Inserts `item` into `store` at `position`. `item` must be of type
         * #GListStore:item-type or derived from it. `position` must be smaller
         * than the length of the list, or equal to it to append.
         *
         * This function takes a ref on `item`.
         *
         * Use g_list_store_splice() to insert multiple items at the same time
         * efficiently.
         * @param position the position at which to insert the new item
         * @param item the new item
         */
        insert(position: number, item: GObject.Object): void;
        // Has conflict: insert_sorted(item: GObject.Object, compare_func: GLib.CompareDataFunc): number
        /**
         * Removes the item from `store` that is at `position`. `position` must be
         * smaller than the current length of the list.
         *
         * Use g_list_store_splice() to remove multiple items at the same time
         * efficiently.
         * @param position the position of the item that is to be removed
         */
        remove(position: number): void;
        /**
         * Removes all items from `store`.
         */
        remove_all(): void;
        /**
         * Sort the items in `store` according to `compare_func`.
         * @param compare_func pairwise comparison function for sorting
         */
        sort(compare_func: GLib.CompareDataFunc): void;
        /**
         * Changes `store` by removing `n_removals` items and adding `n_additions`
         * items to it. `additions` must contain `n_additions` items of type
         * #GListStore:item-type.  %NULL is not permitted.
         *
         * This function is more efficient than g_list_store_insert() and
         * g_list_store_remove(), because it only emits
         * #GListModel::items-changed once for the change.
         *
         * This function takes a ref on each item in `additions`.
         *
         * The parameters `position` and `n_removals` must be correct (ie:
         * `position` + `n_removals` must be less than or equal to the length of
         * the list at the time this function is called).
         * @param position the position at which to make the change
         * @param n_removals the number of items to remove
         * @param additions the items to add
         */
        splice(
            position: number,
            n_removals: number,
            additions: GObject.Object[]
        ): void;
        /**
         * Inserts `item` into `store` at a position to be determined by the
         * `compare_func`.
         *
         * The list must already be sorted before calling this function or the
         * result is undefined.  Usually you would approach this by only ever
         * inserting items by way of this function.
         *
         * This function takes a ref on `item`.
         * @param item the new item
         * @param compare_func pairwise comparison function for sorting
         * @returns the position at which @item was inserted
         */
        insert_sorted(item: A, compare_func: GLib.CompareDataFunc): number;
        sort(compare_func: GLib.CompareDataFunc): void;

        // Class property signals of Gio-2.0.Gio.ListStore

        connect(
            sigName: 'notify::item-type',
            callback: ($obj: ListStore, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::item-type',
            callback: ($obj: ListStore, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::item-type', ...args: any[]): void;
        connect(
            sigName: 'notify::n-items',
            callback: ($obj: ListStore, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::n-items',
            callback: ($obj: ListStore, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::n-items', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GListStore is a simple implementation of #GListModel that stores all
     * items in memory.
     *
     * It provides insertions, deletions, and lookups in logarithmic time
     * with a fast path for the common case of iterating the list linearly.
     * @class
     */
    class ListStore<
        A extends GObject.Object = GObject.Object
    > extends GObject.Object {
        // Own properties of Gio-2.0.Gio.ListStore

        static name: string;
        static $gtype: GObject.GType<ListStore>;

        // Constructors of Gio-2.0.Gio.ListStore

        constructor(config?: ListStore.ConstructorProperties);
        /**
         * Creates a new #GListStore with items of type `item_type`. `item_type`
         * must be a subclass of #GObject.
         * @constructor
         * @param item_type the #GType of items in the list
         * @returns a new #GListStore
         */
        constructor(item_type: GObject.GType);
        /**
         * Creates a new #GListStore with items of type `item_type`. `item_type`
         * must be a subclass of #GObject.
         * @constructor
         * @param item_type the #GType of items in the list
         * @returns a new #GListStore
         */
        static new(item_type: GObject.GType): ListStore;
        _init(config?: ListStore.ConstructorProperties): void;
    }

    namespace MemoryInputStream {
        // Constructor properties interface

        interface ConstructorProperties
            extends PollableInputStream.ConstructorProperties,
                Seekable.ConstructorProperties,
                InputStream.ConstructorProperties {}
    }

    interface MemoryInputStream extends PollableInputStream, Seekable {
        // Own fields of Gio-2.0.Gio.MemoryInputStream

        parent_instance: InputStream & GObject.Object;

        // Owm methods of Gio-2.0.Gio.MemoryInputStream

        /**
         * Appends `bytes` to data that can be read from the input stream.
         * @param bytes input data
         */
        add_bytes(bytes: GLib.Bytes): void;
        /**
         * Appends `data` to data that can be read from the input stream
         * @param data input data
         * @param destroy function that is called to free `data,` or %NULL
         */
        add_data(data: Uint8Array, destroy: GLib.DestroyNotify | null): void;

        // Class property signals of Gio-2.0.Gio.MemoryInputStream

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GMemoryInputStream is a class for using arbitrary
     * memory chunks as input for GIO streaming input operations.
     *
     * As of GLib 2.34, #GMemoryInputStream implements
     * #GPollableInputStream.
     * @class
     */
    class MemoryInputStream extends InputStream {
        // Own properties of Gio-2.0.Gio.MemoryInputStream

        static name: string;
        static $gtype: GObject.GType<MemoryInputStream>;

        // Constructors of Gio-2.0.Gio.MemoryInputStream

        constructor(config?: MemoryInputStream.ConstructorProperties);
        /**
         * Creates a new empty #GMemoryInputStream.
         * @constructor
         * @returns a new #GInputStream
         */
        constructor();
        /**
         * Creates a new empty #GMemoryInputStream.
         * @constructor
         * @returns a new #GInputStream
         */
        static new(): MemoryInputStream;
        /**
         * Creates a new #GMemoryInputStream with data from the given `bytes`.
         * @constructor
         * @param bytes a #GBytes
         * @returns new #GInputStream read from @bytes
         */
        static new_from_bytes(bytes: GLib.Bytes): MemoryInputStream;
        /**
         * Creates a new #GMemoryInputStream with data in memory of a given size.
         * @constructor
         * @param data input data
         * @param destroy function that is called to free `data,` or %NULL
         * @returns new #GInputStream read from @data of @len bytes.
         */
        static new_from_data(
            data: Uint8Array,
            destroy: GLib.DestroyNotify | null
        ): MemoryInputStream;
        _init(config?: MemoryInputStream.ConstructorProperties): void;
    }

    namespace MemoryOutputStream {
        // Constructor properties interface

        interface ConstructorProperties
            extends PollableOutputStream.ConstructorProperties,
                Seekable.ConstructorProperties,
                OutputStream.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.MemoryOutputStream

            /**
             * Pointer to buffer where data will be written.
             */
            data?: any | null;
            /**
             * Current size of the data buffer.
             */
            size?: number | null;
        }
    }

    interface MemoryOutputStream extends PollableOutputStream, Seekable {
        // Own properties of Gio-2.0.Gio.MemoryOutputStream

        /**
         * Pointer to buffer where data will be written.
         */
        readonly data: any;
        /**
         * Size of data written to the buffer.
         */
        readonly data_size: number;
        /**
         * Current size of the data buffer.
         */
        readonly size: number;

        // Own fields of Gio-2.0.Gio.MemoryOutputStream

        parent_instance: OutputStream & GObject.Object;

        // Owm methods of Gio-2.0.Gio.MemoryOutputStream

        /**
         * Gets any loaded data from the `ostream`.
         *
         * Note that the returned pointer may become invalid on the next
         * write or truncate operation on the stream.
         * @returns pointer to the stream's data, or %NULL if the data    has been stolen
         */
        get_data(): any | null;

        // Overloads of get_data

        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string | null): any | null;
        /**
         * Returns the number of bytes from the start up to including the last
         * byte written in the stream that has not been truncated away.
         * @returns the number of bytes written to the stream
         */
        get_data_size(): number;
        /**
         * Gets the size of the currently allocated data area (available from
         * g_memory_output_stream_get_data()).
         *
         * You probably don't want to use this function on resizable streams.
         * See g_memory_output_stream_get_data_size() instead.  For resizable
         * streams the size returned by this function is an implementation
         * detail and may be change at any time in response to operations on the
         * stream.
         *
         * If the stream is fixed-sized (ie: no realloc was passed to
         * g_memory_output_stream_new()) then this is the maximum size of the
         * stream and further writes will return %G_IO_ERROR_NO_SPACE.
         *
         * In any case, if you want the number of bytes currently written to the
         * stream, use g_memory_output_stream_get_data_size().
         * @returns the number of bytes allocated for the data buffer
         */
        get_size(): number;
        /**
         * Returns data from the `ostream` as a #GBytes. `ostream` must be
         * closed before calling this function.
         * @returns the stream's data
         */
        steal_as_bytes(): GLib.Bytes;
        /**
         * Gets any loaded data from the `ostream`. Ownership of the data
         * is transferred to the caller; when no longer needed it must be
         * freed using the free function set in `ostream'`s
         * #GMemoryOutputStream:destroy-function property.
         *
         * `ostream` must be closed before calling this function.
         * @returns the stream's data, or %NULL if it has previously    been stolen
         */
        steal_data(): any | null;

        // Overloads of steal_data

        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string | null): any | null;

        // Class property signals of Gio-2.0.Gio.MemoryOutputStream

        connect(
            sigName: 'notify::data',
            callback: (
                $obj: MemoryOutputStream,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::data',
            callback: (
                $obj: MemoryOutputStream,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::data', ...args: any[]): void;
        connect(
            sigName: 'notify::data-size',
            callback: (
                $obj: MemoryOutputStream,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::data-size',
            callback: (
                $obj: MemoryOutputStream,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::data-size', ...args: any[]): void;
        connect(
            sigName: 'notify::size',
            callback: (
                $obj: MemoryOutputStream,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::size',
            callback: (
                $obj: MemoryOutputStream,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::size', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GMemoryOutputStream is a class for using arbitrary
     * memory chunks as output for GIO streaming output operations.
     *
     * As of GLib 2.34, #GMemoryOutputStream trivially implements
     * #GPollableOutputStream: it always polls as ready.
     * @class
     */
    class MemoryOutputStream extends OutputStream {
        // Own properties of Gio-2.0.Gio.MemoryOutputStream

        static name: string;
        static $gtype: GObject.GType<MemoryOutputStream>;

        // Constructors of Gio-2.0.Gio.MemoryOutputStream

        constructor(config?: MemoryOutputStream.ConstructorProperties);
        /**
         * Creates a new #GMemoryOutputStream, using g_realloc() and g_free()
         * for memory allocation.
         * @constructor
         */
        static new_resizable(): MemoryOutputStream;
        _init(config?: MemoryOutputStream.ConstructorProperties): void;
    }

    namespace Menu {
        // Constructor properties interface

        type ConstructorProperties = MenuModel.ConstructorProperties;
    }

    interface Menu {
        // Owm methods of Gio-2.0.Gio.Menu

        /**
         * Convenience function for appending a normal menu item to the end of
         * `menu`.  Combine g_menu_item_new() and g_menu_insert_item() for a more
         * flexible alternative.
         * @param label the section label, or %NULL
         * @param detailed_action the detailed action string, or %NULL
         */
        append(label: string | null, detailed_action: string | null): void;
        /**
         * Appends `item` to the end of `menu`.
         *
         * See g_menu_insert_item() for more information.
         * @param item a #GMenuItem to append
         */
        append_item(item: MenuItem): void;
        /**
         * Convenience function for appending a section menu item to the end of
         * `menu`.  Combine g_menu_item_new_section() and g_menu_insert_item() for a
         * more flexible alternative.
         * @param label the section label, or %NULL
         * @param section a #GMenuModel with the items of the section
         */
        append_section(label: string | null, section: MenuModel): void;
        /**
         * Convenience function for appending a submenu menu item to the end of
         * `menu`.  Combine g_menu_item_new_submenu() and g_menu_insert_item() for a
         * more flexible alternative.
         * @param label the section label, or %NULL
         * @param submenu a #GMenuModel with the items of the submenu
         */
        append_submenu(label: string | null, submenu: MenuModel): void;
        /**
         * Marks `menu` as frozen.
         *
         * After the menu is frozen, it is an error to attempt to make any
         * changes to it.  In effect this means that the #GMenu API must no
         * longer be used.
         *
         * This function causes g_menu_model_is_mutable() to begin returning
         * %FALSE, which has some positive performance implications.
         */
        freeze(): void;
        /**
         * Convenience function for inserting a normal menu item into `menu`.
         * Combine g_menu_item_new() and g_menu_insert_item() for a more flexible
         * alternative.
         * @param position the position at which to insert the item
         * @param label the section label, or %NULL
         * @param detailed_action the detailed action string, or %NULL
         */
        insert(
            position: number,
            label: string | null,
            detailed_action: string | null
        ): void;
        /**
         * Inserts `item` into `menu`.
         *
         * The "insertion" is actually done by copying all of the attribute and
         * link values of `item` and using them to form a new item within `menu`.
         * As such, `item` itself is not really inserted, but rather, a menu item
         * that is exactly the same as the one presently described by `item`.
         *
         * This means that `item` is essentially useless after the insertion
         * occurs.  Any changes you make to it are ignored unless it is inserted
         * again (at which point its updated values will be copied).
         *
         * You should probably just free `item` once you're done.
         *
         * There are many convenience functions to take care of common cases.
         * See g_menu_insert(), g_menu_insert_section() and
         * g_menu_insert_submenu() as well as "prepend" and "append" variants of
         * each of these functions.
         * @param position the position at which to insert the item
         * @param item the #GMenuItem to insert
         */
        insert_item(position: number, item: MenuItem): void;
        /**
         * Convenience function for inserting a section menu item into `menu`.
         * Combine g_menu_item_new_section() and g_menu_insert_item() for a more
         * flexible alternative.
         * @param position the position at which to insert the item
         * @param label the section label, or %NULL
         * @param section a #GMenuModel with the items of the section
         */
        insert_section(
            position: number,
            label: string | null,
            section: MenuModel
        ): void;
        /**
         * Convenience function for inserting a submenu menu item into `menu`.
         * Combine g_menu_item_new_submenu() and g_menu_insert_item() for a more
         * flexible alternative.
         * @param position the position at which to insert the item
         * @param label the section label, or %NULL
         * @param submenu a #GMenuModel with the items of the submenu
         */
        insert_submenu(
            position: number,
            label: string | null,
            submenu: MenuModel
        ): void;
        /**
         * Convenience function for prepending a normal menu item to the start
         * of `menu`.  Combine g_menu_item_new() and g_menu_insert_item() for a more
         * flexible alternative.
         * @param label the section label, or %NULL
         * @param detailed_action the detailed action string, or %NULL
         */
        prepend(label: string | null, detailed_action: string | null): void;
        /**
         * Prepends `item` to the start of `menu`.
         *
         * See g_menu_insert_item() for more information.
         * @param item a #GMenuItem to prepend
         */
        prepend_item(item: MenuItem): void;
        /**
         * Convenience function for prepending a section menu item to the start
         * of `menu`.  Combine g_menu_item_new_section() and g_menu_insert_item() for
         * a more flexible alternative.
         * @param label the section label, or %NULL
         * @param section a #GMenuModel with the items of the section
         */
        prepend_section(label: string | null, section: MenuModel): void;
        /**
         * Convenience function for prepending a submenu menu item to the start
         * of `menu`.  Combine g_menu_item_new_submenu() and g_menu_insert_item() for
         * a more flexible alternative.
         * @param label the section label, or %NULL
         * @param submenu a #GMenuModel with the items of the submenu
         */
        prepend_submenu(label: string | null, submenu: MenuModel): void;
        /**
         * Removes an item from the menu.
         *
         * `position` gives the index of the item to remove.
         *
         * It is an error if position is not in range the range from 0 to one
         * less than the number of items in the menu.
         *
         * It is not possible to remove items by identity since items are added
         * to the menu simply by copying their links and attributes (ie:
         * identity of the item itself is not preserved).
         * @param position the position of the item to remove
         */
        remove(position: number): void;
        /**
         * Removes all items in the menu.
         */
        remove_all(): void;

        // Class property signals of Gio-2.0.Gio.Menu

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GMenu is a simple implementation of #GMenuModel.
     * You populate a #GMenu by adding #GMenuItem instances to it.
     *
     * There are some convenience functions to allow you to directly
     * add items (avoiding #GMenuItem) for the common cases. To add
     * a regular item, use g_menu_insert(). To add a section, use
     * g_menu_insert_section(). To add a submenu, use
     * g_menu_insert_submenu().
     * @class
     */
    class Menu extends MenuModel {
        // Own properties of Gio-2.0.Gio.Menu

        static name: string;
        static $gtype: GObject.GType<Menu>;

        // Constructors of Gio-2.0.Gio.Menu

        constructor(config?: Menu.ConstructorProperties);
        /**
         * Creates a new #GMenu.
         *
         * The new menu has no items.
         * @constructor
         * @returns a new #GMenu
         */
        constructor();
        /**
         * Creates a new #GMenu.
         *
         * The new menu has no items.
         * @constructor
         * @returns a new #GMenu
         */
        static new(): Menu;
        _init(config?: Menu.ConstructorProperties): void;
    }

    namespace MenuAttributeIter {
        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface MenuAttributeIter {
        // Own fields of Gio-2.0.Gio.MenuAttributeIter

        parent_instance: GObject.Object;
        priv: MenuAttributeIterPrivate;

        // Owm methods of Gio-2.0.Gio.MenuAttributeIter

        /**
         * Gets the name of the attribute at the current iterator position, as
         * a string.
         *
         * The iterator is not advanced.
         * @returns the name of the attribute
         */
        get_name(): string | null;
        /**
         * This function combines g_menu_attribute_iter_next() with
         * g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value().
         *
         * First the iterator is advanced to the next (possibly first) attribute.
         * If that fails, then %FALSE is returned and there are no other
         * effects.
         *
         * If successful, `name` and `value` are set to the name and value of the
         * attribute that has just been advanced to.  At this point,
         * g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value() will
         * return the same values again.
         *
         * The value returned in `name` remains valid for as long as the iterator
         * remains at the current position.  The value returned in `value` must
         * be unreffed using g_variant_unref() when it is no longer in use.
         * @returns %TRUE on success, or %FALSE if there is no additional     attribute
         */
        get_next(): [
            /* returnType */ boolean,
            /* out_name */ string | null,
            /* value */ GLib.Variant
        ];
        /**
         * Gets the value of the attribute at the current iterator position.
         *
         * The iterator is not advanced.
         * @returns the value of the current attribute
         */
        get_value(): GLib.Variant;
        /**
         * Attempts to advance the iterator to the next (possibly first)
         * attribute.
         *
         * %TRUE is returned on success, or %FALSE if there are no more
         * attributes.
         *
         * You must call this function when you first acquire the iterator
         * to advance it to the first attribute (and determine if the first
         * attribute exists at all).
         * @returns %TRUE on success, or %FALSE when there are no more attributes
         */
        next(): boolean;

        // Own virtual methods of Gio-2.0.Gio.MenuAttributeIter

        /**
         * This function combines g_menu_attribute_iter_next() with
         * g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value().
         *
         * First the iterator is advanced to the next (possibly first) attribute.
         * If that fails, then %FALSE is returned and there are no other
         * effects.
         *
         * If successful, `name` and `value` are set to the name and value of the
         * attribute that has just been advanced to.  At this point,
         * g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value() will
         * return the same values again.
         *
         * The value returned in `name` remains valid for as long as the iterator
         * remains at the current position.  The value returned in `value` must
         * be unreffed using g_variant_unref() when it is no longer in use.
         * @virtual
         * @returns %TRUE on success, or %FALSE if there is no additional     attribute
         */
        vfunc_get_next(): [
            /* returnType */ boolean,
            /* out_name */ string | null,
            /* value */ GLib.Variant
        ];

        // Class property signals of Gio-2.0.Gio.MenuAttributeIter

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GMenuAttributeIter is an opaque structure type.  You must access it
     * using the functions below.
     * @class
     */
    class MenuAttributeIter extends GObject.Object {
        // Own properties of Gio-2.0.Gio.MenuAttributeIter

        static name: string;
        static $gtype: GObject.GType<MenuAttributeIter>;

        // Constructors of Gio-2.0.Gio.MenuAttributeIter

        constructor(config?: MenuAttributeIter.ConstructorProperties);
        _init(config?: MenuAttributeIter.ConstructorProperties): void;
    }

    namespace MenuItem {
        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface MenuItem {
        // Owm methods of Gio-2.0.Gio.MenuItem

        /**
         * Queries the named `attribute` on `menu_item`.
         *
         * If `expected_type` is specified and the attribute does not have this
         * type, %NULL is returned.  %NULL is also returned if the attribute
         * simply does not exist.
         * @param attribute the attribute name to query
         * @param expected_type the expected type of the attribute
         * @returns the attribute value, or %NULL
         */
        get_attribute_value(
            attribute: string | null,
            expected_type: GLib.VariantType | null
        ): GLib.Variant | null;
        /**
         * Queries the named `link` on `menu_item`.
         * @param link the link name to query
         * @returns the link, or %NULL
         */
        get_link(link: string | null): MenuModel | null;
        /**
         * Sets or unsets the "action" and "target" attributes of `menu_item`.
         *
         * If `action` is %NULL then both the "action" and "target" attributes
         * are unset (and `target_value` is ignored).
         *
         * If `action` is non-%NULL then the "action" attribute is set.  The
         * "target" attribute is then set to the value of `target_value` if it is
         * non-%NULL or unset otherwise.
         *
         * Normal menu items (ie: not submenu, section or other custom item
         * types) are expected to have the "action" attribute set to identify
         * the action that they are associated with.  The state type of the
         * action help to determine the disposition of the menu item.  See
         * #GAction and #GActionGroup for an overview of actions.
         *
         * In general, clicking on the menu item will result in activation of
         * the named action with the "target" attribute given as the parameter
         * to the action invocation.  If the "target" attribute is not set then
         * the action is invoked with no parameter.
         *
         * If the action has no state then the menu item is usually drawn as a
         * plain menu item (ie: with no additional decoration).
         *
         * If the action has a boolean state then the menu item is usually drawn
         * as a toggle menu item (ie: with a checkmark or equivalent
         * indication).  The item should be marked as 'toggled' or 'checked'
         * when the boolean state is %TRUE.
         *
         * If the action has a string state then the menu item is usually drawn
         * as a radio menu item (ie: with a radio bullet or equivalent
         * indication).  The item should be marked as 'selected' when the string
         * state is equal to the value of the `target` property.
         *
         * See g_menu_item_set_action_and_target() or
         * g_menu_item_set_detailed_action() for two equivalent calls that are
         * probably more convenient for most uses.
         * @param action the name of the action for this item
         * @param target_value a #GVariant to use as the action target
         */
        set_action_and_target_value(
            action: string | null,
            target_value: GLib.Variant | null
        ): void;
        /**
         * Sets or unsets an attribute on `menu_item`.
         *
         * The attribute to set or unset is specified by `attribute`. This
         * can be one of the standard attribute names %G_MENU_ATTRIBUTE_LABEL,
         * %G_MENU_ATTRIBUTE_ACTION, %G_MENU_ATTRIBUTE_TARGET, or a custom
         * attribute name.
         * Attribute names are restricted to lowercase characters, numbers
         * and '-'. Furthermore, the names must begin with a lowercase character,
         * must not end with a '-', and must not contain consecutive dashes.
         *
         * must consist only of lowercase
         * ASCII characters, digits and '-'.
         *
         * If `value` is non-%NULL then it is used as the new value for the
         * attribute.  If `value` is %NULL then the attribute is unset. If
         * the `value` #GVariant is floating, it is consumed.
         *
         * See also g_menu_item_set_attribute() for a more convenient way to do
         * the same.
         * @param attribute the attribute to set
         * @param value a #GVariant to use as the value, or %NULL
         */
        set_attribute_value(
            attribute: string | null,
            value: GLib.Variant | null
        ): void;
        /**
         * Sets the "action" and possibly the "target" attribute of `menu_item`.
         *
         * The format of `detailed_action` is the same format parsed by
         * g_action_parse_detailed_name().
         *
         * See g_menu_item_set_action_and_target() or
         * g_menu_item_set_action_and_target_value() for more flexible (but
         * slightly less convenient) alternatives.
         *
         * See also g_menu_item_set_action_and_target_value() for a description of
         * the semantics of the action and target attributes.
         * @param detailed_action the "detailed" action string
         */
        set_detailed_action(detailed_action: string | null): void;
        /**
         * Sets (or unsets) the icon on `menu_item`.
         *
         * This call is the same as calling g_icon_serialize() and using the
         * result as the value to g_menu_item_set_attribute_value() for
         * %G_MENU_ATTRIBUTE_ICON.
         *
         * This API is only intended for use with "noun" menu items; things like
         * bookmarks or applications in an "Open With" menu.  Don't use it on
         * menu items corresponding to verbs (eg: stock icons for 'Save' or
         * 'Quit').
         *
         * If `icon` is %NULL then the icon is unset.
         * @param icon a #GIcon, or %NULL
         */
        set_icon(icon: Icon): void;
        /**
         * Sets or unsets the "label" attribute of `menu_item`.
         *
         * If `label` is non-%NULL it is used as the label for the menu item.  If
         * it is %NULL then the label attribute is unset.
         * @param label the label to set, or %NULL to unset
         */
        set_label(label: string | null): void;
        /**
         * Creates a link from `menu_item` to `model` if non-%NULL, or unsets it.
         *
         * Links are used to establish a relationship between a particular menu
         * item and another menu.  For example, %G_MENU_LINK_SUBMENU is used to
         * associate a submenu with a particular menu item, and %G_MENU_LINK_SECTION
         * is used to create a section. Other types of link can be used, but there
         * is no guarantee that clients will be able to make sense of them.
         * Link types are restricted to lowercase characters, numbers
         * and '-'. Furthermore, the names must begin with a lowercase character,
         * must not end with a '-', and must not contain consecutive dashes.
         * @param link type of link to establish or unset
         * @param model the #GMenuModel to link to (or %NULL to unset)
         */
        set_link(link: string | null, model: MenuModel | null): void;
        /**
         * Sets or unsets the "section" link of `menu_item` to `section`.
         *
         * The effect of having one menu appear as a section of another is
         * exactly as it sounds: the items from `section` become a direct part of
         * the menu that `menu_item` is added to.  See g_menu_item_new_section()
         * for more information about what it means for a menu item to be a
         * section.
         * @param section a #GMenuModel, or %NULL
         */
        set_section(section: MenuModel | null): void;
        /**
         * Sets or unsets the "submenu" link of `menu_item` to `submenu`.
         *
         * If `submenu` is non-%NULL, it is linked to.  If it is %NULL then the
         * link is unset.
         *
         * The effect of having one menu appear as a submenu of another is
         * exactly as it sounds.
         * @param submenu a #GMenuModel, or %NULL
         */
        set_submenu(submenu: MenuModel | null): void;

        // Class property signals of Gio-2.0.Gio.MenuItem

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GMenuItem is an opaque structure type.  You must access it using the
     * functions below.
     * @class
     */
    class MenuItem extends GObject.Object {
        // Own properties of Gio-2.0.Gio.MenuItem

        static name: string;
        static $gtype: GObject.GType<MenuItem>;

        // Constructors of Gio-2.0.Gio.MenuItem

        constructor(config?: MenuItem.ConstructorProperties);
        /**
         * Creates a new #GMenuItem.
         *
         * If `label` is non-%NULL it is used to set the "label" attribute of the
         * new item.
         *
         * If `detailed_action` is non-%NULL it is used to set the "action" and
         * possibly the "target" attribute of the new item.  See
         * g_menu_item_set_detailed_action() for more information.
         * @constructor
         * @param label the section label, or %NULL
         * @param detailed_action the detailed action string, or %NULL
         * @returns a new #GMenuItem
         */
        constructor(label: string | null, detailed_action: string | null);
        /**
         * Creates a new #GMenuItem.
         *
         * If `label` is non-%NULL it is used to set the "label" attribute of the
         * new item.
         *
         * If `detailed_action` is non-%NULL it is used to set the "action" and
         * possibly the "target" attribute of the new item.  See
         * g_menu_item_set_detailed_action() for more information.
         * @constructor
         * @param label the section label, or %NULL
         * @param detailed_action the detailed action string, or %NULL
         * @returns a new #GMenuItem
         */
        static new(
            label: string | null,
            detailed_action: string | null
        ): MenuItem;
        /**
         * Creates a #GMenuItem as an exact copy of an existing menu item in a
         * #GMenuModel.
         *
         * `item_index` must be valid (ie: be sure to call
         * g_menu_model_get_n_items() first).
         * @constructor
         * @param model a #GMenuModel
         * @param item_index the index of an item in `model`
         * @returns a new #GMenuItem.
         */
        static new_from_model(model: MenuModel, item_index: number): MenuItem;
        /**
         * Creates a new #GMenuItem representing a section.
         *
         * This is a convenience API around g_menu_item_new() and
         * g_menu_item_set_section().
         *
         * The effect of having one menu appear as a section of another is
         * exactly as it sounds: the items from `section` become a direct part of
         * the menu that `menu_item` is added to.
         *
         * Visual separation is typically displayed between two non-empty
         * sections.  If `label` is non-%NULL then it will be encorporated into
         * this visual indication.  This allows for labeled subsections of a
         * menu.
         *
         * As a simple example, consider a typical "Edit" menu from a simple
         * program.  It probably contains an "Undo" and "Redo" item, followed by
         * a separator, followed by "Cut", "Copy" and "Paste".
         *
         * This would be accomplished by creating three #GMenu instances.  The
         * first would be populated with the "Undo" and "Redo" items, and the
         * second with the "Cut", "Copy" and "Paste" items.  The first and
         * second menus would then be added as submenus of the third.  In XML
         * format, this would look something like the following:
         *
         * ```
         * <menu id='edit-menu'>
         *   <section>
         *     <item label='Undo'/>
         *     <item label='Redo'/>
         *   </section>
         *   <section>
         *     <item label='Cut'/>
         *     <item label='Copy'/>
         *     <item label='Paste'/>
         *   </section>
         * </menu>
         * ```
         *
         *
         * The following example is exactly equivalent.  It is more illustrative
         * of the exact relationship between the menus and items (keeping in
         * mind that the 'link' element defines a new menu that is linked to the
         * containing one).  The style of the second example is more verbose and
         * difficult to read (and therefore not recommended except for the
         * purpose of understanding what is really going on).
         *
         * ```
         * <menu id='edit-menu'>
         *   <item>
         *     <link name='section'>
         *       <item label='Undo'/>
         *       <item label='Redo'/>
         *     </link>
         *   </item>
         *   <item>
         *     <link name='section'>
         *       <item label='Cut'/>
         *       <item label='Copy'/>
         *       <item label='Paste'/>
         *     </link>
         *   </item>
         * </menu>
         * ```
         *
         * @constructor
         * @param label the section label, or %NULL
         * @param section a #GMenuModel with the items of the section
         * @returns a new #GMenuItem
         */
        static new_section(label: string | null, section: MenuModel): MenuItem;
        /**
         * Creates a new #GMenuItem representing a submenu.
         *
         * This is a convenience API around g_menu_item_new() and
         * g_menu_item_set_submenu().
         * @constructor
         * @param label the section label, or %NULL
         * @param submenu a #GMenuModel with the items of the submenu
         * @returns a new #GMenuItem
         */
        static new_submenu(label: string | null, submenu: MenuModel): MenuItem;
        _init(config?: MenuItem.ConstructorProperties): void;
    }

    namespace MenuLinkIter {
        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface MenuLinkIter {
        // Own fields of Gio-2.0.Gio.MenuLinkIter

        parent_instance: GObject.Object;
        priv: MenuLinkIterPrivate;

        // Owm methods of Gio-2.0.Gio.MenuLinkIter

        /**
         * Gets the name of the link at the current iterator position.
         *
         * The iterator is not advanced.
         * @returns the type of the link
         */
        get_name(): string | null;
        /**
         * This function combines g_menu_link_iter_next() with
         * g_menu_link_iter_get_name() and g_menu_link_iter_get_value().
         *
         * First the iterator is advanced to the next (possibly first) link.
         * If that fails, then %FALSE is returned and there are no other effects.
         *
         * If successful, `out_link` and `value` are set to the name and #GMenuModel
         * of the link that has just been advanced to.  At this point,
         * g_menu_link_iter_get_name() and g_menu_link_iter_get_value() will return the
         * same values again.
         *
         * The value returned in `out_link` remains valid for as long as the iterator
         * remains at the current position.  The value returned in `value` must
         * be unreffed using g_object_unref() when it is no longer in use.
         * @returns %TRUE on success, or %FALSE if there is no additional link
         */
        get_next(): [
            /* returnType */ boolean,
            /* out_link */ string | null,
            /* value */ MenuModel
        ];
        /**
         * Gets the linked #GMenuModel at the current iterator position.
         *
         * The iterator is not advanced.
         * @returns the #GMenuModel that is linked to
         */
        get_value(): MenuModel;
        /**
         * Attempts to advance the iterator to the next (possibly first)
         * link.
         *
         * %TRUE is returned on success, or %FALSE if there are no more links.
         *
         * You must call this function when you first acquire the iterator to
         * advance it to the first link (and determine if the first link exists
         * at all).
         * @returns %TRUE on success, or %FALSE when there are no more links
         */
        next(): boolean;

        // Own virtual methods of Gio-2.0.Gio.MenuLinkIter

        /**
         * This function combines g_menu_link_iter_next() with
         * g_menu_link_iter_get_name() and g_menu_link_iter_get_value().
         *
         * First the iterator is advanced to the next (possibly first) link.
         * If that fails, then %FALSE is returned and there are no other effects.
         *
         * If successful, `out_link` and `value` are set to the name and #GMenuModel
         * of the link that has just been advanced to.  At this point,
         * g_menu_link_iter_get_name() and g_menu_link_iter_get_value() will return the
         * same values again.
         *
         * The value returned in `out_link` remains valid for as long as the iterator
         * remains at the current position.  The value returned in `value` must
         * be unreffed using g_object_unref() when it is no longer in use.
         * @virtual
         * @returns %TRUE on success, or %FALSE if there is no additional link
         */
        vfunc_get_next(): [
            /* returnType */ boolean,
            /* out_link */ string | null,
            /* value */ MenuModel
        ];

        // Class property signals of Gio-2.0.Gio.MenuLinkIter

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GMenuLinkIter is an opaque structure type.  You must access it using
     * the functions below.
     * @class
     */
    class MenuLinkIter extends GObject.Object {
        // Own properties of Gio-2.0.Gio.MenuLinkIter

        static name: string;
        static $gtype: GObject.GType<MenuLinkIter>;

        // Constructors of Gio-2.0.Gio.MenuLinkIter

        constructor(config?: MenuLinkIter.ConstructorProperties);
        _init(config?: MenuLinkIter.ConstructorProperties): void;
    }

    namespace MenuModel {
        // Signal callback interfaces

        /**
         * Signal callback interface for `items-changed`
         */
        interface ItemsChangedSignalCallback {
            (
                $obj: MenuModel,
                position: number,
                removed: number,
                added: number
            ): void;
        }

        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface MenuModel {
        // Own fields of Gio-2.0.Gio.MenuModel

        parent_instance: GObject.Object;
        priv: MenuModelPrivate;

        // Owm methods of Gio-2.0.Gio.MenuModel

        /**
         * Queries the item at position `item_index` in `model` for the attribute
         * specified by `attribute`.
         *
         * If `expected_type` is non-%NULL then it specifies the expected type of
         * the attribute.  If it is %NULL then any type will be accepted.
         *
         * If the attribute exists and matches `expected_type` (or if the
         * expected type is unspecified) then the value is returned.
         *
         * If the attribute does not exist, or does not match the expected type
         * then %NULL is returned.
         * @param item_index the index of the item
         * @param attribute the attribute to query
         * @param expected_type the expected type of the attribute, or     %NULL
         * @returns the value of the attribute
         */
        get_item_attribute_value(
            item_index: number,
            attribute: string | null,
            expected_type: GLib.VariantType | null
        ): GLib.Variant | null;
        /**
         * Queries the item at position `item_index` in `model` for the link
         * specified by `link`.
         *
         * If the link exists, the linked #GMenuModel is returned.  If the link
         * does not exist, %NULL is returned.
         * @param item_index the index of the item
         * @param link the link to query
         * @returns the linked #GMenuModel, or %NULL
         */
        get_item_link(
            item_index: number,
            link: string | null
        ): MenuModel | null;
        /**
         * Query the number of items in `model`.
         * @returns the number of items
         */
        get_n_items(): number;
        /**
         * Queries if `model` is mutable.
         *
         * An immutable #GMenuModel will never emit the #GMenuModel::items-changed
         * signal. Consumers of the model may make optimisations accordingly.
         * @returns %TRUE if the model is mutable (ie: "items-changed" may be     emitted).
         */
        is_mutable(): boolean;
        /**
         * Requests emission of the #GMenuModel::items-changed signal on `model`.
         *
         * This function should never be called except by #GMenuModel
         * subclasses.  Any other calls to this function will very likely lead
         * to a violation of the interface of the model.
         *
         * The implementation should update its internal representation of the
         * menu before emitting the signal.  The implementation should further
         * expect to receive queries about the new state of the menu (and
         * particularly added menu items) while signal handlers are running.
         *
         * The implementation must dispatch this call directly from a mainloop
         * entry and not in response to calls -- particularly those from the
         * #GMenuModel API.  Said another way: the menu must not change while
         * user code is running without returning to the mainloop.
         * @param position the position of the change
         * @param removed the number of items removed
         * @param added the number of items added
         */
        items_changed(position: number, removed: number, added: number): void;
        /**
         * Creates a #GMenuAttributeIter to iterate over the attributes of
         * the item at position `item_index` in `model`.
         *
         * You must free the iterator with g_object_unref() when you are done.
         * @param item_index the index of the item
         * @returns a new #GMenuAttributeIter
         */
        iterate_item_attributes(item_index: number): MenuAttributeIter;
        /**
         * Creates a #GMenuLinkIter to iterate over the links of the item at
         * position `item_index` in `model`.
         *
         * You must free the iterator with g_object_unref() when you are done.
         * @param item_index the index of the item
         * @returns a new #GMenuLinkIter
         */
        iterate_item_links(item_index: number): MenuLinkIter;

        // Own virtual methods of Gio-2.0.Gio.MenuModel

        /**
         * Queries the item at position `item_index` in `model` for the attribute
         * specified by `attribute`.
         *
         * If `expected_type` is non-%NULL then it specifies the expected type of
         * the attribute.  If it is %NULL then any type will be accepted.
         *
         * If the attribute exists and matches `expected_type` (or if the
         * expected type is unspecified) then the value is returned.
         *
         * If the attribute does not exist, or does not match the expected type
         * then %NULL is returned.
         * @virtual
         * @param item_index the index of the item
         * @param attribute the attribute to query
         * @param expected_type the expected type of the attribute, or     %NULL
         * @returns the value of the attribute
         */
        vfunc_get_item_attribute_value(
            item_index: number,
            attribute: string | null,
            expected_type: GLib.VariantType | null
        ): GLib.Variant | null;
        /**
         * Gets all the attributes associated with the item in the menu model.
         * @virtual
         * @param item_index The #GMenuItem to query
         */
        vfunc_get_item_attributes(
            item_index: number
        ): /* attributes */ GLib.HashTable;
        /**
         * Queries the item at position `item_index` in `model` for the link
         * specified by `link`.
         *
         * If the link exists, the linked #GMenuModel is returned.  If the link
         * does not exist, %NULL is returned.
         * @virtual
         * @param item_index the index of the item
         * @param link the link to query
         * @returns the linked #GMenuModel, or %NULL
         */
        vfunc_get_item_link(
            item_index: number,
            link: string | null
        ): MenuModel | null;
        /**
         * Gets all the links associated with the item in the menu model.
         * @virtual
         * @param item_index The #GMenuItem to query
         */
        vfunc_get_item_links(item_index: number): /* links */ GLib.HashTable;
        /**
         * Query the number of items in `model`.
         * @virtual
         * @returns the number of items
         */
        vfunc_get_n_items(): number;
        /**
         * Queries if `model` is mutable.
         *
         * An immutable #GMenuModel will never emit the #GMenuModel::items-changed
         * signal. Consumers of the model may make optimisations accordingly.
         * @virtual
         * @returns %TRUE if the model is mutable (ie: "items-changed" may be     emitted).
         */
        vfunc_is_mutable(): boolean;
        /**
         * Creates a #GMenuAttributeIter to iterate over the attributes of
         * the item at position `item_index` in `model`.
         *
         * You must free the iterator with g_object_unref() when you are done.
         * @virtual
         * @param item_index the index of the item
         * @returns a new #GMenuAttributeIter
         */
        vfunc_iterate_item_attributes(item_index: number): MenuAttributeIter;
        /**
         * Creates a #GMenuLinkIter to iterate over the links of the item at
         * position `item_index` in `model`.
         *
         * You must free the iterator with g_object_unref() when you are done.
         * @virtual
         * @param item_index the index of the item
         * @returns a new #GMenuLinkIter
         */
        vfunc_iterate_item_links(item_index: number): MenuLinkIter;

        // Own signals of Gio-2.0.Gio.MenuModel

        connect(
            sigName: 'items-changed',
            callback: MenuModel.ItemsChangedSignalCallback
        ): number;
        connect_after(
            sigName: 'items-changed',
            callback: MenuModel.ItemsChangedSignalCallback
        ): number;
        emit(
            sigName: 'items-changed',
            position: number,
            removed: number,
            added: number,
            ...args: any[]
        ): void;

        // Class property signals of Gio-2.0.Gio.MenuModel

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GMenuModel represents the contents of a menu -- an ordered list of
     * menu items. The items are associated with actions, which can be
     * activated through them. Items can be grouped in sections, and may
     * have submenus associated with them. Both items and sections usually
     * have some representation data, such as labels or icons. The type of
     * the associated action (ie whether it is stateful, and what kind of
     * state it has) can influence the representation of the item.
     *
     * The conceptual model of menus in #GMenuModel is hierarchical:
     * sections and submenus are again represented by #GMenuModels.
     * Menus themselves do not define their own roles. Rather, the role
     * of a particular #GMenuModel is defined by the item that references
     * it (or, in the case of the 'root' menu, is defined by the context
     * in which it is used).
     *
     * As an example, consider the visible portions of this menu:
     *
     * ## An example menu # {#menu-example}
     *
     * ![](menu-example.png)
     *
     * There are 8 "menus" visible in the screenshot: one menubar, two
     * submenus and 5 sections:
     *
     * - the toplevel menubar (containing 4 items)
     * - the View submenu (containing 3 sections)
     * - the first section of the View submenu (containing 2 items)
     * - the second section of the View submenu (containing 1 item)
     * - the final section of the View submenu (containing 1 item)
     * - the Highlight Mode submenu (containing 2 sections)
     * - the Sources section (containing 2 items)
     * - the Markup section (containing 2 items)
     *
     * The [example][menu-model] illustrates the conceptual connection between
     * these 8 menus. Each large block in the figure represents a menu and the
     * smaller blocks within the large block represent items in that menu. Some
     * items contain references to other menus.
     *
     * ## A menu example # {#menu-model}
     *
     * ![](menu-model.png)
     *
     * Notice that the separators visible in the [example][menu-example]
     * appear nowhere in the [menu model][menu-model]. This is because
     * separators are not explicitly represented in the menu model. Instead,
     * a separator is inserted between any two non-empty sections of a menu.
     * Section items can have labels just like any other item. In that case,
     * a display system may show a section header instead of a separator.
     *
     * The motivation for this abstract model of application controls is
     * that modern user interfaces tend to make these controls available
     * outside the application. Examples include global menus, jumplists,
     * dash boards, etc. To support such uses, it is necessary to 'export'
     * information about actions and their representation in menus, which
     * is exactly what the [GActionGroup exporter][gio-GActionGroup-exporter]
     * and the [GMenuModel exporter][gio-GMenuModel-exporter] do for
     * #GActionGroup and #GMenuModel. The client-side counterparts to
     * make use of the exported information are #GDBusActionGroup and
     * #GDBusMenuModel.
     *
     * The API of #GMenuModel is very generic, with iterators for the
     * attributes and links of an item, see g_menu_model_iterate_item_attributes()
     * and g_menu_model_iterate_item_links(). The 'standard' attributes and
     * link types have predefined names: %G_MENU_ATTRIBUTE_LABEL,
     * %G_MENU_ATTRIBUTE_ACTION, %G_MENU_ATTRIBUTE_TARGET, %G_MENU_LINK_SECTION
     * and %G_MENU_LINK_SUBMENU.
     *
     * Items in a #GMenuModel represent active controls if they refer to
     * an action that can get activated when the user interacts with the
     * menu item. The reference to the action is encoded by the string id
     * in the %G_MENU_ATTRIBUTE_ACTION attribute. An action id uniquely
     * identifies an action in an action group. Which action group(s) provide
     * actions depends on the context in which the menu model is used.
     * E.g. when the model is exported as the application menu of a
     * #GtkApplication, actions can be application-wide or window-specific
     * (and thus come from two different action groups). By convention, the
     * application-wide actions have names that start with "app.", while the
     * names of window-specific actions start with "win.".
     *
     * While a wide variety of stateful actions is possible, the following
     * is the minimum that is expected to be supported by all users of exported
     * menu information:
     * - an action with no parameter type and no state
     * - an action with no parameter type and boolean state
     * - an action with string parameter type and string state
     *
     * ## Stateless
     *
     * A stateless action typically corresponds to an ordinary menu item.
     *
     * Selecting such a menu item will activate the action (with no parameter).
     *
     * ## Boolean State
     *
     * An action with a boolean state will most typically be used with a "toggle"
     * or "switch" menu item. The state can be set directly, but activating the
     * action (with no parameter) results in the state being toggled.
     *
     * Selecting a toggle menu item will activate the action. The menu item should
     * be rendered as "checked" when the state is true.
     *
     * ## String Parameter and State
     *
     * Actions with string parameters and state will most typically be used to
     * represent an enumerated choice over the items available for a group of
     * radio menu items. Activating the action with a string parameter is
     * equivalent to setting that parameter as the state.
     *
     * Radio menu items, in addition to being associated with the action, will
     * have a target value. Selecting that menu item will result in activation
     * of the action with the target value as the parameter. The menu item should
     * be rendered as "selected" when the state of the action is equal to the
     * target value of the menu item.
     * @class
     */
    class MenuModel extends GObject.Object {
        // Own properties of Gio-2.0.Gio.MenuModel

        static name: string;
        static $gtype: GObject.GType<MenuModel>;

        // Constructors of Gio-2.0.Gio.MenuModel

        constructor(config?: MenuModel.ConstructorProperties);
        _init(config?: MenuModel.ConstructorProperties): void;
    }

    namespace MountOperation {
        // Signal callback interfaces

        /**
         * Signal callback interface for `aborted`
         */
        interface AbortedSignalCallback {
            ($obj: MountOperation): void;
        }

        /**
         * Signal callback interface for `ask-password`
         */
        interface AskPasswordSignalCallback {
            (
                $obj: MountOperation,
                message: string | null,
                default_user: string | null,
                default_domain: string | null,
                flags: AskPasswordFlags
            ): void;
        }

        /**
         * Signal callback interface for `ask-question`
         */
        interface AskQuestionSignalCallback {
            (
                $obj: MountOperation,
                message: string | null,
                choices: string[]
            ): void;
        }

        /**
         * Signal callback interface for `reply`
         */
        interface ReplySignalCallback {
            ($obj: MountOperation, result: MountOperationResult): void;
        }

        /**
         * Signal callback interface for `show-processes`
         */
        interface ShowProcessesSignalCallback {
            (
                $obj: MountOperation,
                message: string | null,
                processes: GLib.Pid[],
                choices: string[]
            ): void;
        }

        /**
         * Signal callback interface for `show-unmount-progress`
         */
        interface ShowUnmountProgressSignalCallback {
            (
                $obj: MountOperation,
                message: string | null,
                time_left: number,
                bytes_left: number
            ): void;
        }

        // Constructor properties interface

        interface ConstructorProperties
            extends GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.MountOperation

            /**
             * Whether to use an anonymous user when authenticating.
             */
            anonymous?: boolean | null;
            /**
             * The index of the user's choice when a question is asked during the
             * mount operation. See the #GMountOperation::ask-question signal.
             */
            choice?: number | null;
            /**
             * The domain to use for the mount operation.
             */
            domain?: string | null;
            /**
             * Whether the device to be unlocked is a TCRYPT hidden volume.
             * See [the VeraCrypt documentation](https://www.veracrypt.fr/en/Hidden%20Volume.html).
             */
            is_tcrypt_hidden_volume?: boolean | null;
            /**
             * Whether the device to be unlocked is a TCRYPT system volume.
             * In this context, a system volume is a volume with a bootloader
             * and operating system installed. This is only supported for Windows
             * operating systems. For further documentation, see
             * [the VeraCrypt documentation](https://www.veracrypt.fr/en/System%20Encryption.html).
             */
            is_tcrypt_system_volume?: boolean | null;
            /**
             * The password that is used for authentication when carrying out
             * the mount operation.
             */
            password?: string | null;
            /**
             * Determines if and how the password information should be saved.
             */
            password_save?: PasswordSave | null;
            /**
             * The VeraCrypt PIM value, when unlocking a VeraCrypt volume. See
             * [the VeraCrypt documentation](https://www.veracrypt.fr/en/Personal%20Iterations%20Multiplier%20(PIM).html).
             */
            pim?: number | null;
            /**
             * The user name that is used for authentication when carrying out
             * the mount operation.
             */
            username?: string | null;
        }
    }

    interface MountOperation {
        // Own properties of Gio-2.0.Gio.MountOperation

        /**
         * Whether to use an anonymous user when authenticating.
         */
        anonymous: boolean;
        /**
         * The index of the user's choice when a question is asked during the
         * mount operation. See the #GMountOperation::ask-question signal.
         */
        choice: number;
        /**
         * The domain to use for the mount operation.
         */
        domain: string | null;
        /**
         * Whether the device to be unlocked is a TCRYPT hidden volume.
         * See [the VeraCrypt documentation](https://www.veracrypt.fr/en/Hidden%20Volume.html).
         */
        is_tcrypt_hidden_volume: boolean;
        /**
         * Whether the device to be unlocked is a TCRYPT system volume.
         * In this context, a system volume is a volume with a bootloader
         * and operating system installed. This is only supported for Windows
         * operating systems. For further documentation, see
         * [the VeraCrypt documentation](https://www.veracrypt.fr/en/System%20Encryption.html).
         */
        is_tcrypt_system_volume: boolean;
        /**
         * The password that is used for authentication when carrying out
         * the mount operation.
         */
        password: string | null;
        /**
         * Determines if and how the password information should be saved.
         */
        password_save: PasswordSave;
        /**
         * The VeraCrypt PIM value, when unlocking a VeraCrypt volume. See
         * [the VeraCrypt documentation](https://www.veracrypt.fr/en/Personal%20Iterations%20Multiplier%20(PIM).html).
         */
        pim: number;
        /**
         * The user name that is used for authentication when carrying out
         * the mount operation.
         */
        username: string | null;

        // Own fields of Gio-2.0.Gio.MountOperation

        parent_instance: GObject.Object;
        priv: MountOperationPrivate;

        // Owm methods of Gio-2.0.Gio.MountOperation

        /**
         * Check to see whether the mount operation is being used
         * for an anonymous user.
         * @returns %TRUE if mount operation is anonymous.
         */
        get_anonymous(): boolean;
        /**
         * Gets a choice from the mount operation.
         * @returns an integer containing an index of the user's choice from the choice's list, or `0`.
         */
        get_choice(): number;
        /**
         * Gets the domain of the mount operation.
         * @returns a string set to the domain.
         */
        get_domain(): string | null;
        /**
         * Check to see whether the mount operation is being used
         * for a TCRYPT hidden volume.
         * @returns %TRUE if mount operation is for hidden volume.
         */
        get_is_tcrypt_hidden_volume(): boolean;
        /**
         * Check to see whether the mount operation is being used
         * for a TCRYPT system volume.
         * @returns %TRUE if mount operation is for system volume.
         */
        get_is_tcrypt_system_volume(): boolean;
        /**
         * Gets a password from the mount operation.
         * @returns a string containing the password within @op.
         */
        get_password(): string | null;
        /**
         * Gets the state of saving passwords for the mount operation.
         * @returns a #GPasswordSave flag.
         */
        get_password_save(): PasswordSave;
        /**
         * Gets a PIM from the mount operation.
         * @returns The VeraCrypt PIM within @op.
         */
        get_pim(): number;
        /**
         * Get the user name from the mount operation.
         * @returns a string containing the user name.
         */
        get_username(): string | null;
        /**
         * Emits the #GMountOperation::reply signal.
         * @param result a #GMountOperationResult
         */
        reply(result: MountOperationResult): void;
        /**
         * Sets the mount operation to use an anonymous user if `anonymous` is %TRUE.
         * @param anonymous boolean value.
         */
        set_anonymous(anonymous: boolean): void;
        /**
         * Sets a default choice for the mount operation.
         * @param choice an integer.
         */
        set_choice(choice: number): void;
        /**
         * Sets the mount operation's domain.
         * @param domain the domain to set.
         */
        set_domain(domain: string | null): void;
        /**
         * Sets the mount operation to use a hidden volume if `hidden_volume` is %TRUE.
         * @param hidden_volume boolean value.
         */
        set_is_tcrypt_hidden_volume(hidden_volume: boolean): void;
        /**
         * Sets the mount operation to use a system volume if `system_volume` is %TRUE.
         * @param system_volume boolean value.
         */
        set_is_tcrypt_system_volume(system_volume: boolean): void;
        /**
         * Sets the mount operation's password to `password`.
         * @param password password to set.
         */
        set_password(password: string | null): void;
        /**
         * Sets the state of saving passwords for the mount operation.
         * @param save a set of #GPasswordSave flags.
         */
        set_password_save(save: PasswordSave): void;
        /**
         * Sets the mount operation's PIM to `pim`.
         * @param pim an unsigned integer.
         */
        set_pim(pim: number): void;
        /**
         * Sets the user name within `op` to `username`.
         * @param username input username.
         */
        set_username(username: string | null): void;

        // Own virtual methods of Gio-2.0.Gio.MountOperation

        vfunc_aborted(): void;
        vfunc_ask_password(
            message: string | null,
            default_user: string | null,
            default_domain: string | null,
            flags: AskPasswordFlags
        ): void;
        /**
         * Virtual implementation of #GMountOperation::ask-question.
         * @virtual
         * @param message string containing a message to display to the user
         * @param choices an array of    strings for each possible choice
         */
        vfunc_ask_question(message: string | null, choices: string[]): void;
        /**
         * Emits the #GMountOperation::reply signal.
         * @virtual
         * @param result a #GMountOperationResult
         */
        vfunc_reply(result: MountOperationResult): void;
        /**
         * Virtual implementation of #GMountOperation::show-processes.
         * @virtual
         * @param message string containing a message to display to the user
         * @param processes an array of #GPid for processes blocking    the operation
         * @param choices an array of    strings for each possible choice
         */
        vfunc_show_processes(
            message: string | null,
            processes: GLib.Pid[],
            choices: string[]
        ): void;
        vfunc_show_unmount_progress(
            message: string | null,
            time_left: number,
            bytes_left: number
        ): void;

        // Own signals of Gio-2.0.Gio.MountOperation

        connect(
            sigName: 'aborted',
            callback: MountOperation.AbortedSignalCallback
        ): number;
        connect_after(
            sigName: 'aborted',
            callback: MountOperation.AbortedSignalCallback
        ): number;
        emit(sigName: 'aborted', ...args: any[]): void;
        connect(
            sigName: 'ask-password',
            callback: MountOperation.AskPasswordSignalCallback
        ): number;
        connect_after(
            sigName: 'ask-password',
            callback: MountOperation.AskPasswordSignalCallback
        ): number;
        emit(
            sigName: 'ask-password',
            message: string | null,
            default_user: string | null,
            default_domain: string | null,
            flags: AskPasswordFlags,
            ...args: any[]
        ): void;
        connect(
            sigName: 'ask-question',
            callback: MountOperation.AskQuestionSignalCallback
        ): number;
        connect_after(
            sigName: 'ask-question',
            callback: MountOperation.AskQuestionSignalCallback
        ): number;
        emit(
            sigName: 'ask-question',
            message: string | null,
            choices: string[],
            ...args: any[]
        ): void;
        connect(
            sigName: 'reply',
            callback: MountOperation.ReplySignalCallback
        ): number;
        connect_after(
            sigName: 'reply',
            callback: MountOperation.ReplySignalCallback
        ): number;
        emit(
            sigName: 'reply',
            result: MountOperationResult,
            ...args: any[]
        ): void;
        connect(
            sigName: 'show-processes',
            callback: MountOperation.ShowProcessesSignalCallback
        ): number;
        connect_after(
            sigName: 'show-processes',
            callback: MountOperation.ShowProcessesSignalCallback
        ): number;
        emit(
            sigName: 'show-processes',
            message: string | null,
            processes: GLib.Pid[],
            choices: string[],
            ...args: any[]
        ): void;
        connect(
            sigName: 'show-unmount-progress',
            callback: MountOperation.ShowUnmountProgressSignalCallback
        ): number;
        connect_after(
            sigName: 'show-unmount-progress',
            callback: MountOperation.ShowUnmountProgressSignalCallback
        ): number;
        emit(
            sigName: 'show-unmount-progress',
            message: string | null,
            time_left: number,
            bytes_left: number,
            ...args: any[]
        ): void;

        // Class property signals of Gio-2.0.Gio.MountOperation

        connect(
            sigName: 'notify::anonymous',
            callback: ($obj: MountOperation, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::anonymous',
            callback: ($obj: MountOperation, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::anonymous', ...args: any[]): void;
        connect(
            sigName: 'notify::choice',
            callback: ($obj: MountOperation, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::choice',
            callback: ($obj: MountOperation, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::choice', ...args: any[]): void;
        connect(
            sigName: 'notify::domain',
            callback: ($obj: MountOperation, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::domain',
            callback: ($obj: MountOperation, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::domain', ...args: any[]): void;
        connect(
            sigName: 'notify::is-tcrypt-hidden-volume',
            callback: ($obj: MountOperation, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::is-tcrypt-hidden-volume',
            callback: ($obj: MountOperation, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::is-tcrypt-hidden-volume', ...args: any[]): void;
        connect(
            sigName: 'notify::is-tcrypt-system-volume',
            callback: ($obj: MountOperation, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::is-tcrypt-system-volume',
            callback: ($obj: MountOperation, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::is-tcrypt-system-volume', ...args: any[]): void;
        connect(
            sigName: 'notify::password',
            callback: ($obj: MountOperation, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::password',
            callback: ($obj: MountOperation, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::password', ...args: any[]): void;
        connect(
            sigName: 'notify::password-save',
            callback: ($obj: MountOperation, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::password-save',
            callback: ($obj: MountOperation, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::password-save', ...args: any[]): void;
        connect(
            sigName: 'notify::pim',
            callback: ($obj: MountOperation, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::pim',
            callback: ($obj: MountOperation, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::pim', ...args: any[]): void;
        connect(
            sigName: 'notify::username',
            callback: ($obj: MountOperation, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::username',
            callback: ($obj: MountOperation, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::username', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GMountOperation provides a mechanism for interacting with the user.
     * It can be used for authenticating mountable operations, such as loop
     * mounting files, hard drive partitions or server locations. It can
     * also be used to ask the user questions or show a list of applications
     * preventing unmount or eject operations from completing.
     *
     * Note that #GMountOperation is used for more than just #GMount
     * objects  for example it is also used in g_drive_start() and
     * g_drive_stop().
     *
     * Users should instantiate a subclass of this that implements all the
     * various callbacks to show the required dialogs, such as
     * #GtkMountOperation. If no user interaction is desired (for example
     * when automounting filesystems at login time), usually %NULL can be
     * passed, see each method taking a #GMountOperation for details.
     *
     * The term TCRYPT is used to mean compatible with TrueCrypt and VeraCrypt.
     * [TrueCrypt](https://en.wikipedia.org/wiki/TrueCrypt) is a discontinued system for
     * encrypting file containers, partitions or whole disks, typically used with Windows.
     * [VeraCrypt](https://www.veracrypt.fr/) is a maintained fork of TrueCrypt with various
     * improvements and auditing fixes.
     * @class
     */
    class MountOperation extends GObject.Object {
        // Own properties of Gio-2.0.Gio.MountOperation

        static name: string;
        static $gtype: GObject.GType<MountOperation>;

        // Constructors of Gio-2.0.Gio.MountOperation

        constructor(config?: MountOperation.ConstructorProperties);
        /**
         * Creates a new mount operation.
         * @constructor
         * @returns a #GMountOperation.
         */
        constructor();
        /**
         * Creates a new mount operation.
         * @constructor
         * @returns a #GMountOperation.
         */
        static new(): MountOperation;
        _init(config?: MountOperation.ConstructorProperties): void;
    }

    namespace NativeSocketAddress {
        // Constructor properties interface

        interface ConstructorProperties
            extends SocketConnectable.ConstructorProperties,
                SocketAddress.ConstructorProperties {}
    }

    interface NativeSocketAddress extends SocketConnectable {
        // Own fields of Gio-2.0.Gio.NativeSocketAddress

        parent_instance: SocketAddress & GObject.Object;

        // Class property signals of Gio-2.0.Gio.NativeSocketAddress

        connect(
            sigName: 'notify::family',
            callback: (
                $obj: NativeSocketAddress,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::family',
            callback: (
                $obj: NativeSocketAddress,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::family', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * A socket address of some unknown native type.
     * @class
     */
    class NativeSocketAddress extends SocketAddress {
        // Own properties of Gio-2.0.Gio.NativeSocketAddress

        static name: string;
        static $gtype: GObject.GType<NativeSocketAddress>;

        // Constructors of Gio-2.0.Gio.NativeSocketAddress

        constructor(config?: NativeSocketAddress.ConstructorProperties);
        /**
         * Creates a new #GNativeSocketAddress for `native` and `len`.
         * @constructor
         * @param native a native address object
         * @param len the length of `native,` in bytes
         * @returns a new #GNativeSocketAddress
         */
        constructor(native: any | null, len: number);
        /**
         * Creates a new #GNativeSocketAddress for `native` and `len`.
         * @constructor
         * @param native a native address object
         * @param len the length of `native,` in bytes
         * @returns a new #GNativeSocketAddress
         */
        static new(native: any | null, len: number): NativeSocketAddress;
        _init(config?: NativeSocketAddress.ConstructorProperties): void;
    }

    namespace NativeVolumeMonitor {
        // Constructor properties interface

        type ConstructorProperties = VolumeMonitor.ConstructorProperties;
    }

    interface NativeVolumeMonitor {
        // Own fields of Gio-2.0.Gio.NativeVolumeMonitor

        parent_instance: VolumeMonitor & GObject.Object;

        // Class property signals of Gio-2.0.Gio.NativeVolumeMonitor

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    class NativeVolumeMonitor extends VolumeMonitor {
        // Own properties of Gio-2.0.Gio.NativeVolumeMonitor

        static name: string;
        static $gtype: GObject.GType<NativeVolumeMonitor>;

        // Constructors of Gio-2.0.Gio.NativeVolumeMonitor

        constructor(config?: NativeVolumeMonitor.ConstructorProperties);
        _init(config?: NativeVolumeMonitor.ConstructorProperties): void;
    }

    namespace NetworkAddress {
        // Constructor properties interface

        interface ConstructorProperties
            extends SocketConnectable.ConstructorProperties,
                GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.NetworkAddress

            hostname?: string | null;
            port?: number | null;
            scheme?: string | null;
        }
    }

    interface NetworkAddress extends SocketConnectable {
        // Own properties of Gio-2.0.Gio.NetworkAddress

        readonly hostname: string | null;
        readonly port: number;
        readonly scheme: string | null;

        // Own fields of Gio-2.0.Gio.NetworkAddress

        parent_instance: GObject.Object;

        // Owm methods of Gio-2.0.Gio.NetworkAddress

        /**
         * Gets `addr'`s hostname. This might be either UTF-8 or ASCII-encoded,
         * depending on what `addr` was created with.
         * @returns @addr's hostname
         */
        get_hostname(): string | null;
        /**
         * Gets `addr'`s port number
         * @returns @addr's port (which may be 0)
         */
        get_port(): number;
        /**
         * Gets `addr'`s scheme
         * @returns @addr's scheme (%NULL if not built from URI)
         */
        get_scheme(): string | null;

        // Class property signals of Gio-2.0.Gio.NetworkAddress

        connect(
            sigName: 'notify::hostname',
            callback: ($obj: NetworkAddress, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::hostname',
            callback: ($obj: NetworkAddress, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::hostname', ...args: any[]): void;
        connect(
            sigName: 'notify::port',
            callback: ($obj: NetworkAddress, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::port',
            callback: ($obj: NetworkAddress, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::port', ...args: any[]): void;
        connect(
            sigName: 'notify::scheme',
            callback: ($obj: NetworkAddress, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::scheme',
            callback: ($obj: NetworkAddress, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::scheme', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GNetworkAddress provides an easy way to resolve a hostname and
     * then attempt to connect to that host, handling the possibility of
     * multiple IP addresses and multiple address families.
     *
     * The enumeration results of resolved addresses *may* be cached as long
     * as this object is kept alive which may have unexpected results if
     * alive for too long.
     *
     * See #GSocketConnectable for an example of using the connectable
     * interface.
     * @class
     */
    class NetworkAddress extends GObject.Object {
        // Own properties of Gio-2.0.Gio.NetworkAddress

        static name: string;
        static $gtype: GObject.GType<NetworkAddress>;

        // Constructors of Gio-2.0.Gio.NetworkAddress

        constructor(config?: NetworkAddress.ConstructorProperties);
        /**
         * Creates a new #GSocketConnectable for connecting to the given
         * `hostname` and `port`.
         *
         * Note that depending on the configuration of the machine, a
         * `hostname` of `localhost` may refer to the IPv4 loopback address
         * only, or to both IPv4 and IPv6; use
         * g_network_address_new_loopback() to create a #GNetworkAddress that
         * is guaranteed to resolve to both addresses.
         * @constructor
         * @param hostname the hostname
         * @param port the port
         * @returns the new #GNetworkAddress
         */
        constructor(hostname: string | null, port: number);
        /**
         * Creates a new #GSocketConnectable for connecting to the given
         * `hostname` and `port`.
         *
         * Note that depending on the configuration of the machine, a
         * `hostname` of `localhost` may refer to the IPv4 loopback address
         * only, or to both IPv4 and IPv6; use
         * g_network_address_new_loopback() to create a #GNetworkAddress that
         * is guaranteed to resolve to both addresses.
         * @constructor
         * @param hostname the hostname
         * @param port the port
         * @returns the new #GNetworkAddress
         */
        static new(hostname: string | null, port: number): NetworkAddress;
        /**
         * Creates a new #GSocketConnectable for connecting to the local host
         * over a loopback connection to the given `port`. This is intended for
         * use in connecting to local services which may be running on IPv4 or
         * IPv6.
         *
         * The connectable will return IPv4 and IPv6 loopback addresses,
         * regardless of how the host resolves `localhost`. By contrast,
         * g_network_address_new() will often only return an IPv4 address when
         * resolving `localhost`, and an IPv6 address for `localhost6`.
         *
         * g_network_address_get_hostname() will always return `localhost` for
         * a #GNetworkAddress created with this constructor.
         * @constructor
         * @param port the port
         * @returns the new #GNetworkAddress
         */
        static new_loopback(port: number): NetworkAddress;
        _init(config?: NetworkAddress.ConstructorProperties): void;
        /**
         * Creates a new #GSocketConnectable for connecting to the given
         * `hostname` and `port`. May fail and return %NULL in case
         * parsing `host_and_port` fails.
         *
         * `host_and_port` may be in any of a number of recognised formats; an IPv6
         * address, an IPv4 address, or a domain name (in which case a DNS
         * lookup is performed). Quoting with [] is supported for all address
         * types. A port override may be specified in the usual way with a
         * colon.
         *
         * If no port is specified in `host_and_port` then `default_port` will be
         * used as the port number to connect to.
         *
         * In general, `host_and_port` is expected to be provided by the user
         * (allowing them to give the hostname, and a port override if necessary)
         * and `default_port` is expected to be provided by the application.
         *
         * (The port component of `host_and_port` can also be specified as a
         * service name rather than as a numeric port, but this functionality
         * is deprecated, because it depends on the contents of /etc/services,
         * which is generally quite sparse on platforms other than Linux.)
         * @param host_and_port the hostname and optionally a port
         * @param default_port the default port if not in `host_and_port`
         * @returns the new   #GNetworkAddress, or %NULL on error
         */
        static parse(
            host_and_port: string | null,
            default_port: number
        ): NetworkAddress;
        /**
         * Creates a new #GSocketConnectable for connecting to the given
         * `uri`. May fail and return %NULL in case parsing `uri` fails.
         *
         * Using this rather than g_network_address_new() or
         * g_network_address_parse() allows #GSocketClient to determine
         * when to use application-specific proxy protocols.
         * @param uri the hostname and optionally a port
         * @param default_port The default port if none is found in the URI
         * @returns the new   #GNetworkAddress, or %NULL on error
         */
        static parse_uri(
            uri: string | null,
            default_port: number
        ): NetworkAddress;
    }

    namespace NetworkService {
        // Constructor properties interface

        interface ConstructorProperties
            extends SocketConnectable.ConstructorProperties,
                GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.NetworkService

            domain?: string | null;
            protocol?: string | null;
            scheme?: string | null;
            service?: string | null;
        }
    }

    interface NetworkService extends SocketConnectable {
        // Own properties of Gio-2.0.Gio.NetworkService

        readonly domain: string | null;
        readonly protocol: string | null;
        scheme: string | null;
        readonly service: string | null;

        // Own fields of Gio-2.0.Gio.NetworkService

        parent_instance: GObject.Object;

        // Owm methods of Gio-2.0.Gio.NetworkService

        /**
         * Gets the domain that `srv` serves. This might be either UTF-8 or
         * ASCII-encoded, depending on what `srv` was created with.
         * @returns @srv's domain name
         */
        get_domain(): string | null;
        /**
         * Gets `srv'`s protocol name (eg, "tcp").
         * @returns @srv's protocol name
         */
        get_protocol(): string | null;
        /**
         * Gets the URI scheme used to resolve proxies. By default, the service name
         * is used as scheme.
         * @returns @srv's scheme name
         */
        get_scheme(): string | null;
        /**
         * Gets `srv'`s service name (eg, "ldap").
         * @returns @srv's service name
         */
        get_service(): string | null;
        /**
         * Set's the URI scheme used to resolve proxies. By default, the service name
         * is used as scheme.
         * @param scheme a URI scheme
         */
        set_scheme(scheme: string | null): void;

        // Class property signals of Gio-2.0.Gio.NetworkService

        connect(
            sigName: 'notify::domain',
            callback: ($obj: NetworkService, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::domain',
            callback: ($obj: NetworkService, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::domain', ...args: any[]): void;
        connect(
            sigName: 'notify::protocol',
            callback: ($obj: NetworkService, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::protocol',
            callback: ($obj: NetworkService, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::protocol', ...args: any[]): void;
        connect(
            sigName: 'notify::scheme',
            callback: ($obj: NetworkService, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::scheme',
            callback: ($obj: NetworkService, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::scheme', ...args: any[]): void;
        connect(
            sigName: 'notify::service',
            callback: ($obj: NetworkService, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::service',
            callback: ($obj: NetworkService, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::service', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * Like #GNetworkAddress does with hostnames, #GNetworkService
     * provides an easy way to resolve a SRV record, and then attempt to
     * connect to one of the hosts that implements that service, handling
     * service priority/weighting, multiple IP addresses, and multiple
     * address families.
     *
     * See #GSrvTarget for more information about SRV records, and see
     * #GSocketConnectable for an example of using the connectable
     * interface.
     * @class
     */
    class NetworkService extends GObject.Object {
        // Own properties of Gio-2.0.Gio.NetworkService

        static name: string;
        static $gtype: GObject.GType<NetworkService>;

        // Constructors of Gio-2.0.Gio.NetworkService

        constructor(config?: NetworkService.ConstructorProperties);
        /**
         * Creates a new #GNetworkService representing the given `service,`
         * `protocol,` and `domain`. This will initially be unresolved; use the
         * #GSocketConnectable interface to resolve it.
         * @constructor
         * @param service the service type to look up (eg, "ldap")
         * @param protocol the networking protocol to use for `service` (eg, "tcp")
         * @param domain the DNS domain to look up the service in
         * @returns a new #GNetworkService
         */
        constructor(
            service: string | null,
            protocol: string | null,
            domain: string | null
        );
        /**
         * Creates a new #GNetworkService representing the given `service,`
         * `protocol,` and `domain`. This will initially be unresolved; use the
         * #GSocketConnectable interface to resolve it.
         * @constructor
         * @param service the service type to look up (eg, "ldap")
         * @param protocol the networking protocol to use for `service` (eg, "tcp")
         * @param domain the DNS domain to look up the service in
         * @returns a new #GNetworkService
         */
        static new(
            service: string | null,
            protocol: string | null,
            domain: string | null
        ): NetworkService;
        _init(config?: NetworkService.ConstructorProperties): void;
    }

    namespace Notification {
        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface Notification {
        // Owm methods of Gio-2.0.Gio.Notification

        /**
         * Adds a button to `notification` that activates the action in
         * `detailed_action` when clicked. That action must be an
         * application-wide action (starting with "app."). If `detailed_action`
         * contains a target, the action will be activated with that target as
         * its parameter.
         *
         * See g_action_parse_detailed_name() for a description of the format
         * for `detailed_action`.
         * @param label label of the button
         * @param detailed_action a detailed action name
         */
        add_button(label: string | null, detailed_action: string | null): void;
        /**
         * Adds a button to `notification` that activates `action` when clicked.
         * `action` must be an application-wide action (it must start with "app.").
         *
         * If `target` is non-%NULL, `action` will be activated with `target` as
         * its parameter.
         * @param label label of the button
         * @param action an action name
         * @param target a #GVariant to use as `action'`s parameter, or %NULL
         */
        add_button_with_target(
            label: string | null,
            action: string | null,
            target: GLib.Variant | null
        ): void;
        /**
         * Sets the body of `notification` to `body`.
         * @param body the new body for `notification,` or %NULL
         */
        set_body(body: string | null): void;
        /**
         * Sets the type of `notification` to `category`. Categories have a main
         * type like `email`, `im` or `device` and can have a detail separated
         * by a `.`, e.g. `im.received` or `email.arrived`. Setting the category
         * helps the notification server to select proper feedback to the user.
         *
         * Standard categories are [listed in the specification](https://specifications.freedesktop.org/notification-spec/latest/ar01s06.html).
         * @param category the category for `notification,` or %NULL for no category
         */
        set_category(category: string | null): void;
        /**
         * Sets the default action of `notification` to `detailed_action`. This
         * action is activated when the notification is clicked on.
         *
         * The action in `detailed_action` must be an application-wide action (it
         * must start with "app."). If `detailed_action` contains a target, the
         * given action will be activated with that target as its parameter.
         * See g_action_parse_detailed_name() for a description of the format
         * for `detailed_action`.
         *
         * When no default action is set, the application that the notification
         * was sent on is activated.
         * @param detailed_action a detailed action name
         */
        set_default_action(detailed_action: string | null): void;
        /**
         * Sets the default action of `notification` to `action`. This action is
         * activated when the notification is clicked on. It must be an
         * application-wide action (start with "app.").
         *
         * If `target` is non-%NULL, `action` will be activated with `target` as
         * its parameter. If `target` is floating, it will be consumed.
         *
         * When no default action is set, the application that the notification
         * was sent on is activated.
         * @param action an action name
         * @param target a #GVariant to use as `action'`s parameter, or %NULL
         */
        set_default_action_and_target(
            action: string | null,
            target: GLib.Variant | null
        ): void;
        /**
         * Sets the icon of `notification` to `icon`.
         * @param icon the icon to be shown in `notification,` as a #GIcon
         */
        set_icon(icon: Icon): void;
        /**
         * Sets the priority of `notification` to `priority`. See
         * #GNotificationPriority for possible values.
         * @param priority a #GNotificationPriority
         */
        set_priority(priority: NotificationPriority): void;
        /**
         * Sets the title of `notification` to `title`.
         * @param title the new title for `notification`
         */
        set_title(title: string | null): void;
        /**
         * Deprecated in favor of g_notification_set_priority().
         * @param urgent %TRUE if `notification` is urgent
         */
        set_urgent(urgent: boolean): void;

        // Class property signals of Gio-2.0.Gio.Notification

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GNotification is a mechanism for creating a notification to be shown
     * to the user -- typically as a pop-up notification presented by the
     * desktop environment shell.
     *
     * The key difference between #GNotification and other similar APIs is
     * that, if supported by the desktop environment, notifications sent
     * with #GNotification will persist after the application has exited,
     * and even across system reboots.
     *
     * Since the user may click on a notification while the application is
     * not running, applications using #GNotification should be able to be
     * started as a D-Bus service, using #GApplication.
     *
     * In order for #GNotification to work, the application must have installed
     * a `.desktop` file. For example:
     *
     * ```
     *  [Desktop Entry]
     *   Name=Test Application
     *   Comment=Description of what Test Application does
     *   Exec=gnome-test-application
     *   Icon=org.gnome.TestApplication
     *   Terminal=false
     *   Type=Application
     *   Categories=GNOME;GTK;TestApplication Category;
     *   StartupNotify=true
     *   DBusActivatable=true
     *   X-GNOME-UsesNotifications=true
     * ```
     *
     *
     * The `X-GNOME-UsesNotifications` key indicates to GNOME Control Center
     * that this application uses notifications, so it can be listed in the
     * Control Centers Notifications panel.
     *
     * The `.desktop` file must be named as `org.gnome.TestApplication.desktop`,
     * where `org.gnome.TestApplication` is the ID passed to g_application_new().
     *
     * User interaction with a notification (either the default action, or
     * buttons) must be associated with actions on the application (ie:
     * "app." actions).  It is not possible to route user interaction
     * through the notification itself, because the object will not exist if
     * the application is autostarted as a result of a notification being
     * clicked.
     *
     * A notification can be sent with g_application_send_notification().
     * @class
     */
    class Notification extends GObject.Object {
        // Own properties of Gio-2.0.Gio.Notification

        static name: string;
        static $gtype: GObject.GType<Notification>;

        // Constructors of Gio-2.0.Gio.Notification

        constructor(config?: Notification.ConstructorProperties);
        /**
         * Creates a new #GNotification with `title` as its title.
         *
         * After populating `notification` with more details, it can be sent to
         * the desktop shell with g_application_send_notification(). Changing
         * any properties after this call will not have any effect until
         * resending `notification`.
         * @constructor
         * @param title the title of the notification
         * @returns a new #GNotification instance
         */
        constructor(title: string | null);
        /**
         * Creates a new #GNotification with `title` as its title.
         *
         * After populating `notification` with more details, it can be sent to
         * the desktop shell with g_application_send_notification(). Changing
         * any properties after this call will not have any effect until
         * resending `notification`.
         * @constructor
         * @param title the title of the notification
         * @returns a new #GNotification instance
         */
        static new(title: string | null): Notification;
        _init(config?: Notification.ConstructorProperties): void;
    }

    namespace OutputStream {
        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface OutputStream {
        // Own fields of Gio-2.0.Gio.OutputStream

        parent_instance: GObject.Object;

        // Owm methods of Gio-2.0.Gio.OutputStream

        /**
         * Clears the pending flag on `stream`.
         */
        clear_pending(): void;
        /**
         * Closes the stream, releasing resources related to it.
         *
         * Once the stream is closed, all other operations will return %G_IO_ERROR_CLOSED.
         * Closing a stream multiple times will not return an error.
         *
         * Closing a stream will automatically flush any outstanding buffers in the
         * stream.
         *
         * Streams will be automatically closed when the last reference
         * is dropped, but you might want to call this function to make sure
         * resources are released as early as possible.
         *
         * Some streams might keep the backing store of the stream (e.g. a file descriptor)
         * open after the stream is closed. See the documentation for the individual
         * stream for details.
         *
         * On failure the first error that happened will be reported, but the close
         * operation will finish as much as possible. A stream that failed to
         * close will still return %G_IO_ERROR_CLOSED for all operations. Still, it
         * is important to check and report the error to the user, otherwise
         * there might be a loss of data as all data might not be written.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * Cancelling a close will still leave the stream closed, but there some streams
         * can use a faster close that doesn't block to e.g. check errors. On
         * cancellation (as with any error) there is no guarantee that all written
         * data will reach the target.
         * @param cancellable optional cancellable object
         * @returns %TRUE on success, %FALSE on failure
         */
        close(cancellable: Cancellable | null): boolean;
        /**
         * Requests an asynchronous close of the stream, releasing resources
         * related to it. When the operation is finished `callback` will be
         * called. You can then call g_output_stream_close_finish() to get
         * the result of the operation.
         *
         * For behaviour details see g_output_stream_close().
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         * @param io_priority the io priority of the request.
         * @param cancellable optional cancellable object
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        close_async(
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of close_async

        /**
         * Promisified version of {@link close_async}
         *
         * Requests an asynchronous close of the stream, releasing resources
         * related to it. When the operation is finished `callback` will be
         * called. You can then call g_output_stream_close_finish() to get
         * the result of the operation.
         *
         * For behaviour details see g_output_stream_close().
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         * @param io_priority the io priority of the request.
         * @param cancellable optional cancellable object
         * @returns A Promise of: %TRUE if stream was successfully closed, %FALSE otherwise.
         */
        close_async(
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<boolean>;
        /**
         * Closes an output stream.
         * @param result a #GAsyncResult.
         * @returns %TRUE if stream was successfully closed, %FALSE otherwise.
         */
        close_finish(result: AsyncResult): boolean;
        /**
         * Forces a write of all user-space buffered data for the given
         * `stream`. Will block during the operation. Closing the stream will
         * implicitly cause a flush.
         *
         * This function is optional for inherited classes.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional cancellable object
         * @returns %TRUE on success, %FALSE on error
         */
        flush(cancellable: Cancellable | null): boolean;
        /**
         * Forces an asynchronous write of all user-space buffered data for
         * the given `stream`.
         * For behaviour details see g_output_stream_flush().
         *
         * When the operation is finished `callback` will be
         * called. You can then call g_output_stream_flush_finish() to get the
         * result of the operation.
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        flush_async(
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of flush_async

        /**
         * Promisified version of {@link flush_async}
         *
         * Forces an asynchronous write of all user-space buffered data for
         * the given `stream`.
         * For behaviour details see g_output_stream_flush().
         *
         * When the operation is finished `callback` will be
         * called. You can then call g_output_stream_flush_finish() to get the
         * result of the operation.
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns A Promise of: %TRUE if flush operation succeeded, %FALSE otherwise.
         */
        flush_async(
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<boolean>;
        /**
         * Finishes flushing an output stream.
         * @param result a GAsyncResult.
         * @returns %TRUE if flush operation succeeded, %FALSE otherwise.
         */
        flush_finish(result: AsyncResult): boolean;
        /**
         * Checks if an output stream has pending actions.
         * @returns %TRUE if @stream has pending actions.
         */
        has_pending(): boolean;
        /**
         * Checks if an output stream has already been closed.
         * @returns %TRUE if @stream is closed. %FALSE otherwise.
         */
        is_closed(): boolean;
        /**
         * Checks if an output stream is being closed. This can be
         * used inside e.g. a flush implementation to see if the
         * flush (or other i/o operation) is called from within
         * the closing operation.
         * @returns %TRUE if @stream is being closed. %FALSE otherwise.
         */
        is_closing(): boolean;
        /**
         * Sets `stream` to have actions pending. If the pending flag is
         * already set or `stream` is closed, it will return %FALSE and set
         * `error`.
         * @returns %TRUE if pending was previously unset and is now set.
         */
        set_pending(): boolean;
        /**
         * Splices an input stream into an output stream.
         * @param source a #GInputStream.
         * @param flags a set of #GOutputStreamSpliceFlags.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a #gssize containing the size of the data spliced, or     -1 if an error occurred. Note that if the number of bytes     spliced is greater than %G_MAXSSIZE, then that will be     returned, and there is no way to determine the actual number     of bytes spliced.
         */
        splice(
            source: InputStream,
            flags: OutputStreamSpliceFlags,
            cancellable: Cancellable | null
        ): number;
        /**
         * Splices a stream asynchronously.
         * When the operation is finished `callback` will be called.
         * You can then call g_output_stream_splice_finish() to get the
         * result of the operation.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_splice().
         * @param source a #GInputStream.
         * @param flags a set of #GOutputStreamSpliceFlags.
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        splice_async(
            source: InputStream,
            flags: OutputStreamSpliceFlags,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of splice_async

        /**
         * Promisified version of {@link splice_async}
         *
         * Splices a stream asynchronously.
         * When the operation is finished `callback` will be called.
         * You can then call g_output_stream_splice_finish() to get the
         * result of the operation.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_splice().
         * @param source a #GInputStream.
         * @param flags a set of #GOutputStreamSpliceFlags.
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns A Promise of: a #gssize of the number of bytes spliced. Note that if the     number of bytes spliced is greater than %G_MAXSSIZE, then that     will be returned, and there is no way to determine the actual     number of bytes spliced.
         */
        splice_async(
            source: InputStream,
            flags: OutputStreamSpliceFlags,
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<number>;
        /**
         * Finishes an asynchronous stream splice operation.
         * @param result a #GAsyncResult.
         * @returns a #gssize of the number of bytes spliced. Note that if the     number of bytes spliced is greater than %G_MAXSSIZE, then that     will be returned, and there is no way to determine the actual     number of bytes spliced.
         */
        splice_finish(result: AsyncResult): number;
        /**
         * Tries to write `count` bytes from `buffer` into the stream. Will block
         * during the operation.
         *
         * If count is 0, returns 0 and does nothing. A value of `count`
         * larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes written to the stream is returned.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. on a partial I/O error, or if there is not enough
         * storage in the stream. All writes block until at least one byte
         * is written or an error occurs; 0 is never returned (unless
         * `count` is 0).
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         *
         * On error -1 is returned and `error` is set accordingly.
         * @param buffer the buffer containing the data to write.
         * @param cancellable optional cancellable object
         * @returns Number of bytes written, or -1 on error
         */
        write(buffer: Uint8Array, cancellable: Cancellable | null): number;
        /**
         * Tries to write `count` bytes from `buffer` into the stream. Will block
         * during the operation.
         *
         * This function is similar to g_output_stream_write(), except it tries to
         * write as many bytes as requested, only stopping on an error.
         *
         * On a successful write of `count` bytes, %TRUE is returned, and `bytes_written`
         * is set to `count`.
         *
         * If there is an error during the operation %FALSE is returned and `error`
         * is set to indicate the error status.
         *
         * As a special exception to the normal conventions for functions that
         * use #GError, if this function returns %FALSE (and sets `error)` then
         * `bytes_written` will be set to the number of bytes that were
         * successfully written before the error was encountered.  This
         * functionality is only available from C.  If you need it from another
         * language then you must write your own loop around
         * g_output_stream_write().
         * @param buffer the buffer containing the data to write.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE on success, %FALSE if there was an error
         */
        write_all(
            buffer: Uint8Array,
            cancellable: Cancellable | null
        ): [/* returnType */ boolean, /* bytes_written */ number];
        /**
         * Request an asynchronous write of `count` bytes from `buffer` into
         * the stream. When the operation is finished `callback` will be called.
         * You can then call g_output_stream_write_all_finish() to get the result of the
         * operation.
         *
         * This is the asynchronous version of g_output_stream_write_all().
         *
         * Call g_output_stream_write_all_finish() to collect the result.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         *
         * Note that no copy of `buffer` will be made, so it must stay valid
         * until `callback` is called.
         * @param buffer the buffer containing the data to write
         * @param io_priority the io priority of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback     to call when the request is satisfied
         */
        write_all_async(
            buffer: Uint8Array,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of write_all_async

        /**
         * Promisified version of {@link write_all_async}
         *
         * Request an asynchronous write of `count` bytes from `buffer` into
         * the stream. When the operation is finished `callback` will be called.
         * You can then call g_output_stream_write_all_finish() to get the result of the
         * operation.
         *
         * This is the asynchronous version of g_output_stream_write_all().
         *
         * Call g_output_stream_write_all_finish() to collect the result.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         *
         * Note that no copy of `buffer` will be made, so it must stay valid
         * until `callback` is called.
         * @param buffer the buffer containing the data to write
         * @param io_priority the io priority of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @returns A Promise of: %TRUE on success, %FALSE if there was an error
         */
        write_all_async(
            buffer: Uint8Array,
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise</* bytes_written */ number>;
        /**
         * Finishes an asynchronous stream write operation started with
         * g_output_stream_write_all_async().
         *
         * As a special exception to the normal conventions for functions that
         * use #GError, if this function returns %FALSE (and sets `error)` then
         * `bytes_written` will be set to the number of bytes that were
         * successfully written before the error was encountered.  This
         * functionality is only available from C.  If you need it from another
         * language then you must write your own loop around
         * g_output_stream_write_async().
         * @param result a #GAsyncResult
         * @returns %TRUE on success, %FALSE if there was an error
         */
        write_all_finish(
            result: AsyncResult
        ): [/* returnType */ boolean, /* bytes_written */ number];
        /**
         * Request an asynchronous write of `count` bytes from `buffer` into
         * the stream. When the operation is finished `callback` will be called.
         * You can then call g_output_stream_write_finish() to get the result of the
         * operation.
         *
         * During an async request no other sync and async calls are allowed,
         * and will result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a
         * %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes written will be passed to the
         * `callback`. It is not an error if this is not the same as the
         * requested size, as it can happen e.g. on a partial I/O error,
         * but generally we try to write as many bytes as requested.
         *
         * You are guaranteed that this method will never fail with
         * %G_IO_ERROR_WOULD_BLOCK - if `stream` can't accept more data, the
         * method will just wait until this changes.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_write().
         *
         * Note that no copy of `buffer` will be made, so it must stay valid
         * until `callback` is called. See g_output_stream_write_bytes_async()
         * for a #GBytes version that will automatically hold a reference to
         * the contents (without copying) for the duration of the call.
         * @param buffer the buffer containing the data to write.
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback     to call when the request is satisfied
         */
        write_async(
            buffer: Uint8Array,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of write_async

        /**
         * Promisified version of {@link write_async}
         *
         * Request an asynchronous write of `count` bytes from `buffer` into
         * the stream. When the operation is finished `callback` will be called.
         * You can then call g_output_stream_write_finish() to get the result of the
         * operation.
         *
         * During an async request no other sync and async calls are allowed,
         * and will result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a
         * %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes written will be passed to the
         * `callback`. It is not an error if this is not the same as the
         * requested size, as it can happen e.g. on a partial I/O error,
         * but generally we try to write as many bytes as requested.
         *
         * You are guaranteed that this method will never fail with
         * %G_IO_ERROR_WOULD_BLOCK - if `stream` can't accept more data, the
         * method will just wait until this changes.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_write().
         *
         * Note that no copy of `buffer` will be made, so it must stay valid
         * until `callback` is called. See g_output_stream_write_bytes_async()
         * for a #GBytes version that will automatically hold a reference to
         * the contents (without copying) for the duration of the call.
         * @param buffer the buffer containing the data to write.
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns A Promise of: a #gssize containing the number of bytes written to the stream.
         */
        write_async(
            buffer: Uint8Array,
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<number>;
        /**
         * A wrapper function for g_output_stream_write() which takes a
         * #GBytes as input.  This can be more convenient for use by language
         * bindings or in other cases where the refcounted nature of #GBytes
         * is helpful over a bare pointer interface.
         *
         * However, note that this function may still perform partial writes,
         * just like g_output_stream_write().  If that occurs, to continue
         * writing, you will need to create a new #GBytes containing just the
         * remaining bytes, using g_bytes_new_from_bytes(). Passing the same
         * #GBytes instance multiple times potentially can result in duplicated
         * data in the output stream.
         * @param bytes the #GBytes to write
         * @param cancellable optional cancellable object
         * @returns Number of bytes written, or -1 on error
         */
        write_bytes(bytes: GLib.Bytes, cancellable: Cancellable | null): number;
        /**
         * This function is similar to g_output_stream_write_async(), but
         * takes a #GBytes as input.  Due to the refcounted nature of #GBytes,
         * this allows the stream to avoid taking a copy of the data.
         *
         * However, note that this function may still perform partial writes,
         * just like g_output_stream_write_async(). If that occurs, to continue
         * writing, you will need to create a new #GBytes containing just the
         * remaining bytes, using g_bytes_new_from_bytes(). Passing the same
         * #GBytes instance multiple times potentially can result in duplicated
         * data in the output stream.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_write_bytes().
         * @param bytes The bytes to write
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        write_bytes_async(
            bytes: GLib.Bytes,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of write_bytes_async

        /**
         * Promisified version of {@link write_bytes_async}
         *
         * This function is similar to g_output_stream_write_async(), but
         * takes a #GBytes as input.  Due to the refcounted nature of #GBytes,
         * this allows the stream to avoid taking a copy of the data.
         *
         * However, note that this function may still perform partial writes,
         * just like g_output_stream_write_async(). If that occurs, to continue
         * writing, you will need to create a new #GBytes containing just the
         * remaining bytes, using g_bytes_new_from_bytes(). Passing the same
         * #GBytes instance multiple times potentially can result in duplicated
         * data in the output stream.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_write_bytes().
         * @param bytes The bytes to write
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns A Promise of: a #gssize containing the number of bytes written to the stream.
         */
        write_bytes_async(
            bytes: GLib.Bytes,
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<number>;
        /**
         * Finishes a stream write-from-#GBytes operation.
         * @param result a #GAsyncResult.
         * @returns a #gssize containing the number of bytes written to the stream.
         */
        write_bytes_finish(result: AsyncResult): number;
        /**
         * Finishes a stream write operation.
         * @param result a #GAsyncResult.
         * @returns a #gssize containing the number of bytes written to the stream.
         */
        write_finish(result: AsyncResult): number;
        /**
         * Tries to write the bytes contained in the `n_vectors` `vectors` into the
         * stream. Will block during the operation.
         *
         * If `n_vectors` is 0 or the sum of all bytes in `vectors` is 0, returns 0 and
         * does nothing.
         *
         * On success, the number of bytes written to the stream is returned.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. on a partial I/O error, or if there is not enough
         * storage in the stream. All writes block until at least one byte
         * is written or an error occurs; 0 is never returned (unless
         * `n_vectors` is 0 or the sum of all bytes in `vectors` is 0).
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         *
         * Some implementations of g_output_stream_writev() may have limitations on the
         * aggregate buffer size, and will return %G_IO_ERROR_INVALID_ARGUMENT if these
         * are exceeded. For example, when writing to a local file on UNIX platforms,
         * the aggregate buffer size must not exceed %G_MAXSSIZE bytes.
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @param cancellable optional cancellable object
         * @returns %TRUE on success, %FALSE if there was an error
         */
        writev(
            vectors: OutputVector[],
            cancellable: Cancellable | null
        ): [/* returnType */ boolean, /* bytes_written */ number];
        /**
         * Tries to write the bytes contained in the `n_vectors` `vectors` into the
         * stream. Will block during the operation.
         *
         * This function is similar to g_output_stream_writev(), except it tries to
         * write as many bytes as requested, only stopping on an error.
         *
         * On a successful write of all `n_vectors` vectors, %TRUE is returned, and
         * `bytes_written` is set to the sum of all the sizes of `vectors`.
         *
         * If there is an error during the operation %FALSE is returned and `error`
         * is set to indicate the error status.
         *
         * As a special exception to the normal conventions for functions that
         * use #GError, if this function returns %FALSE (and sets `error)` then
         * `bytes_written` will be set to the number of bytes that were
         * successfully written before the error was encountered.  This
         * functionality is only available from C. If you need it from another
         * language then you must write your own loop around
         * g_output_stream_write().
         *
         * The content of the individual elements of `vectors` might be changed by this
         * function.
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE on success, %FALSE if there was an error
         */
        writev_all(
            vectors: OutputVector[],
            cancellable: Cancellable | null
        ): [/* returnType */ boolean, /* bytes_written */ number];
        /**
         * Request an asynchronous write of the bytes contained in the `n_vectors` `vectors` into
         * the stream. When the operation is finished `callback` will be called.
         * You can then call g_output_stream_writev_all_finish() to get the result of the
         * operation.
         *
         * This is the asynchronous version of g_output_stream_writev_all().
         *
         * Call g_output_stream_writev_all_finish() to collect the result.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         *
         * Note that no copy of `vectors` will be made, so it must stay valid
         * until `callback` is called. The content of the individual elements
         * of `vectors` might be changed by this function.
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @param io_priority the I/O priority of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback     to call when the request is satisfied
         */
        writev_all_async(
            vectors: OutputVector[],
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of writev_all_async

        /**
         * Promisified version of {@link writev_all_async}
         *
         * Request an asynchronous write of the bytes contained in the `n_vectors` `vectors` into
         * the stream. When the operation is finished `callback` will be called.
         * You can then call g_output_stream_writev_all_finish() to get the result of the
         * operation.
         *
         * This is the asynchronous version of g_output_stream_writev_all().
         *
         * Call g_output_stream_writev_all_finish() to collect the result.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         *
         * Note that no copy of `vectors` will be made, so it must stay valid
         * until `callback` is called. The content of the individual elements
         * of `vectors` might be changed by this function.
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @param io_priority the I/O priority of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @returns A Promise of: %TRUE on success, %FALSE if there was an error
         */
        writev_all_async(
            vectors: OutputVector[],
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise</* bytes_written */ number>;
        /**
         * Finishes an asynchronous stream write operation started with
         * g_output_stream_writev_all_async().
         *
         * As a special exception to the normal conventions for functions that
         * use #GError, if this function returns %FALSE (and sets `error)` then
         * `bytes_written` will be set to the number of bytes that were
         * successfully written before the error was encountered.  This
         * functionality is only available from C.  If you need it from another
         * language then you must write your own loop around
         * g_output_stream_writev_async().
         * @param result a #GAsyncResult
         * @returns %TRUE on success, %FALSE if there was an error
         */
        writev_all_finish(
            result: AsyncResult
        ): [/* returnType */ boolean, /* bytes_written */ number];
        /**
         * Request an asynchronous write of the bytes contained in `n_vectors` `vectors` into
         * the stream. When the operation is finished `callback` will be called.
         * You can then call g_output_stream_writev_finish() to get the result of the
         * operation.
         *
         * During an async request no other sync and async calls are allowed,
         * and will result in %G_IO_ERROR_PENDING errors.
         *
         * On success, the number of bytes written will be passed to the
         * `callback`. It is not an error if this is not the same as the
         * requested size, as it can happen e.g. on a partial I/O error,
         * but generally we try to write as many bytes as requested.
         *
         * You are guaranteed that this method will never fail with
         * %G_IO_ERROR_WOULD_BLOCK  if `stream` can't accept more data, the
         * method will just wait until this changes.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_writev().
         *
         * Note that no copy of `vectors` will be made, so it must stay valid
         * until `callback` is called.
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @param io_priority the I/O priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback     to call when the request is satisfied
         */
        writev_async(
            vectors: OutputVector[],
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of writev_async

        /**
         * Promisified version of {@link writev_async}
         *
         * Request an asynchronous write of the bytes contained in `n_vectors` `vectors` into
         * the stream. When the operation is finished `callback` will be called.
         * You can then call g_output_stream_writev_finish() to get the result of the
         * operation.
         *
         * During an async request no other sync and async calls are allowed,
         * and will result in %G_IO_ERROR_PENDING errors.
         *
         * On success, the number of bytes written will be passed to the
         * `callback`. It is not an error if this is not the same as the
         * requested size, as it can happen e.g. on a partial I/O error,
         * but generally we try to write as many bytes as requested.
         *
         * You are guaranteed that this method will never fail with
         * %G_IO_ERROR_WOULD_BLOCK  if `stream` can't accept more data, the
         * method will just wait until this changes.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_writev().
         *
         * Note that no copy of `vectors` will be made, so it must stay valid
         * until `callback` is called.
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @param io_priority the I/O priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns A Promise of: %TRUE on success, %FALSE if there was an error
         */
        writev_async(
            vectors: OutputVector[],
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise</* bytes_written */ number>;
        /**
         * Finishes a stream writev operation.
         * @param result a #GAsyncResult.
         * @returns %TRUE on success, %FALSE if there was an error
         */
        writev_finish(
            result: AsyncResult
        ): [/* returnType */ boolean, /* bytes_written */ number];

        // Own virtual methods of Gio-2.0.Gio.OutputStream

        /**
         * Requests an asynchronous close of the stream, releasing resources
         * related to it. When the operation is finished `callback` will be
         * called. You can then call g_output_stream_close_finish() to get
         * the result of the operation.
         *
         * For behaviour details see g_output_stream_close().
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         * @virtual
         * @param io_priority the io priority of the request.
         * @param cancellable optional cancellable object
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_close_async(
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Closes an output stream.
         * @virtual
         * @param result a #GAsyncResult.
         * @returns %TRUE if stream was successfully closed, %FALSE otherwise.
         */
        vfunc_close_finish(result: AsyncResult): boolean;
        vfunc_close_fn(cancellable: Cancellable | null): boolean;
        /**
         * Forces a write of all user-space buffered data for the given
         * `stream`. Will block during the operation. Closing the stream will
         * implicitly cause a flush.
         *
         * This function is optional for inherited classes.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @virtual
         * @param cancellable optional cancellable object
         * @returns %TRUE on success, %FALSE on error
         */
        vfunc_flush(cancellable: Cancellable | null): boolean;
        /**
         * Forces an asynchronous write of all user-space buffered data for
         * the given `stream`.
         * For behaviour details see g_output_stream_flush().
         *
         * When the operation is finished `callback` will be
         * called. You can then call g_output_stream_flush_finish() to get the
         * result of the operation.
         * @virtual
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_flush_async(
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes flushing an output stream.
         * @virtual
         * @param result a GAsyncResult.
         * @returns %TRUE if flush operation succeeded, %FALSE otherwise.
         */
        vfunc_flush_finish(result: AsyncResult): boolean;
        /**
         * Splices an input stream into an output stream.
         * @virtual
         * @param source a #GInputStream.
         * @param flags a set of #GOutputStreamSpliceFlags.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a #gssize containing the size of the data spliced, or     -1 if an error occurred. Note that if the number of bytes     spliced is greater than %G_MAXSSIZE, then that will be     returned, and there is no way to determine the actual number     of bytes spliced.
         */
        vfunc_splice(
            source: InputStream,
            flags: OutputStreamSpliceFlags,
            cancellable: Cancellable | null
        ): number;
        /**
         * Splices a stream asynchronously.
         * When the operation is finished `callback` will be called.
         * You can then call g_output_stream_splice_finish() to get the
         * result of the operation.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_splice().
         * @virtual
         * @param source a #GInputStream.
         * @param flags a set of #GOutputStreamSpliceFlags.
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_splice_async(
            source: InputStream,
            flags: OutputStreamSpliceFlags,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes an asynchronous stream splice operation.
         * @virtual
         * @param result a #GAsyncResult.
         * @returns a #gssize of the number of bytes spliced. Note that if the     number of bytes spliced is greater than %G_MAXSSIZE, then that     will be returned, and there is no way to determine the actual     number of bytes spliced.
         */
        vfunc_splice_finish(result: AsyncResult): number;
        /**
         * Request an asynchronous write of `count` bytes from `buffer` into
         * the stream. When the operation is finished `callback` will be called.
         * You can then call g_output_stream_write_finish() to get the result of the
         * operation.
         *
         * During an async request no other sync and async calls are allowed,
         * and will result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a
         * %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes written will be passed to the
         * `callback`. It is not an error if this is not the same as the
         * requested size, as it can happen e.g. on a partial I/O error,
         * but generally we try to write as many bytes as requested.
         *
         * You are guaranteed that this method will never fail with
         * %G_IO_ERROR_WOULD_BLOCK - if `stream` can't accept more data, the
         * method will just wait until this changes.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_write().
         *
         * Note that no copy of `buffer` will be made, so it must stay valid
         * until `callback` is called. See g_output_stream_write_bytes_async()
         * for a #GBytes version that will automatically hold a reference to
         * the contents (without copying) for the duration of the call.
         * @virtual
         * @param buffer the buffer containing the data to write.
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback     to call when the request is satisfied
         */
        vfunc_write_async(
            buffer: Uint8Array | null,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes a stream write operation.
         * @virtual
         * @param result a #GAsyncResult.
         * @returns a #gssize containing the number of bytes written to the stream.
         */
        vfunc_write_finish(result: AsyncResult): number;
        /**
         * Tries to write `count` bytes from `buffer` into the stream. Will block
         * during the operation.
         *
         * If count is 0, returns 0 and does nothing. A value of `count`
         * larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes written to the stream is returned.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. on a partial I/O error, or if there is not enough
         * storage in the stream. All writes block until at least one byte
         * is written or an error occurs; 0 is never returned (unless
         * `count` is 0).
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         *
         * On error -1 is returned and `error` is set accordingly.
         * @virtual
         * @param buffer the buffer containing the data to write.
         * @param cancellable optional cancellable object
         * @returns Number of bytes written, or -1 on error
         */
        vfunc_write_fn(
            buffer: Uint8Array | null,
            cancellable: Cancellable | null
        ): number;
        /**
         * Request an asynchronous write of the bytes contained in `n_vectors` `vectors` into
         * the stream. When the operation is finished `callback` will be called.
         * You can then call g_output_stream_writev_finish() to get the result of the
         * operation.
         *
         * During an async request no other sync and async calls are allowed,
         * and will result in %G_IO_ERROR_PENDING errors.
         *
         * On success, the number of bytes written will be passed to the
         * `callback`. It is not an error if this is not the same as the
         * requested size, as it can happen e.g. on a partial I/O error,
         * but generally we try to write as many bytes as requested.
         *
         * You are guaranteed that this method will never fail with
         * %G_IO_ERROR_WOULD_BLOCK  if `stream` can't accept more data, the
         * method will just wait until this changes.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_writev().
         *
         * Note that no copy of `vectors` will be made, so it must stay valid
         * until `callback` is called.
         * @virtual
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @param io_priority the I/O priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback     to call when the request is satisfied
         */
        vfunc_writev_async(
            vectors: OutputVector[],
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finishes a stream writev operation.
         * @virtual
         * @param result a #GAsyncResult.
         * @returns %TRUE on success, %FALSE if there was an error
         */
        vfunc_writev_finish(
            result: AsyncResult
        ): [/* returnType */ boolean, /* bytes_written */ number];
        /**
         * Tries to write the bytes contained in the `n_vectors` `vectors` into the
         * stream. Will block during the operation.
         *
         * If `n_vectors` is 0 or the sum of all bytes in `vectors` is 0, returns 0 and
         * does nothing.
         *
         * On success, the number of bytes written to the stream is returned.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. on a partial I/O error, or if there is not enough
         * storage in the stream. All writes block until at least one byte
         * is written or an error occurs; 0 is never returned (unless
         * `n_vectors` is 0 or the sum of all bytes in `vectors` is 0).
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         *
         * Some implementations of g_output_stream_writev() may have limitations on the
         * aggregate buffer size, and will return %G_IO_ERROR_INVALID_ARGUMENT if these
         * are exceeded. For example, when writing to a local file on UNIX platforms,
         * the aggregate buffer size must not exceed %G_MAXSSIZE bytes.
         * @virtual
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @param cancellable optional cancellable object
         * @returns %TRUE on success, %FALSE if there was an error
         */
        vfunc_writev_fn(
            vectors: OutputVector[],
            cancellable: Cancellable | null
        ): [/* returnType */ boolean, /* bytes_written */ number];

        // Class property signals of Gio-2.0.Gio.OutputStream

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GOutputStream has functions to write to a stream (g_output_stream_write()),
     * to close a stream (g_output_stream_close()) and to flush pending writes
     * (g_output_stream_flush()).
     *
     * To copy the content of an input stream to an output stream without
     * manually handling the reads and writes, use g_output_stream_splice().
     *
     * See the documentation for #GIOStream for details of thread safety of
     * streaming APIs.
     *
     * All of these functions have async variants too.
     * @interface
     */
    class OutputStream extends GObject.Object {
        // Own properties of Gio-2.0.Gio.OutputStream

        static name: string;
        static $gtype: GObject.GType<OutputStream>;

        // Constructors of Gio-2.0.Gio.OutputStream

        constructor(config?: OutputStream.ConstructorProperties);
        _init(config?: OutputStream.ConstructorProperties): void;
    }

    namespace Permission {
        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface Permission {
        // Own properties of Gio-2.0.Gio.Permission

        /**
         * %TRUE if the caller currently has permission to perform the action that
         * `permission` represents the permission to perform.
         */
        readonly allowed: boolean;
        /**
         * %TRUE if it is generally possible to acquire the permission by calling
         * g_permission_acquire().
         */
        readonly can_acquire: boolean;
        /**
         * %TRUE if it is generally possible to release the permission by calling
         * g_permission_release().
         */
        readonly can_release: boolean;

        // Own fields of Gio-2.0.Gio.Permission

        parent_instance: GObject.Object;

        // Owm methods of Gio-2.0.Gio.Permission

        /**
         * Attempts to acquire the permission represented by `permission`.
         *
         * The precise method by which this happens depends on the permission
         * and the underlying authentication mechanism.  A simple example is
         * that a dialog may appear asking the user to enter their password.
         *
         * You should check with g_permission_get_can_acquire() before calling
         * this function.
         *
         * If the permission is acquired then %TRUE is returned.  Otherwise,
         * %FALSE is returned and `error` is set appropriately.
         *
         * This call is blocking, likely for a very long time (in the case that
         * user interaction is required).  See g_permission_acquire_async() for
         * the non-blocking version.
         * @param cancellable a #GCancellable, or %NULL
         * @returns %TRUE if the permission was successfully acquired
         */
        acquire(cancellable: Cancellable | null): boolean;
        /**
         * Attempts to acquire the permission represented by `permission`.
         *
         * This is the first half of the asynchronous version of
         * g_permission_acquire().
         * @param cancellable a #GCancellable, or %NULL
         * @param callback the #GAsyncReadyCallback to call when done
         */
        acquire_async(
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of acquire_async

        /**
         * Promisified version of {@link acquire_async}
         *
         * Attempts to acquire the permission represented by `permission`.
         *
         * This is the first half of the asynchronous version of
         * g_permission_acquire().
         * @param cancellable a #GCancellable, or %NULL
         * @returns A Promise of: %TRUE if the permission was successfully acquired
         */
        acquire_async(
            cancellable: Cancellable | null
        ): globalThis.Promise<boolean>;
        /**
         * Collects the result of attempting to acquire the permission
         * represented by `permission`.
         *
         * This is the second half of the asynchronous version of
         * g_permission_acquire().
         * @param result the #GAsyncResult given to the #GAsyncReadyCallback
         * @returns %TRUE if the permission was successfully acquired
         */
        acquire_finish(result: AsyncResult): boolean;
        /**
         * Gets the value of the 'allowed' property.  This property is %TRUE if
         * the caller currently has permission to perform the action that
         * `permission` represents the permission to perform.
         * @returns the value of the 'allowed' property
         */
        get_allowed(): boolean;
        /**
         * Gets the value of the 'can-acquire' property.  This property is %TRUE
         * if it is generally possible to acquire the permission by calling
         * g_permission_acquire().
         * @returns the value of the 'can-acquire' property
         */
        get_can_acquire(): boolean;
        /**
         * Gets the value of the 'can-release' property.  This property is %TRUE
         * if it is generally possible to release the permission by calling
         * g_permission_release().
         * @returns the value of the 'can-release' property
         */
        get_can_release(): boolean;
        /**
         * This function is called by the #GPermission implementation to update
         * the properties of the permission.  You should never call this
         * function except from a #GPermission implementation.
         *
         * GObject notify signals are generated, as appropriate.
         * @param allowed the new value for the 'allowed' property
         * @param can_acquire the new value for the 'can-acquire' property
         * @param can_release the new value for the 'can-release' property
         */
        impl_update(
            allowed: boolean,
            can_acquire: boolean,
            can_release: boolean
        ): void;
        /**
         * Attempts to release the permission represented by `permission`.
         *
         * The precise method by which this happens depends on the permission
         * and the underlying authentication mechanism.  In most cases the
         * permission will be dropped immediately without further action.
         *
         * You should check with g_permission_get_can_release() before calling
         * this function.
         *
         * If the permission is released then %TRUE is returned.  Otherwise,
         * %FALSE is returned and `error` is set appropriately.
         *
         * This call is blocking, likely for a very long time (in the case that
         * user interaction is required).  See g_permission_release_async() for
         * the non-blocking version.
         * @param cancellable a #GCancellable, or %NULL
         * @returns %TRUE if the permission was successfully released
         */
        release(cancellable: Cancellable | null): boolean;
        /**
         * Attempts to release the permission represented by `permission`.
         *
         * This is the first half of the asynchronous version of
         * g_permission_release().
         * @param cancellable a #GCancellable, or %NULL
         * @param callback the #GAsyncReadyCallback to call when done
         */
        release_async(
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of release_async

        /**
         * Promisified version of {@link release_async}
         *
         * Attempts to release the permission represented by `permission`.
         *
         * This is the first half of the asynchronous version of
         * g_permission_release().
         * @param cancellable a #GCancellable, or %NULL
         * @returns A Promise of: %TRUE if the permission was successfully released
         */
        release_async(
            cancellable: Cancellable | null
        ): globalThis.Promise<boolean>;
        /**
         * Collects the result of attempting to release the permission
         * represented by `permission`.
         *
         * This is the second half of the asynchronous version of
         * g_permission_release().
         * @param result the #GAsyncResult given to the #GAsyncReadyCallback
         * @returns %TRUE if the permission was successfully released
         */
        release_finish(result: AsyncResult): boolean;

        // Own virtual methods of Gio-2.0.Gio.Permission

        /**
         * Attempts to acquire the permission represented by `permission`.
         *
         * The precise method by which this happens depends on the permission
         * and the underlying authentication mechanism.  A simple example is
         * that a dialog may appear asking the user to enter their password.
         *
         * You should check with g_permission_get_can_acquire() before calling
         * this function.
         *
         * If the permission is acquired then %TRUE is returned.  Otherwise,
         * %FALSE is returned and `error` is set appropriately.
         *
         * This call is blocking, likely for a very long time (in the case that
         * user interaction is required).  See g_permission_acquire_async() for
         * the non-blocking version.
         * @virtual
         * @param cancellable a #GCancellable, or %NULL
         * @returns %TRUE if the permission was successfully acquired
         */
        vfunc_acquire(cancellable: Cancellable | null): boolean;
        /**
         * Attempts to acquire the permission represented by `permission`.
         *
         * This is the first half of the asynchronous version of
         * g_permission_acquire().
         * @virtual
         * @param cancellable a #GCancellable, or %NULL
         * @param callback the #GAsyncReadyCallback to call when done
         */
        vfunc_acquire_async(
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Collects the result of attempting to acquire the permission
         * represented by `permission`.
         *
         * This is the second half of the asynchronous version of
         * g_permission_acquire().
         * @virtual
         * @param result the #GAsyncResult given to the #GAsyncReadyCallback
         * @returns %TRUE if the permission was successfully acquired
         */
        vfunc_acquire_finish(result: AsyncResult): boolean;
        /**
         * Attempts to release the permission represented by `permission`.
         *
         * The precise method by which this happens depends on the permission
         * and the underlying authentication mechanism.  In most cases the
         * permission will be dropped immediately without further action.
         *
         * You should check with g_permission_get_can_release() before calling
         * this function.
         *
         * If the permission is released then %TRUE is returned.  Otherwise,
         * %FALSE is returned and `error` is set appropriately.
         *
         * This call is blocking, likely for a very long time (in the case that
         * user interaction is required).  See g_permission_release_async() for
         * the non-blocking version.
         * @virtual
         * @param cancellable a #GCancellable, or %NULL
         * @returns %TRUE if the permission was successfully released
         */
        vfunc_release(cancellable: Cancellable | null): boolean;
        /**
         * Attempts to release the permission represented by `permission`.
         *
         * This is the first half of the asynchronous version of
         * g_permission_release().
         * @virtual
         * @param cancellable a #GCancellable, or %NULL
         * @param callback the #GAsyncReadyCallback to call when done
         */
        vfunc_release_async(
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Collects the result of attempting to release the permission
         * represented by `permission`.
         *
         * This is the second half of the asynchronous version of
         * g_permission_release().
         * @virtual
         * @param result the #GAsyncResult given to the #GAsyncReadyCallback
         * @returns %TRUE if the permission was successfully released
         */
        vfunc_release_finish(result: AsyncResult): boolean;

        // Class property signals of Gio-2.0.Gio.Permission

        connect(
            sigName: 'notify::allowed',
            callback: ($obj: Permission, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::allowed',
            callback: ($obj: Permission, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::allowed', ...args: any[]): void;
        connect(
            sigName: 'notify::can-acquire',
            callback: ($obj: Permission, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::can-acquire',
            callback: ($obj: Permission, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::can-acquire', ...args: any[]): void;
        connect(
            sigName: 'notify::can-release',
            callback: ($obj: Permission, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::can-release',
            callback: ($obj: Permission, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::can-release', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * A #GPermission represents the status of the caller's permission to
     * perform a certain action.
     *
     * You can query if the action is currently allowed and if it is
     * possible to acquire the permission so that the action will be allowed
     * in the future.
     *
     * There is also an API to actually acquire the permission and one to
     * release it.
     *
     * As an example, a #GPermission might represent the ability for the
     * user to write to a #GSettings object.  This #GPermission object could
     * then be used to decide if it is appropriate to show a "Click here to
     * unlock" button in a dialog and to provide the mechanism to invoke
     * when that button is clicked.
     * @class
     */
    class Permission extends GObject.Object {
        // Own properties of Gio-2.0.Gio.Permission

        static name: string;
        static $gtype: GObject.GType<Permission>;

        // Constructors of Gio-2.0.Gio.Permission

        constructor(config?: Permission.ConstructorProperties);
        _init(config?: Permission.ConstructorProperties): void;
    }

    namespace PropertyAction {
        // Constructor properties interface

        interface ConstructorProperties
            extends Action.ConstructorProperties,
                GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.PropertyAction

            /**
             * If %TRUE, the state of the action will be the negation of the
             * property value, provided the property is boolean.
             */
            invert_boolean?: boolean | null;
            /**
             * The name of the action.  This is mostly meaningful for identifying
             * the action once it has been added to a #GActionMap.
             */
            name?: string | null;
            /**
             * The object to wrap a property on.
             *
             * The object must be a non-%NULL #GObject with properties.
             */
            object?: GObject.Object | null;
            /**
             * The name of the property to wrap on the object.
             *
             * The property must exist on the passed-in object and it must be
             * readable and writable (and not construct-only).
             */
            property_name?: string | null;
        }
    }

    interface PropertyAction extends Action {
        // Own properties of Gio-2.0.Gio.PropertyAction

        /**
         * If `action` is currently enabled.
         *
         * If the action is disabled then calls to g_action_activate() and
         * g_action_change_state() have no effect.
         */
        readonly enabled: boolean;
        /**
         * If %TRUE, the state of the action will be the negation of the
         * property value, provided the property is boolean.
         */
        readonly invert_boolean: boolean;
        /**
         * The name of the action.  This is mostly meaningful for identifying
         * the action once it has been added to a #GActionMap.
         */
        readonly name: string | null;
        /**
         * The object to wrap a property on.
         *
         * The object must be a non-%NULL #GObject with properties.
         */
        readonly object: GObject.Object;
        /**
         * The type of the parameter that must be given when activating the
         * action.
         */
        readonly parameter_type: GLib.VariantType;
        /**
         * The name of the property to wrap on the object.
         *
         * The property must exist on the passed-in object and it must be
         * readable and writable (and not construct-only).
         */
        readonly property_name: string | null;
        /**
         * The state of the action, or %NULL if the action is stateless.
         */
        readonly state: GLib.Variant;
        /**
         * The #GVariantType of the state that the action has, or %NULL if the
         * action is stateless.
         */
        readonly state_type: GLib.VariantType;

        // Class property signals of Gio-2.0.Gio.PropertyAction

        connect(
            sigName: 'notify::enabled',
            callback: ($obj: PropertyAction, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::enabled',
            callback: ($obj: PropertyAction, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::enabled', ...args: any[]): void;
        connect(
            sigName: 'notify::invert-boolean',
            callback: ($obj: PropertyAction, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::invert-boolean',
            callback: ($obj: PropertyAction, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::invert-boolean', ...args: any[]): void;
        connect(
            sigName: 'notify::name',
            callback: ($obj: PropertyAction, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::name',
            callback: ($obj: PropertyAction, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::name', ...args: any[]): void;
        connect(
            sigName: 'notify::object',
            callback: ($obj: PropertyAction, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::object',
            callback: ($obj: PropertyAction, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::object', ...args: any[]): void;
        connect(
            sigName: 'notify::parameter-type',
            callback: ($obj: PropertyAction, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::parameter-type',
            callback: ($obj: PropertyAction, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::parameter-type', ...args: any[]): void;
        connect(
            sigName: 'notify::property-name',
            callback: ($obj: PropertyAction, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::property-name',
            callback: ($obj: PropertyAction, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::property-name', ...args: any[]): void;
        connect(
            sigName: 'notify::state',
            callback: ($obj: PropertyAction, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::state',
            callback: ($obj: PropertyAction, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::state', ...args: any[]): void;
        connect(
            sigName: 'notify::state-type',
            callback: ($obj: PropertyAction, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::state-type',
            callback: ($obj: PropertyAction, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::state-type', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * A #GPropertyAction is a way to get a #GAction with a state value
     * reflecting and controlling the value of a #GObject property.
     *
     * The state of the action will correspond to the value of the property.
     * Changing it will change the property (assuming the requested value
     * matches the requirements as specified in the #GParamSpec).
     *
     * Only the most common types are presently supported.  Booleans are
     * mapped to booleans, strings to strings, signed/unsigned integers to
     * int32/uint32 and floats and doubles to doubles.
     *
     * If the property is an enum then the state will be string-typed and
     * conversion will automatically be performed between the enum value and
     * "nick" string as per the #GEnumValue table.
     *
     * Flags types are not currently supported.
     *
     * Properties of object types, boxed types and pointer types are not
     * supported and probably never will be.
     *
     * Properties of #GVariant types are not currently supported.
     *
     * If the property is boolean-valued then the action will have a NULL
     * parameter type, and activating the action (with no parameter) will
     * toggle the value of the property.
     *
     * In all other cases, the parameter type will correspond to the type of
     * the property.
     *
     * The general idea here is to reduce the number of locations where a
     * particular piece of state is kept (and therefore has to be synchronised
     * between). #GPropertyAction does not have a separate state that is kept
     * in sync with the property value -- its state is the property value.
     *
     * For example, it might be useful to create a #GAction corresponding to
     * the "visible-child-name" property of a #GtkStack so that the current
     * page can be switched from a menu.  The active radio indication in the
     * menu is then directly determined from the active page of the
     * #GtkStack.
     *
     * An anti-example would be binding the "active-id" property on a
     * #GtkComboBox.  This is because the state of the combobox itself is
     * probably uninteresting and is actually being used to control
     * something else.
     *
     * Another anti-example would be to bind to the "visible-child-name"
     * property of a #GtkStack if this value is actually stored in
     * #GSettings.  In that case, the real source of the value is
     * #GSettings.  If you want a #GAction to control a setting stored in
     * #GSettings, see g_settings_create_action() instead, and possibly
     * combine its use with g_settings_bind().
     * @class
     */
    class PropertyAction extends GObject.Object {
        // Own properties of Gio-2.0.Gio.PropertyAction

        static name: string;
        static $gtype: GObject.GType<PropertyAction>;

        // Constructors of Gio-2.0.Gio.PropertyAction

        constructor(config?: PropertyAction.ConstructorProperties);
        /**
         * Creates a #GAction corresponding to the value of property
         * `property_name` on `object`.
         *
         * The property must be existent and readable and writable (and not
         * construct-only).
         *
         * This function takes a reference on `object` and doesn't release it
         * until the action is destroyed.
         * @constructor
         * @param name the name of the action to create
         * @param object the object that has the property   to wrap
         * @param property_name the name of the property
         * @returns a new #GPropertyAction
         */
        constructor(
            name: string | null,
            object: GObject.Object,
            property_name: string | null
        );
        /**
         * Creates a #GAction corresponding to the value of property
         * `property_name` on `object`.
         *
         * The property must be existent and readable and writable (and not
         * construct-only).
         *
         * This function takes a reference on `object` and doesn't release it
         * until the action is destroyed.
         * @constructor
         * @param name the name of the action to create
         * @param object the object that has the property   to wrap
         * @param property_name the name of the property
         * @returns a new #GPropertyAction
         */
        static new(
            name: string | null,
            object: GObject.Object,
            property_name: string | null
        ): PropertyAction;
        _init(config?: PropertyAction.ConstructorProperties): void;
    }

    namespace ProxyAddress {
        // Constructor properties interface

        interface ConstructorProperties
            extends SocketConnectable.ConstructorProperties,
                InetSocketAddress.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.ProxyAddress

            destination_hostname?: string | null;
            destination_port?: number | null;
            /**
             * The protocol being spoke to the destination host, or %NULL if
             * the #GProxyAddress doesn't know.
             */
            destination_protocol?: string | null;
            password?: string | null;
            protocol?: string | null;
            /**
             * The URI string that the proxy was constructed from (or %NULL
             * if the creator didn't specify this).
             */
            uri?: string | null;
            username?: string | null;
        }
    }

    interface ProxyAddress extends SocketConnectable {
        // Own properties of Gio-2.0.Gio.ProxyAddress

        readonly destination_hostname: string | null;
        readonly destination_port: number;
        /**
         * The protocol being spoke to the destination host, or %NULL if
         * the #GProxyAddress doesn't know.
         */
        readonly destination_protocol: string | null;
        readonly password: string | null;
        readonly protocol: string | null;
        /**
         * The URI string that the proxy was constructed from (or %NULL
         * if the creator didn't specify this).
         */
        readonly uri: string | null;
        readonly username: string | null;

        // Own fields of Gio-2.0.Gio.ProxyAddress

        parent_instance: InetSocketAddress &
            SocketAddress &
            GObject.Object &
            GObject.Object;

        // Owm methods of Gio-2.0.Gio.ProxyAddress

        /**
         * Gets `proxy'`s destination hostname; that is, the name of the host
         * that will be connected to via the proxy, not the name of the proxy
         * itself.
         * @returns the @proxy's destination hostname
         */
        get_destination_hostname(): string | null;
        /**
         * Gets `proxy'`s destination port; that is, the port on the
         * destination host that will be connected to via the proxy, not the
         * port number of the proxy itself.
         * @returns the @proxy's destination port
         */
        get_destination_port(): number;
        /**
         * Gets the protocol that is being spoken to the destination
         * server; eg, "http" or "ftp".
         * @returns the @proxy's destination protocol
         */
        get_destination_protocol(): string | null;
        /**
         * Gets `proxy'`s password.
         * @returns the @proxy's password
         */
        get_password(): string | null;
        /**
         * Gets `proxy'`s protocol. eg, "socks" or "http"
         * @returns the @proxy's protocol
         */
        get_protocol(): string | null;
        /**
         * Gets the proxy URI that `proxy` was constructed from.
         * @returns the @proxy's URI, or %NULL if unknown
         */
        get_uri(): string | null;
        /**
         * Gets `proxy'`s username.
         * @returns the @proxy's username
         */
        get_username(): string | null;

        // Class property signals of Gio-2.0.Gio.ProxyAddress

        connect(
            sigName: 'notify::destination-hostname',
            callback: ($obj: ProxyAddress, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::destination-hostname',
            callback: ($obj: ProxyAddress, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::destination-hostname', ...args: any[]): void;
        connect(
            sigName: 'notify::destination-port',
            callback: ($obj: ProxyAddress, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::destination-port',
            callback: ($obj: ProxyAddress, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::destination-port', ...args: any[]): void;
        connect(
            sigName: 'notify::destination-protocol',
            callback: ($obj: ProxyAddress, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::destination-protocol',
            callback: ($obj: ProxyAddress, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::destination-protocol', ...args: any[]): void;
        connect(
            sigName: 'notify::password',
            callback: ($obj: ProxyAddress, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::password',
            callback: ($obj: ProxyAddress, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::password', ...args: any[]): void;
        connect(
            sigName: 'notify::protocol',
            callback: ($obj: ProxyAddress, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::protocol',
            callback: ($obj: ProxyAddress, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::protocol', ...args: any[]): void;
        connect(
            sigName: 'notify::uri',
            callback: ($obj: ProxyAddress, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::uri',
            callback: ($obj: ProxyAddress, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::uri', ...args: any[]): void;
        connect(
            sigName: 'notify::username',
            callback: ($obj: ProxyAddress, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::username',
            callback: ($obj: ProxyAddress, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::username', ...args: any[]): void;
        connect(
            sigName: 'notify::address',
            callback: ($obj: ProxyAddress, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::address',
            callback: ($obj: ProxyAddress, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::address', ...args: any[]): void;
        connect(
            sigName: 'notify::flowinfo',
            callback: ($obj: ProxyAddress, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::flowinfo',
            callback: ($obj: ProxyAddress, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::flowinfo', ...args: any[]): void;
        connect(
            sigName: 'notify::port',
            callback: ($obj: ProxyAddress, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::port',
            callback: ($obj: ProxyAddress, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::port', ...args: any[]): void;
        connect(
            sigName: 'notify::scope-id',
            callback: ($obj: ProxyAddress, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::scope-id',
            callback: ($obj: ProxyAddress, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::scope-id', ...args: any[]): void;
        connect(
            sigName: 'notify::family',
            callback: ($obj: ProxyAddress, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::family',
            callback: ($obj: ProxyAddress, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::family', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * Support for proxied #GInetSocketAddress.
     * @class
     */
    class ProxyAddress extends InetSocketAddress {
        // Own properties of Gio-2.0.Gio.ProxyAddress

        static name: string;
        static $gtype: GObject.GType<ProxyAddress>;

        // Constructors of Gio-2.0.Gio.ProxyAddress

        constructor(config?: ProxyAddress.ConstructorProperties);
        /**
         * Creates a new #GProxyAddress for `inetaddr` with `protocol` that should
         * tunnel through `dest_hostname` and `dest_port`.
         *
         * (Note that this method doesn't set the #GProxyAddress:uri or
         * #GProxyAddress:destination-protocol fields; use g_object_new()
         * directly if you want to set those.)
         * @constructor
         * @param inetaddr The proxy server #GInetAddress.
         * @param port The proxy server port.
         * @param protocol The proxy protocol to support, in lower case (e.g. socks, http).
         * @param dest_hostname The destination hostname the proxy should tunnel to.
         * @param dest_port The destination port to tunnel to.
         * @param username The username to authenticate to the proxy server     (or %NULL).
         * @param password The password to authenticate to the proxy server     (or %NULL).
         * @returns a new #GProxyAddress
         */
        constructor(
            inetaddr: InetAddress,
            port: number,
            protocol: string | null,
            dest_hostname: string | null,
            dest_port: number,
            username: string | null,
            password: string | null
        );
        /**
         * Creates a new #GProxyAddress for `inetaddr` with `protocol` that should
         * tunnel through `dest_hostname` and `dest_port`.
         *
         * (Note that this method doesn't set the #GProxyAddress:uri or
         * #GProxyAddress:destination-protocol fields; use g_object_new()
         * directly if you want to set those.)
         * @constructor
         * @param inetaddr The proxy server #GInetAddress.
         * @param port The proxy server port.
         * @param protocol The proxy protocol to support, in lower case (e.g. socks, http).
         * @param dest_hostname The destination hostname the proxy should tunnel to.
         * @param dest_port The destination port to tunnel to.
         * @param username The username to authenticate to the proxy server     (or %NULL).
         * @param password The password to authenticate to the proxy server     (or %NULL).
         * @returns a new #GProxyAddress
         */
        static new(
            inetaddr: InetAddress,
            port: number,
            protocol: string | null,
            dest_hostname: string | null,
            dest_port: number,
            username: string | null,
            password: string | null
        ): ProxyAddress;

        // Overloads of new

        /**
         * Creates a new #GInetSocketAddress for `address` and `port`.
         * @constructor
         * @param address a #GInetAddress
         * @param port a port number
         * @returns a new #GInetSocketAddress
         */
        static new(address: InetAddress, port: number): InetSocketAddress;
        _init(config?: ProxyAddress.ConstructorProperties): void;
    }

    namespace ProxyAddressEnumerator {
        // Constructor properties interface

        interface ConstructorProperties
            extends SocketAddressEnumerator.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.ProxyAddressEnumerator

            connectable?: SocketConnectable | null;
            /**
             * The default port to use if #GProxyAddressEnumerator:uri does not
             * specify one.
             */
            default_port?: number | null;
            /**
             * The proxy resolver to use.
             */
            proxy_resolver?: ProxyResolver | null;
            uri?: string | null;
        }
    }

    interface ProxyAddressEnumerator {
        // Own properties of Gio-2.0.Gio.ProxyAddressEnumerator

        readonly connectable: SocketConnectable;
        /**
         * The default port to use if #GProxyAddressEnumerator:uri does not
         * specify one.
         */
        readonly default_port: number;
        /**
         * The proxy resolver to use.
         */
        proxy_resolver: ProxyResolver;
        readonly uri: string | null;

        // Class property signals of Gio-2.0.Gio.ProxyAddressEnumerator

        connect(
            sigName: 'notify::connectable',
            callback: (
                $obj: ProxyAddressEnumerator,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::connectable',
            callback: (
                $obj: ProxyAddressEnumerator,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::connectable', ...args: any[]): void;
        connect(
            sigName: 'notify::default-port',
            callback: (
                $obj: ProxyAddressEnumerator,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::default-port',
            callback: (
                $obj: ProxyAddressEnumerator,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::default-port', ...args: any[]): void;
        connect(
            sigName: 'notify::proxy-resolver',
            callback: (
                $obj: ProxyAddressEnumerator,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::proxy-resolver',
            callback: (
                $obj: ProxyAddressEnumerator,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::proxy-resolver', ...args: any[]): void;
        connect(
            sigName: 'notify::uri',
            callback: (
                $obj: ProxyAddressEnumerator,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::uri',
            callback: (
                $obj: ProxyAddressEnumerator,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::uri', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GProxyAddressEnumerator is a wrapper around #GSocketAddressEnumerator which
     * takes the #GSocketAddress instances returned by the #GSocketAddressEnumerator
     * and wraps them in #GProxyAddress instances, using the given
     * #GProxyAddressEnumerator:proxy-resolver.
     *
     * This enumerator will be returned (for example, by
     * g_socket_connectable_enumerate()) as appropriate when a proxy is configured;
     * there should be no need to manually wrap a #GSocketAddressEnumerator instance
     * with one.
     * @class
     */
    class ProxyAddressEnumerator extends SocketAddressEnumerator {
        // Own properties of Gio-2.0.Gio.ProxyAddressEnumerator

        static name: string;
        static $gtype: GObject.GType<ProxyAddressEnumerator>;

        // Constructors of Gio-2.0.Gio.ProxyAddressEnumerator

        constructor(config?: ProxyAddressEnumerator.ConstructorProperties);
        _init(config?: ProxyAddressEnumerator.ConstructorProperties): void;
    }

    namespace Resolver {
        // Signal callback interfaces

        /**
         * Signal callback interface for `reload`
         */
        interface ReloadSignalCallback {
            ($obj: Resolver): void;
        }

        // Constructor properties interface

        interface ConstructorProperties
            extends GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.Resolver

            /**
             * The timeout applied to all resolver lookups, in milliseconds.
             *
             * This may be changed through the lifetime of the #GResolver. The new value
             * will apply to any lookups started after the change, but not to any
             * already-ongoing lookups.
             *
             * If this is `0`, no timeout is applied to lookups.
             *
             * No timeout was applied to lookups before this property was added in
             * GLib 2.78.
             */
            timeout?: number | null;
        }
    }

    interface Resolver {
        // Own properties of Gio-2.0.Gio.Resolver

        /**
         * The timeout applied to all resolver lookups, in milliseconds.
         *
         * This may be changed through the lifetime of the #GResolver. The new value
         * will apply to any lookups started after the change, but not to any
         * already-ongoing lookups.
         *
         * If this is `0`, no timeout is applied to lookups.
         *
         * No timeout was applied to lookups before this property was added in
         * GLib 2.78.
         */
        timeout: number;

        // Own fields of Gio-2.0.Gio.Resolver

        parent_instance: GObject.Object;
        priv: ResolverPrivate;

        // Owm methods of Gio-2.0.Gio.Resolver

        /**
         * Get the timeout applied to all resolver lookups. See #GResolver:timeout.
         * @returns the resolver timeout, in milliseconds, or `0` for no timeout
         */
        get_timeout(): number;
        /**
         * Synchronously reverse-resolves `address` to determine its
         * associated hostname.
         *
         * If the DNS resolution fails, `error` (if non-%NULL) will be set to
         * a value from #GResolverError.
         *
         * If `cancellable` is non-%NULL, it can be used to cancel the
         * operation, in which case `error` (if non-%NULL) will be set to
         * %G_IO_ERROR_CANCELLED.
         * @param address the address to reverse-resolve
         * @param cancellable a #GCancellable, or %NULL
         * @returns a hostname (either ASCII-only, or in ASCII-encoded     form), or %NULL on error.
         */
        lookup_by_address(
            address: InetAddress,
            cancellable: Cancellable | null
        ): string | null;
        /**
         * Begins asynchronously reverse-resolving `address` to determine its
         * associated hostname, and eventually calls `callback,` which must
         * call g_resolver_lookup_by_address_finish() to get the final result.
         * @param address the address to reverse-resolve
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call after resolution completes
         */
        lookup_by_address_async(
            address: InetAddress,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of lookup_by_address_async

        /**
         * Promisified version of {@link lookup_by_address_async}
         *
         * Begins asynchronously reverse-resolving `address` to determine its
         * associated hostname, and eventually calls `callback,` which must
         * call g_resolver_lookup_by_address_finish() to get the final result.
         * @param address the address to reverse-resolve
         * @param cancellable a #GCancellable, or %NULL
         * @returns A Promise of: a hostname (either ASCII-only, or in ASCII-encoded form), or %NULL on error.
         */
        lookup_by_address_async(
            address: InetAddress,
            cancellable: Cancellable | null
        ): globalThis.Promise<string | null>;
        /**
         * Retrieves the result of a previous call to
         * g_resolver_lookup_by_address_async().
         *
         * If the DNS resolution failed, `error` (if non-%NULL) will be set to
         * a value from #GResolverError. If the operation was cancelled,
         * `error` will be set to %G_IO_ERROR_CANCELLED.
         * @param result the result passed to your #GAsyncReadyCallback
         * @returns a hostname (either ASCII-only, or in ASCII-encoded form), or %NULL on error.
         */
        lookup_by_address_finish(result: AsyncResult): string | null;
        /**
         * Synchronously resolves `hostname` to determine its associated IP
         * address(es). `hostname` may be an ASCII-only or UTF-8 hostname, or
         * the textual form of an IP address (in which case this just becomes
         * a wrapper around g_inet_address_new_from_string()).
         *
         * On success, g_resolver_lookup_by_name() will return a non-empty #GList of
         * #GInetAddress, sorted in order of preference and guaranteed to not
         * contain duplicates. That is, if using the result to connect to
         * `hostname,` you should attempt to connect to the first address
         * first, then the second if the first fails, etc. If you are using
         * the result to listen on a socket, it is appropriate to add each
         * result using e.g. g_socket_listener_add_address().
         *
         * If the DNS resolution fails, `error` (if non-%NULL) will be set to a
         * value from #GResolverError and %NULL will be returned.
         *
         * If `cancellable` is non-%NULL, it can be used to cancel the
         * operation, in which case `error` (if non-%NULL) will be set to
         * %G_IO_ERROR_CANCELLED.
         *
         * If you are planning to connect to a socket on the resolved IP
         * address, it may be easier to create a #GNetworkAddress and use its
         * #GSocketConnectable interface.
         * @param hostname the hostname to look up
         * @param cancellable a #GCancellable, or %NULL
         * @returns a non-empty #GList of #GInetAddress, or %NULL on error. You must unref each of the addresses and free the list when you are done with it. (You can use g_resolver_free_addresses() to do this.)
         */
        lookup_by_name(
            hostname: string | null,
            cancellable: Cancellable | null
        ): InetAddress[];
        /**
         * Begins asynchronously resolving `hostname` to determine its
         * associated IP address(es), and eventually calls `callback,` which
         * must call g_resolver_lookup_by_name_finish() to get the result.
         * See g_resolver_lookup_by_name() for more details.
         * @param hostname the hostname to look up the address of
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call after resolution completes
         */
        lookup_by_name_async(
            hostname: string | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of lookup_by_name_async

        /**
         * Promisified version of {@link lookup_by_name_async}
         *
         * Begins asynchronously resolving `hostname` to determine its
         * associated IP address(es), and eventually calls `callback,` which
         * must call g_resolver_lookup_by_name_finish() to get the result.
         * See g_resolver_lookup_by_name() for more details.
         * @param hostname the hostname to look up the address of
         * @param cancellable a #GCancellable, or %NULL
         * @returns A Promise of: a #GList of #GInetAddress, or %NULL on error. See g_resolver_lookup_by_name() for more details.
         */
        lookup_by_name_async(
            hostname: string | null,
            cancellable: Cancellable | null
        ): globalThis.Promise<InetAddress[]>;
        /**
         * Retrieves the result of a call to
         * g_resolver_lookup_by_name_async().
         *
         * If the DNS resolution failed, `error` (if non-%NULL) will be set to
         * a value from #GResolverError. If the operation was cancelled,
         * `error` will be set to %G_IO_ERROR_CANCELLED.
         * @param result the result passed to your #GAsyncReadyCallback
         * @returns a #GList of #GInetAddress, or %NULL on error. See g_resolver_lookup_by_name() for more details.
         */
        lookup_by_name_finish(result: AsyncResult): InetAddress[];
        /**
         * This differs from g_resolver_lookup_by_name() in that you can modify
         * the lookup behavior with `flags`. For example this can be used to limit
         * results with %G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY.
         * @param hostname the hostname to look up
         * @param flags extra #GResolverNameLookupFlags for the lookup
         * @param cancellable a #GCancellable, or %NULL
         * @returns a non-empty #GList of #GInetAddress, or %NULL on error. You must unref each of the addresses and free the list when you are done with it. (You can use g_resolver_free_addresses() to do this.)
         */
        lookup_by_name_with_flags(
            hostname: string | null,
            flags: ResolverNameLookupFlags,
            cancellable: Cancellable | null
        ): InetAddress[];
        /**
         * Begins asynchronously resolving `hostname` to determine its
         * associated IP address(es), and eventually calls `callback,` which
         * must call g_resolver_lookup_by_name_with_flags_finish() to get the result.
         * See g_resolver_lookup_by_name() for more details.
         * @param hostname the hostname to look up the address of
         * @param flags extra #GResolverNameLookupFlags for the lookup
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call after resolution completes
         */
        lookup_by_name_with_flags_async(
            hostname: string | null,
            flags: ResolverNameLookupFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of lookup_by_name_with_flags_async

        /**
         * Promisified version of {@link lookup_by_name_with_flags_async}
         *
         * Begins asynchronously resolving `hostname` to determine its
         * associated IP address(es), and eventually calls `callback,` which
         * must call g_resolver_lookup_by_name_with_flags_finish() to get the result.
         * See g_resolver_lookup_by_name() for more details.
         * @param hostname the hostname to look up the address of
         * @param flags extra #GResolverNameLookupFlags for the lookup
         * @param cancellable a #GCancellable, or %NULL
         * @returns A Promise of: a #GList of #GInetAddress, or %NULL on error. See g_resolver_lookup_by_name() for more details.
         */
        lookup_by_name_with_flags_async(
            hostname: string | null,
            flags: ResolverNameLookupFlags,
            cancellable: Cancellable | null
        ): globalThis.Promise<InetAddress[]>;
        /**
         * Retrieves the result of a call to
         * g_resolver_lookup_by_name_with_flags_async().
         *
         * If the DNS resolution failed, `error` (if non-%NULL) will be set to
         * a value from #GResolverError. If the operation was cancelled,
         * `error` will be set to %G_IO_ERROR_CANCELLED.
         * @param result the result passed to your #GAsyncReadyCallback
         * @returns a #GList of #GInetAddress, or %NULL on error. See g_resolver_lookup_by_name() for more details.
         */
        lookup_by_name_with_flags_finish(result: AsyncResult): InetAddress[];
        /**
         * Synchronously performs a DNS record lookup for the given `rrname` and returns
         * a list of records as #GVariant tuples. See #GResolverRecordType for
         * information on what the records contain for each `record_type`.
         *
         * If the DNS resolution fails, `error` (if non-%NULL) will be set to
         * a value from #GResolverError and %NULL will be returned.
         *
         * If `cancellable` is non-%NULL, it can be used to cancel the
         * operation, in which case `error` (if non-%NULL) will be set to
         * %G_IO_ERROR_CANCELLED.
         * @param rrname the DNS name to look up the record for
         * @param record_type the type of DNS record to look up
         * @param cancellable a #GCancellable, or %NULL
         * @returns a non-empty #GList of #GVariant, or %NULL on error. You must free each of the records and the list when you are done with it. (You can use g_list_free_full() with g_variant_unref() to do this.)
         */
        lookup_records(
            rrname: string | null,
            record_type: ResolverRecordType,
            cancellable: Cancellable | null
        ): GLib.Variant[];
        /**
         * Begins asynchronously performing a DNS lookup for the given
         * `rrname,` and eventually calls `callback,` which must call
         * g_resolver_lookup_records_finish() to get the final result. See
         * g_resolver_lookup_records() for more details.
         * @param rrname the DNS name to look up the record for
         * @param record_type the type of DNS record to look up
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call after resolution completes
         */
        lookup_records_async(
            rrname: string | null,
            record_type: ResolverRecordType,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of lookup_records_async

        /**
         * Promisified version of {@link lookup_records_async}
         *
         * Begins asynchronously performing a DNS lookup for the given
         * `rrname,` and eventually calls `callback,` which must call
         * g_resolver_lookup_records_finish() to get the final result. See
         * g_resolver_lookup_records() for more details.
         * @param rrname the DNS name to look up the record for
         * @param record_type the type of DNS record to look up
         * @param cancellable a #GCancellable, or %NULL
         * @returns A Promise of: a non-empty #GList of #GVariant, or %NULL on error. You must free each of the records and the list when you are done with it. (You can use g_list_free_full() with g_variant_unref() to do this.)
         */
        lookup_records_async(
            rrname: string | null,
            record_type: ResolverRecordType,
            cancellable: Cancellable | null
        ): globalThis.Promise<GLib.Variant[]>;
        /**
         * Retrieves the result of a previous call to
         * g_resolver_lookup_records_async(). Returns a non-empty list of records as
         * #GVariant tuples. See #GResolverRecordType for information on what the
         * records contain.
         *
         * If the DNS resolution failed, `error` (if non-%NULL) will be set to
         * a value from #GResolverError. If the operation was cancelled,
         * `error` will be set to %G_IO_ERROR_CANCELLED.
         * @param result the result passed to your #GAsyncReadyCallback
         * @returns a non-empty #GList of #GVariant, or %NULL on error. You must free each of the records and the list when you are done with it. (You can use g_list_free_full() with g_variant_unref() to do this.)
         */
        lookup_records_finish(result: AsyncResult): GLib.Variant[];
        /**
         * Synchronously performs a DNS SRV lookup for the given `service` and
         * `protocol` in the given `domain` and returns an array of #GSrvTarget.
         * `domain` may be an ASCII-only or UTF-8 hostname. Note also that the
         * `service` and `protocol` arguments do not include the leading underscore
         * that appears in the actual DNS entry.
         *
         * On success, g_resolver_lookup_service() will return a non-empty #GList of
         * #GSrvTarget, sorted in order of preference. (That is, you should
         * attempt to connect to the first target first, then the second if
         * the first fails, etc.)
         *
         * If the DNS resolution fails, `error` (if non-%NULL) will be set to
         * a value from #GResolverError and %NULL will be returned.
         *
         * If `cancellable` is non-%NULL, it can be used to cancel the
         * operation, in which case `error` (if non-%NULL) will be set to
         * %G_IO_ERROR_CANCELLED.
         *
         * If you are planning to connect to the service, it is usually easier
         * to create a #GNetworkService and use its #GSocketConnectable
         * interface.
         * @param service the service type to look up (eg, "ldap")
         * @param protocol the networking protocol to use for `service` (eg, "tcp")
         * @param domain the DNS domain to look up the service in
         * @param cancellable a #GCancellable, or %NULL
         * @returns a non-empty #GList of #GSrvTarget, or %NULL on error. You must free each of the targets and the list when you are done with it. (You can use g_resolver_free_targets() to do this.)
         */
        lookup_service(
            service: string | null,
            protocol: string | null,
            domain: string | null,
            cancellable: Cancellable | null
        ): SrvTarget[];
        /**
         * Begins asynchronously performing a DNS SRV lookup for the given
         * `service` and `protocol` in the given `domain,` and eventually calls
         * `callback,` which must call g_resolver_lookup_service_finish() to
         * get the final result. See g_resolver_lookup_service() for more
         * details.
         * @param service the service type to look up (eg, "ldap")
         * @param protocol the networking protocol to use for `service` (eg, "tcp")
         * @param domain the DNS domain to look up the service in
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call after resolution completes
         */
        lookup_service_async(
            service: string | null,
            protocol: string | null,
            domain: string | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of lookup_service_async

        /**
         * Promisified version of {@link lookup_service_async}
         *
         * Begins asynchronously performing a DNS SRV lookup for the given
         * `service` and `protocol` in the given `domain,` and eventually calls
         * `callback,` which must call g_resolver_lookup_service_finish() to
         * get the final result. See g_resolver_lookup_service() for more
         * details.
         * @param service the service type to look up (eg, "ldap")
         * @param protocol the networking protocol to use for `service` (eg, "tcp")
         * @param domain the DNS domain to look up the service in
         * @param cancellable a #GCancellable, or %NULL
         * @returns A Promise of: a non-empty #GList of #GSrvTarget, or %NULL on error. See g_resolver_lookup_service() for more details.
         */
        lookup_service_async(
            service: string | null,
            protocol: string | null,
            domain: string | null,
            cancellable: Cancellable | null
        ): globalThis.Promise<SrvTarget[]>;
        /**
         * Retrieves the result of a previous call to
         * g_resolver_lookup_service_async().
         *
         * If the DNS resolution failed, `error` (if non-%NULL) will be set to
         * a value from #GResolverError. If the operation was cancelled,
         * `error` will be set to %G_IO_ERROR_CANCELLED.
         * @param result the result passed to your #GAsyncReadyCallback
         * @returns a non-empty #GList of #GSrvTarget, or %NULL on error. See g_resolver_lookup_service() for more details.
         */
        lookup_service_finish(result: AsyncResult): SrvTarget[];
        /**
         * Sets `resolver` to be the application's default resolver (reffing
         * `resolver,` and unreffing the previous default resolver, if any).
         * Future calls to g_resolver_get_default() will return this resolver.
         *
         * This can be used if an application wants to perform any sort of DNS
         * caching or "pinning"; it can implement its own #GResolver that
         * calls the original default resolver for DNS operations, and
         * implements its own cache policies on top of that, and then set
         * itself as the default resolver for all later code to use.
         */
        set_default(): void;
        /**
         * Set the timeout applied to all resolver lookups. See #GResolver:timeout.
         * @param timeout_ms timeout in milliseconds, or `0` for no timeouts
         */
        set_timeout(timeout_ms: number): void;

        // Own virtual methods of Gio-2.0.Gio.Resolver

        /**
         * Synchronously reverse-resolves `address` to determine its
         * associated hostname.
         *
         * If the DNS resolution fails, `error` (if non-%NULL) will be set to
         * a value from #GResolverError.
         *
         * If `cancellable` is non-%NULL, it can be used to cancel the
         * operation, in which case `error` (if non-%NULL) will be set to
         * %G_IO_ERROR_CANCELLED.
         * @virtual
         * @param address the address to reverse-resolve
         * @param cancellable a #GCancellable, or %NULL
         * @returns a hostname (either ASCII-only, or in ASCII-encoded     form), or %NULL on error.
         */
        vfunc_lookup_by_address(
            address: InetAddress,
            cancellable: Cancellable | null
        ): string | null;
        /**
         * Begins asynchronously reverse-resolving `address` to determine its
         * associated hostname, and eventually calls `callback,` which must
         * call g_resolver_lookup_by_address_finish() to get the final result.
         * @virtual
         * @param address the address to reverse-resolve
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call after resolution completes
         */
        vfunc_lookup_by_address_async(
            address: InetAddress,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Retrieves the result of a previous call to
         * g_resolver_lookup_by_address_async().
         *
         * If the DNS resolution failed, `error` (if non-%NULL) will be set to
         * a value from #GResolverError. If the operation was cancelled,
         * `error` will be set to %G_IO_ERROR_CANCELLED.
         * @virtual
         * @param result the result passed to your #GAsyncReadyCallback
         * @returns a hostname (either ASCII-only, or in ASCII-encoded form), or %NULL on error.
         */
        vfunc_lookup_by_address_finish(result: AsyncResult): string | null;
        /**
         * Synchronously resolves `hostname` to determine its associated IP
         * address(es). `hostname` may be an ASCII-only or UTF-8 hostname, or
         * the textual form of an IP address (in which case this just becomes
         * a wrapper around g_inet_address_new_from_string()).
         *
         * On success, g_resolver_lookup_by_name() will return a non-empty #GList of
         * #GInetAddress, sorted in order of preference and guaranteed to not
         * contain duplicates. That is, if using the result to connect to
         * `hostname,` you should attempt to connect to the first address
         * first, then the second if the first fails, etc. If you are using
         * the result to listen on a socket, it is appropriate to add each
         * result using e.g. g_socket_listener_add_address().
         *
         * If the DNS resolution fails, `error` (if non-%NULL) will be set to a
         * value from #GResolverError and %NULL will be returned.
         *
         * If `cancellable` is non-%NULL, it can be used to cancel the
         * operation, in which case `error` (if non-%NULL) will be set to
         * %G_IO_ERROR_CANCELLED.
         *
         * If you are planning to connect to a socket on the resolved IP
         * address, it may be easier to create a #GNetworkAddress and use its
         * #GSocketConnectable interface.
         * @virtual
         * @param hostname the hostname to look up
         * @param cancellable a #GCancellable, or %NULL
         * @returns a non-empty #GList of #GInetAddress, or %NULL on error. You must unref each of the addresses and free the list when you are done with it. (You can use g_resolver_free_addresses() to do this.)
         */
        vfunc_lookup_by_name(
            hostname: string | null,
            cancellable: Cancellable | null
        ): InetAddress[];
        /**
         * Begins asynchronously resolving `hostname` to determine its
         * associated IP address(es), and eventually calls `callback,` which
         * must call g_resolver_lookup_by_name_finish() to get the result.
         * See g_resolver_lookup_by_name() for more details.
         * @virtual
         * @param hostname the hostname to look up the address of
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call after resolution completes
         */
        vfunc_lookup_by_name_async(
            hostname: string | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Retrieves the result of a call to
         * g_resolver_lookup_by_name_async().
         *
         * If the DNS resolution failed, `error` (if non-%NULL) will be set to
         * a value from #GResolverError. If the operation was cancelled,
         * `error` will be set to %G_IO_ERROR_CANCELLED.
         * @virtual
         * @param result the result passed to your #GAsyncReadyCallback
         * @returns a #GList of #GInetAddress, or %NULL on error. See g_resolver_lookup_by_name() for more details.
         */
        vfunc_lookup_by_name_finish(result: AsyncResult): InetAddress[];
        /**
         * This differs from g_resolver_lookup_by_name() in that you can modify
         * the lookup behavior with `flags`. For example this can be used to limit
         * results with %G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY.
         * @virtual
         * @param hostname the hostname to look up
         * @param flags extra #GResolverNameLookupFlags for the lookup
         * @param cancellable a #GCancellable, or %NULL
         * @returns a non-empty #GList of #GInetAddress, or %NULL on error. You must unref each of the addresses and free the list when you are done with it. (You can use g_resolver_free_addresses() to do this.)
         */
        vfunc_lookup_by_name_with_flags(
            hostname: string | null,
            flags: ResolverNameLookupFlags,
            cancellable: Cancellable | null
        ): InetAddress[];
        /**
         * Begins asynchronously resolving `hostname` to determine its
         * associated IP address(es), and eventually calls `callback,` which
         * must call g_resolver_lookup_by_name_with_flags_finish() to get the result.
         * See g_resolver_lookup_by_name() for more details.
         * @virtual
         * @param hostname the hostname to look up the address of
         * @param flags extra #GResolverNameLookupFlags for the lookup
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call after resolution completes
         */
        vfunc_lookup_by_name_with_flags_async(
            hostname: string | null,
            flags: ResolverNameLookupFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Retrieves the result of a call to
         * g_resolver_lookup_by_name_with_flags_async().
         *
         * If the DNS resolution failed, `error` (if non-%NULL) will be set to
         * a value from #GResolverError. If the operation was cancelled,
         * `error` will be set to %G_IO_ERROR_CANCELLED.
         * @virtual
         * @param result the result passed to your #GAsyncReadyCallback
         * @returns a #GList of #GInetAddress, or %NULL on error. See g_resolver_lookup_by_name() for more details.
         */
        vfunc_lookup_by_name_with_flags_finish(
            result: AsyncResult
        ): InetAddress[];
        /**
         * Synchronously performs a DNS record lookup for the given `rrname` and returns
         * a list of records as #GVariant tuples. See #GResolverRecordType for
         * information on what the records contain for each `record_type`.
         *
         * If the DNS resolution fails, `error` (if non-%NULL) will be set to
         * a value from #GResolverError and %NULL will be returned.
         *
         * If `cancellable` is non-%NULL, it can be used to cancel the
         * operation, in which case `error` (if non-%NULL) will be set to
         * %G_IO_ERROR_CANCELLED.
         * @virtual
         * @param rrname the DNS name to look up the record for
         * @param record_type the type of DNS record to look up
         * @param cancellable a #GCancellable, or %NULL
         * @returns a non-empty #GList of #GVariant, or %NULL on error. You must free each of the records and the list when you are done with it. (You can use g_list_free_full() with g_variant_unref() to do this.)
         */
        vfunc_lookup_records(
            rrname: string | null,
            record_type: ResolverRecordType,
            cancellable: Cancellable | null
        ): GLib.Variant[];
        /**
         * Begins asynchronously performing a DNS lookup for the given
         * `rrname,` and eventually calls `callback,` which must call
         * g_resolver_lookup_records_finish() to get the final result. See
         * g_resolver_lookup_records() for more details.
         * @virtual
         * @param rrname the DNS name to look up the record for
         * @param record_type the type of DNS record to look up
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call after resolution completes
         */
        vfunc_lookup_records_async(
            rrname: string | null,
            record_type: ResolverRecordType,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Retrieves the result of a previous call to
         * g_resolver_lookup_records_async(). Returns a non-empty list of records as
         * #GVariant tuples. See #GResolverRecordType for information on what the
         * records contain.
         *
         * If the DNS resolution failed, `error` (if non-%NULL) will be set to
         * a value from #GResolverError. If the operation was cancelled,
         * `error` will be set to %G_IO_ERROR_CANCELLED.
         * @virtual
         * @param result the result passed to your #GAsyncReadyCallback
         * @returns a non-empty #GList of #GVariant, or %NULL on error. You must free each of the records and the list when you are done with it. (You can use g_list_free_full() with g_variant_unref() to do this.)
         */
        vfunc_lookup_records_finish(result: AsyncResult): GLib.Variant[];
        vfunc_lookup_service_async(
            rrname: string | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Retrieves the result of a previous call to
         * g_resolver_lookup_service_async().
         *
         * If the DNS resolution failed, `error` (if non-%NULL) will be set to
         * a value from #GResolverError. If the operation was cancelled,
         * `error` will be set to %G_IO_ERROR_CANCELLED.
         * @virtual
         * @param result the result passed to your #GAsyncReadyCallback
         * @returns a non-empty #GList of #GSrvTarget, or %NULL on error. See g_resolver_lookup_service() for more details.
         */
        vfunc_lookup_service_finish(result: AsyncResult): SrvTarget[];
        vfunc_reload(): void;

        // Own signals of Gio-2.0.Gio.Resolver

        connect(
            sigName: 'reload',
            callback: Resolver.ReloadSignalCallback
        ): number;
        connect_after(
            sigName: 'reload',
            callback: Resolver.ReloadSignalCallback
        ): number;
        emit(sigName: 'reload', ...args: any[]): void;

        // Class property signals of Gio-2.0.Gio.Resolver

        connect(
            sigName: 'notify::timeout',
            callback: ($obj: Resolver, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::timeout',
            callback: ($obj: Resolver, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::timeout', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GResolver provides cancellable synchronous and asynchronous DNS
     * resolution, for hostnames (g_resolver_lookup_by_address(),
     * g_resolver_lookup_by_name() and their async variants) and SRV
     * (service) records (g_resolver_lookup_service()).
     *
     * #GNetworkAddress and #GNetworkService provide wrappers around
     * #GResolver functionality that also implement #GSocketConnectable,
     * making it easy to connect to a remote host/service.
     *
     * The default resolver (see g_resolver_get_default()) has a timeout of 30s set
     * on it since GLib 2.78. Earlier versions of GLib did not support resolver
     * timeouts.
     * @class
     */
    class Resolver extends GObject.Object {
        // Own properties of Gio-2.0.Gio.Resolver

        static name: string;
        static $gtype: GObject.GType<Resolver>;

        // Constructors of Gio-2.0.Gio.Resolver

        constructor(config?: Resolver.ConstructorProperties);
        _init(config?: Resolver.ConstructorProperties): void;
        /**
         * Gets the default #GResolver. You should unref it when you are done
         * with it. #GResolver may use its reference count as a hint about how
         * many threads it should allocate for concurrent DNS resolutions.
         * @returns the default #GResolver.
         */
        static get_default(): Resolver;
    }

    namespace Settings {
        // Signal callback interfaces

        /**
         * Signal callback interface for `change-event`
         */
        interface ChangeEventSignalCallback {
            ($obj: Settings, keys: GLib.Quark[] | null): boolean;
        }

        /**
         * Signal callback interface for `changed`
         */
        interface ChangedSignalCallback {
            ($obj: Settings, key: string | null): void;
        }

        /**
         * Signal callback interface for `writable-change-event`
         */
        interface WritableChangeEventSignalCallback {
            ($obj: Settings, key: number): boolean;
        }

        /**
         * Signal callback interface for `writable-changed`
         */
        interface WritableChangedSignalCallback {
            ($obj: Settings, key: string | null): void;
        }

        // Constructor properties interface

        interface ConstructorProperties
            extends GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.Settings

            /**
             * The name of the context that the settings are stored in.
             */
            backend?: SettingsBackend | null;
            /**
             * The path within the backend where the settings are stored.
             */
            path?: string | null;
            /**
             * The name of the schema that describes the types of keys
             * for this #GSettings object.
             *
             * The type of this property is *not* #GSettingsSchema.
             * #GSettingsSchema has only existed since version 2.32 and
             * unfortunately this name was used in previous versions to refer to
             * the schema ID rather than the schema itself.  Take care to use the
             * 'settings-schema' property if you wish to pass in a
             * #GSettingsSchema.
             */
            schema?: string | null;
            /**
             * The name of the schema that describes the types of keys
             * for this #GSettings object.
             */
            schema_id?: string | null;
            /**
             * The #GSettingsSchema describing the types of keys for this
             * #GSettings object.
             *
             * Ideally, this property would be called 'schema'.  #GSettingsSchema
             * has only existed since version 2.32, however, and before then the
             * 'schema' property was used to refer to the ID of the schema rather
             * than the schema itself.  Take care.
             */
            settings_schema?: SettingsSchema | null;
        }
    }

    interface Settings {
        // Own properties of Gio-2.0.Gio.Settings

        /**
         * The name of the context that the settings are stored in.
         */
        readonly backend: SettingsBackend;
        /**
         * Whether the #GSettings object is in 'delay-apply' mode. See
         * g_settings_delay() for details.
         */
        readonly delay_apply: boolean;
        /**
         * If this property is %TRUE, the #GSettings object has outstanding
         * changes that will be applied when g_settings_apply() is called.
         */
        readonly has_unapplied: boolean;
        /**
         * The path within the backend where the settings are stored.
         */
        readonly path: string | null;
        /**
         * The name of the schema that describes the types of keys
         * for this #GSettings object.
         *
         * The type of this property is *not* #GSettingsSchema.
         * #GSettingsSchema has only existed since version 2.32 and
         * unfortunately this name was used in previous versions to refer to
         * the schema ID rather than the schema itself.  Take care to use the
         * 'settings-schema' property if you wish to pass in a
         * #GSettingsSchema.
         */
        readonly schema: string | null;
        /**
         * The name of the schema that describes the types of keys
         * for this #GSettings object.
         */
        readonly schema_id: string | null;
        /**
         * The #GSettingsSchema describing the types of keys for this
         * #GSettings object.
         *
         * Ideally, this property would be called 'schema'.  #GSettingsSchema
         * has only existed since version 2.32, however, and before then the
         * 'schema' property was used to refer to the ID of the schema rather
         * than the schema itself.  Take care.
         */
        readonly settings_schema: SettingsSchema;

        // Own fields of Gio-2.0.Gio.Settings

        parent_instance: GObject.Object;
        priv: SettingsPrivate;

        // Owm methods of Gio-2.0.Gio.Settings

        /**
         * Applies any changes that have been made to the settings.  This
         * function does nothing unless `settings` is in 'delay-apply' mode;
         * see g_settings_delay().  In the normal case settings are always
         * applied immediately.
         */
        apply(): void;
        /**
         * Create a binding between the `key` in the `settings` object
         * and the property `property` of `object`.
         *
         * The binding uses the default GIO mapping functions to map
         * between the settings and property values. These functions
         * handle booleans, numeric types and string types in a
         * straightforward way. Use g_settings_bind_with_mapping() if
         * you need a custom mapping, or map between types that are not
         * supported by the default mapping functions.
         *
         * Unless the `flags` include %G_SETTINGS_BIND_NO_SENSITIVITY, this
         * function also establishes a binding between the writability of
         * `key` and the "sensitive" property of `object` (if `object` has
         * a boolean property by that name). See g_settings_bind_writable()
         * for more details about writable bindings.
         *
         * Note that the lifecycle of the binding is tied to `object,`
         * and that you can have only one binding per object property.
         * If you bind the same property twice on the same object, the second
         * binding overrides the first one.
         * @param key the key to bind
         * @param object a #GObject
         * @param property the name of the property to bind
         * @param flags flags for the binding
         */
        bind(
            key: string | null,
            object: GObject.Object,
            property: string | null,
            flags: SettingsBindFlags
        ): void;
        /**
         * Create a binding between the writability of `key` in the
         * `settings` object and the property `property` of `object`.
         * The property must be boolean; "sensitive" or "visible"
         * properties of widgets are the most likely candidates.
         *
         * Writable bindings are always uni-directional; changes of the
         * writability of the setting will be propagated to the object
         * property, not the other way.
         *
         * When the `inverted` argument is %TRUE, the binding inverts the
         * value as it passes from the setting to the object, i.e. `property`
         * will be set to %TRUE if the key is not writable.
         *
         * Note that the lifecycle of the binding is tied to `object,`
         * and that you can have only one binding per object property.
         * If you bind the same property twice on the same object, the second
         * binding overrides the first one.
         * @param key the key to bind
         * @param object a #GObject
         * @param property the name of a boolean property to bind
         * @param inverted whether to 'invert' the value
         */
        bind_writable(
            key: string | null,
            object: GObject.Object,
            property: string | null,
            inverted: boolean
        ): void;
        /**
         * Creates a #GAction corresponding to a given #GSettings key.
         *
         * The action has the same name as the key.
         *
         * The value of the key becomes the state of the action and the action
         * is enabled when the key is writable.  Changing the state of the
         * action results in the key being written to.  Changes to the value or
         * writability of the key cause appropriate change notifications to be
         * emitted for the action.
         *
         * For boolean-valued keys, action activations take no parameter and
         * result in the toggling of the value.  For all other types,
         * activations take the new value for the key (which must have the
         * correct type).
         * @param key the name of a key in `settings`
         * @returns a new #GAction
         */
        create_action(key: string | null): Action;
        /**
         * Changes the #GSettings object into 'delay-apply' mode. In this
         * mode, changes to `settings` are not immediately propagated to the
         * backend, but kept locally until g_settings_apply() is called.
         */
        delay(): void;
        /**
         * Gets the value that is stored at `key` in `settings`.
         *
         * A convenience variant of g_settings_get() for booleans.
         *
         * It is a programmer error to give a `key` that isn't specified as
         * having a boolean type in the schema for `settings`.
         * @param key the key to get the value for
         * @returns a boolean
         */
        get_boolean(key: string | null): boolean;
        /**
         * Creates a child settings object which has a base path of
         * `base-path/`name``, where `base-path` is the base path of
         * `settings`.
         *
         * The schema for the child settings object must have been declared
         * in the schema of `settings` using a `<child>` element.
         *
         * The created child settings object will inherit the #GSettings:delay-apply
         * mode from `settings`.
         * @param name the name of the child schema
         * @returns a 'child' settings object
         */
        get_child(name: string | null): Settings;
        /**
         * Gets the "default value" of a key.
         *
         * This is the value that would be read if g_settings_reset() were to be
         * called on the key.
         *
         * Note that this may be a different value than returned by
         * g_settings_schema_key_get_default_value() if the system administrator
         * has provided a default value.
         *
         * Comparing the return values of g_settings_get_default_value() and
         * g_settings_get_value() is not sufficient for determining if a value
         * has been set because the user may have explicitly set the value to
         * something that happens to be equal to the default.  The difference
         * here is that if the default changes in the future, the user's key
         * will still be set.
         *
         * This function may be useful for adding an indication to a UI of what
         * the default value was before the user set it.
         *
         * It is a programmer error to give a `key` that isn't contained in the
         * schema for `settings`.
         * @param key the key to get the default value for
         * @returns the default value
         */
        get_default_value(key: string | null): GLib.Variant | null;
        /**
         * Gets the value that is stored at `key` in `settings`.
         *
         * A convenience variant of g_settings_get() for doubles.
         *
         * It is a programmer error to give a `key` that isn't specified as
         * having a 'double' type in the schema for `settings`.
         * @param key the key to get the value for
         * @returns a double
         */
        get_double(key: string | null): number;
        /**
         * Gets the value that is stored in `settings` for `key` and converts it
         * to the enum value that it represents.
         *
         * In order to use this function the type of the value must be a string
         * and it must be marked in the schema file as an enumerated type.
         *
         * It is a programmer error to give a `key` that isn't contained in the
         * schema for `settings` or is not marked as an enumerated type.
         *
         * If the value stored in the configuration database is not a valid
         * value for the enumerated type then this function will return the
         * default value.
         * @param key the key to get the value for
         * @returns the enum value
         */
        get_enum(key: string | null): number;
        /**
         * Gets the value that is stored in `settings` for `key` and converts it
         * to the flags value that it represents.
         *
         * In order to use this function the type of the value must be an array
         * of strings and it must be marked in the schema file as a flags type.
         *
         * It is a programmer error to give a `key` that isn't contained in the
         * schema for `settings` or is not marked as a flags type.
         *
         * If the value stored in the configuration database is not a valid
         * value for the flags type then this function will return the default
         * value.
         * @param key the key to get the value for
         * @returns the flags value
         */
        get_flags(key: string | null): number;
        /**
         * Returns whether the #GSettings object has any unapplied
         * changes.  This can only be the case if it is in 'delayed-apply' mode.
         * @returns %TRUE if @settings has unapplied changes
         */
        get_has_unapplied(): boolean;
        /**
         * Gets the value that is stored at `key` in `settings`.
         *
         * A convenience variant of g_settings_get() for 32-bit integers.
         *
         * It is a programmer error to give a `key` that isn't specified as
         * having a int32 type in the schema for `settings`.
         * @param key the key to get the value for
         * @returns an integer
         */
        get_int(key: string | null): number;
        /**
         * Gets the value that is stored at `key` in `settings`.
         *
         * A convenience variant of g_settings_get() for 64-bit integers.
         *
         * It is a programmer error to give a `key` that isn't specified as
         * having a int64 type in the schema for `settings`.
         * @param key the key to get the value for
         * @returns a 64-bit integer
         */
        get_int64(key: string | null): number;
        /**
         * Gets the value that is stored at `key` in `settings,` subject to
         * application-level validation/mapping.
         *
         * You should use this function when the application needs to perform
         * some processing on the value of the key (for example, parsing).  The
         * `mapping` function performs that processing.  If the function
         * indicates that the processing was unsuccessful (due to a parse error,
         * for example) then the mapping is tried again with another value.
         *
         * This allows a robust 'fall back to defaults' behaviour to be
         * implemented somewhat automatically.
         *
         * The first value that is tried is the user's setting for the key.  If
         * the mapping function fails to map this value, other values may be
         * tried in an unspecified order (system or site defaults, translated
         * schema default values, untranslated schema default values, etc).
         *
         * If the mapping function fails for all possible values, one additional
         * attempt is made: the mapping function is called with a %NULL value.
         * If the mapping function still indicates failure at this point then
         * the application will be aborted.
         *
         * The result parameter for the `mapping` function is pointed to a
         * #gpointer which is initially set to %NULL.  The same pointer is given
         * to each invocation of `mapping`.  The final value of that #gpointer is
         * what is returned by this function.  %NULL is valid; it is returned
         * just as any other value would be.
         * @param key the key to get the value for
         * @param mapping the function to map the value in the           settings database to the value used by the application
         * @returns the result, which may be %NULL
         */
        get_mapped(key: string | null, mapping: SettingsGetMapping): any | null;
        /**
         * Queries the range of a key.
         * @param key the key to query the range of
         */
        get_range(key: string | null): GLib.Variant;
        /**
         * Gets the value that is stored at `key` in `settings`.
         *
         * A convenience variant of g_settings_get() for strings.
         *
         * It is a programmer error to give a `key` that isn't specified as
         * having a string type in the schema for `settings`.
         * @param key the key to get the value for
         * @returns a newly-allocated string
         */
        get_string(key: string | null): string | null;
        /**
         * A convenience variant of g_settings_get() for string arrays.
         *
         * It is a programmer error to give a `key` that isn't specified as
         * having an array of strings type in the schema for `settings`.
         * @param key the key to get the value for
         * @returns a newly-allocated, %NULL-terminated array of strings, the value that is stored at @key in @settings.
         */
        get_strv(key: string | null): string[];
        /**
         * Gets the value that is stored at `key` in `settings`.
         *
         * A convenience variant of g_settings_get() for 32-bit unsigned
         * integers.
         *
         * It is a programmer error to give a `key` that isn't specified as
         * having a uint32 type in the schema for `settings`.
         * @param key the key to get the value for
         * @returns an unsigned integer
         */
        get_uint(key: string | null): number;
        /**
         * Gets the value that is stored at `key` in `settings`.
         *
         * A convenience variant of g_settings_get() for 64-bit unsigned
         * integers.
         *
         * It is a programmer error to give a `key` that isn't specified as
         * having a uint64 type in the schema for `settings`.
         * @param key the key to get the value for
         * @returns a 64-bit unsigned integer
         */
        get_uint64(key: string | null): number;
        /**
         * Checks the "user value" of a key, if there is one.
         *
         * The user value of a key is the last value that was set by the user.
         *
         * After calling g_settings_reset() this function should always return
         * %NULL (assuming something is not wrong with the system
         * configuration).
         *
         * It is possible that g_settings_get_value() will return a different
         * value than this function.  This can happen in the case that the user
         * set a value for a key that was subsequently locked down by the system
         * administrator -- this function will return the user's old value.
         *
         * This function may be useful for adding a "reset" option to a UI or
         * for providing indication that a particular value has been changed.
         *
         * It is a programmer error to give a `key` that isn't contained in the
         * schema for `settings`.
         * @param key the key to get the user value for
         * @returns the user's value, if set
         */
        get_user_value(key: string | null): GLib.Variant | null;
        /**
         * Gets the value that is stored in `settings` for `key`.
         *
         * It is a programmer error to give a `key` that isn't contained in the
         * schema for `settings`.
         * @param key the key to get the value for
         * @returns a new #GVariant
         */
        get_value(key: string | null): GLib.Variant;
        /**
         * Finds out if a key can be written or not
         * @param name the name of a key
         * @returns %TRUE if the key @name is writable
         */
        is_writable(name: string | null): boolean;
        /**
         * Gets the list of children on `settings`.
         *
         * The list is exactly the list of strings for which it is not an error
         * to call g_settings_get_child().
         *
         * There is little reason to call this function from "normal" code, since
         * you should already know what children are in your schema. This function
         * may still be useful there for introspection reasons, however.
         *
         * You should free the return value with g_strfreev() when you are done
         * with it.
         * @returns a list of the children    on @settings, in no defined order
         */
        list_children(): string[];
        /**
         * Introspects the list of keys on `settings`.
         *
         * You should probably not be calling this function from "normal" code
         * (since you should already know what keys are in your schema).  This
         * function is intended for introspection reasons.
         *
         * You should free the return value with g_strfreev() when you are done
         * with it.
         * @returns a list    of the keys on @settings, in no defined order
         */
        list_keys(): string[];
        /**
         * Checks if the given `value` is of the correct type and within the
         * permitted range for `key`.
         * @param key the key to check
         * @param value the value to check
         * @returns %TRUE if @value is valid for @key
         */
        range_check(key: string | null, value: GLib.Variant): boolean;
        /**
         * Resets `key` to its default value.
         *
         * This call resets the key, as much as possible, to its default value.
         * That might be the value specified in the schema or the one set by the
         * administrator.
         * @param key the name of a key
         */
        reset(key: string | null): void;
        /**
         * Reverts all non-applied changes to the settings.  This function
         * does nothing unless `settings` is in 'delay-apply' mode; see
         * g_settings_delay().  In the normal case settings are always applied
         * immediately.
         *
         * Change notifications will be emitted for affected keys.
         */
        revert(): void;
        /**
         * Sets `key` in `settings` to `value`.
         *
         * A convenience variant of g_settings_set() for booleans.
         *
         * It is a programmer error to give a `key` that isn't specified as
         * having a boolean type in the schema for `settings`.
         * @param key the name of the key to set
         * @param value the value to set it to
         * @returns %TRUE if setting the key succeeded,     %FALSE if the key was not writable
         */
        set_boolean(key: string | null, value: boolean): boolean;
        /**
         * Sets `key` in `settings` to `value`.
         *
         * A convenience variant of g_settings_set() for doubles.
         *
         * It is a programmer error to give a `key` that isn't specified as
         * having a 'double' type in the schema for `settings`.
         * @param key the name of the key to set
         * @param value the value to set it to
         * @returns %TRUE if setting the key succeeded,     %FALSE if the key was not writable
         */
        set_double(key: string | null, value: number): boolean;
        /**
         * Looks up the enumerated type nick for `value` and writes it to `key,`
         * within `settings`.
         *
         * It is a programmer error to give a `key` that isn't contained in the
         * schema for `settings` or is not marked as an enumerated type, or for
         * `value` not to be a valid value for the named type.
         *
         * After performing the write, accessing `key` directly with
         * g_settings_get_string() will return the 'nick' associated with
         * `value`.
         * @param key a key, within `settings`
         * @param value an enumerated value
         * @returns %TRUE, if the set succeeds
         */
        set_enum(key: string | null, value: number): boolean;
        /**
         * Looks up the flags type nicks for the bits specified by `value,` puts
         * them in an array of strings and writes the array to `key,` within
         * `settings`.
         *
         * It is a programmer error to give a `key` that isn't contained in the
         * schema for `settings` or is not marked as a flags type, or for `value`
         * to contain any bits that are not value for the named type.
         *
         * After performing the write, accessing `key` directly with
         * g_settings_get_strv() will return an array of 'nicks'; one for each
         * bit in `value`.
         * @param key a key, within `settings`
         * @param value a flags value
         * @returns %TRUE, if the set succeeds
         */
        set_flags(key: string | null, value: number): boolean;
        /**
         * Sets `key` in `settings` to `value`.
         *
         * A convenience variant of g_settings_set() for 32-bit integers.
         *
         * It is a programmer error to give a `key` that isn't specified as
         * having a int32 type in the schema for `settings`.
         * @param key the name of the key to set
         * @param value the value to set it to
         * @returns %TRUE if setting the key succeeded,     %FALSE if the key was not writable
         */
        set_int(key: string | null, value: number): boolean;
        /**
         * Sets `key` in `settings` to `value`.
         *
         * A convenience variant of g_settings_set() for 64-bit integers.
         *
         * It is a programmer error to give a `key` that isn't specified as
         * having a int64 type in the schema for `settings`.
         * @param key the name of the key to set
         * @param value the value to set it to
         * @returns %TRUE if setting the key succeeded,     %FALSE if the key was not writable
         */
        set_int64(key: string | null, value: number): boolean;
        /**
         * Sets `key` in `settings` to `value`.
         *
         * A convenience variant of g_settings_set() for strings.
         *
         * It is a programmer error to give a `key` that isn't specified as
         * having a string type in the schema for `settings`.
         * @param key the name of the key to set
         * @param value the value to set it to
         * @returns %TRUE if setting the key succeeded,     %FALSE if the key was not writable
         */
        set_string(key: string | null, value: string | null): boolean;
        /**
         * Sets `key` in `settings` to `value`.
         *
         * A convenience variant of g_settings_set() for string arrays.  If
         * `value` is %NULL, then `key` is set to be the empty array.
         *
         * It is a programmer error to give a `key` that isn't specified as
         * having an array of strings type in the schema for `settings`.
         * @param key the name of the key to set
         * @param value the value to set it to, or %NULL
         * @returns %TRUE if setting the key succeeded,     %FALSE if the key was not writable
         */
        set_strv(key: string | null, value: string[] | null): boolean;
        /**
         * Sets `key` in `settings` to `value`.
         *
         * A convenience variant of g_settings_set() for 32-bit unsigned
         * integers.
         *
         * It is a programmer error to give a `key` that isn't specified as
         * having a uint32 type in the schema for `settings`.
         * @param key the name of the key to set
         * @param value the value to set it to
         * @returns %TRUE if setting the key succeeded,     %FALSE if the key was not writable
         */
        set_uint(key: string | null, value: number): boolean;
        /**
         * Sets `key` in `settings` to `value`.
         *
         * A convenience variant of g_settings_set() for 64-bit unsigned
         * integers.
         *
         * It is a programmer error to give a `key` that isn't specified as
         * having a uint64 type in the schema for `settings`.
         * @param key the name of the key to set
         * @param value the value to set it to
         * @returns %TRUE if setting the key succeeded,     %FALSE if the key was not writable
         */
        set_uint64(key: string | null, value: number): boolean;
        /**
         * Sets `key` in `settings` to `value`.
         *
         * It is a programmer error to give a `key` that isn't contained in the
         * schema for `settings` or for `value` to have the incorrect type, per
         * the schema.
         *
         * If `value` is floating then this function consumes the reference.
         * @param key the name of the key to set
         * @param value a #GVariant of the correct type
         * @returns %TRUE if setting the key succeeded,     %FALSE if the key was not writable
         */
        set_value(key: string | null, value: GLib.Variant): boolean;

        // Own virtual methods of Gio-2.0.Gio.Settings

        vfunc_change_event(keys: GLib.Quark, n_keys: number): boolean;
        vfunc_changed(key: string | null): void;
        vfunc_writable_change_event(key: GLib.Quark): boolean;
        vfunc_writable_changed(key: string | null): void;

        // Own signals of Gio-2.0.Gio.Settings

        connect(
            sigName: 'change-event',
            callback: Settings.ChangeEventSignalCallback
        ): number;
        connect_after(
            sigName: 'change-event',
            callback: Settings.ChangeEventSignalCallback
        ): number;
        emit(
            sigName: 'change-event',
            keys: GLib.Quark[] | null,
            ...args: any[]
        ): void;
        connect(
            sigName: 'changed',
            callback: Settings.ChangedSignalCallback
        ): number;
        connect_after(
            sigName: 'changed',
            callback: Settings.ChangedSignalCallback
        ): number;
        emit(sigName: 'changed', key: string | null, ...args: any[]): void;
        connect(
            sigName: 'writable-change-event',
            callback: Settings.WritableChangeEventSignalCallback
        ): number;
        connect_after(
            sigName: 'writable-change-event',
            callback: Settings.WritableChangeEventSignalCallback
        ): number;
        emit(
            sigName: 'writable-change-event',
            key: number,
            ...args: any[]
        ): void;
        connect(
            sigName: 'writable-changed',
            callback: Settings.WritableChangedSignalCallback
        ): number;
        connect_after(
            sigName: 'writable-changed',
            callback: Settings.WritableChangedSignalCallback
        ): number;
        emit(
            sigName: 'writable-changed',
            key: string | null,
            ...args: any[]
        ): void;

        // Class property signals of Gio-2.0.Gio.Settings

        connect(
            sigName: 'notify::backend',
            callback: ($obj: Settings, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::backend',
            callback: ($obj: Settings, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::backend', ...args: any[]): void;
        connect(
            sigName: 'notify::delay-apply',
            callback: ($obj: Settings, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::delay-apply',
            callback: ($obj: Settings, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::delay-apply', ...args: any[]): void;
        connect(
            sigName: 'notify::has-unapplied',
            callback: ($obj: Settings, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::has-unapplied',
            callback: ($obj: Settings, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::has-unapplied', ...args: any[]): void;
        connect(
            sigName: 'notify::path',
            callback: ($obj: Settings, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::path',
            callback: ($obj: Settings, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::path', ...args: any[]): void;
        connect(
            sigName: 'notify::schema',
            callback: ($obj: Settings, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::schema',
            callback: ($obj: Settings, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::schema', ...args: any[]): void;
        connect(
            sigName: 'notify::schema-id',
            callback: ($obj: Settings, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::schema-id',
            callback: ($obj: Settings, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::schema-id', ...args: any[]): void;
        connect(
            sigName: 'notify::settings-schema',
            callback: ($obj: Settings, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::settings-schema',
            callback: ($obj: Settings, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::settings-schema', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * The #GSettings class provides a convenient API for storing and retrieving
     * application settings.
     *
     * Reads and writes can be considered to be non-blocking.  Reading
     * settings with #GSettings is typically extremely fast: on
     * approximately the same order of magnitude (but slower than) a
     * #GHashTable lookup.  Writing settings is also extremely fast in terms
     * of time to return to your application, but can be extremely expensive
     * for other threads and other processes.  Many settings backends
     * (including dconf) have lazy initialisation which means in the common
     * case of the user using their computer without modifying any settings
     * a lot of work can be avoided.  For dconf, the D-Bus service doesn't
     * even need to be started in this case.  For this reason, you should
     * only ever modify #GSettings keys in response to explicit user action.
     * Particular care should be paid to ensure that modifications are not
     * made during startup -- for example, when setting the initial value
     * of preferences widgets.  The built-in g_settings_bind() functionality
     * is careful not to write settings in response to notify signals as a
     * result of modifications that it makes to widgets.
     *
     * When creating a GSettings instance, you have to specify a schema
     * that describes the keys in your settings and their types and default
     * values, as well as some other information.
     *
     * Normally, a schema has a fixed path that determines where the settings
     * are stored in the conceptual global tree of settings. However, schemas
     * can also be '[relocatable][gsettings-relocatable]', i.e. not equipped with
     * a fixed path. This is
     * useful e.g. when the schema describes an 'account', and you want to be
     * able to store a arbitrary number of accounts.
     *
     * Paths must start with and end with a forward slash character ('/')
     * and must not contain two sequential slash characters.  Paths should
     * be chosen based on a domain name associated with the program or
     * library to which the settings belong.  Examples of paths are
     * "/org/gtk/settings/file-chooser/" and "/ca/desrt/dconf-editor/".
     * Paths should not start with "/apps/", "/desktop/" or "/system/" as
     * they often did in GConf.
     *
     * Unlike other configuration systems (like GConf), GSettings does not
     * restrict keys to basic types like strings and numbers. GSettings stores
     * values as #GVariant, and allows any #GVariantType for keys. Key names
     * are restricted to lowercase characters, numbers and '-'. Furthermore,
     * the names must begin with a lowercase character, must not end
     * with a '-', and must not contain consecutive dashes.
     *
     * Similar to GConf, the default values in GSettings schemas can be
     * localized, but the localized values are stored in gettext catalogs
     * and looked up with the domain that is specified in the
     * `gettext-domain` attribute of the <schemalist> or <schema>
     * elements and the category that is specified in the `l10n` attribute of
     * the <default> element. The string which is translated includes all text in
     * the <default> element, including any surrounding quotation marks.
     *
     * The `l10n` attribute must be set to `messages` or `time`, and sets the
     * [locale category for
     * translation](https://www.gnu.org/software/gettext/manual/html_node/Aspects.html#index-locale-categories-1).
     * The `messages` category should be used by default; use `time` for
     * translatable date or time formats. A translation comment can be added as an
     * XML comment immediately above the <default> element  it is recommended to
     * add these comments to aid translators understand the meaning and
     * implications of the default value. An optional translation `context`
     * attribute can be set on the <default> element to disambiguate multiple
     * defaults which use the same string.
     *
     * For example:
     *
     * ```
     *  <!-- Translators: A list of words which are not allowed to be typed, in
     *       GVariant serialization syntax.
     *       See: https://developer.gnome.org/glib/stable/gvariant-text.html -->
     *  <default l10n='messages' context='Banned words'>['bad', 'words']</default>
     * ```
     *
     *
     * Translations of default values must remain syntactically valid serialized
     * #GVariants (e.g. retaining any surrounding quotation marks) or runtime
     * errors will occur.
     *
     * GSettings uses schemas in a compact binary form that is created
     * by the [glib-compile-schemas][glib-compile-schemas]
     * utility. The input is a schema description in an XML format.
     *
     * A DTD for the gschema XML format can be found here:
     * [gschema.dtd](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/gschema.dtd)
     *
     * The [glib-compile-schemas][glib-compile-schemas] tool expects schema
     * files to have the extension `.gschema.xml`.
     *
     * At runtime, schemas are identified by their id (as specified in the
     * id attribute of the <schema> element). The convention for schema
     * ids is to use a dotted name, similar in style to a D-Bus bus name,
     * e.g. "org.gnome.SessionManager". In particular, if the settings are
     * for a specific service that owns a D-Bus bus name, the D-Bus bus name
     * and schema id should match. For schemas which deal with settings not
     * associated with one named application, the id should not use
     * StudlyCaps, e.g. "org.gnome.font-rendering".
     *
     * In addition to #GVariant types, keys can have types that have
     * enumerated types. These can be described by a <choice>,
     * <enum> or <flags> element, as seen in the
     * [example][schema-enumerated]. The underlying type of such a key
     * is string, but you can use g_settings_get_enum(), g_settings_set_enum(),
     * g_settings_get_flags(), g_settings_set_flags() access the numeric values
     * corresponding to the string value of enum and flags keys.
     *
     * An example for default value:
     *
     * ```
     * <schemalist>
     *   <schema id="org.gtk.Test" path="/org/gtk/Test/" gettext-domain="test">
     *
     *     <key name="greeting" type="s">
     *       <default l10n="messages">"Hello, earthlings"</default>
     *       <summary>A greeting</summary>
     *       <description>
     *         Greeting of the invading martians
     *       </description>
     *     </key>
     *
     *     <key name="box" type="(ii)">
     *       <default>(20,30)</default>
     *     </key>
     *
     *     <key name="empty-string" type="s">
     *       <default>""</default>
     *       <summary>Empty strings have to be provided in GVariant form</summary>
     *     </key>
     *
     *   </schema>
     * </schemalist>
     * ```
     *
     *
     * An example for ranges, choices and enumerated types:
     *
     * ```
     * <schemalist>
     *
     *   <enum id="org.gtk.Test.myenum">
     *     <value nick="first" value="1"/>
     *     <value nick="second" value="2"/>
     *   </enum>
     *
     *   <flags id="org.gtk.Test.myflags">
     *     <value nick="flag1" value="1"/>
     *     <value nick="flag2" value="2"/>
     *     <value nick="flag3" value="4"/>
     *   </flags>
     *
     *   <schema id="org.gtk.Test">
     *
     *     <key name="key-with-range" type="i">
     *       <range min="1" max="100"/>
     *       <default>10</default>
     *     </key>
     *
     *     <key name="key-with-choices" type="s">
     *       <choices>
     *         <choice value='Elisabeth'/>
     *         <choice value='Annabeth'/>
     *         <choice value='Joe'/>
     *       </choices>
     *       <aliases>
     *         <alias value='Anna' target='Annabeth'/>
     *         <alias value='Beth' target='Elisabeth'/>
     *       </aliases>
     *       <default>'Joe'</default>
     *     </key>
     *
     *     <key name='enumerated-key' enum='org.gtk.Test.myenum'>
     *       <default>'first'</default>
     *     </key>
     *
     *     <key name='flags-key' flags='org.gtk.Test.myflags'>
     *       <default>["flag1","flag2"]</default>
     *     </key>
     *   </schema>
     * </schemalist>
     * ```
     *
     *
     * ## Vendor overrides
     *
     * Default values are defined in the schemas that get installed by
     * an application. Sometimes, it is necessary for a vendor or distributor
     * to adjust these defaults. Since patching the XML source for the schema
     * is inconvenient and error-prone,
     * [glib-compile-schemas][glib-compile-schemas] reads so-called vendor
     * override' files. These are keyfiles in the same directory as the XML
     * schema sources which can override default values. The schema id serves
     * as the group name in the key file, and the values are expected in
     * serialized GVariant form, as in the following example:
     *
     * ```
     *     [org.gtk.Example]
     *     key1='string'
     *     key2=1.5
     * ```
     *
     *
     * glib-compile-schemas expects schema files to have the extension
     * `.gschema.override`.
     *
     * ## Binding
     *
     * A very convenient feature of GSettings lets you bind #GObject properties
     * directly to settings, using g_settings_bind(). Once a GObject property
     * has been bound to a setting, changes on either side are automatically
     * propagated to the other side. GSettings handles details like mapping
     * between GObject and GVariant types, and preventing infinite cycles.
     *
     * This makes it very easy to hook up a preferences dialog to the
     * underlying settings. To make this even more convenient, GSettings
     * looks for a boolean property with the name "sensitivity" and
     * automatically binds it to the writability of the bound setting.
     * If this 'magic' gets in the way, it can be suppressed with the
     * %G_SETTINGS_BIND_NO_SENSITIVITY flag.
     *
     * ## Relocatable schemas # {#gsettings-relocatable}
     *
     * A relocatable schema is one with no `path` attribute specified on its
     * <schema> element. By using g_settings_new_with_path(), a #GSettings object
     * can be instantiated for a relocatable schema, assigning a path to the
     * instance. Paths passed to g_settings_new_with_path() will typically be
     * constructed dynamically from a constant prefix plus some form of instance
     * identifier; but they must still be valid GSettings paths. Paths could also
     * be constant and used with a globally installed schema originating from a
     * dependency library.
     *
     * For example, a relocatable schema could be used to store geometry information
     * for different windows in an application. If the schema ID was
     * `org.foo.MyApp.Window`, it could be instantiated for paths
     * `/org/foo/MyApp/main/`, `/org/foo/MyApp/document-1/`,
     * `/org/foo/MyApp/document-2/`, etc. If any of the paths are well-known
     * they can be specified as <child> elements in the parent schema, e.g.:
     *
     * ```
     * <schema id="org.foo.MyApp" path="/org/foo/MyApp/">
     *   <child name="main" schema="org.foo.MyApp.Window"/>
     * </schema>
     * ```
     *
     *
     * ## Build system integration # {#gsettings-build-system}
     *
     * GSettings comes with autotools integration to simplify compiling and
     * installing schemas. To add GSettings support to an application, add the
     * following to your `configure.ac`:
     *
     * ```
     * GLIB_GSETTINGS
     * ```
     *
     *
     * In the appropriate `Makefile.am`, use the following snippet to compile and
     * install the named schema:
     *
     * ```
     * gsettings_SCHEMAS = org.foo.MyApp.gschema.xml
     * EXTRA_DIST = $(gsettings_SCHEMAS)
     *
     * `GSETTINGS_RULES@`
     * ```
     *
     *
     * No changes are needed to the build system to mark a schema XML file for
     * translation. Assuming it sets the `gettext-domain` attribute, a schema may
     * be marked for translation by adding it to `POTFILES.in`, assuming gettext
     * 0.19 is in use (the preferred method for translation):
     *
     * ```
     * data/org.foo.MyApp.gschema.xml
     * ```
     *
     *
     * Alternatively, if intltool 0.50.1 is in use:
     *
     * ```
     * [type: gettext/gsettings]data/org.foo.MyApp.gschema.xml
     * ```
     *
     *
     * GSettings will use gettext to look up translations for the <summary> and
     * <description> elements, and also any <default> elements which have a `l10n`
     * attribute set. Translations must not be included in the `.gschema.xml` file
     * by the build system, for example by using intltool XML rules with a
     * `.gschema.xml.in` template.
     *
     * If an enumerated type defined in a C header file is to be used in a GSettings
     * schema, it can either be defined manually using an <enum> element in the
     * schema XML, or it can be extracted automatically from the C header. This
     * approach is preferred, as it ensures the two representations are always
     * synchronised. To do so, add the following to the relevant `Makefile.am`:
     *
     * ```
     * gsettings_ENUM_NAMESPACE = org.foo.MyApp
     * gsettings_ENUM_FILES = my-app-enums.h my-app-misc.h
     * ```
     *
     *
     * `gsettings_ENUM_NAMESPACE` specifies the schema namespace for the enum files,
     * which are specified in `gsettings_ENUM_FILES`. This will generate a
     * `org.foo.MyApp.enums.xml` file containing the extracted enums, which will be
     * automatically included in the schema compilation, install and uninstall
     * rules. It should not be committed to version control or included in
     * `EXTRA_DIST`.
     * @class
     */
    class Settings extends GObject.Object {
        // Own properties of Gio-2.0.Gio.Settings

        static name: string;
        static $gtype: GObject.GType<Settings>;

        // Constructors of Gio-2.0.Gio.Settings

        constructor(config?: Settings.ConstructorProperties);
        /**
         * Creates a new #GSettings object with the schema specified by
         * `schema_id`.
         *
         * It is an error for the schema to not exist: schemas are an
         * essential part of a program, as they provide type information.
         * If schemas need to be dynamically loaded (for example, from an
         * optional runtime dependency), g_settings_schema_source_lookup()
         * can be used to test for their existence before loading them.
         *
         * Signals on the newly created #GSettings object will be dispatched
         * via the thread-default #GMainContext in effect at the time of the
         * call to g_settings_new().  The new #GSettings will hold a reference
         * on the context.  See g_main_context_push_thread_default().
         * @constructor
         * @param schema_id the id of the schema
         * @returns a new #GSettings object
         */
        constructor(schema_id: string | null);
        /**
         * Creates a new #GSettings object with the schema specified by
         * `schema_id`.
         *
         * It is an error for the schema to not exist: schemas are an
         * essential part of a program, as they provide type information.
         * If schemas need to be dynamically loaded (for example, from an
         * optional runtime dependency), g_settings_schema_source_lookup()
         * can be used to test for their existence before loading them.
         *
         * Signals on the newly created #GSettings object will be dispatched
         * via the thread-default #GMainContext in effect at the time of the
         * call to g_settings_new().  The new #GSettings will hold a reference
         * on the context.  See g_main_context_push_thread_default().
         * @constructor
         * @param schema_id the id of the schema
         * @returns a new #GSettings object
         */
        static new(schema_id: string | null): Settings;
        /**
         * Creates a new #GSettings object with a given schema, backend and
         * path.
         *
         * It should be extremely rare that you ever want to use this function.
         * It is made available for advanced use-cases (such as plugin systems
         * that want to provide access to schemas loaded from custom locations,
         * etc).
         *
         * At the most basic level, a #GSettings object is a pure composition of
         * 4 things: a #GSettingsSchema, a #GSettingsBackend, a path within that
         * backend, and a #GMainContext to which signals are dispatched.
         *
         * This constructor therefore gives you full control over constructing
         * #GSettings instances.  The first 3 parameters are given directly as
         * `schema,` `backend` and `path,` and the main context is taken from the
         * thread-default (as per g_settings_new()).
         *
         * If `backend` is %NULL then the default backend is used.
         *
         * If `path` is %NULL then the path from the schema is used.  It is an
         * error if `path` is %NULL and the schema has no path of its own or if
         * `path` is non-%NULL and not equal to the path that the schema does
         * have.
         * @constructor
         * @param schema a #GSettingsSchema
         * @param backend a #GSettingsBackend
         * @param path the path to use
         * @returns a new #GSettings object
         */
        static new_full(
            schema: SettingsSchema,
            backend: SettingsBackend | null,
            path: string | null
        ): Settings;
        /**
         * Creates a new #GSettings object with the schema specified by
         * `schema_id` and a given #GSettingsBackend.
         *
         * Creating a #GSettings object with a different backend allows accessing
         * settings from a database other than the usual one. For example, it may make
         * sense to pass a backend corresponding to the "defaults" settings database on
         * the system to get a settings object that modifies the system default
         * settings instead of the settings for this user.
         * @constructor
         * @param schema_id the id of the schema
         * @param backend the #GSettingsBackend to use
         * @returns a new #GSettings object
         */
        static new_with_backend(
            schema_id: string | null,
            backend: SettingsBackend
        ): Settings;
        /**
         * Creates a new #GSettings object with the schema specified by
         * `schema_id` and a given #GSettingsBackend and path.
         *
         * This is a mix of g_settings_new_with_backend() and
         * g_settings_new_with_path().
         * @constructor
         * @param schema_id the id of the schema
         * @param backend the #GSettingsBackend to use
         * @param path the path to use
         * @returns a new #GSettings object
         */
        static new_with_backend_and_path(
            schema_id: string | null,
            backend: SettingsBackend,
            path: string | null
        ): Settings;
        /**
         * Creates a new #GSettings object with the relocatable schema specified
         * by `schema_id` and a given path.
         *
         * You only need to do this if you want to directly create a settings
         * object with a schema that doesn't have a specified path of its own.
         * That's quite rare.
         *
         * It is a programmer error to call this function for a schema that
         * has an explicitly specified path.
         *
         * It is a programmer error if `path` is not a valid path.  A valid path
         * begins and ends with '/' and does not contain two consecutive '/'
         * characters.
         * @constructor
         * @param schema_id the id of the schema
         * @param path the path to use
         * @returns a new #GSettings object
         */
        static new_with_path(
            schema_id: string | null,
            path: string | null
        ): Settings;
        _init(config?: Settings.ConstructorProperties): void;
        /**
         * Deprecated.
         * @returns a list of   relocatable #GSettings schemas that are available, in no defined order.   The list must not be modified or freed.
         */
        static list_relocatable_schemas(): string[];
        /**
         * Deprecated.
         * @returns a list of   #GSettings schemas that are available, in no defined order.  The list   must not be modified or freed.
         */
        static list_schemas(): string[];
        /**
         * Ensures that all pending operations are complete for the default backend.
         *
         * Writes made to a #GSettings are handled asynchronously.  For this
         * reason, it is very unlikely that the changes have it to disk by the
         * time g_settings_set() returns.
         *
         * This call will block until all of the writes have made it to the
         * backend.  Since the mainloop is not running, no change notifications
         * will be dispatched during this call (but some may be queued by the
         * time the call is done).
         */
        static sync(): void;
        /**
         * Removes an existing binding for `property` on `object`.
         *
         * Note that bindings are automatically removed when the
         * object is finalized, so it is rarely necessary to call this
         * function.
         * @param object the object
         * @param property the property whose binding is removed
         */
        static unbind(object: GObject.Object, property: string | null): void;
    }

    namespace SettingsBackend {
        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface SettingsBackend {
        // Own fields of Gio-2.0.Gio.SettingsBackend

        parent_instance: GObject.Object;

        // Owm methods of Gio-2.0.Gio.SettingsBackend

        /**
         * Signals that a single key has possibly changed.  Backend
         * implementations should call this if a key has possibly changed its
         * value.
         *
         * `key` must be a valid key (ie starting with a slash, not containing
         * '//', and not ending with a slash).
         *
         * The implementation must call this function during any call to
         * g_settings_backend_write(), before the call returns (except in the
         * case that no keys are actually changed and it cares to detect this
         * fact).  It may not rely on the existence of a mainloop for
         * dispatching the signal later.
         *
         * The implementation may call this function at any other time it likes
         * in response to other events (such as changes occurring outside of the
         * program).  These calls may originate from a mainloop or may originate
         * in response to any other action (including from calls to
         * g_settings_backend_write()).
         *
         * In the case that this call is in response to a call to
         * g_settings_backend_write() then `origin_tag` must be set to the same
         * value that was passed to that call.
         * @param key the name of the key
         * @param origin_tag the origin tag
         */
        changed(key: string | null, origin_tag: any | null): void;
        /**
         * This call is a convenience wrapper.  It gets the list of changes from
         * `tree,` computes the longest common prefix and calls
         * g_settings_backend_changed().
         * @param tree a #GTree containing the changes
         * @param origin_tag the origin tag
         */
        changed_tree(tree: GLib.Tree, origin_tag: any | null): void;
        /**
         * Signals that a list of keys have possibly changed.  Backend
         * implementations should call this if keys have possibly changed their
         * values.
         *
         * `path` must be a valid path (ie starting and ending with a slash and
         * not containing '//').  Each string in `items` must form a valid key
         * name when `path` is prefixed to it (ie: each item must not start or
         * end with '/' and must not contain '//').
         *
         * The meaning of this signal is that any of the key names resulting
         * from the contatenation of `path` with each item in `items` may have
         * changed.
         *
         * The same rules for when notifications must occur apply as per
         * g_settings_backend_changed().  These two calls can be used
         * interchangeably if exactly one item has changed (although in that
         * case g_settings_backend_changed() is definitely preferred).
         *
         * For efficiency reasons, the implementation should strive for `path` to
         * be as long as possible (ie: the longest common prefix of all of the
         * keys that were changed) but this is not strictly required.
         * @param path the path containing the changes
         * @param items the %NULL-terminated list of changed keys
         * @param origin_tag the origin tag
         */
        keys_changed(
            path: string | null,
            items: string[],
            origin_tag: any | null
        ): void;
        /**
         * Signals that all keys below a given path may have possibly changed.
         * Backend implementations should call this if an entire path of keys
         * have possibly changed their values.
         *
         * `path` must be a valid path (ie starting and ending with a slash and
         * not containing '//').
         *
         * The meaning of this signal is that any of the key which has a name
         * starting with `path` may have changed.
         *
         * The same rules for when notifications must occur apply as per
         * g_settings_backend_changed().  This call might be an appropriate
         * reasponse to a 'reset' call but implementations are also free to
         * explicitly list the keys that were affected by that call if they can
         * easily do so.
         *
         * For efficiency reasons, the implementation should strive for `path` to
         * be as long as possible (ie: the longest common prefix of all of the
         * keys that were changed) but this is not strictly required.  As an
         * example, if this function is called with the path of "/" then every
         * single key in the application will be notified of a possible change.
         * @param path the path containing the changes
         * @param origin_tag the origin tag
         */
        path_changed(path: string | null, origin_tag: any | null): void;
        /**
         * Signals that the writability of all keys below a given path may have
         * changed.
         *
         * Since GSettings performs no locking operations for itself, this call
         * will always be made in response to external events.
         * @param path the name of the path
         */
        path_writable_changed(path: string | null): void;
        /**
         * Signals that the writability of a single key has possibly changed.
         *
         * Since GSettings performs no locking operations for itself, this call
         * will always be made in response to external events.
         * @param key the name of the key
         */
        writable_changed(key: string | null): void;

        // Own virtual methods of Gio-2.0.Gio.SettingsBackend

        vfunc_get_writable(key: string | null): boolean;
        vfunc_read(
            key: string | null,
            expected_type: GLib.VariantType,
            default_value: boolean
        ): GLib.Variant;
        vfunc_read_user_value(
            key: string | null,
            expected_type: GLib.VariantType
        ): GLib.Variant;
        vfunc_reset(key: string | null, origin_tag: any | null): void;
        vfunc_subscribe(name: string | null): void;
        vfunc_sync(): void;
        vfunc_unsubscribe(name: string | null): void;
        vfunc_write(
            key: string | null,
            value: GLib.Variant,
            origin_tag: any | null
        ): boolean;
        vfunc_write_tree(tree: GLib.Tree, origin_tag: any | null): boolean;

        // Class property signals of Gio-2.0.Gio.SettingsBackend

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * The #GSettingsBackend interface defines a generic interface for
     * non-strictly-typed data that is stored in a hierarchy. To implement
     * an alternative storage backend for #GSettings, you need to implement
     * the #GSettingsBackend interface and then make it implement the
     * extension point %G_SETTINGS_BACKEND_EXTENSION_POINT_NAME.
     *
     * The interface defines methods for reading and writing values, a
     * method for determining if writing of certain values will fail
     * (lockdown) and a change notification mechanism.
     *
     * The semantics of the interface are very precisely defined and
     * implementations must carefully adhere to the expectations of
     * callers that are documented on each of the interface methods.
     *
     * Some of the #GSettingsBackend functions accept or return a #GTree.
     * These trees always have strings as keys and #GVariant as values.
     * g_settings_backend_create_tree() is a convenience function to create
     * suitable trees.
     *
     * The #GSettingsBackend API is exported to allow third-party
     * implementations, but does not carry the same stability guarantees
     * as the public GIO API. For this reason, you have to define the
     * C preprocessor symbol %G_SETTINGS_ENABLE_BACKEND before including
     * `gio/gsettingsbackend.h`.
     * @class
     */
    class SettingsBackend extends GObject.Object {
        // Own properties of Gio-2.0.Gio.SettingsBackend

        static name: string;
        static $gtype: GObject.GType<SettingsBackend>;

        // Constructors of Gio-2.0.Gio.SettingsBackend

        constructor(config?: SettingsBackend.ConstructorProperties);
        _init(config?: SettingsBackend.ConstructorProperties): void;
        /**
         * Calculate the longest common prefix of all keys in a tree and write
         * out an array of the key names relative to that prefix and,
         * optionally, the value to store at each of those keys.
         *
         * You must free the value returned in `path,` `keys` and `values` using
         * g_free().  You should not attempt to free or unref the contents of
         * `keys` or `values`.
         * @param tree a #GTree containing the changes
         */
        static flatten_tree(
            tree: GLib.Tree
        ): [
            /* path */ string | null,
            /* keys */ string[],
            /* values */ GLib.Variant[]
        ];
        /**
         * Returns the default #GSettingsBackend. It is possible to override
         * the default by setting the `GSETTINGS_BACKEND` environment variable
         * to the name of a settings backend.
         *
         * The user gets a reference to the backend.
         * @returns the default #GSettingsBackend,     which will be a dummy (memory) settings backend if no other settings     backend is available.
         */
        static get_default(): SettingsBackend;
    }

    namespace SimpleAction {
        // Signal callback interfaces

        /**
         * Signal callback interface for `activate`
         */
        interface ActivateSignalCallback {
            ($obj: SimpleAction, parameter: GLib.Variant | null): void;
        }

        /**
         * Signal callback interface for `change-state`
         */
        interface ChangeStateSignalCallback {
            ($obj: SimpleAction, value: GLib.Variant | null): void;
        }

        // Constructor properties interface

        interface ConstructorProperties
            extends Action.ConstructorProperties,
                GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.SimpleAction

            /**
             * If `action` is currently enabled.
             *
             * If the action is disabled then calls to g_action_activate() and
             * g_action_change_state() have no effect.
             */
            enabled?: boolean | null;
            /**
             * The name of the action. This is mostly meaningful for identifying
             * the action once it has been added to a #GSimpleActionGroup.
             */
            name?: string | null;
            /**
             * The type of the parameter that must be given when activating the
             * action.
             */
            parameter_type?: GLib.VariantType | null;
            /**
             * The state of the action, or %NULL if the action is stateless.
             */
            state?: GLib.Variant | null;
        }
    }

    interface SimpleAction extends Action {
        // Own properties of Gio-2.0.Gio.SimpleAction

        /**
         * If `action` is currently enabled.
         *
         * If the action is disabled then calls to g_action_activate() and
         * g_action_change_state() have no effect.
         */
        enabled: any;
        /**
         * The name of the action. This is mostly meaningful for identifying
         * the action once it has been added to a #GSimpleActionGroup.
         */
        readonly name: string | null;
        /**
         * The type of the parameter that must be given when activating the
         * action.
         */
        readonly parameter_type: GLib.VariantType;
        /**
         * The state of the action, or %NULL if the action is stateless.
         */
        state: any;
        /**
         * The #GVariantType of the state that the action has, or %NULL if the
         * action is stateless.
         */
        readonly state_type: GLib.VariantType;

        // Owm methods of Gio-2.0.Gio.SimpleAction

        /**
         * Sets the action as enabled or not.
         *
         * An action must be enabled in order to be activated or in order to
         * have its state changed from outside callers.
         *
         * This should only be called by the implementor of the action.  Users
         * of the action should not attempt to modify its enabled flag.
         * @param enabled whether the action is enabled
         */
        set_enabled(enabled: boolean): void;
        /**
         * Sets the state of the action.
         *
         * This directly updates the 'state' property to the given value.
         *
         * This should only be called by the implementor of the action.  Users
         * of the action should not attempt to directly modify the 'state'
         * property.  Instead, they should call g_action_change_state() to
         * request the change.
         *
         * If the `value` GVariant is floating, it is consumed.
         * @param value the new #GVariant for the state
         */
        set_state(value: GLib.Variant): void;
        /**
         * Sets the state hint for the action.
         *
         * See g_action_get_state_hint() for more information about
         * action state hints.
         * @param state_hint a #GVariant representing the state hint
         */
        set_state_hint(state_hint: GLib.Variant | null): void;

        // Own signals of Gio-2.0.Gio.SimpleAction

        connect(
            sigName: 'activate',
            callback: SimpleAction.ActivateSignalCallback
        ): number;
        connect_after(
            sigName: 'activate',
            callback: SimpleAction.ActivateSignalCallback
        ): number;
        emit(
            sigName: 'activate',
            parameter: GLib.Variant | null,
            ...args: any[]
        ): void;
        connect(
            sigName: 'change-state',
            callback: SimpleAction.ChangeStateSignalCallback
        ): number;
        connect_after(
            sigName: 'change-state',
            callback: SimpleAction.ChangeStateSignalCallback
        ): number;
        emit(
            sigName: 'change-state',
            value: GLib.Variant | null,
            ...args: any[]
        ): void;

        // Class property signals of Gio-2.0.Gio.SimpleAction

        connect(
            sigName: 'notify::enabled',
            callback: ($obj: SimpleAction, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::enabled',
            callback: ($obj: SimpleAction, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::enabled', ...args: any[]): void;
        connect(
            sigName: 'notify::name',
            callback: ($obj: SimpleAction, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::name',
            callback: ($obj: SimpleAction, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::name', ...args: any[]): void;
        connect(
            sigName: 'notify::parameter-type',
            callback: ($obj: SimpleAction, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::parameter-type',
            callback: ($obj: SimpleAction, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::parameter-type', ...args: any[]): void;
        connect(
            sigName: 'notify::state',
            callback: ($obj: SimpleAction, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::state',
            callback: ($obj: SimpleAction, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::state', ...args: any[]): void;
        connect(
            sigName: 'notify::state-type',
            callback: ($obj: SimpleAction, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::state-type',
            callback: ($obj: SimpleAction, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::state-type', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * A #GSimpleAction is the obvious simple implementation of the #GAction
     * interface. This is the easiest way to create an action for purposes of
     * adding it to a #GSimpleActionGroup.
     *
     * See also #GtkAction.
     * @class
     */
    class SimpleAction extends GObject.Object {
        // Own properties of Gio-2.0.Gio.SimpleAction

        static name: string;
        static $gtype: GObject.GType<SimpleAction>;

        // Constructors of Gio-2.0.Gio.SimpleAction

        constructor(config?: SimpleAction.ConstructorProperties);
        /**
         * Creates a new action.
         *
         * The created action is stateless. See g_simple_action_new_stateful() to create
         * an action that has state.
         * @constructor
         * @param name the name of the action
         * @param parameter_type the type of parameter that will be passed to   handlers for the #GSimpleAction::activate signal, or %NULL for no parameter
         * @returns a new #GSimpleAction
         */
        constructor(
            name: string | null,
            parameter_type: GLib.VariantType | null
        );
        /**
         * Creates a new action.
         *
         * The created action is stateless. See g_simple_action_new_stateful() to create
         * an action that has state.
         * @constructor
         * @param name the name of the action
         * @param parameter_type the type of parameter that will be passed to   handlers for the #GSimpleAction::activate signal, or %NULL for no parameter
         * @returns a new #GSimpleAction
         */
        static new(
            name: string | null,
            parameter_type: GLib.VariantType | null
        ): SimpleAction;
        /**
         * Creates a new stateful action.
         *
         * All future state values must have the same #GVariantType as the initial
         * `state`.
         *
         * If the `state` #GVariant is floating, it is consumed.
         * @constructor
         * @param name the name of the action
         * @param parameter_type the type of the parameter that will be passed to   handlers for the #GSimpleAction::activate signal, or %NULL for no parameter
         * @param state the initial state of the action
         * @returns a new #GSimpleAction
         */
        static new_stateful(
            name: string | null,
            parameter_type: GLib.VariantType | null,
            state: GLib.Variant
        ): SimpleAction;
        _init(config?: SimpleAction.ConstructorProperties): void;
    }

    namespace SimpleActionGroup {
        // Constructor properties interface

        interface ConstructorProperties
            extends ActionGroup.ConstructorProperties,
                ActionMap.ConstructorProperties,
                GObject.Object.ConstructorProperties {}
    }

    interface SimpleActionGroup extends ActionGroup, ActionMap {
        // Owm methods of Gio-2.0.Gio.SimpleActionGroup

        /**
         * A convenience function for creating multiple #GSimpleAction instances
         * and adding them to the action group.
         * @param entries a pointer to the first item in           an array of #GActionEntry structs
         * @param user_data the user data for signal connections
         */
        add_entries(entries: ActionEntry[], user_data: any | null): void;
        /**
         * Adds an action to the action group.
         *
         * If the action group already contains an action with the same name as
         * `action` then the old action is dropped from the group.
         *
         * The action group takes its own reference on `action`.
         * @param action a #GAction
         */
        insert(action: Action): void;
        /**
         * Looks up the action with the name `action_name` in the group.
         *
         * If no such action exists, returns %NULL.
         * @param action_name the name of an action
         * @returns a #GAction, or %NULL
         */
        lookup(action_name: string | null): Action;
        /**
         * Removes the named action from the action group.
         *
         * If no action of this name is in the group then nothing happens.
         * @param action_name the name of the action
         */
        remove(action_name: string | null): void;

        // Class property signals of Gio-2.0.Gio.SimpleActionGroup

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GSimpleActionGroup is a hash table filled with #GAction objects,
     * implementing the #GActionGroup and #GActionMap interfaces.
     * @class
     */
    class SimpleActionGroup extends GObject.Object {
        // Own properties of Gio-2.0.Gio.SimpleActionGroup

        static name: string;
        static $gtype: GObject.GType<SimpleActionGroup>;

        // Constructors of Gio-2.0.Gio.SimpleActionGroup

        constructor(config?: SimpleActionGroup.ConstructorProperties);
        /**
         * Creates a new, empty, #GSimpleActionGroup.
         * @constructor
         * @returns a new #GSimpleActionGroup
         */
        constructor();
        /**
         * Creates a new, empty, #GSimpleActionGroup.
         * @constructor
         * @returns a new #GSimpleActionGroup
         */
        static new(): SimpleActionGroup;
        _init(config?: SimpleActionGroup.ConstructorProperties): void;
    }

    namespace SimpleAsyncResult {
        // Constructor properties interface

        interface ConstructorProperties
            extends AsyncResult.ConstructorProperties,
                GObject.Object.ConstructorProperties {}
    }

    interface SimpleAsyncResult extends AsyncResult {
        // Owm methods of Gio-2.0.Gio.SimpleAsyncResult

        /**
         * Completes an asynchronous I/O job immediately. Must be called in
         * the thread where the asynchronous result was to be delivered, as it
         * invokes the callback directly. If you are in a different thread use
         * g_simple_async_result_complete_in_idle().
         *
         * Calling this function takes a reference to `simple` for as long as
         * is needed to complete the call.
         */
        complete(): void;
        /**
         * Completes an asynchronous function in an idle handler in the
         * [thread-default main context][g-main-context-push-thread-default]
         * of the thread that `simple` was initially created in
         * (and re-pushes that context around the invocation of the callback).
         *
         * Calling this function takes a reference to `simple` for as long as
         * is needed to complete the call.
         */
        complete_in_idle(): void;
        /**
         * Gets the operation result boolean from within the asynchronous result.
         * @returns %TRUE if the operation's result was %TRUE, %FALSE     if the operation's result was %FALSE.
         */
        get_op_res_gboolean(): boolean;
        /**
         * Gets a gssize from the asynchronous result.
         * @returns a gssize returned from the asynchronous function.
         */
        get_op_res_gssize(): number;
        /**
         * Propagates an error from within the simple asynchronous result to
         * a given destination.
         *
         * If the #GCancellable given to a prior call to
         * g_simple_async_result_set_check_cancellable() is cancelled then this
         * function will return %TRUE with `dest` set appropriately.
         * @returns %TRUE if the error was propagated to @dest. %FALSE otherwise.
         */
        propagate_error(): boolean;
        /**
         * Sets a #GCancellable to check before dispatching results.
         *
         * This function has one very specific purpose: the provided cancellable
         * is checked at the time of g_simple_async_result_propagate_error() If
         * it is cancelled, these functions will return an "Operation was
         * cancelled" error (%G_IO_ERROR_CANCELLED).
         *
         * Implementors of cancellable asynchronous functions should use this in
         * order to provide a guarantee to their callers that cancelling an
         * async operation will reliably result in an error being returned for
         * that operation (even if a positive result for the operation has
         * already been sent as an idle to the main context to be dispatched).
         *
         * The checking described above is done regardless of any call to the
         * unrelated g_simple_async_result_set_handle_cancellation() function.
         * @param check_cancellable a #GCancellable to check, or %NULL to unset
         */
        set_check_cancellable(check_cancellable: Cancellable | null): void;
        /**
         * Sets the result from a #GError.
         * @param error #GError.
         */
        set_from_error(error: GLib.Error): void;
        /**
         * Sets whether to handle cancellation within the asynchronous operation.
         *
         * This function has nothing to do with
         * g_simple_async_result_set_check_cancellable().  It only refers to the
         * #GCancellable passed to g_simple_async_result_run_in_thread().
         * @param handle_cancellation a #gboolean.
         */
        set_handle_cancellation(handle_cancellation: boolean): void;
        /**
         * Sets the operation result to a boolean within the asynchronous result.
         * @param op_res a #gboolean.
         */
        set_op_res_gboolean(op_res: boolean): void;
        /**
         * Sets the operation result within the asynchronous result to
         * the given `op_res`.
         * @param op_res a #gssize.
         */
        set_op_res_gssize(op_res: number): void;

        // Class property signals of Gio-2.0.Gio.SimpleAsyncResult

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * As of GLib 2.46, #GSimpleAsyncResult is deprecated in favor of
     * #GTask, which provides a simpler API.
     *
     * #GSimpleAsyncResult implements #GAsyncResult.
     *
     * GSimpleAsyncResult handles #GAsyncReadyCallbacks, error
     * reporting, operation cancellation and the final state of an operation,
     * completely transparent to the application. Results can be returned
     * as a pointer e.g. for functions that return data that is collected
     * asynchronously, a boolean value for checking the success or failure
     * of an operation, or a #gssize for operations which return the number
     * of bytes modified by the operation; all of the simple return cases
     * are covered.
     *
     * Most of the time, an application will not need to know of the details
     * of this API; it is handled transparently, and any necessary operations
     * are handled by #GAsyncResult's interface. However, if implementing a
     * new GIO module, for writing language bindings, or for complex
     * applications that need better control of how asynchronous operations
     * are completed, it is important to understand this functionality.
     *
     * GSimpleAsyncResults are tagged with the calling function to ensure
     * that asynchronous functions and their finishing functions are used
     * together correctly.
     *
     * To create a new #GSimpleAsyncResult, call g_simple_async_result_new().
     * If the result needs to be created for a #GError, use
     * g_simple_async_result_new_from_error() or
     * g_simple_async_result_new_take_error(). If a #GError is not available
     * (e.g. the asynchronous operation's doesn't take a #GError argument),
     * but the result still needs to be created for an error condition, use
     * g_simple_async_result_new_error() (or g_simple_async_result_set_error_va()
     * if your application or binding requires passing a variable argument list
     * directly), and the error can then be propagated through the use of
     * g_simple_async_result_propagate_error().
     *
     * An asynchronous operation can be made to ignore a cancellation event by
     * calling g_simple_async_result_set_handle_cancellation() with a
     * #GSimpleAsyncResult for the operation and %FALSE. This is useful for
     * operations that are dangerous to cancel, such as close (which would
     * cause a leak if cancelled before being run).
     *
     * GSimpleAsyncResult can integrate into GLib's event loop, #GMainLoop,
     * or it can use #GThreads.
     * g_simple_async_result_complete() will finish an I/O task directly
     * from the point where it is called. g_simple_async_result_complete_in_idle()
     * will finish it from an idle handler in the
     * [thread-default main context][g-main-context-push-thread-default]
     * where the #GSimpleAsyncResult was created.
     * g_simple_async_result_run_in_thread() will run the job in a
     * separate thread and then use
     * g_simple_async_result_complete_in_idle() to deliver the result.
     *
     * To set the results of an asynchronous function,
     * g_simple_async_result_set_op_res_gpointer(),
     * g_simple_async_result_set_op_res_gboolean(), and
     * g_simple_async_result_set_op_res_gssize()
     * are provided, setting the operation's result to a gpointer, gboolean, or
     * gssize, respectively.
     *
     * Likewise, to get the result of an asynchronous function,
     * g_simple_async_result_get_op_res_gpointer(),
     * g_simple_async_result_get_op_res_gboolean(), and
     * g_simple_async_result_get_op_res_gssize() are
     * provided, getting the operation's result as a gpointer, gboolean, and
     * gssize, respectively.
     *
     * For the details of the requirements implementations must respect, see
     * #GAsyncResult.  A typical implementation of an asynchronous operation
     * using GSimpleAsyncResult looks something like this:
     *
     *
     * ```c
     * static void
     * baked_cb (Cake    *cake,
     *           gpointer user_data)
     * {
     *   // In this example, this callback is not given a reference to the cake,
     *   // so the GSimpleAsyncResult has to take a reference to it.
     *   GSimpleAsyncResult *result = user_data;
     *
     *   if (cake == NULL)
     *     g_simple_async_result_set_error (result,
     *                                      BAKER_ERRORS,
     *                                      BAKER_ERROR_NO_FLOUR,
     *                                      "Go to the supermarket");
     *   else
     *     g_simple_async_result_set_op_res_gpointer (result,
     *                                                g_object_ref (cake),
     *                                                g_object_unref);
     *
     *
     *   // In this example, we assume that baked_cb is called as a callback from
     *   // the mainloop, so it's safe to complete the operation synchronously here.
     *   // If, however, _baker_prepare_cake () might call its callback without
     *   // first returning to the mainloop  inadvisable, but some APIs do so 
     *   // we would need to use g_simple_async_result_complete_in_idle().
     *   g_simple_async_result_complete (result);
     *   g_object_unref (result);
     * }
     *
     * void
     * baker_bake_cake_async (Baker              *self,
     *                        guint               radius,
     *                        GAsyncReadyCallback callback,
     *                        gpointer            user_data)
     * {
     *   GSimpleAsyncResult *simple;
     *   Cake               *cake;
     *
     *   if (radius < 3)
     *     {
     *       g_simple_async_report_error_in_idle (G_OBJECT (self),
     *                                            callback,
     *                                            user_data,
     *                                            BAKER_ERRORS,
     *                                            BAKER_ERROR_TOO_SMALL,
     *                                            "%ucm radius cakes are silly",
     *                                            radius);
     *       return;
     *     }
     *
     *   simple = g_simple_async_result_new (G_OBJECT (self),
     *                                       callback,
     *                                       user_data,
     *                                       baker_bake_cake_async);
     *   cake = _baker_get_cached_cake (self, radius);
     *
     *   if (cake != NULL)
     *     {
     *       g_simple_async_result_set_op_res_gpointer (simple,
     *                                                  g_object_ref (cake),
     *                                                  g_object_unref);
     *       g_simple_async_result_complete_in_idle (simple);
     *       g_object_unref (simple);
     *       // Drop the reference returned by _baker_get_cached_cake();
     *       // the GSimpleAsyncResult has taken its own reference.
     *       g_object_unref (cake);
     *       return;
     *     }
     *
     *   _baker_prepare_cake (self, radius, baked_cb, simple);
     * }
     *
     * Cake *
     * baker_bake_cake_finish (Baker        *self,
     *                         GAsyncResult *result,
     *                         GError      **error)
     * {
     *   GSimpleAsyncResult *simple;
     *   Cake               *cake;
     *
     *   g_return_val_if_fail (g_simple_async_result_is_valid (result,
     *                                                         G_OBJECT (self),
     *                                                         baker_bake_cake_async),
     *                         NULL);
     *
     *   simple = (GSimpleAsyncResult *) result;
     *
     *   if (g_simple_async_result_propagate_error (simple, error))
     *     return NULL;
     *
     *   cake = CAKE (g_simple_async_result_get_op_res_gpointer (simple));
     *   return g_object_ref (cake);
     * }
     * ```
     *
     * @class
     */
    class SimpleAsyncResult extends GObject.Object {
        // Own properties of Gio-2.0.Gio.SimpleAsyncResult

        static name: string;
        static $gtype: GObject.GType<SimpleAsyncResult>;

        // Constructors of Gio-2.0.Gio.SimpleAsyncResult

        constructor(config?: SimpleAsyncResult.ConstructorProperties);
        /**
         * Creates a #GSimpleAsyncResult.
         *
         * The common convention is to create the #GSimpleAsyncResult in the
         * function that starts the asynchronous operation and use that same
         * function as the `source_tag`.
         *
         * If your operation supports cancellation with #GCancellable (which it
         * probably should) then you should provide the user's cancellable to
         * g_simple_async_result_set_check_cancellable() immediately after
         * this function returns.
         * @constructor
         * @param source_object a #GObject, or %NULL.
         * @param callback a #GAsyncReadyCallback.
         * @param source_tag the asynchronous function.
         * @returns a #GSimpleAsyncResult.
         */
        constructor(
            source_object: GObject.Object | null,
            callback: AsyncReadyCallback<SimpleAsyncResult> | null,
            source_tag: any | null
        );
        /**
         * Creates a #GSimpleAsyncResult.
         *
         * The common convention is to create the #GSimpleAsyncResult in the
         * function that starts the asynchronous operation and use that same
         * function as the `source_tag`.
         *
         * If your operation supports cancellation with #GCancellable (which it
         * probably should) then you should provide the user's cancellable to
         * g_simple_async_result_set_check_cancellable() immediately after
         * this function returns.
         * @constructor
         * @param source_object a #GObject, or %NULL.
         * @param callback a #GAsyncReadyCallback.
         * @param source_tag the asynchronous function.
         * @returns a #GSimpleAsyncResult.
         */
        static new(
            source_object: GObject.Object | null,
            callback: AsyncReadyCallback<SimpleAsyncResult> | null,
            source_tag: any | null
        ): SimpleAsyncResult;
        /**
         * Creates a #GSimpleAsyncResult from an error condition.
         * @constructor
         * @param source_object a #GObject, or %NULL.
         * @param callback a #GAsyncReadyCallback.
         * @param error a #GError
         * @returns a #GSimpleAsyncResult.
         */
        static new_from_error(
            source_object: GObject.Object | null,
            callback: AsyncReadyCallback<SimpleAsyncResult> | null,
            error: GLib.Error
        ): SimpleAsyncResult;
        _init(config?: SimpleAsyncResult.ConstructorProperties): void;
        /**
         * Ensures that the data passed to the _finish function of an async
         * operation is consistent.  Three checks are performed.
         *
         * First, `result` is checked to ensure that it is really a
         * #GSimpleAsyncResult.  Second, `source` is checked to ensure that it
         * matches the source object of `result`.  Third, `source_tag` is
         * checked to ensure that it is equal to the `source_tag` argument given
         * to g_simple_async_result_new() (which, by convention, is a pointer
         * to the _async function corresponding to the _finish function from
         * which this function is called).  (Alternatively, if either
         * `source_tag` or `result'`s source tag is %NULL, then the source tag
         * check is skipped.)
         * @param result the #GAsyncResult passed to the _finish function.
         * @param source the #GObject passed to the _finish function.
         * @param source_tag the asynchronous function.
         * @returns #TRUE if all checks passed or #FALSE if any failed.
         */
        static is_valid(
            result: AsyncResult,
            source: GObject.Object | null,
            source_tag: any | null
        ): boolean;
    }

    namespace SimpleIOStream {
        // Constructor properties interface

        interface ConstructorProperties extends IOStream.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.SimpleIOStream

            input_stream?: InputStream | null;
            output_stream?: OutputStream | null;
        }
    }

    interface SimpleIOStream {
        // Own properties of Gio-2.0.Gio.SimpleIOStream

        readonly input_stream: InputStream;
        readonly output_stream: OutputStream;

        // Class property signals of Gio-2.0.Gio.SimpleIOStream

        connect(
            sigName: 'notify::input-stream',
            callback: ($obj: SimpleIOStream, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::input-stream',
            callback: ($obj: SimpleIOStream, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::input-stream', ...args: any[]): void;
        connect(
            sigName: 'notify::output-stream',
            callback: ($obj: SimpleIOStream, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::output-stream',
            callback: ($obj: SimpleIOStream, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::output-stream', ...args: any[]): void;
        connect(
            sigName: 'notify::closed',
            callback: ($obj: SimpleIOStream, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::closed',
            callback: ($obj: SimpleIOStream, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::closed', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * GSimpleIOStream creates a #GIOStream from an arbitrary #GInputStream and
     * #GOutputStream. This allows any pair of input and output streams to be used
     * with #GIOStream methods.
     *
     * This is useful when you obtained a #GInputStream and a #GOutputStream
     * by other means, for instance creating them with platform specific methods as
     * g_unix_input_stream_new() or g_win32_input_stream_new(), and you want
     * to take advantage of the methods provided by #GIOStream.
     * @class
     */
    class SimpleIOStream extends IOStream {
        // Own properties of Gio-2.0.Gio.SimpleIOStream

        static name: string;
        static $gtype: GObject.GType<SimpleIOStream>;

        // Constructors of Gio-2.0.Gio.SimpleIOStream

        constructor(config?: SimpleIOStream.ConstructorProperties);
        /**
         * Creates a new #GSimpleIOStream wrapping `input_stream` and `output_stream`.
         * See also #GIOStream.
         * @constructor
         * @param input_stream a #GInputStream.
         * @param output_stream a #GOutputStream.
         * @returns a new #GSimpleIOStream instance.
         */
        constructor(input_stream: InputStream, output_stream: OutputStream);
        /**
         * Creates a new #GSimpleIOStream wrapping `input_stream` and `output_stream`.
         * See also #GIOStream.
         * @constructor
         * @param input_stream a #GInputStream.
         * @param output_stream a #GOutputStream.
         * @returns a new #GSimpleIOStream instance.
         */
        static new(
            input_stream: InputStream,
            output_stream: OutputStream
        ): SimpleIOStream;
        _init(config?: SimpleIOStream.ConstructorProperties): void;
    }

    namespace SimplePermission {
        // Constructor properties interface

        type ConstructorProperties = Permission.ConstructorProperties;
    }

    interface SimplePermission {
        // Class property signals of Gio-2.0.Gio.SimplePermission

        connect(
            sigName: 'notify::allowed',
            callback: ($obj: SimplePermission, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::allowed',
            callback: ($obj: SimplePermission, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::allowed', ...args: any[]): void;
        connect(
            sigName: 'notify::can-acquire',
            callback: ($obj: SimplePermission, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::can-acquire',
            callback: ($obj: SimplePermission, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::can-acquire', ...args: any[]): void;
        connect(
            sigName: 'notify::can-release',
            callback: ($obj: SimplePermission, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::can-release',
            callback: ($obj: SimplePermission, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::can-release', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GSimplePermission is a trivial implementation of #GPermission that
     * represents a permission that is either always or never allowed.  The
     * value is given at construction and doesn't change.
     *
     * Calling request or release will result in errors.
     * @class
     */
    class SimplePermission extends Permission {
        // Own properties of Gio-2.0.Gio.SimplePermission

        static name: string;
        static $gtype: GObject.GType<SimplePermission>;

        // Constructors of Gio-2.0.Gio.SimplePermission

        constructor(config?: SimplePermission.ConstructorProperties);
        /**
         * Creates a new #GPermission instance that represents an action that is
         * either always or never allowed.
         * @constructor
         * @param allowed %TRUE if the action is allowed
         * @returns the #GSimplePermission, as a #GPermission
         */
        constructor(allowed: boolean);
        /**
         * Creates a new #GPermission instance that represents an action that is
         * either always or never allowed.
         * @constructor
         * @param allowed %TRUE if the action is allowed
         * @returns the #GSimplePermission, as a #GPermission
         */
        static new(allowed: boolean): SimplePermission;
        _init(config?: SimplePermission.ConstructorProperties): void;
    }

    namespace SimpleProxyResolver {
        // Constructor properties interface

        interface ConstructorProperties
            extends ProxyResolver.ConstructorProperties,
                GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.SimpleProxyResolver

            /**
             * The default proxy URI that will be used for any URI that doesn't
             * match #GSimpleProxyResolver:ignore-hosts, and doesn't match any
             * of the schemes set with g_simple_proxy_resolver_set_uri_proxy().
             *
             * Note that as a special case, if this URI starts with
             * "socks://", #GSimpleProxyResolver will treat it as referring
             * to all three of the socks5, socks4a, and socks4 proxy types.
             */
            default_proxy?: string | null;
            /**
             * A list of hostnames and IP addresses that the resolver should
             * allow direct connections to.
             *
             * Entries can be in one of 4 formats:
             *
             * - A hostname, such as "example.com", ".example.com", or
             *   "*.example.com", any of which match "example.com" or
             *   any subdomain of it.
             *
             * - An IPv4 or IPv6 address, such as "192.168.1.1",
             *   which matches only that address.
             *
             * - A hostname or IP address followed by a port, such as
             *   "example.com:80", which matches whatever the hostname or IP
             *   address would match, but only for URLs with the (explicitly)
             *   indicated port. In the case of an IPv6 address, the address
             *   part must appear in brackets: "[::1]:443"
             *
             * - An IP address range, given by a base address and prefix length,
             *   such as "fe80::/10", which matches any address in that range.
             *
             * Note that when dealing with Unicode hostnames, the matching is
             * done against the ASCII form of the name.
             *
             * Also note that hostname exclusions apply only to connections made
             * to hosts identified by name, and IP address exclusions apply only
             * to connections made to hosts identified by address. That is, if
             * example.com has an address of 192.168.1.1, and the :ignore-hosts list
             * contains only "192.168.1.1", then a connection to "example.com"
             * (eg, via a #GNetworkAddress) will use the proxy, and a connection to
             * "192.168.1.1" (eg, via a #GInetSocketAddress) will not.
             *
             * These rules match the "ignore-hosts"/"noproxy" rules most
             * commonly used by other applications.
             */
            ignore_hosts?: string[] | null;
        }
    }

    interface SimpleProxyResolver extends ProxyResolver {
        // Own properties of Gio-2.0.Gio.SimpleProxyResolver

        /**
         * The default proxy URI that will be used for any URI that doesn't
         * match #GSimpleProxyResolver:ignore-hosts, and doesn't match any
         * of the schemes set with g_simple_proxy_resolver_set_uri_proxy().
         *
         * Note that as a special case, if this URI starts with
         * "socks://", #GSimpleProxyResolver will treat it as referring
         * to all three of the socks5, socks4a, and socks4 proxy types.
         */
        default_proxy: string | null;
        /**
         * A list of hostnames and IP addresses that the resolver should
         * allow direct connections to.
         *
         * Entries can be in one of 4 formats:
         *
         * - A hostname, such as "example.com", ".example.com", or
         *   "*.example.com", any of which match "example.com" or
         *   any subdomain of it.
         *
         * - An IPv4 or IPv6 address, such as "192.168.1.1",
         *   which matches only that address.
         *
         * - A hostname or IP address followed by a port, such as
         *   "example.com:80", which matches whatever the hostname or IP
         *   address would match, but only for URLs with the (explicitly)
         *   indicated port. In the case of an IPv6 address, the address
         *   part must appear in brackets: "[::1]:443"
         *
         * - An IP address range, given by a base address and prefix length,
         *   such as "fe80::/10", which matches any address in that range.
         *
         * Note that when dealing with Unicode hostnames, the matching is
         * done against the ASCII form of the name.
         *
         * Also note that hostname exclusions apply only to connections made
         * to hosts identified by name, and IP address exclusions apply only
         * to connections made to hosts identified by address. That is, if
         * example.com has an address of 192.168.1.1, and the :ignore-hosts list
         * contains only "192.168.1.1", then a connection to "example.com"
         * (eg, via a #GNetworkAddress) will use the proxy, and a connection to
         * "192.168.1.1" (eg, via a #GInetSocketAddress) will not.
         *
         * These rules match the "ignore-hosts"/"noproxy" rules most
         * commonly used by other applications.
         */
        ignore_hosts: string[];

        // Own fields of Gio-2.0.Gio.SimpleProxyResolver

        parent_instance: GObject.Object;

        // Owm methods of Gio-2.0.Gio.SimpleProxyResolver

        /**
         * Sets the default proxy on `resolver,` to be used for any URIs that
         * don't match #GSimpleProxyResolver:ignore-hosts or a proxy set
         * via g_simple_proxy_resolver_set_uri_proxy().
         *
         * If `default_proxy` starts with "socks://",
         * #GSimpleProxyResolver will treat it as referring to all three of
         * the socks5, socks4a, and socks4 proxy types.
         * @param default_proxy the default proxy to use
         */
        set_default_proxy(default_proxy: string | null): void;
        /**
         * Sets the list of ignored hosts.
         *
         * See #GSimpleProxyResolver:ignore-hosts for more details on how the
         * `ignore_hosts` argument is interpreted.
         * @param ignore_hosts %NULL-terminated list of hosts/IP addresses     to not use a proxy for
         */
        set_ignore_hosts(ignore_hosts: string[]): void;
        /**
         * Adds a URI-scheme-specific proxy to `resolver;` URIs whose scheme
         * matches `uri_scheme` (and which don't match
         * #GSimpleProxyResolver:ignore-hosts) will be proxied via `proxy`.
         *
         * As with #GSimpleProxyResolver:default-proxy, if `proxy` starts with
         * "socks://", #GSimpleProxyResolver will treat it
         * as referring to all three of the socks5, socks4a, and socks4 proxy
         * types.
         * @param uri_scheme the URI scheme to add a proxy for
         * @param proxy the proxy to use for `uri_scheme`
         */
        set_uri_proxy(uri_scheme: string | null, proxy: string | null): void;

        // Class property signals of Gio-2.0.Gio.SimpleProxyResolver

        connect(
            sigName: 'notify::default-proxy',
            callback: (
                $obj: SimpleProxyResolver,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::default-proxy',
            callback: (
                $obj: SimpleProxyResolver,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::default-proxy', ...args: any[]): void;
        connect(
            sigName: 'notify::ignore-hosts',
            callback: (
                $obj: SimpleProxyResolver,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::ignore-hosts',
            callback: (
                $obj: SimpleProxyResolver,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::ignore-hosts', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GSimpleProxyResolver is a simple #GProxyResolver implementation
     * that handles a single default proxy, multiple URI-scheme-specific
     * proxies, and a list of hosts that proxies should not be used for.
     *
     * #GSimpleProxyResolver is never the default proxy resolver, but it
     * can be used as the base class for another proxy resolver
     * implementation, or it can be created and used manually, such as
     * with g_socket_client_set_proxy_resolver().
     * @class
     */
    class SimpleProxyResolver extends GObject.Object {
        // Own properties of Gio-2.0.Gio.SimpleProxyResolver

        static name: string;
        static $gtype: GObject.GType<SimpleProxyResolver>;

        // Constructors of Gio-2.0.Gio.SimpleProxyResolver

        constructor(config?: SimpleProxyResolver.ConstructorProperties);
        _init(config?: SimpleProxyResolver.ConstructorProperties): void;
        /**
         * Creates a new #GSimpleProxyResolver. See
         * #GSimpleProxyResolver:default-proxy and
         * #GSimpleProxyResolver:ignore-hosts for more details on how the
         * arguments are interpreted.
         * @param default_proxy the default proxy to use, eg     "socks://192.168.1.1"
         * @param ignore_hosts an optional list of hosts/IP addresses     to not use a proxy for.
         * @returns a new #GSimpleProxyResolver
         */
        static new(
            default_proxy: string | null,
            ignore_hosts: string[] | null
        ): ProxyResolver;
    }

    namespace Socket {
        // Constructor properties interface

        interface ConstructorProperties
            extends DatagramBased.ConstructorProperties,
                Initable.ConstructorProperties,
                GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.Socket

            blocking?: boolean | null;
            /**
             * Whether the socket should allow sending to broadcast addresses.
             */
            broadcast?: boolean | null;
            family?: SocketFamily | null;
            fd?: number | null;
            keepalive?: boolean | null;
            listen_backlog?: number | null;
            /**
             * Whether outgoing multicast packets loop back to the local host.
             */
            multicast_loopback?: boolean | null;
            /**
             * Time-to-live out outgoing multicast packets
             */
            multicast_ttl?: number | null;
            protocol?: SocketProtocol | null;
            /**
             * The timeout in seconds on socket I/O
             */
            timeout?: number | null;
            /**
             * Time-to-live for outgoing unicast packets
             */
            ttl?: number | null;
            type?: SocketType | null;
        }
    }

    interface Socket extends DatagramBased, Initable {
        // Own properties of Gio-2.0.Gio.Socket

        blocking: boolean;
        /**
         * Whether the socket should allow sending to broadcast addresses.
         */
        broadcast: boolean;
        readonly family: SocketFamily;
        readonly fd: number;
        keepalive: boolean;
        listen_backlog: number;
        readonly local_address: SocketAddress;
        /**
         * Whether outgoing multicast packets loop back to the local host.
         */
        multicast_loopback: boolean;
        /**
         * Time-to-live out outgoing multicast packets
         */
        multicast_ttl: number;
        readonly protocol: SocketProtocol;
        readonly remote_address: SocketAddress;
        /**
         * The timeout in seconds on socket I/O
         */
        timeout: number;
        /**
         * Time-to-live for outgoing unicast packets
         */
        ttl: number;
        readonly type: SocketType;

        // Own fields of Gio-2.0.Gio.Socket

        parent_instance: GObject.Object;
        priv: SocketPrivate;

        // Owm methods of Gio-2.0.Gio.Socket

        /**
         * Accept incoming connections on a connection-based socket. This removes
         * the first outstanding connection request from the listening socket and
         * creates a #GSocket object for it.
         *
         * The `socket` must be bound to a local address with g_socket_bind() and
         * must be listening for incoming connections (g_socket_listen()).
         *
         * If there are no outstanding connections then the operation will block
         * or return %G_IO_ERROR_WOULD_BLOCK if non-blocking I/O is enabled.
         * To be notified of an incoming connection, wait for the %G_IO_IN condition.
         * @param cancellable a %GCancellable or %NULL
         * @returns a new #GSocket, or %NULL on error.     Free the returned object with g_object_unref().
         */
        accept(cancellable: Cancellable | null): Socket;
        /**
         * When a socket is created it is attached to an address family, but it
         * doesn't have an address in this family. g_socket_bind() assigns the
         * address (sometimes called name) of the socket.
         *
         * It is generally required to bind to a local address before you can
         * receive connections. (See g_socket_listen() and g_socket_accept() ).
         * In certain situations, you may also want to bind a socket that will be
         * used to initiate connections, though this is not normally required.
         *
         * If `socket` is a TCP socket, then `allow_reuse` controls the setting
         * of the `SO_REUSEADDR` socket option; normally it should be %TRUE for
         * server sockets (sockets that you will eventually call
         * g_socket_accept() on), and %FALSE for client sockets. (Failing to
         * set this flag on a server socket may cause g_socket_bind() to return
         * %G_IO_ERROR_ADDRESS_IN_USE if the server program is stopped and then
         * immediately restarted.)
         *
         * If `socket` is a UDP socket, then `allow_reuse` determines whether or
         * not other UDP sockets can be bound to the same address at the same
         * time. In particular, you can have several UDP sockets bound to the
         * same address, and they will all receive all of the multicast and
         * broadcast packets sent to that address. (The behavior of unicast
         * UDP packets to an address with multiple listeners is not defined.)
         * @param address a #GSocketAddress specifying the local address.
         * @param allow_reuse whether to allow reusing this address
         * @returns %TRUE on success, %FALSE on error.
         */
        bind(address: SocketAddress, allow_reuse: boolean): boolean;
        /**
         * Checks and resets the pending connect error for the socket.
         * This is used to check for errors when g_socket_connect() is
         * used in non-blocking mode.
         * @returns %TRUE if no error, %FALSE otherwise, setting @error to the error
         */
        check_connect_result(): boolean;
        /**
         * Closes the socket, shutting down any active connection.
         *
         * Closing a socket does not wait for all outstanding I/O operations
         * to finish, so the caller should not rely on them to be guaranteed
         * to complete even if the close returns with no error.
         *
         * Once the socket is closed, all other operations will return
         * %G_IO_ERROR_CLOSED. Closing a socket multiple times will not
         * return an error.
         *
         * Sockets will be automatically closed when the last reference
         * is dropped, but you might want to call this function to make sure
         * resources are released as early as possible.
         *
         * Beware that due to the way that TCP works, it is possible for
         * recently-sent data to be lost if either you close a socket while the
         * %G_IO_IN condition is set, or else if the remote connection tries to
         * send something to you after you close the socket but before it has
         * finished reading all of the data you sent. There is no easy generic
         * way to avoid this problem; the easiest fix is to design the network
         * protocol such that the client will never send data "out of turn".
         * Another solution is for the server to half-close the connection by
         * calling g_socket_shutdown() with only the `shutdown_write` flag set,
         * and then wait for the client to notice this and close its side of the
         * connection, after which the server can safely call g_socket_close().
         * (This is what #GTcpConnection does if you call
         * g_tcp_connection_set_graceful_disconnect(). But of course, this
         * only works if the client will close its connection after the server
         * does.)
         * @returns %TRUE on success, %FALSE on error
         */
        close(): boolean;
        /**
         * Checks on the readiness of `socket` to perform operations.
         * The operations specified in `condition` are checked for and masked
         * against the currently-satisfied conditions on `socket`. The result
         * is returned.
         *
         * Note that on Windows, it is possible for an operation to return
         * %G_IO_ERROR_WOULD_BLOCK even immediately after
         * g_socket_condition_check() has claimed that the socket is ready for
         * writing. Rather than calling g_socket_condition_check() and then
         * writing to the socket if it succeeds, it is generally better to
         * simply try writing to the socket right away, and try again later if
         * the initial attempt returns %G_IO_ERROR_WOULD_BLOCK.
         *
         * It is meaningless to specify %G_IO_ERR or %G_IO_HUP in condition;
         * these conditions will always be set in the output if they are true.
         *
         * This call never blocks.
         * @param condition a #GIOCondition mask to check
         * @returns the @GIOCondition mask of the current state
         */
        condition_check(condition: GLib.IOCondition): GLib.IOCondition;
        /**
         * Waits for up to `timeout_us` microseconds for `condition` to become true
         * on `socket`. If the condition is met, %TRUE is returned.
         *
         * If `cancellable` is cancelled before the condition is met, or if
         * `timeout_us` (or the socket's #GSocket:timeout) is reached before the
         * condition is met, then %FALSE is returned and `error,` if non-%NULL,
         * is set to the appropriate value (%G_IO_ERROR_CANCELLED or
         * %G_IO_ERROR_TIMED_OUT).
         *
         * If you don't want a timeout, use g_socket_condition_wait().
         * (Alternatively, you can pass -1 for `timeout_us`.)
         *
         * Note that although `timeout_us` is in microseconds for consistency with
         * other GLib APIs, this function actually only has millisecond
         * resolution, and the behavior is undefined if `timeout_us` is not an
         * exact number of milliseconds.
         * @param condition a #GIOCondition mask to wait for
         * @param timeout_us the maximum time (in microseconds) to wait, or -1
         * @param cancellable a #GCancellable, or %NULL
         * @returns %TRUE if the condition was met, %FALSE otherwise
         */
        condition_timed_wait(
            condition: GLib.IOCondition,
            timeout_us: number,
            cancellable: Cancellable | null
        ): boolean;
        /**
         * Waits for `condition` to become true on `socket`. When the condition
         * is met, %TRUE is returned.
         *
         * If `cancellable` is cancelled before the condition is met, or if the
         * socket has a timeout set and it is reached before the condition is
         * met, then %FALSE is returned and `error,` if non-%NULL, is set to
         * the appropriate value (%G_IO_ERROR_CANCELLED or
         * %G_IO_ERROR_TIMED_OUT).
         *
         * See also g_socket_condition_timed_wait().
         * @param condition a #GIOCondition mask to wait for
         * @param cancellable a #GCancellable, or %NULL
         * @returns %TRUE if the condition was met, %FALSE otherwise
         */
        condition_wait(
            condition: GLib.IOCondition,
            cancellable: Cancellable | null
        ): boolean;

        // Overloads of condition_wait

        /**
         * Waits for up to `timeout` microseconds for condition to become true on
         * `datagram_based`. If the condition is met, %TRUE is returned.
         *
         * If `cancellable` is cancelled before the condition is met, or if `timeout` is
         * reached before the condition is met, then %FALSE is returned and `error` is
         * set appropriately (%G_IO_ERROR_CANCELLED or %G_IO_ERROR_TIMED_OUT).
         * @param condition a #GIOCondition mask to wait for
         * @param timeout the maximum time (in microseconds) to wait, 0 to not block, or -1   to block indefinitely
         * @param cancellable a #GCancellable
         * @returns %TRUE if the condition was met, %FALSE otherwise
         */
        condition_wait(
            condition: GLib.IOCondition,
            timeout: number,
            cancellable: Cancellable | null
        ): boolean;
        /**
         * Connect the socket to the specified remote address.
         *
         * For connection oriented socket this generally means we attempt to make
         * a connection to the `address`. For a connection-less socket it sets
         * the default address for g_socket_send() and discards all incoming datagrams
         * from other sources.
         *
         * Generally connection oriented sockets can only connect once, but
         * connection-less sockets can connect multiple times to change the
         * default address.
         *
         * If the connect call needs to do network I/O it will block, unless
         * non-blocking I/O is enabled. Then %G_IO_ERROR_PENDING is returned
         * and the user can be notified of the connection finishing by waiting
         * for the G_IO_OUT condition. The result of the connection must then be
         * checked with g_socket_check_connect_result().
         * @param address a #GSocketAddress specifying the remote address.
         * @param cancellable a %GCancellable or %NULL
         * @returns %TRUE if connected, %FALSE on error.
         */
        connect(
            address: SocketAddress,
            cancellable: Cancellable | null
        ): boolean;
        /**
         * Creates a #GSocketConnection subclass of the right type for
         * `socket`.
         * @returns a #GSocketConnection
         */
        connection_factory_create_connection(): SocketConnection;
        /**
         * Get the amount of data pending in the OS input buffer, without blocking.
         *
         * If `socket` is a UDP or SCTP socket, this will return the size of
         * just the next packet, even if additional packets are buffered after
         * that one.
         *
         * Note that on Windows, this function is rather inefficient in the
         * UDP case, and so if you know any plausible upper bound on the size
         * of the incoming packet, it is better to just do a
         * g_socket_receive() with a buffer of that size, rather than calling
         * g_socket_get_available_bytes() first and then doing a receive of
         * exactly the right size.
         * @returns the number of bytes that can be read from the socket without blocking or truncating, or -1 on error.
         */
        get_available_bytes(): number;
        /**
         * Gets the blocking mode of the socket. For details on blocking I/O,
         * see g_socket_set_blocking().
         * @returns %TRUE if blocking I/O is used, %FALSE otherwise.
         */
        get_blocking(): boolean;
        /**
         * Gets the broadcast setting on `socket;` if %TRUE,
         * it is possible to send packets to broadcast
         * addresses.
         * @returns the broadcast setting on @socket
         */
        get_broadcast(): boolean;
        /**
         * Returns the credentials of the foreign process connected to this
         * socket, if any (e.g. it is only supported for %G_SOCKET_FAMILY_UNIX
         * sockets).
         *
         * If this operation isn't supported on the OS, the method fails with
         * the %G_IO_ERROR_NOT_SUPPORTED error. On Linux this is implemented
         * by reading the %SO_PEERCRED option on the underlying socket.
         *
         * This method can be expected to be available on the following platforms:
         *
         * - Linux since GLib 2.26
         * - OpenBSD since GLib 2.30
         * - Solaris, Illumos and OpenSolaris since GLib 2.40
         * - NetBSD since GLib 2.42
         * - macOS, tvOS, iOS since GLib 2.66
         *
         * Other ways to obtain credentials from a foreign peer includes the
         * #GUnixCredentialsMessage type and
         * g_unix_connection_send_credentials() /
         * g_unix_connection_receive_credentials() functions.
         * @returns %NULL if @error is set, otherwise a #GCredentials object that must be freed with g_object_unref().
         */
        get_credentials(): Credentials;
        /**
         * Gets the socket family of the socket.
         * @returns a #GSocketFamily
         */
        get_family(): SocketFamily;
        /**
         * Returns the underlying OS socket object. On unix this
         * is a socket file descriptor, and on Windows this is
         * a Winsock2 SOCKET handle. This may be useful for
         * doing platform specific or otherwise unusual operations
         * on the socket.
         * @returns the file descriptor of the socket.
         */
        get_fd(): number;
        /**
         * Gets the keepalive mode of the socket. For details on this,
         * see g_socket_set_keepalive().
         * @returns %TRUE if keepalive is active, %FALSE otherwise.
         */
        get_keepalive(): boolean;
        /**
         * Gets the listen backlog setting of the socket. For details on this,
         * see g_socket_set_listen_backlog().
         * @returns the maximum number of pending connections.
         */
        get_listen_backlog(): number;
        /**
         * Try to get the local address of a bound socket. This is only
         * useful if the socket has been bound to a local address,
         * either explicitly or implicitly when connecting.
         * @returns a #GSocketAddress or %NULL on error.     Free the returned object with g_object_unref().
         */
        get_local_address(): SocketAddress;
        /**
         * Gets the multicast loopback setting on `socket;` if %TRUE (the
         * default), outgoing multicast packets will be looped back to
         * multicast listeners on the same host.
         * @returns the multicast loopback setting on @socket
         */
        get_multicast_loopback(): boolean;
        /**
         * Gets the multicast time-to-live setting on `socket;` see
         * g_socket_set_multicast_ttl() for more details.
         * @returns the multicast time-to-live setting on @socket
         */
        get_multicast_ttl(): number;
        /**
         * Gets the value of an integer-valued option on `socket,` as with
         * getsockopt(). (If you need to fetch a  non-integer-valued option,
         * you will need to call getsockopt() directly.)
         *
         * The [<gio/gnetworking.h>][gio-gnetworking.h]
         * header pulls in system headers that will define most of the
         * standard/portable socket options. For unusual socket protocols or
         * platform-dependent options, you may need to include additional
         * headers.
         *
         * Note that even for socket options that are a single byte in size,
         * `value` is still a pointer to a #gint variable, not a #guchar;
         * g_socket_get_option() will handle the conversion internally.
         * @param level the "API level" of the option (eg, `SOL_SOCKET`)
         * @param optname the "name" of the option (eg, `SO_BROADCAST`)
         * @returns success or failure. On failure, @error will be set, and   the system error value (`errno` or WSAGetLastError()) will still   be set to the result of the getsockopt() call.
         */
        get_option(
            level: number,
            optname: number
        ): [/* returnType */ boolean, /* value */ number];
        /**
         * Gets the socket protocol id the socket was created with.
         * In case the protocol is unknown, -1 is returned.
         * @returns a protocol id, or -1 if unknown
         */
        get_protocol(): SocketProtocol;
        /**
         * Try to get the remote address of a connected socket. This is only
         * useful for connection oriented sockets that have been connected.
         * @returns a #GSocketAddress or %NULL on error.     Free the returned object with g_object_unref().
         */
        get_remote_address(): SocketAddress;
        /**
         * Gets the socket type of the socket.
         * @returns a #GSocketType
         */
        get_socket_type(): SocketType;
        /**
         * Gets the timeout setting of the socket. For details on this, see
         * g_socket_set_timeout().
         * @returns the timeout in seconds
         */
        get_timeout(): number;
        /**
         * Gets the unicast time-to-live setting on `socket;` see
         * g_socket_set_ttl() for more details.
         * @returns the time-to-live setting on @socket
         */
        get_ttl(): number;
        /**
         * Checks whether a socket is closed.
         * @returns %TRUE if socket is closed, %FALSE otherwise
         */
        is_closed(): boolean;
        /**
         * Check whether the socket is connected. This is only useful for
         * connection-oriented sockets.
         *
         * If using g_socket_shutdown(), this function will return %TRUE until the
         * socket has been shut down for reading and writing. If you do a non-blocking
         * connect, this function will not return %TRUE until after you call
         * g_socket_check_connect_result().
         * @returns %TRUE if socket is connected, %FALSE otherwise.
         */
        is_connected(): boolean;
        /**
         * Registers `socket` to receive multicast messages sent to `group`.
         * `socket` must be a %G_SOCKET_TYPE_DATAGRAM socket, and must have
         * been bound to an appropriate interface and port with
         * g_socket_bind().
         *
         * If `iface` is %NULL, the system will automatically pick an interface
         * to bind to based on `group`.
         *
         * If `source_specific` is %TRUE, source-specific multicast as defined
         * in RFC 4604 is used. Note that on older platforms this may fail
         * with a %G_IO_ERROR_NOT_SUPPORTED error.
         *
         * To bind to a given source-specific multicast address, use
         * g_socket_join_multicast_group_ssm() instead.
         * @param group a #GInetAddress specifying the group address to join.
         * @param source_specific %TRUE if source-specific multicast should be used
         * @param iface Name of the interface to use, or %NULL
         * @returns %TRUE on success, %FALSE on error.
         */
        join_multicast_group(
            group: InetAddress,
            source_specific: boolean,
            iface: string | null
        ): boolean;
        /**
         * Registers `socket` to receive multicast messages sent to `group`.
         * `socket` must be a %G_SOCKET_TYPE_DATAGRAM socket, and must have
         * been bound to an appropriate interface and port with
         * g_socket_bind().
         *
         * If `iface` is %NULL, the system will automatically pick an interface
         * to bind to based on `group`.
         *
         * If `source_specific` is not %NULL, use source-specific multicast as
         * defined in RFC 4604. Note that on older platforms this may fail
         * with a %G_IO_ERROR_NOT_SUPPORTED error.
         *
         * Note that this function can be called multiple times for the same
         * `group` with different `source_specific` in order to receive multicast
         * packets from more than one source.
         * @param group a #GInetAddress specifying the group address to join.
         * @param source_specific a #GInetAddress specifying the source-specific multicast address or %NULL to ignore.
         * @param iface Name of the interface to use, or %NULL
         * @returns %TRUE on success, %FALSE on error.
         */
        join_multicast_group_ssm(
            group: InetAddress,
            source_specific: InetAddress | null,
            iface: string | null
        ): boolean;
        /**
         * Removes `socket` from the multicast group defined by `group,` `iface,`
         * and `source_specific` (which must all have the same values they had
         * when you joined the group).
         *
         * `socket` remains bound to its address and port, and can still receive
         * unicast messages after calling this.
         *
         * To unbind to a given source-specific multicast address, use
         * g_socket_leave_multicast_group_ssm() instead.
         * @param group a #GInetAddress specifying the group address to leave.
         * @param source_specific %TRUE if source-specific multicast was used
         * @param iface Interface used
         * @returns %TRUE on success, %FALSE on error.
         */
        leave_multicast_group(
            group: InetAddress,
            source_specific: boolean,
            iface: string | null
        ): boolean;
        /**
         * Removes `socket` from the multicast group defined by `group,` `iface,`
         * and `source_specific` (which must all have the same values they had
         * when you joined the group).
         *
         * `socket` remains bound to its address and port, and can still receive
         * unicast messages after calling this.
         * @param group a #GInetAddress specifying the group address to leave.
         * @param source_specific a #GInetAddress specifying the source-specific multicast address or %NULL to ignore.
         * @param iface Name of the interface to use, or %NULL
         * @returns %TRUE on success, %FALSE on error.
         */
        leave_multicast_group_ssm(
            group: InetAddress,
            source_specific: InetAddress | null,
            iface: string | null
        ): boolean;
        /**
         * Marks the socket as a server socket, i.e. a socket that is used
         * to accept incoming requests using g_socket_accept().
         *
         * Before calling this the socket must be bound to a local address using
         * g_socket_bind().
         *
         * To set the maximum amount of outstanding clients, use
         * g_socket_set_listen_backlog().
         * @returns %TRUE on success, %FALSE on error.
         */
        listen(): boolean;
        /**
         * Receive data (up to `size` bytes) from a socket. This is mainly used by
         * connection-oriented sockets; it is identical to g_socket_receive_from()
         * with `address` set to %NULL.
         *
         * For %G_SOCKET_TYPE_DATAGRAM and %G_SOCKET_TYPE_SEQPACKET sockets,
         * g_socket_receive() will always read either 0 or 1 complete messages from
         * the socket. If the received message is too large to fit in `buffer,` then
         * the data beyond `size` bytes will be discarded, without any explicit
         * indication that this has occurred.
         *
         * For %G_SOCKET_TYPE_STREAM sockets, g_socket_receive() can return any
         * number of bytes, up to `size`. If more than `size` bytes have been
         * received, the additional data will be returned in future calls to
         * g_socket_receive().
         *
         * If the socket is in blocking mode the call will block until there
         * is some data to receive, the connection is closed, or there is an
         * error. If there is no data available and the socket is in
         * non-blocking mode, a %G_IO_ERROR_WOULD_BLOCK error will be
         * returned. To be notified when data is available, wait for the
         * %G_IO_IN condition.
         *
         * On error -1 is returned and `error` is set accordingly.
         * @param cancellable a %GCancellable or %NULL
         * @returns Number of bytes read, or 0 if the connection was closed by the peer, or -1 on error
         */
        receive(
            cancellable: Cancellable | null
        ): [/* returnType */ number, /* buffer */ Uint8Array];
        /**
         * Receive data (up to `size` bytes) from a socket.
         *
         * If `address` is non-%NULL then `address` will be set equal to the
         * source address of the received packet.
         * `address` is owned by the caller.
         *
         * See g_socket_receive() for additional information.
         * @param cancellable a %GCancellable or %NULL
         * @returns Number of bytes read, or 0 if the connection was closed by the peer, or -1 on error
         */
        receive_from(
            cancellable: Cancellable | null
        ): [
            /* returnType */ number,
            /* address */ SocketAddress,
            /* buffer */ Uint8Array
        ];
        /**
         * Receive data from a socket.  For receiving multiple messages, see
         * g_socket_receive_messages(); for easier use, see
         * g_socket_receive() and g_socket_receive_from().
         *
         * If `address` is non-%NULL then `address` will be set equal to the
         * source address of the received packet.
         * `address` is owned by the caller.
         *
         * `vector` must point to an array of #GInputVector structs and
         * `num_vectors` must be the length of this array.  These structs
         * describe the buffers that received data will be scattered into.
         * If `num_vectors` is -1, then `vectors` is assumed to be terminated
         * by a #GInputVector with a %NULL buffer pointer.
         *
         * As a special case, if `num_vectors` is 0 (in which case, `vectors`
         * may of course be %NULL), then a single byte is received and
         * discarded. This is to facilitate the common practice of sending a
         * single '\0' byte for the purposes of transferring ancillary data.
         *
         * `messages,` if non-%NULL, will be set to point to a newly-allocated
         * array of #GSocketControlMessage instances or %NULL if no such
         * messages was received. These correspond to the control messages
         * received from the kernel, one #GSocketControlMessage per message
         * from the kernel. This array is %NULL-terminated and must be freed
         * by the caller using g_free() after calling g_object_unref() on each
         * element. If `messages` is %NULL, any control messages received will
         * be discarded.
         *
         * `num_messages,` if non-%NULL, will be set to the number of control
         * messages received.
         *
         * If both `messages` and `num_messages` are non-%NULL, then
         * `num_messages` gives the number of #GSocketControlMessage instances
         * in `messages` (ie: not including the %NULL terminator).
         *
         * `flags` is an in/out parameter. The commonly available arguments
         * for this are available in the #GSocketMsgFlags enum, but the
         * values there are the same as the system values, and the flags
         * are passed in as-is, so you can pass in system-specific flags too
         * (and g_socket_receive_message() may pass system-specific flags out).
         * Flags passed in to the parameter affect the receive operation; flags returned
         * out of it are relevant to the specific returned message.
         *
         * As with g_socket_receive(), data may be discarded if `socket` is
         * %G_SOCKET_TYPE_DATAGRAM or %G_SOCKET_TYPE_SEQPACKET and you do not
         * provide enough buffer space to read a complete message. You can pass
         * %G_SOCKET_MSG_PEEK in `flags` to peek at the current message without
         * removing it from the receive queue, but there is no portable way to find
         * out the length of the message other than by reading it into a
         * sufficiently-large buffer.
         *
         * If the socket is in blocking mode the call will block until there
         * is some data to receive, the connection is closed, or there is an
         * error. If there is no data available and the socket is in
         * non-blocking mode, a %G_IO_ERROR_WOULD_BLOCK error will be
         * returned. To be notified when data is available, wait for the
         * %G_IO_IN condition.
         *
         * On error -1 is returned and `error` is set accordingly.
         * @param vectors an array of #GInputVector structs
         * @param flags a pointer to an int containing #GSocketMsgFlags flags,    which may additionally contain    [other platform specific flags](http://man7.org/linux/man-pages/man2/recv.2.html)
         * @param cancellable a %GCancellable or %NULL
         * @returns Number of bytes read, or 0 if the connection was closed by the peer, or -1 on error
         */
        receive_message(
            vectors: InputVector[],
            flags: number,
            cancellable: Cancellable | null
        ): [
            /* returnType */ number,
            /* address */ SocketAddress,
            /* messages */ SocketControlMessage[] | null,
            /* flags */ number
        ];
        /**
         * Receive multiple data messages from `socket` in one go.  This is the most
         * complicated and fully-featured version of this call. For easier use, see
         * g_socket_receive(), g_socket_receive_from(), and g_socket_receive_message().
         *
         * `messages` must point to an array of #GInputMessage structs and
         * `num_messages` must be the length of this array. Each #GInputMessage
         * contains a pointer to an array of #GInputVector structs describing the
         * buffers that the data received in each message will be written to. Using
         * multiple #GInputVectors is more memory-efficient than manually copying data
         * out of a single buffer to multiple sources, and more system-call-efficient
         * than making multiple calls to g_socket_receive(), such as in scenarios where
         * a lot of data packets need to be received (e.g. high-bandwidth video
         * streaming over RTP/UDP).
         *
         * `flags` modify how all messages are received. The commonly available
         * arguments for this are available in the #GSocketMsgFlags enum, but the
         * values there are the same as the system values, and the flags
         * are passed in as-is, so you can pass in system-specific flags too. These
         * flags affect the overall receive operation. Flags affecting individual
         * messages are returned in #GInputMessage.flags.
         *
         * The other members of #GInputMessage are treated as described in its
         * documentation.
         *
         * If #GSocket:blocking is %TRUE the call will block until `num_messages` have
         * been received, or the end of the stream is reached.
         *
         * If #GSocket:blocking is %FALSE the call will return up to `num_messages`
         * without blocking, or %G_IO_ERROR_WOULD_BLOCK if no messages are queued in the
         * operating system to be received.
         *
         * In blocking mode, if #GSocket:timeout is positive and is reached before any
         * messages are received, %G_IO_ERROR_TIMED_OUT is returned, otherwise up to
         * `num_messages` are returned. (Note: This is effectively the
         * behaviour of `MSG_WAITFORONE` with recvmmsg().)
         *
         * To be notified when messages are available, wait for the
         * %G_IO_IN condition. Note though that you may still receive
         * %G_IO_ERROR_WOULD_BLOCK from g_socket_receive_messages() even if you were
         * previously notified of a %G_IO_IN condition.
         *
         * If the remote peer closes the connection, any messages queued in the
         * operating system will be returned, and subsequent calls to
         * g_socket_receive_messages() will return 0 (with no error set).
         *
         * On error -1 is returned and `error` is set accordingly. An error will only
         * be returned if zero messages could be received; otherwise the number of
         * messages successfully received before the error will be returned.
         * @param messages an array of #GInputMessage structs
         * @param flags an int containing #GSocketMsgFlags flags for the overall operation,    which may additionally contain    [other platform specific flags](http://man7.org/linux/man-pages/man2/recv.2.html)
         * @param cancellable a %GCancellable or %NULL
         * @returns number of messages received, or -1 on error. Note that the number     of messages received may be smaller than @num_messages if in non-blocking     mode, if the peer closed the connection, or if @num_messages     was larger than `UIO_MAXIOV` (1024), in which case the caller may re-try     to receive the remaining messages.
         */
        receive_messages(
            messages: InputMessage[],
            flags: number,
            cancellable: Cancellable | null
        ): number;

        // Overloads of receive_messages

        /**
         * Receive one or more data messages from `datagram_based` in one go.
         *
         * `messages` must point to an array of #GInputMessage structs and
         * `num_messages` must be the length of this array. Each #GInputMessage
         * contains a pointer to an array of #GInputVector structs describing the
         * buffers that the data received in each message will be written to.
         *
         * `flags` modify how all messages are received. The commonly available
         * arguments for this are available in the #GSocketMsgFlags enum, but the
         * values there are the same as the system values, and the flags
         * are passed in as-is, so you can pass in system-specific flags too. These
         * flags affect the overall receive operation. Flags affecting individual
         * messages are returned in #GInputMessage.flags.
         *
         * The other members of #GInputMessage are treated as described in its
         * documentation.
         *
         * If `timeout` is negative the call will block until `num_messages` have been
         * received, the connection is closed remotely (EOS), `cancellable` is cancelled,
         * or an error occurs.
         *
         * If `timeout` is 0 the call will return up to `num_messages` without blocking,
         * or %G_IO_ERROR_WOULD_BLOCK if no messages are queued in the operating system
         * to be received.
         *
         * If `timeout` is positive the call will block on the same conditions as if
         * `timeout` were negative. If the timeout is reached
         * before any messages are received, %G_IO_ERROR_TIMED_OUT is returned,
         * otherwise it will return the number of messages received before timing out.
         * (Note: This is effectively the behaviour of `MSG_WAITFORONE` with
         * recvmmsg().)
         *
         * To be notified when messages are available, wait for the %G_IO_IN condition.
         * Note though that you may still receive %G_IO_ERROR_WOULD_BLOCK from
         * g_datagram_based_receive_messages() even if you were previously notified of a
         * %G_IO_IN condition.
         *
         * If the remote peer closes the connection, any messages queued in the
         * underlying receive buffer will be returned, and subsequent calls to
         * g_datagram_based_receive_messages() will return 0 (with no error set).
         *
         * If the connection is shut down or closed (by calling g_socket_close() or
         * g_socket_shutdown() with `shutdown_read` set, if its a #GSocket, for
         * example), all calls to this function will return %G_IO_ERROR_CLOSED.
         *
         * On error -1 is returned and `error` is set accordingly. An error will only
         * be returned if zero messages could be received; otherwise the number of
         * messages successfully received before the error will be returned. If
         * `cancellable` is cancelled, %G_IO_ERROR_CANCELLED is returned as with any
         * other error.
         * @param messages an array of #GInputMessage structs
         * @param flags an int containing #GSocketMsgFlags flags for the overall operation
         * @param timeout the maximum time (in microseconds) to wait, 0 to not block, or -1   to block indefinitely
         * @param cancellable a %GCancellable
         * @returns number of messages received, or -1 on error. Note that the number     of messages received may be smaller than @num_messages if @timeout is     zero or positive, if the peer closed the connection, or if @num_messages     was larger than `UIO_MAXIOV` (1024), in which case the caller may re-try     to receive the remaining messages.
         */
        receive_messages(
            messages: InputMessage[],
            flags: number,
            timeout: number,
            cancellable: Cancellable | null
        ): number;
        /**
         * This behaves exactly the same as g_socket_receive(), except that
         * the choice of blocking or non-blocking behavior is determined by
         * the `blocking` argument rather than by `socket'`s properties.
         * @param blocking whether to do blocking or non-blocking I/O
         * @param cancellable a %GCancellable or %NULL
         * @returns Number of bytes read, or 0 if the connection was closed by the peer, or -1 on error
         */
        receive_with_blocking(
            blocking: boolean,
            cancellable: Cancellable | null
        ): [/* returnType */ number, /* buffer */ Uint8Array];
        /**
         * Tries to send `size` bytes from `buffer` on the socket. This is
         * mainly used by connection-oriented sockets; it is identical to
         * g_socket_send_to() with `address` set to %NULL.
         *
         * If the socket is in blocking mode the call will block until there is
         * space for the data in the socket queue. If there is no space available
         * and the socket is in non-blocking mode a %G_IO_ERROR_WOULD_BLOCK error
         * will be returned. To be notified when space is available, wait for the
         * %G_IO_OUT condition. Note though that you may still receive
         * %G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
         * notified of a %G_IO_OUT condition. (On Windows in particular, this is
         * very common due to the way the underlying APIs work.)
         *
         * On error -1 is returned and `error` is set accordingly.
         * @param buffer the buffer     containing the data to send.
         * @param cancellable a %GCancellable or %NULL
         * @returns Number of bytes written (which may be less than @size), or -1 on error
         */
        send(buffer: Uint8Array, cancellable: Cancellable | null): number;
        /**
         * Send data to `address` on `socket`.  For sending multiple messages see
         * g_socket_send_messages(); for easier use, see
         * g_socket_send() and g_socket_send_to().
         *
         * If `address` is %NULL then the message is sent to the default receiver
         * (set by g_socket_connect()).
         *
         * `vectors` must point to an array of #GOutputVector structs and
         * `num_vectors` must be the length of this array. (If `num_vectors` is -1,
         * then `vectors` is assumed to be terminated by a #GOutputVector with a
         * %NULL buffer pointer.) The #GOutputVector structs describe the buffers
         * that the sent data will be gathered from. Using multiple
         * #GOutputVectors is more memory-efficient than manually copying
         * data from multiple sources into a single buffer, and more
         * network-efficient than making multiple calls to g_socket_send().
         *
         * `messages,` if non-%NULL, is taken to point to an array of `num_messages`
         * #GSocketControlMessage instances. These correspond to the control
         * messages to be sent on the socket.
         * If `num_messages` is -1 then `messages` is treated as a %NULL-terminated
         * array.
         *
         * `flags` modify how the message is sent. The commonly available arguments
         * for this are available in the #GSocketMsgFlags enum, but the
         * values there are the same as the system values, and the flags
         * are passed in as-is, so you can pass in system-specific flags too.
         *
         * If the socket is in blocking mode the call will block until there is
         * space for the data in the socket queue. If there is no space available
         * and the socket is in non-blocking mode a %G_IO_ERROR_WOULD_BLOCK error
         * will be returned. To be notified when space is available, wait for the
         * %G_IO_OUT condition. Note though that you may still receive
         * %G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
         * notified of a %G_IO_OUT condition. (On Windows in particular, this is
         * very common due to the way the underlying APIs work.)
         *
         * The sum of the sizes of each #GOutputVector in vectors must not be
         * greater than %G_MAXSSIZE. If the message can be larger than this,
         * then it is mandatory to use the g_socket_send_message_with_timeout()
         * function.
         *
         * On error -1 is returned and `error` is set accordingly.
         * @param address a #GSocketAddress, or %NULL
         * @param vectors an array of #GOutputVector structs
         * @param messages a pointer to an   array of #GSocketControlMessages, or %NULL.
         * @param flags an int containing #GSocketMsgFlags flags, which may additionally    contain [other platform specific flags](http://man7.org/linux/man-pages/man2/recv.2.html)
         * @param cancellable a %GCancellable or %NULL
         * @returns Number of bytes written (which may be less than @size), or -1 on error
         */
        send_message(
            address: SocketAddress | null,
            vectors: OutputVector[],
            messages: SocketControlMessage[] | null,
            flags: number,
            cancellable: Cancellable | null
        ): number;
        /**
         * This behaves exactly the same as g_socket_send_message(), except that
         * the choice of timeout behavior is determined by the `timeout_us` argument
         * rather than by `socket'`s properties.
         *
         * On error %G_POLLABLE_RETURN_FAILED is returned and `error` is set accordingly, or
         * if the socket is currently not writable %G_POLLABLE_RETURN_WOULD_BLOCK is
         * returned. `bytes_written` will contain 0 in both cases.
         * @param address a #GSocketAddress, or %NULL
         * @param vectors an array of #GOutputVector structs
         * @param messages a pointer to an   array of #GSocketControlMessages, or %NULL.
         * @param flags an int containing #GSocketMsgFlags flags, which may additionally    contain [other platform specific flags](http://man7.org/linux/man-pages/man2/recv.2.html)
         * @param timeout_us the maximum time (in microseconds) to wait, or -1
         * @param cancellable a %GCancellable or %NULL
         * @returns %G_POLLABLE_RETURN_OK if all data was successfully written, %G_POLLABLE_RETURN_WOULD_BLOCK if the socket is currently not writable, or %G_POLLABLE_RETURN_FAILED if an error happened and @error is set.
         */
        send_message_with_timeout(
            address: SocketAddress | null,
            vectors: OutputVector[],
            messages: SocketControlMessage[] | null,
            flags: number,
            timeout_us: number,
            cancellable: Cancellable | null
        ): [/* returnType */ PollableReturn, /* bytes_written */ number];
        /**
         * Send multiple data messages from `socket` in one go.  This is the most
         * complicated and fully-featured version of this call. For easier use, see
         * g_socket_send(), g_socket_send_to(), and g_socket_send_message().
         *
         * `messages` must point to an array of #GOutputMessage structs and
         * `num_messages` must be the length of this array. Each #GOutputMessage
         * contains an address to send the data to, and a pointer to an array of
         * #GOutputVector structs to describe the buffers that the data to be sent
         * for each message will be gathered from. Using multiple #GOutputVectors is
         * more memory-efficient than manually copying data from multiple sources
         * into a single buffer, and more network-efficient than making multiple
         * calls to g_socket_send(). Sending multiple messages in one go avoids the
         * overhead of making a lot of syscalls in scenarios where a lot of data
         * packets need to be sent (e.g. high-bandwidth video streaming over RTP/UDP),
         * or where the same data needs to be sent to multiple recipients.
         *
         * `flags` modify how the message is sent. The commonly available arguments
         * for this are available in the #GSocketMsgFlags enum, but the
         * values there are the same as the system values, and the flags
         * are passed in as-is, so you can pass in system-specific flags too.
         *
         * If the socket is in blocking mode the call will block until there is
         * space for all the data in the socket queue. If there is no space available
         * and the socket is in non-blocking mode a %G_IO_ERROR_WOULD_BLOCK error
         * will be returned if no data was written at all, otherwise the number of
         * messages sent will be returned. To be notified when space is available,
         * wait for the %G_IO_OUT condition. Note though that you may still receive
         * %G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
         * notified of a %G_IO_OUT condition. (On Windows in particular, this is
         * very common due to the way the underlying APIs work.)
         *
         * On error -1 is returned and `error` is set accordingly. An error will only
         * be returned if zero messages could be sent; otherwise the number of messages
         * successfully sent before the error will be returned.
         * @param messages an array of #GOutputMessage structs
         * @param flags an int containing #GSocketMsgFlags flags, which may additionally    contain [other platform specific flags](http://man7.org/linux/man-pages/man2/recv.2.html)
         * @param cancellable a %GCancellable or %NULL
         * @returns number of messages sent, or -1 on error. Note that the number of     messages sent may be smaller than @num_messages if the socket is     non-blocking or if @num_messages was larger than UIO_MAXIOV (1024),     in which case the caller may re-try to send the remaining messages.
         */
        send_messages(
            messages: OutputMessage[],
            flags: number,
            cancellable: Cancellable | null
        ): number;

        // Overloads of send_messages

        /**
         * Send one or more data messages from `datagram_based` in one go.
         *
         * `messages` must point to an array of #GOutputMessage structs and
         * `num_messages` must be the length of this array. Each #GOutputMessage
         * contains an address to send the data to, and a pointer to an array of
         * #GOutputVector structs to describe the buffers that the data to be sent
         * for each message will be gathered from.
         *
         * `flags` modify how the message is sent. The commonly available arguments
         * for this are available in the #GSocketMsgFlags enum, but the
         * values there are the same as the system values, and the flags
         * are passed in as-is, so you can pass in system-specific flags too.
         *
         * The other members of #GOutputMessage are treated as described in its
         * documentation.
         *
         * If `timeout` is negative the call will block until `num_messages` have been
         * sent, `cancellable` is cancelled, or an error occurs.
         *
         * If `timeout` is 0 the call will send up to `num_messages` without blocking,
         * or will return %G_IO_ERROR_WOULD_BLOCK if there is no space to send messages.
         *
         * If `timeout` is positive the call will block on the same conditions as if
         * `timeout` were negative. If the timeout is reached before any messages are
         * sent, %G_IO_ERROR_TIMED_OUT is returned, otherwise it will return the number
         * of messages sent before timing out.
         *
         * To be notified when messages can be sent, wait for the %G_IO_OUT condition.
         * Note though that you may still receive %G_IO_ERROR_WOULD_BLOCK from
         * g_datagram_based_send_messages() even if you were previously notified of a
         * %G_IO_OUT condition. (On Windows in particular, this is very common due to
         * the way the underlying APIs work.)
         *
         * If the connection is shut down or closed (by calling g_socket_close() or
         * g_socket_shutdown() with `shutdown_write` set, if its a #GSocket, for
         * example), all calls to this function will return %G_IO_ERROR_CLOSED.
         *
         * On error -1 is returned and `error` is set accordingly. An error will only
         * be returned if zero messages could be sent; otherwise the number of messages
         * successfully sent before the error will be returned. If `cancellable` is
         * cancelled, %G_IO_ERROR_CANCELLED is returned as with any other error.
         * @param messages an array of #GOutputMessage structs
         * @param flags an int containing #GSocketMsgFlags flags
         * @param timeout the maximum time (in microseconds) to wait, 0 to not block, or -1   to block indefinitely
         * @param cancellable a %GCancellable
         * @returns number of messages sent, or -1 on error. Note that the number of     messages sent may be smaller than @num_messages if @timeout is zero     or positive, or if @num_messages was larger than `UIO_MAXIOV` (1024), in     which case the caller may re-try to send the remaining messages.
         */
        send_messages(
            messages: OutputMessage[],
            flags: number,
            timeout: number,
            cancellable: Cancellable | null
        ): number;
        /**
         * Tries to send `size` bytes from `buffer` to `address`. If `address` is
         * %NULL then the message is sent to the default receiver (set by
         * g_socket_connect()).
         *
         * See g_socket_send() for additional information.
         * @param address a #GSocketAddress, or %NULL
         * @param buffer the buffer     containing the data to send.
         * @param cancellable a %GCancellable or %NULL
         * @returns Number of bytes written (which may be less than @size), or -1 on error
         */
        send_to(
            address: SocketAddress | null,
            buffer: Uint8Array,
            cancellable: Cancellable | null
        ): number;
        /**
         * This behaves exactly the same as g_socket_send(), except that
         * the choice of blocking or non-blocking behavior is determined by
         * the `blocking` argument rather than by `socket'`s properties.
         * @param buffer the buffer     containing the data to send.
         * @param blocking whether to do blocking or non-blocking I/O
         * @param cancellable a %GCancellable or %NULL
         * @returns Number of bytes written (which may be less than @size), or -1 on error
         */
        send_with_blocking(
            buffer: Uint8Array,
            blocking: boolean,
            cancellable: Cancellable | null
        ): number;
        /**
         * Sets the blocking mode of the socket. In blocking mode
         * all operations (which dont take an explicit blocking parameter) block until
         * they succeed or there is an error. In
         * non-blocking mode all functions return results immediately or
         * with a %G_IO_ERROR_WOULD_BLOCK error.
         *
         * All sockets are created in blocking mode. However, note that the
         * platform level socket is always non-blocking, and blocking mode
         * is a GSocket level feature.
         * @param blocking Whether to use blocking I/O or not.
         */
        set_blocking(blocking: boolean): void;
        /**
         * Sets whether `socket` should allow sending to broadcast addresses.
         * This is %FALSE by default.
         * @param broadcast whether `socket` should allow sending to broadcast     addresses
         */
        set_broadcast(broadcast: boolean): void;
        /**
         * Sets or unsets the %SO_KEEPALIVE flag on the underlying socket. When
         * this flag is set on a socket, the system will attempt to verify that the
         * remote socket endpoint is still present if a sufficiently long period of
         * time passes with no data being exchanged. If the system is unable to
         * verify the presence of the remote endpoint, it will automatically close
         * the connection.
         *
         * This option is only functional on certain kinds of sockets. (Notably,
         * %G_SOCKET_PROTOCOL_TCP sockets.)
         *
         * The exact time between pings is system- and protocol-dependent, but will
         * normally be at least two hours. Most commonly, you would set this flag
         * on a server socket if you want to allow clients to remain idle for long
         * periods of time, but also want to ensure that connections are eventually
         * garbage-collected if clients crash or become unreachable.
         * @param keepalive Value for the keepalive flag
         */
        set_keepalive(keepalive: boolean): void;
        /**
         * Sets the maximum number of outstanding connections allowed
         * when listening on this socket. If more clients than this are
         * connecting to the socket and the application is not handling them
         * on time then the new connections will be refused.
         *
         * Note that this must be called before g_socket_listen() and has no
         * effect if called after that.
         * @param backlog the maximum number of pending connections.
         */
        set_listen_backlog(backlog: number): void;
        /**
         * Sets whether outgoing multicast packets will be received by sockets
         * listening on that multicast address on the same host. This is %TRUE
         * by default.
         * @param loopback whether `socket` should receive messages sent to its   multicast groups from the local host
         */
        set_multicast_loopback(loopback: boolean): void;
        /**
         * Sets the time-to-live for outgoing multicast datagrams on `socket`.
         * By default, this is 1, meaning that multicast packets will not leave
         * the local network.
         * @param ttl the time-to-live value for all multicast datagrams on `socket`
         */
        set_multicast_ttl(ttl: number): void;
        /**
         * Sets the value of an integer-valued option on `socket,` as with
         * setsockopt(). (If you need to set a non-integer-valued option,
         * you will need to call setsockopt() directly.)
         *
         * The [<gio/gnetworking.h>][gio-gnetworking.h]
         * header pulls in system headers that will define most of the
         * standard/portable socket options. For unusual socket protocols or
         * platform-dependent options, you may need to include additional
         * headers.
         * @param level the "API level" of the option (eg, `SOL_SOCKET`)
         * @param optname the "name" of the option (eg, `SO_BROADCAST`)
         * @param value the value to set the option to
         * @returns success or failure. On failure, @error will be set, and   the system error value (`errno` or WSAGetLastError()) will still   be set to the result of the setsockopt() call.
         */
        set_option(level: number, optname: number, value: number): boolean;
        /**
         * Sets the time in seconds after which I/O operations on `socket` will
         * time out if they have not yet completed.
         *
         * On a blocking socket, this means that any blocking #GSocket
         * operation will time out after `timeout` seconds of inactivity,
         * returning %G_IO_ERROR_TIMED_OUT.
         *
         * On a non-blocking socket, calls to g_socket_condition_wait() will
         * also fail with %G_IO_ERROR_TIMED_OUT after the given time. Sources
         * created with g_socket_create_source() will trigger after
         * `timeout` seconds of inactivity, with the requested condition
         * set, at which point calling g_socket_receive(), g_socket_send(),
         * g_socket_check_connect_result(), etc, will fail with
         * %G_IO_ERROR_TIMED_OUT.
         *
         * If `timeout` is 0 (the default), operations will never time out
         * on their own.
         *
         * Note that if an I/O operation is interrupted by a signal, this may
         * cause the timeout to be reset.
         * @param timeout the timeout for `socket,` in seconds, or 0 for none
         */
        set_timeout(timeout: number): void;
        /**
         * Sets the time-to-live for outgoing unicast packets on `socket`.
         * By default the platform-specific default value is used.
         * @param ttl the time-to-live value for all unicast packets on `socket`
         */
        set_ttl(ttl: number): void;
        /**
         * Shut down part or all of a full-duplex connection.
         *
         * If `shutdown_read` is %TRUE then the receiving side of the connection
         * is shut down, and further reading is disallowed.
         *
         * If `shutdown_write` is %TRUE then the sending side of the connection
         * is shut down, and further writing is disallowed.
         *
         * It is allowed for both `shutdown_read` and `shutdown_write` to be %TRUE.
         *
         * One example where it is useful to shut down only one side of a connection is
         * graceful disconnect for TCP connections where you close the sending side,
         * then wait for the other side to close the connection, thus ensuring that the
         * other side saw all sent data.
         * @param shutdown_read whether to shut down the read side
         * @param shutdown_write whether to shut down the write side
         * @returns %TRUE on success, %FALSE on error
         */
        shutdown(shutdown_read: boolean, shutdown_write: boolean): boolean;
        /**
         * Checks if a socket is capable of speaking IPv4.
         *
         * IPv4 sockets are capable of speaking IPv4.  On some operating systems
         * and under some combinations of circumstances IPv6 sockets are also
         * capable of speaking IPv4.  See RFC 3493 section 3.7 for more
         * information.
         *
         * No other types of sockets are currently considered as being capable
         * of speaking IPv4.
         * @returns %TRUE if this socket can be used with IPv4.
         */
        speaks_ipv4(): boolean;

        // Class property signals of Gio-2.0.Gio.Socket

        connect(
            sigName: 'notify::blocking',
            callback: ($obj: Socket, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::blocking',
            callback: ($obj: Socket, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::blocking', ...args: any[]): void;
        connect(
            sigName: 'notify::broadcast',
            callback: ($obj: Socket, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::broadcast',
            callback: ($obj: Socket, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::broadcast', ...args: any[]): void;
        connect(
            sigName: 'notify::family',
            callback: ($obj: Socket, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::family',
            callback: ($obj: Socket, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::family', ...args: any[]): void;
        connect(
            sigName: 'notify::fd',
            callback: ($obj: Socket, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::fd',
            callback: ($obj: Socket, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::fd', ...args: any[]): void;
        connect(
            sigName: 'notify::keepalive',
            callback: ($obj: Socket, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::keepalive',
            callback: ($obj: Socket, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::keepalive', ...args: any[]): void;
        connect(
            sigName: 'notify::listen-backlog',
            callback: ($obj: Socket, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::listen-backlog',
            callback: ($obj: Socket, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::listen-backlog', ...args: any[]): void;
        connect(
            sigName: 'notify::local-address',
            callback: ($obj: Socket, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::local-address',
            callback: ($obj: Socket, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::local-address', ...args: any[]): void;
        connect(
            sigName: 'notify::multicast-loopback',
            callback: ($obj: Socket, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::multicast-loopback',
            callback: ($obj: Socket, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::multicast-loopback', ...args: any[]): void;
        connect(
            sigName: 'notify::multicast-ttl',
            callback: ($obj: Socket, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::multicast-ttl',
            callback: ($obj: Socket, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::multicast-ttl', ...args: any[]): void;
        connect(
            sigName: 'notify::protocol',
            callback: ($obj: Socket, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::protocol',
            callback: ($obj: Socket, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::protocol', ...args: any[]): void;
        connect(
            sigName: 'notify::remote-address',
            callback: ($obj: Socket, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::remote-address',
            callback: ($obj: Socket, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::remote-address', ...args: any[]): void;
        connect(
            sigName: 'notify::timeout',
            callback: ($obj: Socket, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::timeout',
            callback: ($obj: Socket, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::timeout', ...args: any[]): void;
        connect(
            sigName: 'notify::ttl',
            callback: ($obj: Socket, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::ttl',
            callback: ($obj: Socket, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::ttl', ...args: any[]): void;
        connect(
            sigName: 'notify::type',
            callback: ($obj: Socket, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::type',
            callback: ($obj: Socket, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::type', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * A #GSocket is a low-level networking primitive. It is a more or less
     * direct mapping of the BSD socket API in a portable GObject based API.
     * It supports both the UNIX socket implementations and winsock2 on Windows.
     *
     * #GSocket is the platform independent base upon which the higher level
     * network primitives are based. Applications are not typically meant to
     * use it directly, but rather through classes like #GSocketClient,
     * #GSocketService and #GSocketConnection. However there may be cases where
     * direct use of #GSocket is useful.
     *
     * #GSocket implements the #GInitable interface, so if it is manually constructed
     * by e.g. g_object_new() you must call g_initable_init() and check the
     * results before using the object. This is done automatically in
     * g_socket_new() and g_socket_new_from_fd(), so these functions can return
     * %NULL.
     *
     * Sockets operate in two general modes, blocking or non-blocking. When
     * in blocking mode all operations (which dont take an explicit blocking
     * parameter) block until the requested operation
     * is finished or there is an error. In non-blocking mode all calls that
     * would block return immediately with a %G_IO_ERROR_WOULD_BLOCK error.
     * To know when a call would successfully run you can call g_socket_condition_check(),
     * or g_socket_condition_wait(). You can also use g_socket_create_source() and
     * attach it to a #GMainContext to get callbacks when I/O is possible.
     * Note that all sockets are always set to non blocking mode in the system, and
     * blocking mode is emulated in GSocket.
     *
     * When working in non-blocking mode applications should always be able to
     * handle getting a %G_IO_ERROR_WOULD_BLOCK error even when some other
     * function said that I/O was possible. This can easily happen in case
     * of a race condition in the application, but it can also happen for other
     * reasons. For instance, on Windows a socket is always seen as writable
     * until a write returns %G_IO_ERROR_WOULD_BLOCK.
     *
     * #GSockets can be either connection oriented or datagram based.
     * For connection oriented types you must first establish a connection by
     * either connecting to an address or accepting a connection from another
     * address. For connectionless socket types the target/source address is
     * specified or received in each I/O operation.
     *
     * All socket file descriptors are set to be close-on-exec.
     *
     * Note that creating a #GSocket causes the signal %SIGPIPE to be
     * ignored for the remainder of the program. If you are writing a
     * command-line utility that uses #GSocket, you may need to take into
     * account the fact that your program will not automatically be killed
     * if it tries to write to %stdout after it has been closed.
     *
     * Like most other APIs in GLib, #GSocket is not inherently thread safe. To use
     * a #GSocket concurrently from multiple threads, you must implement your own
     * locking.
     * @class
     */
    class Socket extends GObject.Object {
        // Own properties of Gio-2.0.Gio.Socket

        static name: string;
        static $gtype: GObject.GType<Socket>;

        // Constructors of Gio-2.0.Gio.Socket

        constructor(config?: Socket.ConstructorProperties);
        /**
         * Creates a new #GSocket with the defined family, type and protocol.
         * If `protocol` is 0 (%G_SOCKET_PROTOCOL_DEFAULT) the default protocol type
         * for the family and type is used.
         *
         * The `protocol` is a family and type specific int that specifies what
         * kind of protocol to use. #GSocketProtocol lists several common ones.
         * Many families only support one protocol, and use 0 for this, others
         * support several and using 0 means to use the default protocol for
         * the family and type.
         *
         * The protocol id is passed directly to the operating
         * system, so you can use protocols not listed in #GSocketProtocol if you
         * know the protocol number used for it.
         * @constructor
         * @param family the socket family to use, e.g. %G_SOCKET_FAMILY_IPV4.
         * @param type the socket type to use.
         * @param protocol the id of the protocol to use, or 0 for default.
         * @returns a #GSocket or %NULL on error.     Free the returned object with g_object_unref().
         */
        constructor(
            family: SocketFamily,
            type: SocketType,
            protocol: SocketProtocol
        );
        /**
         * Creates a new #GSocket with the defined family, type and protocol.
         * If `protocol` is 0 (%G_SOCKET_PROTOCOL_DEFAULT) the default protocol type
         * for the family and type is used.
         *
         * The `protocol` is a family and type specific int that specifies what
         * kind of protocol to use. #GSocketProtocol lists several common ones.
         * Many families only support one protocol, and use 0 for this, others
         * support several and using 0 means to use the default protocol for
         * the family and type.
         *
         * The protocol id is passed directly to the operating
         * system, so you can use protocols not listed in #GSocketProtocol if you
         * know the protocol number used for it.
         * @constructor
         * @param family the socket family to use, e.g. %G_SOCKET_FAMILY_IPV4.
         * @param type the socket type to use.
         * @param protocol the id of the protocol to use, or 0 for default.
         * @returns a #GSocket or %NULL on error.     Free the returned object with g_object_unref().
         */
        static new(
            family: SocketFamily,
            type: SocketType,
            protocol: SocketProtocol
        ): Socket;
        /**
         * Creates a new #GSocket from a native file descriptor
         * or winsock SOCKET handle.
         *
         * This reads all the settings from the file descriptor so that
         * all properties should work. Note that the file descriptor
         * will be set to non-blocking mode, independent on the blocking
         * mode of the #GSocket.
         *
         * On success, the returned #GSocket takes ownership of `fd`. On failure, the
         * caller must close `fd` themselves.
         *
         * Since GLib 2.46, it is no longer a fatal error to call this on a non-socket
         * descriptor.  Instead, a GError will be set with code %G_IO_ERROR_FAILED
         * @constructor
         * @param fd a native socket file descriptor.
         * @returns a #GSocket or %NULL on error.     Free the returned object with g_object_unref().
         */
        static new_from_fd(fd: number): Socket;
        _init(config?: Socket.ConstructorProperties): void;
    }

    namespace SocketAddress {
        // Constructor properties interface

        interface ConstructorProperties
            extends SocketConnectable.ConstructorProperties,
                GObject.Object.ConstructorProperties {}
    }

    interface SocketAddress extends SocketConnectable {
        // Own properties of Gio-2.0.Gio.SocketAddress

        readonly family: SocketFamily;

        // Own fields of Gio-2.0.Gio.SocketAddress

        parent_instance: GObject.Object;

        // Owm methods of Gio-2.0.Gio.SocketAddress

        /**
         * Gets the socket family type of `address`.
         * @returns the socket family type of @address
         */
        get_family(): SocketFamily;
        /**
         * Gets the size of `address'`s native struct sockaddr.
         * You can use this to allocate memory to pass to
         * g_socket_address_to_native().
         * @returns the size of the native struct sockaddr that     @address represents
         */
        get_native_size(): number;
        /**
         * Converts a #GSocketAddress to a native struct sockaddr, which can
         * be passed to low-level functions like connect() or bind().
         *
         * If not enough space is available, a %G_IO_ERROR_NO_SPACE error
         * is returned. If the address type is not known on the system
         * then a %G_IO_ERROR_NOT_SUPPORTED error is returned.
         * @param dest a pointer to a memory location that will contain the native struct sockaddr
         * @param destlen the size of `dest`. Must be at least as large as     g_socket_address_get_native_size()
         * @returns %TRUE if @dest was filled in, %FALSE on error
         */
        to_native(dest: any | null, destlen: number): boolean;

        // Own virtual methods of Gio-2.0.Gio.SocketAddress

        /**
         * Gets the socket family type of `address`.
         * @virtual
         * @returns the socket family type of @address
         */
        vfunc_get_family(): SocketFamily;
        /**
         * Gets the size of `address'`s native struct sockaddr.
         * You can use this to allocate memory to pass to
         * g_socket_address_to_native().
         * @virtual
         * @returns the size of the native struct sockaddr that     @address represents
         */
        vfunc_get_native_size(): number;
        /**
         * Converts a #GSocketAddress to a native struct sockaddr, which can
         * be passed to low-level functions like connect() or bind().
         *
         * If not enough space is available, a %G_IO_ERROR_NO_SPACE error
         * is returned. If the address type is not known on the system
         * then a %G_IO_ERROR_NOT_SUPPORTED error is returned.
         * @virtual
         * @param dest a pointer to a memory location that will contain the native struct sockaddr
         * @param destlen the size of `dest`. Must be at least as large as     g_socket_address_get_native_size()
         * @returns %TRUE if @dest was filled in, %FALSE on error
         */
        vfunc_to_native(dest: any | null, destlen: number): boolean;

        // Class property signals of Gio-2.0.Gio.SocketAddress

        connect(
            sigName: 'notify::family',
            callback: ($obj: SocketAddress, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::family',
            callback: ($obj: SocketAddress, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::family', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GSocketAddress is the equivalent of struct sockaddr in the BSD
     * sockets API. This is an abstract class; use #GInetSocketAddress
     * for internet sockets, or #GUnixSocketAddress for UNIX domain sockets.
     * @class
     */
    class SocketAddress extends GObject.Object {
        // Own properties of Gio-2.0.Gio.SocketAddress

        static name: string;
        static $gtype: GObject.GType<SocketAddress>;

        // Constructors of Gio-2.0.Gio.SocketAddress

        constructor(config?: SocketAddress.ConstructorProperties);
        /**
         * Creates a #GSocketAddress subclass corresponding to the native
         * struct sockaddr `native`.
         * @constructor
         * @param native a pointer to a struct sockaddr
         * @param len the size of the memory location pointed to by `native`
         * @returns a new #GSocketAddress if @native could successfully     be converted, otherwise %NULL
         */
        static new_from_native(native: any, len: number): SocketAddress;
        _init(config?: SocketAddress.ConstructorProperties): void;
    }

    namespace SocketAddressEnumerator {
        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface SocketAddressEnumerator {
        // Owm methods of Gio-2.0.Gio.SocketAddressEnumerator

        /**
         * Retrieves the next #GSocketAddress from `enumerator`. Note that this
         * may block for some amount of time. (Eg, a #GNetworkAddress may need
         * to do a DNS lookup before it can return an address.) Use
         * g_socket_address_enumerator_next_async() if you need to avoid
         * blocking.
         *
         * If `enumerator` is expected to yield addresses, but for some reason
         * is unable to (eg, because of a DNS error), then the first call to
         * g_socket_address_enumerator_next() will return an appropriate error
         * in *`error`. However, if the first call to
         * g_socket_address_enumerator_next() succeeds, then any further
         * internal errors (other than `cancellable` being triggered) will be
         * ignored.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a #GSocketAddress (owned by the caller), or %NULL on     error (in which case *@error will be set) or if there are no     more addresses.
         */
        next(cancellable: Cancellable | null): SocketAddress | null;
        /**
         * Asynchronously retrieves the next #GSocketAddress from `enumerator`
         * and then calls `callback,` which must call
         * g_socket_address_enumerator_next_finish() to get the result.
         *
         * It is an error to call this multiple times before the previous callback has finished.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
         */
        next_async(
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of next_async

        /**
         * Promisified version of {@link next_async}
         *
         * Asynchronously retrieves the next #GSocketAddress from `enumerator`
         * and then calls `callback,` which must call
         * g_socket_address_enumerator_next_finish() to get the result.
         *
         * It is an error to call this multiple times before the previous callback has finished.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns A Promise of: a #GSocketAddress (owned by the caller), or %NULL on     error (in which case *@error will be set) or if there are no     more addresses.
         */
        next_async(
            cancellable: Cancellable | null
        ): globalThis.Promise<SocketAddress | null>;
        /**
         * Retrieves the result of a completed call to
         * g_socket_address_enumerator_next_async(). See
         * g_socket_address_enumerator_next() for more information about
         * error handling.
         * @param result a #GAsyncResult
         * @returns a #GSocketAddress (owned by the caller), or %NULL on     error (in which case *@error will be set) or if there are no     more addresses.
         */
        next_finish(result: AsyncResult): SocketAddress | null;

        // Own virtual methods of Gio-2.0.Gio.SocketAddressEnumerator

        /**
         * Retrieves the next #GSocketAddress from `enumerator`. Note that this
         * may block for some amount of time. (Eg, a #GNetworkAddress may need
         * to do a DNS lookup before it can return an address.) Use
         * g_socket_address_enumerator_next_async() if you need to avoid
         * blocking.
         *
         * If `enumerator` is expected to yield addresses, but for some reason
         * is unable to (eg, because of a DNS error), then the first call to
         * g_socket_address_enumerator_next() will return an appropriate error
         * in *`error`. However, if the first call to
         * g_socket_address_enumerator_next() succeeds, then any further
         * internal errors (other than `cancellable` being triggered) will be
         * ignored.
         * @virtual
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a #GSocketAddress (owned by the caller), or %NULL on     error (in which case *@error will be set) or if there are no     more addresses.
         */
        vfunc_next(cancellable: Cancellable | null): SocketAddress | null;
        /**
         * Asynchronously retrieves the next #GSocketAddress from `enumerator`
         * and then calls `callback,` which must call
         * g_socket_address_enumerator_next_finish() to get the result.
         *
         * It is an error to call this multiple times before the previous callback has finished.
         * @virtual
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
         */
        vfunc_next_async(
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Retrieves the result of a completed call to
         * g_socket_address_enumerator_next_async(). See
         * g_socket_address_enumerator_next() for more information about
         * error handling.
         * @virtual
         * @param result a #GAsyncResult
         * @returns a #GSocketAddress (owned by the caller), or %NULL on     error (in which case *@error will be set) or if there are no     more addresses.
         */
        vfunc_next_finish(result: AsyncResult): SocketAddress | null;

        // Class property signals of Gio-2.0.Gio.SocketAddressEnumerator

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GSocketAddressEnumerator is an enumerator type for #GSocketAddress
     * instances. It is returned by enumeration functions such as
     * g_socket_connectable_enumerate(), which returns a #GSocketAddressEnumerator
     * to list each #GSocketAddress which could be used to connect to that
     * #GSocketConnectable.
     *
     * Enumeration is typically a blocking operation, so the asynchronous methods
     * g_socket_address_enumerator_next_async() and
     * g_socket_address_enumerator_next_finish() should be used where possible.
     *
     * Each #GSocketAddressEnumerator can only be enumerated once. Once
     * g_socket_address_enumerator_next() has returned %NULL, further
     * enumeration with that #GSocketAddressEnumerator is not possible, and it can
     * be unreffed.
     * @class
     */
    class SocketAddressEnumerator extends GObject.Object {
        // Own properties of Gio-2.0.Gio.SocketAddressEnumerator

        static name: string;
        static $gtype: GObject.GType<SocketAddressEnumerator>;

        // Constructors of Gio-2.0.Gio.SocketAddressEnumerator

        constructor(config?: SocketAddressEnumerator.ConstructorProperties);
        _init(config?: SocketAddressEnumerator.ConstructorProperties): void;
    }

    namespace SocketClient {
        // Signal callback interfaces

        /**
         * Signal callback interface for `event`
         */
        interface EventSignalCallback {
            (
                $obj: SocketClient,
                event: SocketClientEvent,
                connectable: SocketConnectable,
                connection: IOStream | null
            ): void;
        }

        // Constructor properties interface

        interface ConstructorProperties
            extends GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.SocketClient

            enable_proxy?: boolean | null;
            family?: SocketFamily | null;
            local_address?: SocketAddress | null;
            protocol?: SocketProtocol | null;
            /**
             * The proxy resolver to use
             */
            proxy_resolver?: ProxyResolver | null;
            timeout?: number | null;
            tls?: boolean | null;
            /**
             * The TLS validation flags used when creating TLS connections. The
             * default value is %G_TLS_CERTIFICATE_VALIDATE_ALL.
             *
             * GLib guarantees that if certificate verification fails, at least one
             * flag will be set, but it does not guarantee that all possible flags
             * will be set. Accordingly, you may not safely decide to ignore any
             * particular type of error. For example, it would be incorrect to mask
             * %G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates,
             * because this could potentially be the only error flag set even if
             * other problems exist with the certificate. Therefore, there is no
             * safe way to use this property. This is not a horrible problem,
             * though, because you should not be attempting to ignore validation
             * errors anyway. If you really must ignore TLS certificate errors,
             * connect to the #GSocketClient::event signal, wait for it to be
             * emitted with %G_SOCKET_CLIENT_TLS_HANDSHAKING, and use that to
             * connect to #GTlsConnection::accept-certificate.
             */
            tls_validation_flags?: TlsCertificateFlags | null;
            type?: SocketType | null;
        }
    }

    interface SocketClient {
        // Own properties of Gio-2.0.Gio.SocketClient

        enable_proxy: boolean;
        family: SocketFamily;
        local_address: SocketAddress;
        protocol: SocketProtocol;
        /**
         * The proxy resolver to use
         */
        proxy_resolver: ProxyResolver;
        timeout: number;
        tls: boolean;
        /**
         * The TLS validation flags used when creating TLS connections. The
         * default value is %G_TLS_CERTIFICATE_VALIDATE_ALL.
         *
         * GLib guarantees that if certificate verification fails, at least one
         * flag will be set, but it does not guarantee that all possible flags
         * will be set. Accordingly, you may not safely decide to ignore any
         * particular type of error. For example, it would be incorrect to mask
         * %G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates,
         * because this could potentially be the only error flag set even if
         * other problems exist with the certificate. Therefore, there is no
         * safe way to use this property. This is not a horrible problem,
         * though, because you should not be attempting to ignore validation
         * errors anyway. If you really must ignore TLS certificate errors,
         * connect to the #GSocketClient::event signal, wait for it to be
         * emitted with %G_SOCKET_CLIENT_TLS_HANDSHAKING, and use that to
         * connect to #GTlsConnection::accept-certificate.
         */
        tls_validation_flags: TlsCertificateFlags;
        type: SocketType;

        // Own fields of Gio-2.0.Gio.SocketClient

        parent_instance: GObject.Object;
        priv: SocketClientPrivate;

        // Owm methods of Gio-2.0.Gio.SocketClient

        /**
         * Enable proxy protocols to be handled by the application. When the
         * indicated proxy protocol is returned by the #GProxyResolver,
         * #GSocketClient will consider this protocol as supported but will
         * not try to find a #GProxy instance to handle handshaking. The
         * application must check for this case by calling
         * g_socket_connection_get_remote_address() on the returned
         * #GSocketConnection, and seeing if it's a #GProxyAddress of the
         * appropriate type, to determine whether or not it needs to handle
         * the proxy handshaking itself.
         *
         * This should be used for proxy protocols that are dialects of
         * another protocol such as HTTP proxy. It also allows cohabitation of
         * proxy protocols that are reused between protocols. A good example
         * is HTTP. It can be used to proxy HTTP, FTP and Gopher and can also
         * be use as generic socket proxy through the HTTP CONNECT method.
         *
         * When the proxy is detected as being an application proxy, TLS handshake
         * will be skipped. This is required to let the application do the proxy
         * specific handshake.
         * @param protocol The proxy protocol
         */
        add_application_proxy(protocol: string | null): void;
        /**
         * Tries to resolve the `connectable` and make a network connection to it.
         *
         * Upon a successful connection, a new #GSocketConnection is constructed
         * and returned.  The caller owns this new object and must drop their
         * reference to it when finished with it.
         *
         * The type of the #GSocketConnection object returned depends on the type of
         * the underlying socket that is used. For instance, for a TCP/IP connection
         * it will be a #GTcpConnection.
         *
         * The socket created will be the same family as the address that the
         * `connectable` resolves to, unless family is set with g_socket_client_set_family()
         * or indirectly via g_socket_client_set_local_address(). The socket type
         * defaults to %G_SOCKET_TYPE_STREAM but can be set with
         * g_socket_client_set_socket_type().
         *
         * If a local address is specified with g_socket_client_set_local_address() the
         * socket will be bound to this address before connecting.
         * @param connectable a #GSocketConnectable specifying the remote address.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a #GSocketConnection on success, %NULL on error.
         */
        connect(
            connectable: SocketConnectable,
            cancellable: Cancellable | null
        ): SocketConnection;
        /**
         * This is the asynchronous version of g_socket_client_connect().
         *
         * You may wish to prefer the asynchronous version even in synchronous
         * command line programs because, since 2.60, it implements
         * [RFC 8305](https://tools.ietf.org/html/rfc8305) "Happy Eyeballs"
         * recommendations to work around long connection timeouts in networks
         * where IPv6 is broken by performing an IPv4 connection simultaneously
         * without waiting for IPv6 to time out, which is not supported by the
         * synchronous call. (This is not an API guarantee, and may change in
         * the future.)
         *
         * When the operation is finished `callback` will be
         * called. You can then call g_socket_client_connect_finish() to get
         * the result of the operation.
         * @param connectable a #GSocketConnectable specifying the remote address.
         * @param cancellable a #GCancellable, or %NULL
         * @param callback a #GAsyncReadyCallback
         */
        connect_async(
            connectable: SocketConnectable,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of connect_async

        /**
         * Promisified version of {@link connect_async}
         *
         * This is the asynchronous version of g_socket_client_connect().
         *
         * You may wish to prefer the asynchronous version even in synchronous
         * command line programs because, since 2.60, it implements
         * [RFC 8305](https://tools.ietf.org/html/rfc8305) "Happy Eyeballs"
         * recommendations to work around long connection timeouts in networks
         * where IPv6 is broken by performing an IPv4 connection simultaneously
         * without waiting for IPv6 to time out, which is not supported by the
         * synchronous call. (This is not an API guarantee, and may change in
         * the future.)
         *
         * When the operation is finished `callback` will be
         * called. You can then call g_socket_client_connect_finish() to get
         * the result of the operation.
         * @param connectable a #GSocketConnectable specifying the remote address.
         * @param cancellable a #GCancellable, or %NULL
         * @returns A Promise of: a #GSocketConnection on success, %NULL on error.
         */
        connect_async(
            connectable: SocketConnectable,
            cancellable: Cancellable | null
        ): globalThis.Promise<SocketConnection>;
        /**
         * Finishes an async connect operation. See g_socket_client_connect_async()
         * @param result a #GAsyncResult.
         * @returns a #GSocketConnection on success, %NULL on error.
         */
        connect_finish(result: AsyncResult): SocketConnection;
        /**
         * This is a helper function for g_socket_client_connect().
         *
         * Attempts to create a TCP connection to the named host.
         *
         * `host_and_port` may be in any of a number of recognized formats; an IPv6
         * address, an IPv4 address, or a domain name (in which case a DNS
         * lookup is performed).  Quoting with [] is supported for all address
         * types.  A port override may be specified in the usual way with a
         * colon.  Ports may be given as decimal numbers or symbolic names (in
         * which case an /etc/services lookup is performed).
         *
         * If no port override is given in `host_and_port` then `default_port` will be
         * used as the port number to connect to.
         *
         * In general, `host_and_port` is expected to be provided by the user (allowing
         * them to give the hostname, and a port override if necessary) and
         * `default_port` is expected to be provided by the application.
         *
         * In the case that an IP address is given, a single connection
         * attempt is made.  In the case that a name is given, multiple
         * connection attempts may be made, in turn and according to the
         * number of address records in DNS, until a connection succeeds.
         *
         * Upon a successful connection, a new #GSocketConnection is constructed
         * and returned.  The caller owns this new object and must drop their
         * reference to it when finished with it.
         *
         * In the event of any failure (DNS error, service not found, no hosts
         * connectable) %NULL is returned and `error` (if non-%NULL) is set
         * accordingly.
         * @param host_and_port the name and optionally port of the host to connect to
         * @param default_port the default port to connect to
         * @param cancellable a #GCancellable, or %NULL
         * @returns a #GSocketConnection on success, %NULL on error.
         */
        connect_to_host(
            host_and_port: string | null,
            default_port: number,
            cancellable: Cancellable | null
        ): SocketConnection;
        /**
         * This is the asynchronous version of g_socket_client_connect_to_host().
         *
         * When the operation is finished `callback` will be
         * called. You can then call g_socket_client_connect_to_host_finish() to get
         * the result of the operation.
         * @param host_and_port the name and optionally the port of the host to connect to
         * @param default_port the default port to connect to
         * @param cancellable a #GCancellable, or %NULL
         * @param callback a #GAsyncReadyCallback
         */
        connect_to_host_async(
            host_and_port: string | null,
            default_port: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of connect_to_host_async

        /**
         * Promisified version of {@link connect_to_host_async}
         *
         * This is the asynchronous version of g_socket_client_connect_to_host().
         *
         * When the operation is finished `callback` will be
         * called. You can then call g_socket_client_connect_to_host_finish() to get
         * the result of the operation.
         * @param host_and_port the name and optionally the port of the host to connect to
         * @param default_port the default port to connect to
         * @param cancellable a #GCancellable, or %NULL
         * @returns A Promise of: a #GSocketConnection on success, %NULL on error.
         */
        connect_to_host_async(
            host_and_port: string | null,
            default_port: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<SocketConnection>;
        /**
         * Finishes an async connect operation. See g_socket_client_connect_to_host_async()
         * @param result a #GAsyncResult.
         * @returns a #GSocketConnection on success, %NULL on error.
         */
        connect_to_host_finish(result: AsyncResult): SocketConnection;
        /**
         * Attempts to create a TCP connection to a service.
         *
         * This call looks up the SRV record for `service` at `domain` for the
         * "tcp" protocol.  It then attempts to connect, in turn, to each of
         * the hosts providing the service until either a connection succeeds
         * or there are no hosts remaining.
         *
         * Upon a successful connection, a new #GSocketConnection is constructed
         * and returned.  The caller owns this new object and must drop their
         * reference to it when finished with it.
         *
         * In the event of any failure (DNS error, service not found, no hosts
         * connectable) %NULL is returned and `error` (if non-%NULL) is set
         * accordingly.
         * @param domain a domain name
         * @param service the name of the service to connect to
         * @param cancellable a #GCancellable, or %NULL
         * @returns a #GSocketConnection if successful, or %NULL on error
         */
        connect_to_service(
            domain: string | null,
            service: string | null,
            cancellable: Cancellable | null
        ): SocketConnection;
        /**
         * This is the asynchronous version of
         * g_socket_client_connect_to_service().
         * @param domain a domain name
         * @param service the name of the service to connect to
         * @param cancellable a #GCancellable, or %NULL
         * @param callback a #GAsyncReadyCallback
         */
        connect_to_service_async(
            domain: string | null,
            service: string | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of connect_to_service_async

        /**
         * Promisified version of {@link connect_to_service_async}
         *
         * This is the asynchronous version of
         * g_socket_client_connect_to_service().
         * @param domain a domain name
         * @param service the name of the service to connect to
         * @param cancellable a #GCancellable, or %NULL
         * @returns A Promise of: a #GSocketConnection on success, %NULL on error.
         */
        connect_to_service_async(
            domain: string | null,
            service: string | null,
            cancellable: Cancellable | null
        ): globalThis.Promise<SocketConnection>;
        /**
         * Finishes an async connect operation. See g_socket_client_connect_to_service_async()
         * @param result a #GAsyncResult.
         * @returns a #GSocketConnection on success, %NULL on error.
         */
        connect_to_service_finish(result: AsyncResult): SocketConnection;
        /**
         * This is a helper function for g_socket_client_connect().
         *
         * Attempts to create a TCP connection with a network URI.
         *
         * `uri` may be any valid URI containing an "authority" (hostname/port)
         * component. If a port is not specified in the URI, `default_port`
         * will be used. TLS will be negotiated if #GSocketClient:tls is %TRUE.
         * (#GSocketClient does not know to automatically assume TLS for
         * certain URI schemes.)
         *
         * Using this rather than g_socket_client_connect() or
         * g_socket_client_connect_to_host() allows #GSocketClient to
         * determine when to use application-specific proxy protocols.
         *
         * Upon a successful connection, a new #GSocketConnection is constructed
         * and returned.  The caller owns this new object and must drop their
         * reference to it when finished with it.
         *
         * In the event of any failure (DNS error, service not found, no hosts
         * connectable) %NULL is returned and `error` (if non-%NULL) is set
         * accordingly.
         * @param uri A network URI
         * @param default_port the default port to connect to
         * @param cancellable a #GCancellable, or %NULL
         * @returns a #GSocketConnection on success, %NULL on error.
         */
        connect_to_uri(
            uri: string | null,
            default_port: number,
            cancellable: Cancellable | null
        ): SocketConnection;
        /**
         * This is the asynchronous version of g_socket_client_connect_to_uri().
         *
         * When the operation is finished `callback` will be
         * called. You can then call g_socket_client_connect_to_uri_finish() to get
         * the result of the operation.
         * @param uri a network uri
         * @param default_port the default port to connect to
         * @param cancellable a #GCancellable, or %NULL
         * @param callback a #GAsyncReadyCallback
         */
        connect_to_uri_async(
            uri: string | null,
            default_port: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of connect_to_uri_async

        /**
         * Promisified version of {@link connect_to_uri_async}
         *
         * This is the asynchronous version of g_socket_client_connect_to_uri().
         *
         * When the operation is finished `callback` will be
         * called. You can then call g_socket_client_connect_to_uri_finish() to get
         * the result of the operation.
         * @param uri a network uri
         * @param default_port the default port to connect to
         * @param cancellable a #GCancellable, or %NULL
         * @returns A Promise of: a #GSocketConnection on success, %NULL on error.
         */
        connect_to_uri_async(
            uri: string | null,
            default_port: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<SocketConnection>;
        /**
         * Finishes an async connect operation. See g_socket_client_connect_to_uri_async()
         * @param result a #GAsyncResult.
         * @returns a #GSocketConnection on success, %NULL on error.
         */
        connect_to_uri_finish(result: AsyncResult): SocketConnection;
        /**
         * Gets the proxy enable state; see g_socket_client_set_enable_proxy()
         * @returns whether proxying is enabled
         */
        get_enable_proxy(): boolean;
        /**
         * Gets the socket family of the socket client.
         *
         * See g_socket_client_set_family() for details.
         * @returns a #GSocketFamily
         */
        get_family(): SocketFamily;
        /**
         * Gets the local address of the socket client.
         *
         * See g_socket_client_set_local_address() for details.
         * @returns a #GSocketAddress or %NULL. Do not free.
         */
        get_local_address(): SocketAddress | null;
        /**
         * Gets the protocol name type of the socket client.
         *
         * See g_socket_client_set_protocol() for details.
         * @returns a #GSocketProtocol
         */
        get_protocol(): SocketProtocol;
        /**
         * Gets the #GProxyResolver being used by `client`. Normally, this will
         * be the resolver returned by g_proxy_resolver_get_default(), but you
         * can override it with g_socket_client_set_proxy_resolver().
         * @returns The #GProxyResolver being used by   @client.
         */
        get_proxy_resolver(): ProxyResolver;
        /**
         * Gets the socket type of the socket client.
         *
         * See g_socket_client_set_socket_type() for details.
         * @returns a #GSocketFamily
         */
        get_socket_type(): SocketType;
        /**
         * Gets the I/O timeout time for sockets created by `client`.
         *
         * See g_socket_client_set_timeout() for details.
         * @returns the timeout in seconds
         */
        get_timeout(): number;
        /**
         * Gets whether `client` creates TLS connections. See
         * g_socket_client_set_tls() for details.
         * @returns whether @client uses TLS
         */
        get_tls(): boolean;
        /**
         * Gets the TLS validation flags used creating TLS connections via
         * `client`.
         *
         * This function does not work as originally designed and is impossible
         * to use correctly. See #GSocketClient:tls-validation-flags for more
         * information.
         * @returns the TLS validation flags
         */
        get_tls_validation_flags(): TlsCertificateFlags;
        /**
         * Sets whether or not `client` attempts to make connections via a
         * proxy server. When enabled (the default), #GSocketClient will use a
         * #GProxyResolver to determine if a proxy protocol such as SOCKS is
         * needed, and automatically do the necessary proxy negotiation.
         *
         * See also g_socket_client_set_proxy_resolver().
         * @param enable whether to enable proxies
         */
        set_enable_proxy(enable: boolean): void;
        /**
         * Sets the socket family of the socket client.
         * If this is set to something other than %G_SOCKET_FAMILY_INVALID
         * then the sockets created by this object will be of the specified
         * family.
         *
         * This might be useful for instance if you want to force the local
         * connection to be an ipv4 socket, even though the address might
         * be an ipv6 mapped to ipv4 address.
         * @param family a #GSocketFamily
         */
        set_family(family: SocketFamily): void;
        /**
         * Sets the local address of the socket client.
         * The sockets created by this object will bound to the
         * specified address (if not %NULL) before connecting.
         *
         * This is useful if you want to ensure that the local
         * side of the connection is on a specific port, or on
         * a specific interface.
         * @param address a #GSocketAddress, or %NULL
         */
        set_local_address(address: SocketAddress | null): void;
        /**
         * Sets the protocol of the socket client.
         * The sockets created by this object will use of the specified
         * protocol.
         *
         * If `protocol` is %G_SOCKET_PROTOCOL_DEFAULT that means to use the default
         * protocol for the socket family and type.
         * @param protocol a #GSocketProtocol
         */
        set_protocol(protocol: SocketProtocol): void;
        /**
         * Overrides the #GProxyResolver used by `client`. You can call this if
         * you want to use specific proxies, rather than using the system
         * default proxy settings.
         *
         * Note that whether or not the proxy resolver is actually used
         * depends on the setting of #GSocketClient:enable-proxy, which is not
         * changed by this function (but which is %TRUE by default)
         * @param proxy_resolver a #GProxyResolver, or %NULL for the   default.
         */
        set_proxy_resolver(proxy_resolver: ProxyResolver | null): void;
        /**
         * Sets the socket type of the socket client.
         * The sockets created by this object will be of the specified
         * type.
         *
         * It doesn't make sense to specify a type of %G_SOCKET_TYPE_DATAGRAM,
         * as GSocketClient is used for connection oriented services.
         * @param type a #GSocketType
         */
        set_socket_type(type: SocketType): void;
        /**
         * Sets the I/O timeout for sockets created by `client`. `timeout` is a
         * time in seconds, or 0 for no timeout (the default).
         *
         * The timeout value affects the initial connection attempt as well,
         * so setting this may cause calls to g_socket_client_connect(), etc,
         * to fail with %G_IO_ERROR_TIMED_OUT.
         * @param timeout the timeout
         */
        set_timeout(timeout: number): void;
        /**
         * Sets whether `client` creates TLS (aka SSL) connections. If `tls` is
         * %TRUE, `client` will wrap its connections in a #GTlsClientConnection
         * and perform a TLS handshake when connecting.
         *
         * Note that since #GSocketClient must return a #GSocketConnection,
         * but #GTlsClientConnection is not a #GSocketConnection, this
         * actually wraps the resulting #GTlsClientConnection in a
         * #GTcpWrapperConnection when returning it. You can use
         * g_tcp_wrapper_connection_get_base_io_stream() on the return value
         * to extract the #GTlsClientConnection.
         *
         * If you need to modify the behavior of the TLS handshake (eg, by
         * setting a client-side certificate to use, or connecting to the
         * #GTlsConnection::accept-certificate signal), you can connect to
         * `client'`s #GSocketClient::event signal and wait for it to be
         * emitted with %G_SOCKET_CLIENT_TLS_HANDSHAKING, which will give you
         * a chance to see the #GTlsClientConnection before the handshake
         * starts.
         * @param tls whether to use TLS
         */
        set_tls(tls: boolean): void;
        /**
         * Sets the TLS validation flags used when creating TLS connections
         * via `client`. The default value is %G_TLS_CERTIFICATE_VALIDATE_ALL.
         *
         * This function does not work as originally designed and is impossible
         * to use correctly. See #GSocketClient:tls-validation-flags for more
         * information.
         * @param flags the validation flags
         */
        set_tls_validation_flags(flags: TlsCertificateFlags): void;

        // Own virtual methods of Gio-2.0.Gio.SocketClient

        vfunc_event(
            event: SocketClientEvent,
            connectable: SocketConnectable,
            connection: IOStream
        ): void;

        // Own signals of Gio-2.0.Gio.SocketClient

        connect(
            sigName: 'event',
            callback: SocketClient.EventSignalCallback
        ): number;
        connect_after(
            sigName: 'event',
            callback: SocketClient.EventSignalCallback
        ): number;
        emit(
            sigName: 'event',
            event: SocketClientEvent,
            connectable: SocketConnectable,
            connection: IOStream | null,
            ...args: any[]
        ): void;

        // Class property signals of Gio-2.0.Gio.SocketClient

        connect(
            sigName: 'notify::enable-proxy',
            callback: ($obj: SocketClient, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::enable-proxy',
            callback: ($obj: SocketClient, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::enable-proxy', ...args: any[]): void;
        connect(
            sigName: 'notify::family',
            callback: ($obj: SocketClient, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::family',
            callback: ($obj: SocketClient, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::family', ...args: any[]): void;
        connect(
            sigName: 'notify::local-address',
            callback: ($obj: SocketClient, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::local-address',
            callback: ($obj: SocketClient, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::local-address', ...args: any[]): void;
        connect(
            sigName: 'notify::protocol',
            callback: ($obj: SocketClient, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::protocol',
            callback: ($obj: SocketClient, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::protocol', ...args: any[]): void;
        connect(
            sigName: 'notify::proxy-resolver',
            callback: ($obj: SocketClient, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::proxy-resolver',
            callback: ($obj: SocketClient, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::proxy-resolver', ...args: any[]): void;
        connect(
            sigName: 'notify::timeout',
            callback: ($obj: SocketClient, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::timeout',
            callback: ($obj: SocketClient, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::timeout', ...args: any[]): void;
        connect(
            sigName: 'notify::tls',
            callback: ($obj: SocketClient, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::tls',
            callback: ($obj: SocketClient, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::tls', ...args: any[]): void;
        connect(
            sigName: 'notify::tls-validation-flags',
            callback: ($obj: SocketClient, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::tls-validation-flags',
            callback: ($obj: SocketClient, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::tls-validation-flags', ...args: any[]): void;
        connect(
            sigName: 'notify::type',
            callback: ($obj: SocketClient, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::type',
            callback: ($obj: SocketClient, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::type', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GSocketClient is a lightweight high-level utility class for connecting to
     * a network host using a connection oriented socket type.
     *
     * You create a #GSocketClient object, set any options you want, and then
     * call a sync or async connect operation, which returns a #GSocketConnection
     * subclass on success.
     *
     * The type of the #GSocketConnection object returned depends on the type of
     * the underlying socket that is in use. For instance, for a TCP/IP connection
     * it will be a #GTcpConnection.
     *
     * As #GSocketClient is a lightweight object, you don't need to cache it. You
     * can just create a new one any time you need one.
     * @class
     */
    class SocketClient extends GObject.Object {
        // Own properties of Gio-2.0.Gio.SocketClient

        static name: string;
        static $gtype: GObject.GType<SocketClient>;

        // Constructors of Gio-2.0.Gio.SocketClient

        constructor(config?: SocketClient.ConstructorProperties);
        /**
         * Creates a new #GSocketClient with the default options.
         * @constructor
         * @returns a #GSocketClient.     Free the returned object with g_object_unref().
         */
        constructor();
        /**
         * Creates a new #GSocketClient with the default options.
         * @constructor
         * @returns a #GSocketClient.     Free the returned object with g_object_unref().
         */
        static new(): SocketClient;
        _init(config?: SocketClient.ConstructorProperties): void;
    }

    namespace SocketConnection {
        // Constructor properties interface

        interface ConstructorProperties extends IOStream.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.SocketConnection

            socket?: Socket | null;
        }
    }

    interface SocketConnection {
        // Own properties of Gio-2.0.Gio.SocketConnection

        readonly socket: Socket;

        // Own fields of Gio-2.0.Gio.SocketConnection

        parent_instance: IOStream & GObject.Object;
        priv: SocketConnectionPrivate;

        // Owm methods of Gio-2.0.Gio.SocketConnection

        /**
         * Connect `connection` to the specified remote address.
         * @param address a #GSocketAddress specifying the remote address.
         * @param cancellable a %GCancellable or %NULL
         * @returns %TRUE if the connection succeeded, %FALSE on error
         */
        connect(
            address: SocketAddress,
            cancellable: Cancellable | null
        ): boolean;
        /**
         * Asynchronously connect `connection` to the specified remote address.
         *
         * This clears the #GSocket:blocking flag on `connection'`s underlying
         * socket if it is currently set.
         *
         * Use g_socket_connection_connect_finish() to retrieve the result.
         * @param address a #GSocketAddress specifying the remote address.
         * @param cancellable a %GCancellable or %NULL
         * @param callback a #GAsyncReadyCallback
         */
        connect_async(
            address: SocketAddress,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of connect_async

        /**
         * Promisified version of {@link connect_async}
         *
         * Asynchronously connect `connection` to the specified remote address.
         *
         * This clears the #GSocket:blocking flag on `connection'`s underlying
         * socket if it is currently set.
         *
         * Use g_socket_connection_connect_finish() to retrieve the result.
         * @param address a #GSocketAddress specifying the remote address.
         * @param cancellable a %GCancellable or %NULL
         * @returns A Promise of: %TRUE if the connection succeeded, %FALSE on error
         */
        connect_async(
            address: SocketAddress,
            cancellable: Cancellable | null
        ): globalThis.Promise<boolean>;
        /**
         * Gets the result of a g_socket_connection_connect_async() call.
         * @param result the #GAsyncResult
         * @returns %TRUE if the connection succeeded, %FALSE on error
         */
        connect_finish(result: AsyncResult): boolean;
        /**
         * Try to get the local address of a socket connection.
         * @returns a #GSocketAddress or %NULL on error.     Free the returned object with g_object_unref().
         */
        get_local_address(): SocketAddress;
        /**
         * Try to get the remote address of a socket connection.
         *
         * Since GLib 2.40, when used with g_socket_client_connect() or
         * g_socket_client_connect_async(), during emission of
         * %G_SOCKET_CLIENT_CONNECTING, this function will return the remote
         * address that will be used for the connection.  This allows
         * applications to print e.g. "Connecting to example.com
         * (10.42.77.3)...".
         * @returns a #GSocketAddress or %NULL on error.     Free the returned object with g_object_unref().
         */
        get_remote_address(): SocketAddress;
        /**
         * Gets the underlying #GSocket object of the connection.
         * This can be useful if you want to do something unusual on it
         * not supported by the #GSocketConnection APIs.
         * @returns a #GSocket or %NULL on error.
         */
        get_socket(): Socket;
        /**
         * Checks if `connection` is connected. This is equivalent to calling
         * g_socket_is_connected() on `connection'`s underlying #GSocket.
         * @returns whether @connection is connected
         */
        is_connected(): boolean;

        // Class property signals of Gio-2.0.Gio.SocketConnection

        connect(
            sigName: 'notify::socket',
            callback: ($obj: SocketConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::socket',
            callback: ($obj: SocketConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::socket', ...args: any[]): void;
        connect(
            sigName: 'notify::closed',
            callback: ($obj: SocketConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::closed',
            callback: ($obj: SocketConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::closed', ...args: any[]): void;
        connect(
            sigName: 'notify::input-stream',
            callback: ($obj: SocketConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::input-stream',
            callback: ($obj: SocketConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::input-stream', ...args: any[]): void;
        connect(
            sigName: 'notify::output-stream',
            callback: ($obj: SocketConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::output-stream',
            callback: ($obj: SocketConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::output-stream', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GSocketConnection is a #GIOStream for a connected socket. They
     * can be created either by #GSocketClient when connecting to a host,
     * or by #GSocketListener when accepting a new client.
     *
     * The type of the #GSocketConnection object returned from these calls
     * depends on the type of the underlying socket that is in use. For
     * instance, for a TCP/IP connection it will be a #GTcpConnection.
     *
     * Choosing what type of object to construct is done with the socket
     * connection factory, and it is possible for 3rd parties to register
     * custom socket connection types for specific combination of socket
     * family/type/protocol using g_socket_connection_factory_register_type().
     *
     * To close a #GSocketConnection, use g_io_stream_close(). Closing both
     * substreams of the #GIOStream separately will not close the underlying
     * #GSocket.
     * @class
     */
    class SocketConnection extends IOStream {
        // Own properties of Gio-2.0.Gio.SocketConnection

        static name: string;
        static $gtype: GObject.GType<SocketConnection>;

        // Constructors of Gio-2.0.Gio.SocketConnection

        constructor(config?: SocketConnection.ConstructorProperties);
        _init(config?: SocketConnection.ConstructorProperties): void;
        /**
         * Looks up the #GType to be used when creating socket connections on
         * sockets with the specified `family,` `type` and `protocol_id`.
         *
         * If no type is registered, the #GSocketConnection base type is returned.
         * @param family a #GSocketFamily
         * @param type a #GSocketType
         * @param protocol_id a protocol id
         * @returns a #GType
         */
        static factory_lookup_type(
            family: SocketFamily,
            type: SocketType,
            protocol_id: number
        ): GObject.GType;
        /**
         * Looks up the #GType to be used when creating socket connections on
         * sockets with the specified `family,` `type` and `protocol`.
         *
         * If no type is registered, the #GSocketConnection base type is returned.
         * @param g_type a #GType, inheriting from %G_TYPE_SOCKET_CONNECTION
         * @param family a #GSocketFamily
         * @param type a #GSocketType
         * @param protocol a protocol id
         */
        static factory_register_type(
            g_type: GObject.GType,
            family: SocketFamily,
            type: SocketType,
            protocol: number
        ): void;
    }

    namespace SocketControlMessage {
        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface SocketControlMessage {
        // Own fields of Gio-2.0.Gio.SocketControlMessage

        parent_instance: GObject.Object;
        priv: SocketControlMessagePrivate;

        // Owm methods of Gio-2.0.Gio.SocketControlMessage

        /**
         * Returns the "level" (i.e. the originating protocol) of the control message.
         * This is often SOL_SOCKET.
         * @returns an integer describing the level
         */
        get_level(): number;
        /**
         * Returns the protocol specific type of the control message.
         * For instance, for UNIX fd passing this would be SCM_RIGHTS.
         * @returns an integer describing the type of control message
         */
        get_msg_type(): number;
        /**
         * Returns the space required for the control message, not including
         * headers or alignment.
         * @returns The number of bytes required.
         */
        get_size(): number;
        /**
         * Converts the data in the message to bytes placed in the
         * message.
         *
         * `data` is guaranteed to have enough space to fit the size
         * returned by g_socket_control_message_get_size() on this
         * object.
         * @param data A buffer to write data to
         */
        serialize(data: any): void;

        // Own virtual methods of Gio-2.0.Gio.SocketControlMessage

        /**
         * Returns the "level" (i.e. the originating protocol) of the control message.
         * This is often SOL_SOCKET.
         * @virtual
         * @returns an integer describing the level
         */
        vfunc_get_level(): number;
        /**
         * Returns the space required for the control message, not including
         * headers or alignment.
         * @virtual
         * @returns The number of bytes required.
         */
        vfunc_get_size(): number;
        vfunc_get_type(): number;
        /**
         * Converts the data in the message to bytes placed in the
         * message.
         *
         * `data` is guaranteed to have enough space to fit the size
         * returned by g_socket_control_message_get_size() on this
         * object.
         * @virtual
         * @param data A buffer to write data to
         */
        vfunc_serialize(data: any): void;

        // Class property signals of Gio-2.0.Gio.SocketControlMessage

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * A #GSocketControlMessage is a special-purpose utility message that
     * can be sent to or received from a #GSocket. These types of
     * messages are often called "ancillary data".
     *
     * The message can represent some sort of special instruction to or
     * information from the socket or can represent a special kind of
     * transfer to the peer (for example, sending a file descriptor over
     * a UNIX socket).
     *
     * These messages are sent with g_socket_send_message() and received
     * with g_socket_receive_message().
     *
     * To extend the set of control message that can be sent, subclass this
     * class and override the get_size, get_level, get_type and serialize
     * methods.
     *
     * To extend the set of control messages that can be received, subclass
     * this class and implement the deserialize method. Also, make sure your
     * class is registered with the GType typesystem before calling
     * g_socket_receive_message() to read such a message.
     * @class
     */
    class SocketControlMessage extends GObject.Object {
        // Own properties of Gio-2.0.Gio.SocketControlMessage

        static name: string;
        static $gtype: GObject.GType<SocketControlMessage>;

        // Constructors of Gio-2.0.Gio.SocketControlMessage

        constructor(config?: SocketControlMessage.ConstructorProperties);
        _init(config?: SocketControlMessage.ConstructorProperties): void;
        /**
         * Tries to deserialize a socket control message of a given
         * `level` and `type`. This will ask all known (to GType) subclasses
         * of #GSocketControlMessage if they can understand this kind
         * of message and if so deserialize it into a #GSocketControlMessage.
         *
         * If there is no implementation for this kind of control message, %NULL
         * will be returned.
         * @param level a socket level
         * @param type a socket control message type for the given `level`
         * @param data pointer to the message data
         * @returns the deserialized message or %NULL
         */
        static deserialize(
            level: number,
            type: number,
            data: Uint8Array
        ): SocketControlMessage | null;
    }

    namespace SocketListener {
        // Signal callback interfaces

        /**
         * Signal callback interface for `event`
         */
        interface EventSignalCallback {
            (
                $obj: SocketListener,
                event: SocketListenerEvent,
                socket: Socket
            ): void;
        }

        // Constructor properties interface

        interface ConstructorProperties
            extends GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.SocketListener

            listen_backlog?: number | null;
        }
    }

    interface SocketListener {
        // Own properties of Gio-2.0.Gio.SocketListener

        listen_backlog: number;

        // Own fields of Gio-2.0.Gio.SocketListener

        parent_instance: GObject.Object;
        priv: SocketListenerPrivate;

        // Owm methods of Gio-2.0.Gio.SocketListener

        /**
         * Blocks waiting for a client to connect to any of the sockets added
         * to the listener. Returns a #GSocketConnection for the socket that was
         * accepted.
         *
         * If `source_object` is not %NULL it will be filled out with the source
         * object specified when the corresponding socket or address was added
         * to the listener.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a #GSocketConnection on success, %NULL on error.
         */
        accept(
            cancellable: Cancellable | null
        ): [
            /* returnType */ SocketConnection,
            /* source_object */ GObject.Object | null
        ];
        /**
         * This is the asynchronous version of g_socket_listener_accept().
         *
         * When the operation is finished `callback` will be
         * called. You can then call g_socket_listener_accept_finish()
         * to get the result of the operation.
         * @param cancellable a #GCancellable, or %NULL
         * @param callback a #GAsyncReadyCallback
         */
        accept_async(
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of accept_async

        /**
         * Promisified version of {@link accept_async}
         *
         * This is the asynchronous version of g_socket_listener_accept().
         *
         * When the operation is finished `callback` will be
         * called. You can then call g_socket_listener_accept_finish()
         * to get the result of the operation.
         * @param cancellable a #GCancellable, or %NULL
         * @returns A Promise of: a #GSocketConnection on success, %NULL on error.
         */
        accept_async(
            cancellable: Cancellable | null
        ): globalThis.Promise</* source_object */ GObject.Object | null>;
        /**
         * Finishes an async accept operation. See g_socket_listener_accept_async()
         * @param result a #GAsyncResult.
         * @returns a #GSocketConnection on success, %NULL on error.
         */
        accept_finish(
            result: AsyncResult
        ): [
            /* returnType */ SocketConnection,
            /* source_object */ GObject.Object | null
        ];
        /**
         * Blocks waiting for a client to connect to any of the sockets added
         * to the listener. Returns the #GSocket that was accepted.
         *
         * If you want to accept the high-level #GSocketConnection, not a #GSocket,
         * which is often the case, then you should use g_socket_listener_accept()
         * instead.
         *
         * If `source_object` is not %NULL it will be filled out with the source
         * object specified when the corresponding socket or address was added
         * to the listener.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a #GSocket on success, %NULL on error.
         */
        accept_socket(
            cancellable: Cancellable | null
        ): [/* returnType */ Socket, /* source_object */ GObject.Object | null];
        /**
         * This is the asynchronous version of g_socket_listener_accept_socket().
         *
         * When the operation is finished `callback` will be
         * called. You can then call g_socket_listener_accept_socket_finish()
         * to get the result of the operation.
         * @param cancellable a #GCancellable, or %NULL
         * @param callback a #GAsyncReadyCallback
         */
        accept_socket_async(
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of accept_socket_async

        /**
         * Promisified version of {@link accept_socket_async}
         *
         * This is the asynchronous version of g_socket_listener_accept_socket().
         *
         * When the operation is finished `callback` will be
         * called. You can then call g_socket_listener_accept_socket_finish()
         * to get the result of the operation.
         * @param cancellable a #GCancellable, or %NULL
         * @returns A Promise of: a #GSocket on success, %NULL on error.
         */
        accept_socket_async(
            cancellable: Cancellable | null
        ): globalThis.Promise</* source_object */ GObject.Object | null>;
        /**
         * Finishes an async accept operation. See g_socket_listener_accept_socket_async()
         * @param result a #GAsyncResult.
         * @returns a #GSocket on success, %NULL on error.
         */
        accept_socket_finish(
            result: AsyncResult
        ): [/* returnType */ Socket, /* source_object */ GObject.Object | null];
        /**
         * Creates a socket of type `type` and protocol `protocol,` binds
         * it to `address` and adds it to the set of sockets we're accepting
         * sockets from.
         *
         * Note that adding an IPv6 address, depending on the platform,
         * may or may not result in a listener that also accepts IPv4
         * connections.  For more deterministic behavior, see
         * g_socket_listener_add_inet_port().
         *
         * `source_object` will be passed out in the various calls
         * to accept to identify this particular source, which is
         * useful if you're listening on multiple addresses and do
         * different things depending on what address is connected to.
         *
         * If successful and `effective_address` is non-%NULL then it will
         * be set to the address that the binding actually occurred at.  This
         * is helpful for determining the port number that was used for when
         * requesting a binding to port 0 (ie: "any port").  This address, if
         * requested, belongs to the caller and must be freed.
         *
         * Call g_socket_listener_close() to stop listening on `address;` this will not
         * be done automatically when you drop your final reference to `listener,` as
         * references may be held internally.
         * @param address a #GSocketAddress
         * @param type a #GSocketType
         * @param protocol a #GSocketProtocol
         * @param source_object Optional #GObject identifying this source
         * @returns %TRUE on success, %FALSE on error.
         */
        add_address(
            address: SocketAddress,
            type: SocketType,
            protocol: SocketProtocol,
            source_object: GObject.Object | null
        ): [/* returnType */ boolean, /* effective_address */ SocketAddress];
        /**
         * Listens for TCP connections on any available port number for both
         * IPv6 and IPv4 (if each is available).
         *
         * This is useful if you need to have a socket for incoming connections
         * but don't care about the specific port number.
         *
         * `source_object` will be passed out in the various calls
         * to accept to identify this particular source, which is
         * useful if you're listening on multiple addresses and do
         * different things depending on what address is connected to.
         * @param source_object Optional #GObject identifying this source
         * @returns the port number, or 0 in case of failure.
         */
        add_any_inet_port(source_object: GObject.Object | null): number;
        /**
         * Helper function for g_socket_listener_add_address() that
         * creates a TCP/IP socket listening on IPv4 and IPv6 (if
         * supported) on the specified port on all interfaces.
         *
         * `source_object` will be passed out in the various calls
         * to accept to identify this particular source, which is
         * useful if you're listening on multiple addresses and do
         * different things depending on what address is connected to.
         *
         * Call g_socket_listener_close() to stop listening on `port;` this will not
         * be done automatically when you drop your final reference to `listener,` as
         * references may be held internally.
         * @param port an IP port number (non-zero)
         * @param source_object Optional #GObject identifying this source
         * @returns %TRUE on success, %FALSE on error.
         */
        add_inet_port(
            port: number,
            source_object: GObject.Object | null
        ): boolean;
        /**
         * Adds `socket` to the set of sockets that we try to accept
         * new clients from. The socket must be bound to a local
         * address and listened to.
         *
         * `source_object` will be passed out in the various calls
         * to accept to identify this particular source, which is
         * useful if you're listening on multiple addresses and do
         * different things depending on what address is connected to.
         *
         * The `socket` will not be automatically closed when the `listener` is finalized
         * unless the listener held the final reference to the socket. Before GLib 2.42,
         * the `socket` was automatically closed on finalization of the `listener,` even
         * if references to it were held elsewhere.
         * @param socket a listening #GSocket
         * @param source_object Optional #GObject identifying this source
         * @returns %TRUE on success, %FALSE on error.
         */
        add_socket(
            socket: Socket,
            source_object: GObject.Object | null
        ): boolean;
        /**
         * Closes all the sockets in the listener.
         */
        close(): void;
        /**
         * Sets the listen backlog on the sockets in the listener. This must be called
         * before adding any sockets, addresses or ports to the #GSocketListener (for
         * example, by calling g_socket_listener_add_inet_port()) to be effective.
         *
         * See g_socket_set_listen_backlog() for details
         * @param listen_backlog an integer
         */
        set_backlog(listen_backlog: number): void;

        // Own virtual methods of Gio-2.0.Gio.SocketListener

        vfunc_changed(): void;
        vfunc_event(event: SocketListenerEvent, socket: Socket): void;

        // Own signals of Gio-2.0.Gio.SocketListener

        connect(
            sigName: 'event',
            callback: SocketListener.EventSignalCallback
        ): number;
        connect_after(
            sigName: 'event',
            callback: SocketListener.EventSignalCallback
        ): number;
        emit(
            sigName: 'event',
            event: SocketListenerEvent,
            socket: Socket,
            ...args: any[]
        ): void;

        // Class property signals of Gio-2.0.Gio.SocketListener

        connect(
            sigName: 'notify::listen-backlog',
            callback: ($obj: SocketListener, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::listen-backlog',
            callback: ($obj: SocketListener, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::listen-backlog', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * A #GSocketListener is an object that keeps track of a set
     * of server sockets and helps you accept sockets from any of the
     * socket, either sync or async.
     *
     * Add addresses and ports to listen on using g_socket_listener_add_address()
     * and g_socket_listener_add_inet_port(). These will be listened on until
     * g_socket_listener_close() is called. Dropping your final reference to the
     * #GSocketListener will not cause g_socket_listener_close() to be called
     * implicitly, as some references to the #GSocketListener may be held
     * internally.
     *
     * If you want to implement a network server, also look at #GSocketService
     * and #GThreadedSocketService which are subclasses of #GSocketListener
     * that make this even easier.
     * @class
     */
    class SocketListener extends GObject.Object {
        // Own properties of Gio-2.0.Gio.SocketListener

        static name: string;
        static $gtype: GObject.GType<SocketListener>;

        // Constructors of Gio-2.0.Gio.SocketListener

        constructor(config?: SocketListener.ConstructorProperties);
        /**
         * Creates a new #GSocketListener with no sockets to listen for.
         * New listeners can be added with e.g. g_socket_listener_add_address()
         * or g_socket_listener_add_inet_port().
         * @constructor
         * @returns a new #GSocketListener.
         */
        constructor();
        /**
         * Creates a new #GSocketListener with no sockets to listen for.
         * New listeners can be added with e.g. g_socket_listener_add_address()
         * or g_socket_listener_add_inet_port().
         * @constructor
         * @returns a new #GSocketListener.
         */
        static new(): SocketListener;
        _init(config?: SocketListener.ConstructorProperties): void;
    }

    namespace SocketService {
        // Signal callback interfaces

        /**
         * Signal callback interface for `incoming`
         */
        interface IncomingSignalCallback {
            (
                $obj: SocketService,
                connection: SocketConnection,
                source_object: GObject.Object | null
            ): boolean;
        }

        // Constructor properties interface

        interface ConstructorProperties
            extends SocketListener.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.SocketService

            /**
             * Whether the service is currently accepting connections.
             */
            active?: boolean | null;
        }
    }

    interface SocketService {
        // Own properties of Gio-2.0.Gio.SocketService

        /**
         * Whether the service is currently accepting connections.
         */
        active: boolean;

        // Own fields of Gio-2.0.Gio.SocketService

        parent_instance: SocketListener & GObject.Object;
        priv: any;

        // Owm methods of Gio-2.0.Gio.SocketService

        /**
         * Check whether the service is active or not. An active
         * service will accept new clients that connect, while
         * a non-active service will let connecting clients queue
         * up until the service is started.
         * @returns %TRUE if the service is active, %FALSE otherwise
         */
        is_active(): boolean;
        /**
         * Restarts the service, i.e. start accepting connections
         * from the added sockets when the mainloop runs. This only needs
         * to be called after the service has been stopped from
         * g_socket_service_stop().
         *
         * This call is thread-safe, so it may be called from a thread
         * handling an incoming client request.
         */
        start(): void;
        /**
         * Stops the service, i.e. stops accepting connections
         * from the added sockets when the mainloop runs.
         *
         * This call is thread-safe, so it may be called from a thread
         * handling an incoming client request.
         *
         * Note that this only stops accepting new connections; it does not
         * close the listening sockets, and you can call
         * g_socket_service_start() again later to begin listening again. To
         * close the listening sockets, call g_socket_listener_close(). (This
         * will happen automatically when the #GSocketService is finalized.)
         *
         * This must be called before calling g_socket_listener_close() as
         * the socket service will start accepting connections immediately
         * when a new socket is added.
         */
        stop(): void;

        // Own virtual methods of Gio-2.0.Gio.SocketService

        vfunc_incoming(
            connection: SocketConnection,
            source_object: GObject.Object
        ): boolean;

        // Own signals of Gio-2.0.Gio.SocketService

        connect(
            sigName: 'incoming',
            callback: SocketService.IncomingSignalCallback
        ): number;
        connect_after(
            sigName: 'incoming',
            callback: SocketService.IncomingSignalCallback
        ): number;
        emit(
            sigName: 'incoming',
            connection: SocketConnection,
            source_object: GObject.Object | null,
            ...args: any[]
        ): void;

        // Class property signals of Gio-2.0.Gio.SocketService

        connect(
            sigName: 'notify::active',
            callback: ($obj: SocketService, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::active',
            callback: ($obj: SocketService, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::active', ...args: any[]): void;
        connect(
            sigName: 'notify::listen-backlog',
            callback: ($obj: SocketService, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::listen-backlog',
            callback: ($obj: SocketService, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::listen-backlog', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * A #GSocketService is an object that represents a service that
     * is provided to the network or over local sockets.  When a new
     * connection is made to the service the #GSocketService::incoming
     * signal is emitted.
     *
     * A #GSocketService is a subclass of #GSocketListener and you need
     * to add the addresses you want to accept connections on with the
     * #GSocketListener APIs.
     *
     * There are two options for implementing a network service based on
     * #GSocketService. The first is to create the service using
     * g_socket_service_new() and to connect to the #GSocketService::incoming
     * signal. The second is to subclass #GSocketService and override the
     * default signal handler implementation.
     *
     * In either case, the handler must immediately return, or else it
     * will block additional incoming connections from being serviced.
     * If you are interested in writing connection handlers that contain
     * blocking code then see #GThreadedSocketService.
     *
     * The socket service runs on the main loop of the
     * [thread-default context][g-main-context-push-thread-default-context]
     * of the thread it is created in, and is not
     * threadsafe in general. However, the calls to start and stop the
     * service are thread-safe so these can be used from threads that
     * handle incoming clients.
     * @class
     */
    class SocketService extends SocketListener {
        // Own properties of Gio-2.0.Gio.SocketService

        static name: string;
        static $gtype: GObject.GType<SocketService>;

        // Constructors of Gio-2.0.Gio.SocketService

        constructor(config?: SocketService.ConstructorProperties);
        /**
         * Creates a new #GSocketService with no sockets to listen for.
         * New listeners can be added with e.g. g_socket_listener_add_address()
         * or g_socket_listener_add_inet_port().
         *
         * New services are created active, there is no need to call
         * g_socket_service_start(), unless g_socket_service_stop() has been
         * called before.
         * @constructor
         * @returns a new #GSocketService.
         */
        constructor();
        /**
         * Creates a new #GSocketService with no sockets to listen for.
         * New listeners can be added with e.g. g_socket_listener_add_address()
         * or g_socket_listener_add_inet_port().
         *
         * New services are created active, there is no need to call
         * g_socket_service_start(), unless g_socket_service_stop() has been
         * called before.
         * @constructor
         * @returns a new #GSocketService.
         */
        static new(): SocketService;

        // Overloads of new

        /**
         * Creates a new #GSocketListener with no sockets to listen for.
         * New listeners can be added with e.g. g_socket_listener_add_address()
         * or g_socket_listener_add_inet_port().
         * @constructor
         * @returns a new #GSocketListener.
         */
        static new(): SocketListener;
        _init(config?: SocketService.ConstructorProperties): void;
    }

    namespace Subprocess {
        // Constructor properties interface

        interface ConstructorProperties
            extends Initable.ConstructorProperties,
                GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.Subprocess

            argv?: string[] | null;
            flags?: SubprocessFlags | null;
        }
    }

    interface Subprocess extends Initable {
        // Own properties of Gio-2.0.Gio.Subprocess

        readonly argv: string[];
        readonly flags: SubprocessFlags;

        // Owm methods of Gio-2.0.Gio.Subprocess

        /**
         * Communicate with the subprocess until it terminates, and all input
         * and output has been completed.
         *
         * If `stdin_buf` is given, the subprocess must have been created with
         * %G_SUBPROCESS_FLAGS_STDIN_PIPE.  The given data is fed to the
         * stdin of the subprocess and the pipe is closed (ie: EOF).
         *
         * At the same time (as not to cause blocking when dealing with large
         * amounts of data), if %G_SUBPROCESS_FLAGS_STDOUT_PIPE or
         * %G_SUBPROCESS_FLAGS_STDERR_PIPE were used, reads from those
         * streams.  The data that was read is returned in `stdout` and/or
         * the `stderr`.
         *
         * If the subprocess was created with %G_SUBPROCESS_FLAGS_STDOUT_PIPE,
         * `stdout_buf` will contain the data read from stdout.  Otherwise, for
         * subprocesses not created with %G_SUBPROCESS_FLAGS_STDOUT_PIPE,
         * `stdout_buf` will be set to %NULL.  Similar provisions apply to
         * `stderr_buf` and %G_SUBPROCESS_FLAGS_STDERR_PIPE.
         *
         * As usual, any output variable may be given as %NULL to ignore it.
         *
         * If you desire the stdout and stderr data to be interleaved, create
         * the subprocess with %G_SUBPROCESS_FLAGS_STDOUT_PIPE and
         * %G_SUBPROCESS_FLAGS_STDERR_MERGE.  The merged result will be returned
         * in `stdout_buf` and `stderr_buf` will be set to %NULL.
         *
         * In case of any error (including cancellation), %FALSE will be
         * returned with `error` set.  Some or all of the stdin data may have
         * been written.  Any stdout or stderr data that has been read will be
         * discarded. None of the out variables (aside from `error)` will have
         * been set to anything in particular and should not be inspected.
         *
         * In the case that %TRUE is returned, the subprocess has exited and the
         * exit status inspection APIs (eg: g_subprocess_get_if_exited(),
         * g_subprocess_get_exit_status()) may be used.
         *
         * You should not attempt to use any of the subprocess pipes after
         * starting this function, since they may be left in strange states,
         * even if the operation was cancelled.  You should especially not
         * attempt to interact with the pipes while the operation is in progress
         * (either from another thread or if using the asynchronous version).
         * @param stdin_buf data to send to the stdin of the subprocess, or %NULL
         * @param cancellable a #GCancellable
         * @returns %TRUE if successful
         */
        communicate(
            stdin_buf: GLib.Bytes | null,
            cancellable: Cancellable | null
        ): [
            /* returnType */ boolean,
            /* stdout_buf */ GLib.Bytes | null,
            /* stderr_buf */ GLib.Bytes | null
        ];
        /**
         * Asynchronous version of g_subprocess_communicate().  Complete
         * invocation with g_subprocess_communicate_finish().
         * @param stdin_buf Input data, or %NULL
         * @param cancellable Cancellable
         * @param callback Callback
         */
        communicate_async(
            stdin_buf: GLib.Bytes | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of communicate_async

        /**
         * Promisified version of {@link communicate_async}
         *
         * Asynchronous version of g_subprocess_communicate().  Complete
         * invocation with g_subprocess_communicate_finish().
         * @param stdin_buf Input data, or %NULL
         * @param cancellable Cancellable
         * @returns A Promise of the result of {@link communicate_async}
         */
        communicate_async(
            stdin_buf: GLib.Bytes | null,
            cancellable: Cancellable | null
        ): globalThis.Promise<
            [
                /* stdout_buf */ GLib.Bytes | null,
                /* stderr_buf */ GLib.Bytes | null
            ]
        >;
        /**
         * Complete an invocation of g_subprocess_communicate_async().
         * @param result Result
         */
        communicate_finish(
            result: AsyncResult
        ): [
            /* returnType */ boolean,
            /* stdout_buf */ GLib.Bytes | null,
            /* stderr_buf */ GLib.Bytes | null
        ];
        /**
         * Like g_subprocess_communicate(), but validates the output of the
         * process as UTF-8, and returns it as a regular NUL terminated string.
         *
         * On error, `stdout_buf` and `stderr_buf` will be set to undefined values and
         * should not be used.
         * @param stdin_buf data to send to the stdin of the subprocess, or %NULL
         * @param cancellable a #GCancellable
         */
        communicate_utf8(
            stdin_buf: string | null,
            cancellable: Cancellable | null
        ): [
            /* returnType */ boolean,
            /* stdout_buf */ string | null,
            /* stderr_buf */ string | null
        ];
        /**
         * Asynchronous version of g_subprocess_communicate_utf8().  Complete
         * invocation with g_subprocess_communicate_utf8_finish().
         * @param stdin_buf Input data, or %NULL
         * @param cancellable Cancellable
         * @param callback Callback
         */
        communicate_utf8_async(
            stdin_buf: string | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of communicate_utf8_async

        /**
         * Promisified version of {@link communicate_utf8_async}
         *
         * Asynchronous version of g_subprocess_communicate_utf8().  Complete
         * invocation with g_subprocess_communicate_utf8_finish().
         * @param stdin_buf Input data, or %NULL
         * @param cancellable Cancellable
         * @returns A Promise of the result of {@link communicate_utf8_async}
         */
        communicate_utf8_async(
            stdin_buf: string | null,
            cancellable: Cancellable | null
        ): globalThis.Promise<
            [/* stdout_buf */ string | null, /* stderr_buf */ string | null]
        >;
        /**
         * Complete an invocation of g_subprocess_communicate_utf8_async().
         * @param result Result
         */
        communicate_utf8_finish(
            result: AsyncResult
        ): [
            /* returnType */ boolean,
            /* stdout_buf */ string | null,
            /* stderr_buf */ string | null
        ];
        /**
         * Use an operating-system specific method to attempt an immediate,
         * forceful termination of the process.  There is no mechanism to
         * determine whether or not the request itself was successful;
         * however, you can use g_subprocess_wait() to monitor the status of
         * the process after calling this function.
         *
         * On Unix, this function sends %SIGKILL.
         */
        force_exit(): void;
        /**
         * Check the exit status of the subprocess, given that it exited
         * normally.  This is the value passed to the exit() system call or the
         * return value from main.
         *
         * This is equivalent to the system WEXITSTATUS macro.
         *
         * It is an error to call this function before g_subprocess_wait() and
         * unless g_subprocess_get_if_exited() returned %TRUE.
         * @returns the exit status
         */
        get_exit_status(): number;
        /**
         * On UNIX, returns the process ID as a decimal string.
         * On Windows, returns the result of GetProcessId() also as a string.
         * If the subprocess has terminated, this will return %NULL.
         * @returns the subprocess identifier, or %NULL if the subprocess    has terminated
         */
        get_identifier(): string | null;
        /**
         * Check if the given subprocess exited normally (ie: by way of exit()
         * or return from main()).
         *
         * This is equivalent to the system WIFEXITED macro.
         *
         * It is an error to call this function before g_subprocess_wait() has
         * returned.
         * @returns %TRUE if the case of a normal exit
         */
        get_if_exited(): boolean;
        /**
         * Check if the given subprocess terminated in response to a signal.
         *
         * This is equivalent to the system WIFSIGNALED macro.
         *
         * It is an error to call this function before g_subprocess_wait() has
         * returned.
         * @returns %TRUE if the case of termination due to a signal
         */
        get_if_signaled(): boolean;
        /**
         * Gets the raw status code of the process, as from waitpid().
         *
         * This value has no particular meaning, but it can be used with the
         * macros defined by the system headers such as WIFEXITED.  It can also
         * be used with g_spawn_check_wait_status().
         *
         * It is more likely that you want to use g_subprocess_get_if_exited()
         * followed by g_subprocess_get_exit_status().
         *
         * It is an error to call this function before g_subprocess_wait() has
         * returned.
         * @returns the (meaningless) waitpid() exit status from the kernel
         */
        get_status(): number;
        /**
         * Gets the #GInputStream from which to read the stderr output of
         * `subprocess`.
         *
         * The process must have been created with %G_SUBPROCESS_FLAGS_STDERR_PIPE,
         * otherwise %NULL will be returned.
         * @returns the stderr pipe
         */
        get_stderr_pipe(): InputStream | null;
        /**
         * Gets the #GOutputStream that you can write to in order to give data
         * to the stdin of `subprocess`.
         *
         * The process must have been created with %G_SUBPROCESS_FLAGS_STDIN_PIPE and
         * not %G_SUBPROCESS_FLAGS_STDIN_INHERIT, otherwise %NULL will be returned.
         * @returns the stdout pipe
         */
        get_stdin_pipe(): OutputStream | null;
        /**
         * Gets the #GInputStream from which to read the stdout output of
         * `subprocess`.
         *
         * The process must have been created with %G_SUBPROCESS_FLAGS_STDOUT_PIPE,
         * otherwise %NULL will be returned.
         * @returns the stdout pipe
         */
        get_stdout_pipe(): InputStream | null;
        /**
         * Checks if the process was "successful".  A process is considered
         * successful if it exited cleanly with an exit status of 0, either by
         * way of the exit() system call or return from main().
         *
         * It is an error to call this function before g_subprocess_wait() has
         * returned.
         * @returns %TRUE if the process exited cleanly with a exit status of 0
         */
        get_successful(): boolean;
        /**
         * Get the signal number that caused the subprocess to terminate, given
         * that it terminated due to a signal.
         *
         * This is equivalent to the system WTERMSIG macro.
         *
         * It is an error to call this function before g_subprocess_wait() and
         * unless g_subprocess_get_if_signaled() returned %TRUE.
         * @returns the signal causing termination
         */
        get_term_sig(): number;
        /**
         * Sends the UNIX signal `signal_num` to the subprocess, if it is still
         * running.
         *
         * This API is race-free.  If the subprocess has terminated, it will not
         * be signalled.
         *
         * This API is not available on Windows.
         * @param signal_num the signal number to send
         */
        send_signal(signal_num: number): void;
        /**
         * Synchronously wait for the subprocess to terminate.
         *
         * After the process terminates you can query its exit status with
         * functions such as g_subprocess_get_if_exited() and
         * g_subprocess_get_exit_status().
         *
         * This function does not fail in the case of the subprocess having
         * abnormal termination.  See g_subprocess_wait_check() for that.
         *
         * Cancelling `cancellable` doesn't kill the subprocess.  Call
         * g_subprocess_force_exit() if it is desirable.
         * @param cancellable a #GCancellable
         * @returns %TRUE on success, %FALSE if @cancellable was cancelled
         */
        wait(cancellable: Cancellable | null): boolean;
        /**
         * Wait for the subprocess to terminate.
         *
         * This is the asynchronous version of g_subprocess_wait().
         * @param cancellable a #GCancellable, or %NULL
         * @param callback a #GAsyncReadyCallback to call when the operation is complete
         */
        wait_async(
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of wait_async

        /**
         * Promisified version of {@link wait_async}
         *
         * Wait for the subprocess to terminate.
         *
         * This is the asynchronous version of g_subprocess_wait().
         * @param cancellable a #GCancellable, or %NULL
         * @returns A Promise of: %TRUE if successful, or %FALSE with @error set
         */
        wait_async(
            cancellable: Cancellable | null
        ): globalThis.Promise<boolean>;
        /**
         * Combines g_subprocess_wait() with g_spawn_check_wait_status().
         * @param cancellable a #GCancellable
         * @returns %TRUE on success, %FALSE if process exited abnormally, or @cancellable was cancelled
         */
        wait_check(cancellable: Cancellable | null): boolean;
        /**
         * Combines g_subprocess_wait_async() with g_spawn_check_wait_status().
         *
         * This is the asynchronous version of g_subprocess_wait_check().
         * @param cancellable a #GCancellable, or %NULL
         * @param callback a #GAsyncReadyCallback to call when the operation is complete
         */
        wait_check_async(
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of wait_check_async

        /**
         * Promisified version of {@link wait_check_async}
         *
         * Combines g_subprocess_wait_async() with g_spawn_check_wait_status().
         *
         * This is the asynchronous version of g_subprocess_wait_check().
         * @param cancellable a #GCancellable, or %NULL
         * @returns A Promise of: %TRUE if successful, or %FALSE with @error set
         */
        wait_check_async(
            cancellable: Cancellable | null
        ): globalThis.Promise<boolean>;
        /**
         * Collects the result of a previous call to
         * g_subprocess_wait_check_async().
         * @param result the #GAsyncResult passed to your #GAsyncReadyCallback
         * @returns %TRUE if successful, or %FALSE with @error set
         */
        wait_check_finish(result: AsyncResult): boolean;
        /**
         * Collects the result of a previous call to
         * g_subprocess_wait_async().
         * @param result the #GAsyncResult passed to your #GAsyncReadyCallback
         * @returns %TRUE if successful, or %FALSE with @error set
         */
        wait_finish(result: AsyncResult): boolean;

        // Class property signals of Gio-2.0.Gio.Subprocess

        connect(
            sigName: 'notify::argv',
            callback: ($obj: Subprocess, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::argv',
            callback: ($obj: Subprocess, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::argv', ...args: any[]): void;
        connect(
            sigName: 'notify::flags',
            callback: ($obj: Subprocess, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::flags',
            callback: ($obj: Subprocess, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::flags', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GSubprocess allows the creation of and interaction with child
     * processes.
     *
     * Processes can be communicated with using standard GIO-style APIs (ie:
     * #GInputStream, #GOutputStream).  There are GIO-style APIs to wait for
     * process termination (ie: cancellable and with an asynchronous
     * variant).
     *
     * There is an API to force a process to terminate, as well as a
     * race-free API for sending UNIX signals to a subprocess.
     *
     * One major advantage that GIO brings over the core GLib library is
     * comprehensive API for asynchronous I/O, such
     * g_output_stream_splice_async().  This makes GSubprocess
     * significantly more powerful and flexible than equivalent APIs in
     * some other languages such as the `subprocess.py`
     * included with Python.  For example, using #GSubprocess one could
     * create two child processes, reading standard output from the first,
     * processing it, and writing to the input stream of the second, all
     * without blocking the main loop.
     *
     * A powerful g_subprocess_communicate() API is provided similar to the
     * `communicate()` method of `subprocess.py`. This enables very easy
     * interaction with a subprocess that has been opened with pipes.
     *
     * #GSubprocess defaults to tight control over the file descriptors open
     * in the child process, avoiding dangling-fd issues that are caused by
     * a simple fork()/exec().  The only open file descriptors in the
     * spawned process are ones that were explicitly specified by the
     * #GSubprocess API (unless %G_SUBPROCESS_FLAGS_INHERIT_FDS was
     * specified).
     *
     * #GSubprocess will quickly reap all child processes as they exit,
     * avoiding "zombie processes" remaining around for long periods of
     * time.  g_subprocess_wait() can be used to wait for this to happen,
     * but it will happen even without the call being explicitly made.
     *
     * As a matter of principle, #GSubprocess has no API that accepts
     * shell-style space-separated strings.  It will, however, match the
     * typical shell behaviour of searching the PATH for executables that do
     * not contain a directory separator in their name. By default, the `PATH`
     * of the current process is used.  You can specify
     * %G_SUBPROCESS_FLAGS_SEARCH_PATH_FROM_ENVP to use the `PATH` of the
     * launcher environment instead.
     *
     * #GSubprocess attempts to have a very simple API for most uses (ie:
     * spawning a subprocess with arguments and support for most typical
     * kinds of input and output redirection).  See g_subprocess_new(). The
     * #GSubprocessLauncher API is provided for more complicated cases
     * (advanced types of redirection, environment variable manipulation,
     * change of working directory, child setup functions, etc).
     *
     * A typical use of #GSubprocess will involve calling
     * g_subprocess_new(), followed by g_subprocess_wait_async() or
     * g_subprocess_wait().  After the process exits, the status can be
     * checked using functions such as g_subprocess_get_if_exited() (which
     * are similar to the familiar WIFEXITED-style POSIX macros).
     * @class
     */
    class Subprocess extends GObject.Object {
        // Own properties of Gio-2.0.Gio.Subprocess

        static name: string;
        static $gtype: GObject.GType<Subprocess>;

        // Constructors of Gio-2.0.Gio.Subprocess

        constructor(config?: Subprocess.ConstructorProperties);
        /**
         * Create a new process with the given flags and argument list.
         *
         * The argument list is expected to be %NULL-terminated.
         * @constructor
         * @param argv commandline arguments for the subprocess
         * @param flags flags that define the behaviour of the subprocess
         * @returns A newly created #GSubprocess, or %NULL on error (and @error   will be set)
         */
        constructor(argv: string[], flags: SubprocessFlags);
        /**
         * Create a new process with the given flags and argument list.
         *
         * The argument list is expected to be %NULL-terminated.
         * @constructor
         * @param argv commandline arguments for the subprocess
         * @param flags flags that define the behaviour of the subprocess
         * @returns A newly created #GSubprocess, or %NULL on error (and @error   will be set)
         */
        static new(argv: string[], flags: SubprocessFlags): Subprocess;
        _init(config?: Subprocess.ConstructorProperties): void;
    }

    namespace SubprocessLauncher {
        // Constructor properties interface

        interface ConstructorProperties
            extends GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.SubprocessLauncher

            flags?: SubprocessFlags | null;
        }
    }

    interface SubprocessLauncher {
        // Own properties of Gio-2.0.Gio.SubprocessLauncher

        readonly flags: SubprocessFlags;

        // Owm methods of Gio-2.0.Gio.SubprocessLauncher

        /**
         * Closes all the file descriptors previously passed to the object with
         * g_subprocess_launcher_take_fd(), g_subprocess_launcher_take_stderr_fd(), etc.
         *
         * After calling this method, any subsequent calls to g_subprocess_launcher_spawn() or g_subprocess_launcher_spawnv() will
         * return %G_IO_ERROR_CLOSED. This method is idempotent if
         * called more than once.
         *
         * This function is called automatically when the #GSubprocessLauncher
         * is disposed, but is provided separately so that garbage collected
         * language bindings can call it earlier to guarantee when FDs are closed.
         */
        close(): void;
        /**
         * Returns the value of the environment variable `variable` in the
         * environment of processes launched from this launcher.
         *
         * On UNIX, the returned string can be an arbitrary byte string.
         * On Windows, it will be UTF-8.
         * @param variable the environment variable to get
         * @returns the value of the environment variable,     %NULL if unset
         */
        getenv(variable: string): string | null;
        /**
         * Sets the current working directory that processes will be launched
         * with.
         *
         * By default processes are launched with the current working directory
         * of the launching process at the time of launch.
         * @param cwd the cwd for launched processes
         */
        set_cwd(cwd: string): void;
        /**
         * Replace the entire environment of processes launched from this
         * launcher with the given 'environ' variable.
         *
         * Typically you will build this variable by using g_listenv() to copy
         * the process 'environ' and using the functions g_environ_setenv(),
         * g_environ_unsetenv(), etc.
         *
         * As an alternative, you can use g_subprocess_launcher_setenv(),
         * g_subprocess_launcher_unsetenv(), etc.
         *
         * Pass an empty array to set an empty environment. Pass %NULL to inherit the
         * parent process environment. As of GLib 2.54, the parent process environment
         * will be copied when g_subprocess_launcher_set_environ() is called.
         * Previously, it was copied when the subprocess was executed. This means the
         * copied environment may now be modified (using g_subprocess_launcher_setenv(),
         * etc.) before launching the subprocess.
         *
         * On UNIX, all strings in this array can be arbitrary byte strings.
         * On Windows, they should be in UTF-8.
         * @param env      the replacement environment
         */
        set_environ(env: string[]): void;
        /**
         * Sets the flags on the launcher.
         *
         * The default flags are %G_SUBPROCESS_FLAGS_NONE.
         *
         * You may not set flags that specify conflicting options for how to
         * handle a particular stdio stream (eg: specifying both
         * %G_SUBPROCESS_FLAGS_STDIN_PIPE and
         * %G_SUBPROCESS_FLAGS_STDIN_INHERIT).
         *
         * You may also not set a flag that conflicts with a previous call to a
         * function like g_subprocess_launcher_set_stdin_file_path() or
         * g_subprocess_launcher_take_stdout_fd().
         * @param flags #GSubprocessFlags
         */
        set_flags(flags: SubprocessFlags): void;
        /**
         * Sets the file path to use as the stderr for spawned processes.
         *
         * If `path` is %NULL then any previously given path is unset.
         *
         * The file will be created or truncated when the process is spawned, as
         * would be the case if using '2>' at the shell.
         *
         * If you want to send both stdout and stderr to the same file then use
         * %G_SUBPROCESS_FLAGS_STDERR_MERGE.
         *
         * You may not set a stderr file path if a stderr fd is already set or
         * if the launcher flags contain any flags directing stderr elsewhere.
         *
         * This feature is only available on UNIX.
         * @param path a filename or %NULL
         */
        set_stderr_file_path(path: string | null): void;
        /**
         * Sets the file path to use as the stdin for spawned processes.
         *
         * If `path` is %NULL then any previously given path is unset.
         *
         * The file must exist or spawning the process will fail.
         *
         * You may not set a stdin file path if a stdin fd is already set or if
         * the launcher flags contain any flags directing stdin elsewhere.
         *
         * This feature is only available on UNIX.
         * @param path
         */
        set_stdin_file_path(path: string | null): void;
        /**
         * Sets the file path to use as the stdout for spawned processes.
         *
         * If `path` is %NULL then any previously given path is unset.
         *
         * The file will be created or truncated when the process is spawned, as
         * would be the case if using '>' at the shell.
         *
         * You may not set a stdout file path if a stdout fd is already set or
         * if the launcher flags contain any flags directing stdout elsewhere.
         *
         * This feature is only available on UNIX.
         * @param path a filename or %NULL
         */
        set_stdout_file_path(path: string | null): void;
        /**
         * Sets the environment variable `variable` in the environment of
         * processes launched from this launcher.
         *
         * On UNIX, both the variable's name and value can be arbitrary byte
         * strings, except that the variable's name cannot contain '='.
         * On Windows, they should be in UTF-8.
         * @param variable the environment variable to set,     must not contain '='
         * @param value the new value for the variable
         * @param overwrite whether to change the variable if it already exists
         */
        setenv(variable: string, value: string, overwrite: boolean): void;
        /**
         * Creates a #GSubprocess given a provided array of arguments.
         * @param argv Command line arguments
         * @returns A new #GSubprocess, or %NULL on error (and @error will be set)
         */
        spawnv(argv: string[]): Subprocess;
        /**
         * Transfer an arbitrary file descriptor from parent process to the
         * child.  This function takes ownership of the `source_fd;` it will be closed
         * in the parent when `self` is freed.
         *
         * By default, all file descriptors from the parent will be closed.
         * This function allows you to create (for example) a custom `pipe()` or
         * `socketpair()` before launching the process, and choose the target
         * descriptor in the child.
         *
         * An example use case is GNUPG, which has a command line argument
         * `--passphrase-fd` providing a file descriptor number where it expects
         * the passphrase to be written.
         * @param source_fd File descriptor in parent process
         * @param target_fd Target descriptor for child process
         */
        take_fd(source_fd: number, target_fd: number): void;
        /**
         * Sets the file descriptor to use as the stderr for spawned processes.
         *
         * If `fd` is -1 then any previously given fd is unset.
         *
         * Note that the default behaviour is to pass stderr through to the
         * stderr of the parent process.
         *
         * The passed `fd` belongs to the #GSubprocessLauncher.  It will be
         * automatically closed when the launcher is finalized.  The file
         * descriptor will also be closed on the child side when executing the
         * spawned process.
         *
         * You may not set a stderr fd if a stderr file path is already set or
         * if the launcher flags contain any flags directing stderr elsewhere.
         *
         * This feature is only available on UNIX.
         * @param fd a file descriptor, or -1
         */
        take_stderr_fd(fd: number): void;
        /**
         * Sets the file descriptor to use as the stdin for spawned processes.
         *
         * If `fd` is -1 then any previously given fd is unset.
         *
         * Note that if your intention is to have the stdin of the calling
         * process inherited by the child then %G_SUBPROCESS_FLAGS_STDIN_INHERIT
         * is a better way to go about doing that.
         *
         * The passed `fd` is noted but will not be touched in the current
         * process.  It is therefore necessary that it be kept open by the
         * caller until the subprocess is spawned.  The file descriptor will
         * also not be explicitly closed on the child side, so it must be marked
         * O_CLOEXEC if that's what you want.
         *
         * You may not set a stdin fd if a stdin file path is already set or if
         * the launcher flags contain any flags directing stdin elsewhere.
         *
         * This feature is only available on UNIX.
         * @param fd a file descriptor, or -1
         */
        take_stdin_fd(fd: number): void;
        /**
         * Sets the file descriptor to use as the stdout for spawned processes.
         *
         * If `fd` is -1 then any previously given fd is unset.
         *
         * Note that the default behaviour is to pass stdout through to the
         * stdout of the parent process.
         *
         * The passed `fd` is noted but will not be touched in the current
         * process.  It is therefore necessary that it be kept open by the
         * caller until the subprocess is spawned.  The file descriptor will
         * also not be explicitly closed on the child side, so it must be marked
         * O_CLOEXEC if that's what you want.
         *
         * You may not set a stdout fd if a stdout file path is already set or
         * if the launcher flags contain any flags directing stdout elsewhere.
         *
         * This feature is only available on UNIX.
         * @param fd a file descriptor, or -1
         */
        take_stdout_fd(fd: number): void;
        /**
         * Removes the environment variable `variable` from the environment of
         * processes launched from this launcher.
         *
         * On UNIX, the variable's name can be an arbitrary byte string not
         * containing '='. On Windows, it should be in UTF-8.
         * @param variable the environment variable to unset,     must not contain '='
         */
        unsetenv(variable: string): void;

        // Class property signals of Gio-2.0.Gio.SubprocessLauncher

        connect(
            sigName: 'notify::flags',
            callback: (
                $obj: SubprocessLauncher,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::flags',
            callback: (
                $obj: SubprocessLauncher,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::flags', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * This class contains a set of options for launching child processes,
     * such as where its standard input and output will be directed, the
     * argument list, the environment, and more.
     *
     * While the #GSubprocess class has high level functions covering
     * popular cases, use of this class allows access to more advanced
     * options.  It can also be used to launch multiple subprocesses with
     * a similar configuration.
     * @class
     */
    class SubprocessLauncher extends GObject.Object {
        // Own properties of Gio-2.0.Gio.SubprocessLauncher

        static name: string;
        static $gtype: GObject.GType<SubprocessLauncher>;

        // Constructors of Gio-2.0.Gio.SubprocessLauncher

        constructor(config?: SubprocessLauncher.ConstructorProperties);
        /**
         * Creates a new #GSubprocessLauncher.
         *
         * The launcher is created with the default options.  A copy of the
         * environment of the calling process is made at the time of this call
         * and will be used as the environment that the process is launched in.
         * @constructor
         * @param flags #GSubprocessFlags
         */
        constructor(flags: SubprocessFlags);
        /**
         * Creates a new #GSubprocessLauncher.
         *
         * The launcher is created with the default options.  A copy of the
         * environment of the calling process is made at the time of this call
         * and will be used as the environment that the process is launched in.
         * @constructor
         * @param flags #GSubprocessFlags
         */
        static new(flags: SubprocessFlags): SubprocessLauncher;
        _init(config?: SubprocessLauncher.ConstructorProperties): void;
    }

    namespace Task {
        // Constructor properties interface

        interface ConstructorProperties
            extends AsyncResult.ConstructorProperties,
                GObject.Object.ConstructorProperties {}
    }

    interface Task extends AsyncResult {
        // Own properties of Gio-2.0.Gio.Task

        /**
         * Whether the task has completed, meaning its callback (if set) has been
         * invoked. This can only happen after g_task_return_pointer(),
         * g_task_return_error() or one of the other return functions have been called
         * on the task.
         *
         * This property is guaranteed to change from %FALSE to %TRUE exactly once.
         *
         * The #GObject::notify signal for this change is emitted in the same main
         * context as the tasks callback, immediately after that callback is invoked.
         */
        readonly completed: boolean;

        // Owm methods of Gio-2.0.Gio.Task

        /**
         * Gets `task'`s #GCancellable
         * @returns @task's #GCancellable
         */
        get_cancellable(): Cancellable | null;
        /**
         * Gets `task'`s check-cancellable flag. See
         * g_task_set_check_cancellable() for more details.
         */
        get_check_cancellable(): boolean;
        /**
         * Gets the value of #GTask:completed. This changes from %FALSE to %TRUE after
         * the tasks callback is invoked, and will return %FALSE if called from inside
         * the callback.
         * @returns %TRUE if the task has completed, %FALSE otherwise.
         */
        get_completed(): boolean;
        /**
         * Gets the #GMainContext that `task` will return its result in (that
         * is, the context that was the
         * [thread-default main context][g-main-context-push-thread-default]
         * at the point when `task` was created).
         *
         * This will always return a non-%NULL value, even if the task's
         * context is the default #GMainContext.
         * @returns @task's #GMainContext
         */
        get_context(): GLib.MainContext;
        /**
         * Gets `task`s name. See g_task_set_name().
         * @returns @tasks name, or %NULL
         */
        get_name(): string | null;
        /**
         * Gets `task'`s priority
         * @returns @task's priority
         */
        get_priority(): number;
        /**
         * Gets `task'`s return-on-cancel flag. See
         * g_task_set_return_on_cancel() for more details.
         */
        get_return_on_cancel(): boolean;
        /**
         * Gets the source object from `task`. Like
         * g_async_result_get_source_object(), but does not ref the object.
         * @returns @task's source object, or %NULL
         */
        get_source_object(): GObject.Object | null;
        /**
         * Gets `task'`s source tag. See g_task_set_source_tag().
         * @returns @task's source tag
         */
        get_source_tag(): any | null;
        /**
         * Gets `task'`s `task_data`.
         * @returns @task's `task_data`.
         */
        get_task_data(): any | null;
        /**
         * Tests if `task` resulted in an error.
         * @returns %TRUE if the task resulted in an error, %FALSE otherwise.
         */
        had_error(): boolean;
        /**
         * Gets the result of `task` as a #gboolean.
         *
         * If the task resulted in an error, or was cancelled, then this will
         * instead return %FALSE and set `error`.
         *
         * Since this method transfers ownership of the return value (or
         * error) to the caller, you may only call it once.
         * @returns the task result, or %FALSE on error
         */
        propagate_boolean(): boolean;
        /**
         * Gets the result of `task` as an integer (#gssize).
         *
         * If the task resulted in an error, or was cancelled, then this will
         * instead return -1 and set `error`.
         *
         * Since this method transfers ownership of the return value (or
         * error) to the caller, you may only call it once.
         * @returns the task result, or -1 on error
         */
        propagate_int(): number;
        /**
         * Gets the result of `task` as a pointer, and transfers ownership
         * of that value to the caller.
         *
         * If the task resulted in an error, or was cancelled, then this will
         * instead return %NULL and set `error`.
         *
         * Since this method transfers ownership of the return value (or
         * error) to the caller, you may only call it once.
         * @returns the task result, or %NULL on error
         */
        propagate_pointer(): any | null;
        /**
         * Gets the result of `task` as a #GValue, and transfers ownership of
         * that value to the caller. As with g_task_return_value(), this is
         * a generic low-level method; g_task_propagate_pointer() and the like
         * will usually be more useful for C code.
         *
         * If the task resulted in an error, or was cancelled, then this will
         * instead set `error` and return %FALSE.
         *
         * Since this method transfers ownership of the return value (or
         * error) to the caller, you may only call it once.
         * @returns %TRUE if @task succeeded, %FALSE on error.
         */
        propagate_value(): [/* returnType */ boolean, /* value */ any];
        /**
         * Sets `task'`s result to `result` and completes the task (see
         * g_task_return_pointer() for more discussion of exactly what this
         * means).
         * @param result the #gboolean result of a task function.
         */
        return_boolean(result: boolean): void;
        /**
         * Sets `task'`s result to `error` (which `task` assumes ownership of)
         * and completes the task (see g_task_return_pointer() for more
         * discussion of exactly what this means).
         *
         * Note that since the task takes ownership of `error,` and since the
         * task may be completed before returning from g_task_return_error(),
         * you cannot assume that `error` is still valid after calling this.
         * Call g_error_copy() on the error if you need to keep a local copy
         * as well.
         *
         * See also g_task_return_new_error().
         * @param error the #GError result of a task function.
         */
        return_error(error: GLib.Error): void;
        /**
         * Checks if `task'`s #GCancellable has been cancelled, and if so, sets
         * `task'`s error accordingly and completes the task (see
         * g_task_return_pointer() for more discussion of exactly what this
         * means).
         * @returns %TRUE if @task has been cancelled, %FALSE if not
         */
        return_error_if_cancelled(): boolean;
        /**
         * Sets `task'`s result to `result` and completes the task (see
         * g_task_return_pointer() for more discussion of exactly what this
         * means).
         * @param result the integer (#gssize) result of a task function.
         */
        return_int(result: number): void;
        /**
         * Sets `task'`s result to `result` and completes the task. If `result`
         * is not %NULL, then `result_destroy` will be used to free `result` if
         * the caller does not take ownership of it with
         * g_task_propagate_pointer().
         *
         * "Completes the task" means that for an ordinary asynchronous task
         * it will either invoke the task's callback, or else queue that
         * callback to be invoked in the proper #GMainContext, or in the next
         * iteration of the current #GMainContext. For a task run via
         * g_task_run_in_thread() or g_task_run_in_thread_sync(), calling this
         * method will save `result` to be returned to the caller later, but
         * the task will not actually be completed until the #GTaskThreadFunc
         * exits.
         *
         * Note that since the task may be completed before returning from
         * g_task_return_pointer(), you cannot assume that `result` is still
         * valid after calling this, unless you are still holding another
         * reference on it.
         * @param result the pointer result of a task     function
         * @param result_destroy a #GDestroyNotify function.
         */
        return_pointer(
            result: any | null,
            result_destroy: GLib.DestroyNotify | null
        ): void;
        /**
         * Sets `task'`s result to `result` (by copying it) and completes the task.
         *
         * If `result` is %NULL then a #GValue of type %G_TYPE_POINTER
         * with a value of %NULL will be used for the result.
         *
         * This is a very generic low-level method intended primarily for use
         * by language bindings; for C code, g_task_return_pointer() and the
         * like will normally be much easier to use.
         * @param result the #GValue result of                                      a task function
         */
        return_value(result: any | null): void;
        /**
         * Runs `task_func` in another thread. When `task_func` returns, `task'`s
         * #GAsyncReadyCallback will be invoked in `task'`s #GMainContext.
         *
         * This takes a ref on `task` until the task completes.
         *
         * See #GTaskThreadFunc for more details about how `task_func` is handled.
         *
         * Although GLib currently rate-limits the tasks queued via
         * g_task_run_in_thread(), you should not assume that it will always
         * do this. If you have a very large number of tasks to run (several tens of
         * tasks), but don't want them to all run at once, you should only queue a
         * limited number of them (around ten) at a time.
         *
         * Be aware that if your task depends on other tasks to complete, use of this
         * function could lead to a livelock if the other tasks also use this function
         * and enough of them (around 10) execute in a dependency chain, as that will
         * exhaust the thread pool. If this situation is possible, consider using a
         * separate worker thread or thread pool explicitly, rather than using
         * g_task_run_in_thread().
         * @param task_func a #GTaskThreadFunc
         */
        run_in_thread(task_func: TaskThreadFunc): void;
        /**
         * Runs `task_func` in another thread, and waits for it to return or be
         * cancelled. You can use g_task_propagate_pointer(), etc, afterward
         * to get the result of `task_func`.
         *
         * See #GTaskThreadFunc for more details about how `task_func` is handled.
         *
         * Normally this is used with tasks created with a %NULL
         * `callback`, but note that even if the task does
         * have a callback, it will not be invoked when `task_func` returns.
         * #GTask:completed will be set to %TRUE just before this function returns.
         *
         * Although GLib currently rate-limits the tasks queued via
         * g_task_run_in_thread_sync(), you should not assume that it will
         * always do this. If you have a very large number of tasks to run,
         * but don't want them to all run at once, you should only queue a
         * limited number of them at a time.
         * @param task_func a #GTaskThreadFunc
         */
        run_in_thread_sync(task_func: TaskThreadFunc): void;
        /**
         * Sets or clears `task'`s check-cancellable flag. If this is %TRUE
         * (the default), then g_task_propagate_pointer(), etc, and
         * g_task_had_error() will check the task's #GCancellable first, and
         * if it has been cancelled, then they will consider the task to have
         * returned an "Operation was cancelled" error
         * (%G_IO_ERROR_CANCELLED), regardless of any other error or return
         * value the task may have had.
         *
         * If `check_cancellable` is %FALSE, then the #GTask will not check the
         * cancellable itself, and it is up to `task'`s owner to do this (eg,
         * via g_task_return_error_if_cancelled()).
         *
         * If you are using g_task_set_return_on_cancel() as well, then
         * you must leave check-cancellable set %TRUE.
         * @param check_cancellable whether #GTask will check the state of   its #GCancellable for you.
         */
        set_check_cancellable(check_cancellable: boolean): void;
        /**
         * Sets `task`s name, used in debugging and profiling. The name defaults to
         * %NULL.
         *
         * The task name should describe in a human readable way what the task does.
         * For example, Open file or Connect to network host. It is used to set the
         * name of the #GSource used for idle completion of the task.
         *
         * This function may only be called before the `task` is first used in a thread
         * other than the one it was constructed in. It is called automatically by
         * g_task_set_source_tag() if not called already.
         * @param name a human readable name for the task, or %NULL to unset it
         */
        set_name(name: string | null): void;
        /**
         * Sets `task'`s priority. If you do not call this, it will default to
         * %G_PRIORITY_DEFAULT.
         *
         * This will affect the priority of #GSources created with
         * g_task_attach_source() and the scheduling of tasks run in threads,
         * and can also be explicitly retrieved later via
         * g_task_get_priority().
         * @param priority the [priority][io-priority] of the request
         */
        set_priority(priority: number): void;
        /**
         * Sets or clears `task'`s return-on-cancel flag. This is only
         * meaningful for tasks run via g_task_run_in_thread() or
         * g_task_run_in_thread_sync().
         *
         * If `return_on_cancel` is %TRUE, then cancelling `task'`s
         * #GCancellable will immediately cause it to return, as though the
         * task's #GTaskThreadFunc had called
         * g_task_return_error_if_cancelled() and then returned.
         *
         * This allows you to create a cancellable wrapper around an
         * uninterruptible function. The #GTaskThreadFunc just needs to be
         * careful that it does not modify any externally-visible state after
         * it has been cancelled. To do that, the thread should call
         * g_task_set_return_on_cancel() again to (atomically) set
         * return-on-cancel %FALSE before making externally-visible changes;
         * if the task gets cancelled before the return-on-cancel flag could
         * be changed, g_task_set_return_on_cancel() will indicate this by
         * returning %FALSE.
         *
         * You can disable and re-enable this flag multiple times if you wish.
         * If the task's #GCancellable is cancelled while return-on-cancel is
         * %FALSE, then calling g_task_set_return_on_cancel() to set it %TRUE
         * again will cause the task to be cancelled at that point.
         *
         * If the task's #GCancellable is already cancelled before you call
         * g_task_run_in_thread()/g_task_run_in_thread_sync(), then the
         * #GTaskThreadFunc will still be run (for consistency), but the task
         * will also be completed right away.
         * @param return_on_cancel whether the task returns automatically when   it is cancelled.
         * @returns %TRUE if @task's return-on-cancel flag was changed to   match @return_on_cancel. %FALSE if @task has already been   cancelled.
         */
        set_return_on_cancel(return_on_cancel: boolean): boolean;
        /**
         * Sets `task'`s source tag.
         *
         * You can use this to tag a task return
         * value with a particular pointer (usually a pointer to the function
         * doing the tagging) and then later check it using
         * g_task_get_source_tag() (or g_async_result_is_tagged()) in the
         * task's "finish" function, to figure out if the response came from a
         * particular place.
         *
         * A macro wrapper around this function will automatically set the
         * tasks name to the string form of `source_tag` if its not already
         * set, for convenience.
         * @param source_tag an opaque pointer indicating the source of this task
         */
        set_source_tag(source_tag: any | null): void;
        /**
         * Sets `task`s name, used in debugging and profiling.
         *
         * This is a variant of g_task_set_name() that avoids copying `name`.
         * @param name a human readable name for the task. Must be a string literal
         */
        set_static_name(name: string | null): void;
        /**
         * Sets `task'`s task data (freeing the existing task data, if any).
         * @param task_data task-specific data
         * @param task_data_destroy #GDestroyNotify for `task_data`
         */
        set_task_data(
            task_data: any | null,
            task_data_destroy: GLib.DestroyNotify | null
        ): void;

        // Class property signals of Gio-2.0.Gio.Task

        connect(
            sigName: 'notify::completed',
            callback: ($obj: Task, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::completed',
            callback: ($obj: Task, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::completed', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * A #GTask represents and manages a cancellable "task".
     *
     * ## Asynchronous operations
     *
     * The most common usage of #GTask is as a #GAsyncResult, to
     * manage data during an asynchronous operation. You call
     * g_task_new() in the "start" method, followed by
     * g_task_set_task_data() and the like if you need to keep some
     * additional data associated with the task, and then pass the
     * task object around through your asynchronous operation.
     * Eventually, you will call a method such as
     * g_task_return_pointer() or g_task_return_error(), which will
     * save the value you give it and then invoke the task's callback
     * function in the
     * [thread-default main context][g-main-context-push-thread-default]
     * where it was created (waiting until the next iteration of the main
     * loop first, if necessary). The caller will pass the #GTask back to
     * the operation's finish function (as a #GAsyncResult), and you can
     * use g_task_propagate_pointer() or the like to extract the
     * return value.
     *
     * Using #GTask requires the thread-default #GMainContext from when the
     * #GTask was constructed to be running at least until the task has completed
     * and its data has been freed.
     *
     * If a #GTask has been constructed and its callback set, it is an error to
     * not call `g_task_return_*()` on it. GLib will warn at runtime if this happens
     * (since 2.76).
     *
     * Here is an example for using GTask as a GAsyncResult:
     *
     * ```c
     *     typedef struct {
     *       CakeFrostingType frosting;
     *       char *message;
     *     } DecorationData;
     *
     *     static void
     *     decoration_data_free (DecorationData *decoration)
     *     {
     *       g_free (decoration->message);
     *       g_slice_free (DecorationData, decoration);
     *     }
     *
     *     static void
     *     baked_cb (Cake     *cake,
     *               gpointer  user_data)
     *     {
     *       GTask *task = user_data;
     *       DecorationData *decoration = g_task_get_task_data (task);
     *       GError *error = NULL;
     *
     *       if (cake == NULL)
     *         {
     *           g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_NO_FLOUR,
     *                                    "Go to the supermarket");
     *           g_object_unref (task);
     *           return;
     *         }
     *
     *       if (!cake_decorate (cake, decoration->frosting, decoration->message, &error))
     *         {
     *           g_object_unref (cake);
     *           // g_task_return_error() takes ownership of error
     *           g_task_return_error (task, error);
     *           g_object_unref (task);
     *           return;
     *         }
     *
     *       g_task_return_pointer (task, cake, g_object_unref);
     *       g_object_unref (task);
     *     }
     *
     *     void
     *     baker_bake_cake_async (Baker               *self,
     *                            guint                radius,
     *                            CakeFlavor           flavor,
     *                            CakeFrostingType     frosting,
     *                            const char          *message,
     *                            GCancellable        *cancellable,
     *                            GAsyncReadyCallback  callback,
     *                            gpointer             user_data)
     *     {
     *       GTask *task;
     *       DecorationData *decoration;
     *       Cake  *cake;
     *
     *       task = g_task_new (self, cancellable, callback, user_data);
     *       if (radius < 3)
     *         {
     *           g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_TOO_SMALL,
     *                                    "%ucm radius cakes are silly",
     *                                    radius);
     *           g_object_unref (task);
     *           return;
     *         }
     *
     *       cake = _baker_get_cached_cake (self, radius, flavor, frosting, message);
     *       if (cake != NULL)
     *         {
     *           // _baker_get_cached_cake() returns a reffed cake
     *           g_task_return_pointer (task, cake, g_object_unref);
     *           g_object_unref (task);
     *           return;
     *         }
     *
     *       decoration = g_slice_new (DecorationData);
     *       decoration->frosting = frosting;
     *       decoration->message = g_strdup (message);
     *       g_task_set_task_data (task, decoration, (GDestroyNotify) decoration_data_free);
     *
     *       _baker_begin_cake (self, radius, flavor, cancellable, baked_cb, task);
     *     }
     *
     *     Cake *
     *     baker_bake_cake_finish (Baker         *self,
     *                             GAsyncResult  *result,
     *                             GError       **error)
     *     {
     *       g_return_val_if_fail (g_task_is_valid (result, self), NULL);
     *
     *       return g_task_propagate_pointer (G_TASK (result), error);
     *     }
     * ```
     *
     *
     * ## Chained asynchronous operations
     *
     * #GTask also tries to simplify asynchronous operations that
     * internally chain together several smaller asynchronous
     * operations. g_task_get_cancellable(), g_task_get_context(),
     * and g_task_get_priority() allow you to get back the task's
     * #GCancellable, #GMainContext, and [I/O priority][io-priority]
     * when starting a new subtask, so you don't have to keep track
     * of them yourself. g_task_attach_source() simplifies the case
     * of waiting for a source to fire (automatically using the correct
     * #GMainContext and priority).
     *
     * Here is an example for chained asynchronous operations:
     *
     * ```c
     *     typedef struct {
     *       Cake *cake;
     *       CakeFrostingType frosting;
     *       char *message;
     *     } BakingData;
     *
     *     static void
     *     decoration_data_free (BakingData *bd)
     *     {
     *       if (bd->cake)
     *         g_object_unref (bd->cake);
     *       g_free (bd->message);
     *       g_slice_free (BakingData, bd);
     *     }
     *
     *     static void
     *     decorated_cb (Cake         *cake,
     *                   GAsyncResult *result,
     *                   gpointer      user_data)
     *     {
     *       GTask *task = user_data;
     *       GError *error = NULL;
     *
     *       if (!cake_decorate_finish (cake, result, &error))
     *         {
     *           g_object_unref (cake);
     *           g_task_return_error (task, error);
     *           g_object_unref (task);
     *           return;
     *         }
     *
     *       // baking_data_free() will drop its ref on the cake, so we have to
     *       // take another here to give to the caller.
     *       g_task_return_pointer (task, g_object_ref (cake), g_object_unref);
     *       g_object_unref (task);
     *     }
     *
     *     static gboolean
     *     decorator_ready (gpointer user_data)
     *     {
     *       GTask *task = user_data;
     *       BakingData *bd = g_task_get_task_data (task);
     *
     *       cake_decorate_async (bd->cake, bd->frosting, bd->message,
     *                            g_task_get_cancellable (task),
     *                            decorated_cb, task);
     *
     *       return G_SOURCE_REMOVE;
     *     }
     *
     *     static void
     *     baked_cb (Cake     *cake,
     *               gpointer  user_data)
     *     {
     *       GTask *task = user_data;
     *       BakingData *bd = g_task_get_task_data (task);
     *       GError *error = NULL;
     *
     *       if (cake == NULL)
     *         {
     *           g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_NO_FLOUR,
     *                                    "Go to the supermarket");
     *           g_object_unref (task);
     *           return;
     *         }
     *
     *       bd->cake = cake;
     *
     *       // Bail out now if the user has already cancelled
     *       if (g_task_return_error_if_cancelled (task))
     *         {
     *           g_object_unref (task);
     *           return;
     *         }
     *
     *       if (cake_decorator_available (cake))
     *         decorator_ready (task);
     *       else
     *         {
     *           GSource *source;
     *
     *           source = cake_decorator_wait_source_new (cake);
     *           // Attach `source` to `task'`s GMainContext and have it call
     *           // decorator_ready() when it is ready.
     *           g_task_attach_source (task, source, decorator_ready);
     *           g_source_unref (source);
     *         }
     *     }
     *
     *     void
     *     baker_bake_cake_async (Baker               *self,
     *                            guint                radius,
     *                            CakeFlavor           flavor,
     *                            CakeFrostingType     frosting,
     *                            const char          *message,
     *                            gint                 priority,
     *                            GCancellable        *cancellable,
     *                            GAsyncReadyCallback  callback,
     *                            gpointer             user_data)
     *     {
     *       GTask *task;
     *       BakingData *bd;
     *
     *       task = g_task_new (self, cancellable, callback, user_data);
     *       g_task_set_priority (task, priority);
     *
     *       bd = g_slice_new0 (BakingData);
     *       bd->frosting = frosting;
     *       bd->message = g_strdup (message);
     *       g_task_set_task_data (task, bd, (GDestroyNotify) baking_data_free);
     *
     *       _baker_begin_cake (self, radius, flavor, cancellable, baked_cb, task);
     *     }
     *
     *     Cake *
     *     baker_bake_cake_finish (Baker         *self,
     *                             GAsyncResult  *result,
     *                             GError       **error)
     *     {
     *       g_return_val_if_fail (g_task_is_valid (result, self), NULL);
     *
     *       return g_task_propagate_pointer (G_TASK (result), error);
     *     }
     * ```
     *
     *
     * ## Asynchronous operations from synchronous ones
     *
     * You can use g_task_run_in_thread() to turn a synchronous
     * operation into an asynchronous one, by running it in a thread.
     * When it completes, the result will be dispatched to the
     * [thread-default main context][g-main-context-push-thread-default]
     * where the #GTask was created.
     *
     * Running a task in a thread:
     *
     * ```c
     *     typedef struct {
     *       guint radius;
     *       CakeFlavor flavor;
     *       CakeFrostingType frosting;
     *       char *message;
     *     } CakeData;
     *
     *     static void
     *     cake_data_free (CakeData *cake_data)
     *     {
     *       g_free (cake_data->message);
     *       g_slice_free (CakeData, cake_data);
     *     }
     *
     *     static void
     *     bake_cake_thread (GTask         *task,
     *                       gpointer       source_object,
     *                       gpointer       task_data,
     *                       GCancellable  *cancellable)
     *     {
     *       Baker *self = source_object;
     *       CakeData *cake_data = task_data;
     *       Cake *cake;
     *       GError *error = NULL;
     *
     *       cake = bake_cake (baker, cake_data->radius, cake_data->flavor,
     *                         cake_data->frosting, cake_data->message,
     *                         cancellable, &error);
     *       if (cake)
     *         g_task_return_pointer (task, cake, g_object_unref);
     *       else
     *         g_task_return_error (task, error);
     *     }
     *
     *     void
     *     baker_bake_cake_async (Baker               *self,
     *                            guint                radius,
     *                            CakeFlavor           flavor,
     *                            CakeFrostingType     frosting,
     *                            const char          *message,
     *                            GCancellable        *cancellable,
     *                            GAsyncReadyCallback  callback,
     *                            gpointer             user_data)
     *     {
     *       CakeData *cake_data;
     *       GTask *task;
     *
     *       cake_data = g_slice_new (CakeData);
     *       cake_data->radius = radius;
     *       cake_data->flavor = flavor;
     *       cake_data->frosting = frosting;
     *       cake_data->message = g_strdup (message);
     *       task = g_task_new (self, cancellable, callback, user_data);
     *       g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
     *       g_task_run_in_thread (task, bake_cake_thread);
     *       g_object_unref (task);
     *     }
     *
     *     Cake *
     *     baker_bake_cake_finish (Baker         *self,
     *                             GAsyncResult  *result,
     *                             GError       **error)
     *     {
     *       g_return_val_if_fail (g_task_is_valid (result, self), NULL);
     *
     *       return g_task_propagate_pointer (G_TASK (result), error);
     *     }
     * ```
     *
     *
     * ## Adding cancellability to uncancellable tasks
     *
     * Finally, g_task_run_in_thread() and g_task_run_in_thread_sync()
     * can be used to turn an uncancellable operation into a
     * cancellable one. If you call g_task_set_return_on_cancel(),
     * passing %TRUE, then if the task's #GCancellable is cancelled,
     * it will return control back to the caller immediately, while
     * allowing the task thread to continue running in the background
     * (and simply discarding its result when it finally does finish).
     * Provided that the task thread is careful about how it uses
     * locks and other externally-visible resources, this allows you
     * to make "GLib-friendly" asynchronous and cancellable
     * synchronous variants of blocking APIs.
     *
     * Cancelling a task:
     *
     * ```c
     *     static void
     *     bake_cake_thread (GTask         *task,
     *                       gpointer       source_object,
     *                       gpointer       task_data,
     *                       GCancellable  *cancellable)
     *     {
     *       Baker *self = source_object;
     *       CakeData *cake_data = task_data;
     *       Cake *cake;
     *       GError *error = NULL;
     *
     *       cake = bake_cake (baker, cake_data->radius, cake_data->flavor,
     *                         cake_data->frosting, cake_data->message,
     *                         &error);
     *       if (error)
     *         {
     *           g_task_return_error (task, error);
     *           return;
     *         }
     *
     *       // If the task has already been cancelled, then we don't want to add
     *       // the cake to the cake cache. Likewise, we don't  want to have the
     *       // task get cancelled in the middle of updating the cache.
     *       // g_task_set_return_on_cancel() will return %TRUE here if it managed
     *       // to disable return-on-cancel, or %FALSE if the task was cancelled
     *       // before it could.
     *       if (g_task_set_return_on_cancel (task, FALSE))
     *         {
     *           // If the caller cancels at this point, their
     *           // GAsyncReadyCallback won't be invoked until we return,
     *           // so we don't have to worry that this code will run at
     *           // the same time as that code does. But if there were
     *           // other functions that might look at the cake cache,
     *           // then we'd probably need a GMutex here as well.
     *           baker_add_cake_to_cache (baker, cake);
     *           g_task_return_pointer (task, cake, g_object_unref);
     *         }
     *     }
     *
     *     void
     *     baker_bake_cake_async (Baker               *self,
     *                            guint                radius,
     *                            CakeFlavor           flavor,
     *                            CakeFrostingType     frosting,
     *                            const char          *message,
     *                            GCancellable        *cancellable,
     *                            GAsyncReadyCallback  callback,
     *                            gpointer             user_data)
     *     {
     *       CakeData *cake_data;
     *       GTask *task;
     *
     *       cake_data = g_slice_new (CakeData);
     *
     *       ...
     *
     *       task = g_task_new (self, cancellable, callback, user_data);
     *       g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
     *       g_task_set_return_on_cancel (task, TRUE);
     *       g_task_run_in_thread (task, bake_cake_thread);
     *     }
     *
     *     Cake *
     *     baker_bake_cake_sync (Baker               *self,
     *                           guint                radius,
     *                           CakeFlavor           flavor,
     *                           CakeFrostingType     frosting,
     *                           const char          *message,
     *                           GCancellable        *cancellable,
     *                           GError             **error)
     *     {
     *       CakeData *cake_data;
     *       GTask *task;
     *       Cake *cake;
     *
     *       cake_data = g_slice_new (CakeData);
     *
     *       ...
     *
     *       task = g_task_new (self, cancellable, NULL, NULL);
     *       g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
     *       g_task_set_return_on_cancel (task, TRUE);
     *       g_task_run_in_thread_sync (task, bake_cake_thread);
     *
     *       cake = g_task_propagate_pointer (task, error);
     *       g_object_unref (task);
     *       return cake;
     *     }
     * ```
     *
     *
     * ## Porting from GSimpleAsyncResult
     *
     * #GTask's API attempts to be simpler than #GSimpleAsyncResult's
     * in several ways:
     * - You can save task-specific data with g_task_set_task_data(), and
     *   retrieve it later with g_task_get_task_data(). This replaces the
     *   abuse of g_simple_async_result_set_op_res_gpointer() for the same
     *   purpose with #GSimpleAsyncResult.
     * - In addition to the task data, #GTask also keeps track of the
     *   [priority][io-priority], #GCancellable, and
     *   #GMainContext associated with the task, so tasks that consist of
     *   a chain of simpler asynchronous operations will have easy access
     *   to those values when starting each sub-task.
     * - g_task_return_error_if_cancelled() provides simplified
     *   handling for cancellation. In addition, cancellation
     *   overrides any other #GTask return value by default, like
     *   #GSimpleAsyncResult does when
     *   g_simple_async_result_set_check_cancellable() is called.
     *   (You can use g_task_set_check_cancellable() to turn off that
     *   behavior.) On the other hand, g_task_run_in_thread()
     *   guarantees that it will always run your
     *   `task_func`, even if the task's #GCancellable
     *   is already cancelled before the task gets a chance to run;
     *   you can start your `task_func` with a
     *   g_task_return_error_if_cancelled() check if you need the
     *   old behavior.
     * - The "return" methods (eg, g_task_return_pointer())
     *   automatically cause the task to be "completed" as well, and
     *   there is no need to worry about the "complete" vs "complete
     *   in idle" distinction. (#GTask automatically figures out
     *   whether the task's callback can be invoked directly, or
     *   if it needs to be sent to another #GMainContext, or delayed
     *   until the next iteration of the current #GMainContext.)
     * - The "finish" functions for #GTask based operations are generally
     *   much simpler than #GSimpleAsyncResult ones, normally consisting
     *   of only a single call to g_task_propagate_pointer() or the like.
     *   Since g_task_propagate_pointer() "steals" the return value from
     *   the #GTask, it is not necessary to juggle pointers around to
     *   prevent it from being freed twice.
     * - With #GSimpleAsyncResult, it was common to call
     *   g_simple_async_result_propagate_error() from the
     *   `_finish()` wrapper function, and have
     *   virtual method implementations only deal with successful
     *   returns. This behavior is deprecated, because it makes it
     *   difficult for a subclass to chain to a parent class's async
     *   methods. Instead, the wrapper function should just be a
     *   simple wrapper, and the virtual method should call an
     *   appropriate `g_task_propagate_` function.
     *   Note that wrapper methods can now use
     *   g_async_result_legacy_propagate_error() to do old-style
     *   #GSimpleAsyncResult error-returning behavior, and
     *   g_async_result_is_tagged() to check if a result is tagged as
     *   having come from the `_async()` wrapper
     *   function (for "short-circuit" results, such as when passing
     *   0 to g_input_stream_read_async()).
     *
     * ## Thread-safety considerations
     *
     * Due to some infelicities in the API design, there is a
     * thread-safety concern that users of GTask have to be aware of:
     *
     * If the `main` thread drops its last reference to the source object
     * or the task data before the task is finalized, then the finalizers
     * of these objects may be called on the worker thread.
     *
     * This is a problem if the finalizers use non-threadsafe API, and
     * can lead to hard-to-debug crashes. Possible workarounds include:
     *
     * - Clear task data in a signal handler for `notify::completed`
     *
     * - Keep iterating a main context in the main thread and defer
     *   dropping the reference to the source object to that main
     *   context when the task is finalized
     * @class
     */
    class Task extends GObject.Object {
        // Own properties of Gio-2.0.Gio.Task

        static name: string;
        static $gtype: GObject.GType<Task>;

        // Constructors of Gio-2.0.Gio.Task

        constructor(config?: Task.ConstructorProperties);
        /**
         * Creates a #GTask acting on `source_object,` which will eventually be
         * used to invoke `callback` in the current
         * [thread-default main context][g-main-context-push-thread-default].
         *
         * Call this in the "start" method of your asynchronous method, and
         * pass the #GTask around throughout the asynchronous operation. You
         * can use g_task_set_task_data() to attach task-specific data to the
         * object, which you can retrieve later via g_task_get_task_data().
         *
         * By default, if `cancellable` is cancelled, then the return value of
         * the task will always be %G_IO_ERROR_CANCELLED, even if the task had
         * already completed before the cancellation. This allows for
         * simplified handling in cases where cancellation may imply that
         * other objects that the task depends on have been destroyed. If you
         * do not want this behavior, you can use
         * g_task_set_check_cancellable() to change it.
         * @constructor
         * @param source_object the #GObject that owns   this task, or %NULL.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback.
         * @returns a #GTask.
         */
        constructor(
            source_object: GObject.Object | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<Task> | null
        );
        /**
         * Creates a #GTask acting on `source_object,` which will eventually be
         * used to invoke `callback` in the current
         * [thread-default main context][g-main-context-push-thread-default].
         *
         * Call this in the "start" method of your asynchronous method, and
         * pass the #GTask around throughout the asynchronous operation. You
         * can use g_task_set_task_data() to attach task-specific data to the
         * object, which you can retrieve later via g_task_get_task_data().
         *
         * By default, if `cancellable` is cancelled, then the return value of
         * the task will always be %G_IO_ERROR_CANCELLED, even if the task had
         * already completed before the cancellation. This allows for
         * simplified handling in cases where cancellation may imply that
         * other objects that the task depends on have been destroyed. If you
         * do not want this behavior, you can use
         * g_task_set_check_cancellable() to change it.
         * @constructor
         * @param source_object the #GObject that owns   this task, or %NULL.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback.
         * @returns a #GTask.
         */
        static new(
            source_object: GObject.Object | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<Task> | null
        ): Task;
        _init(config?: Task.ConstructorProperties): void;
        /**
         * Checks that `result` is a #GTask, and that `source_object` is its
         * source object (or that `source_object` is %NULL and `result` has no
         * source object). This can be used in g_return_if_fail() checks.
         * @param result A #GAsyncResult
         * @param source_object the source object   expected to be associated with the task
         * @returns %TRUE if @result and @source_object are valid, %FALSE if not
         */
        static is_valid(
            result: AsyncResult,
            source_object: GObject.Object | null
        ): boolean;
        /**
         * Creates a #GTask and then immediately calls g_task_return_error()
         * on it. Use this in the wrapper function of an asynchronous method
         * when you want to avoid even calling the virtual method. You can
         * then use g_async_result_is_tagged() in the finish method wrapper to
         * check if the result there is tagged as having been created by the
         * wrapper method, and deal with it appropriately if so.
         *
         * See also g_task_report_new_error().
         * @param source_object the #GObject that owns   this task, or %NULL.
         * @param callback a #GAsyncReadyCallback.
         * @param source_tag an opaque pointer indicating the source of this task
         * @param error error to report
         */
        static report_error(
            source_object: GObject.Object | null,
            callback: AsyncReadyCallback<Task> | null,
            source_tag: any | null,
            error: GLib.Error
        ): void;
    }

    namespace TcpConnection {
        // Constructor properties interface

        interface ConstructorProperties
            extends SocketConnection.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.TcpConnection

            graceful_disconnect?: boolean | null;
        }
    }

    interface TcpConnection {
        // Own properties of Gio-2.0.Gio.TcpConnection

        graceful_disconnect: boolean;

        // Own fields of Gio-2.0.Gio.TcpConnection

        parent_instance: SocketConnection &
            IOStream &
            GObject.Object &
            GObject.Object;
        priv: any;

        // Owm methods of Gio-2.0.Gio.TcpConnection

        /**
         * Checks if graceful disconnects are used. See
         * g_tcp_connection_set_graceful_disconnect().
         * @returns %TRUE if graceful disconnect is used on close, %FALSE otherwise
         */
        get_graceful_disconnect(): boolean;
        /**
         * This enables graceful disconnects on close. A graceful disconnect
         * means that we signal the receiving end that the connection is terminated
         * and wait for it to close the connection before closing the connection.
         *
         * A graceful disconnect means that we can be sure that we successfully sent
         * all the outstanding data to the other end, or get an error reported.
         * However, it also means we have to wait for all the data to reach the
         * other side and for it to acknowledge this by closing the socket, which may
         * take a while. For this reason it is disabled by default.
         * @param graceful_disconnect Whether to do graceful disconnects or not
         */
        set_graceful_disconnect(graceful_disconnect: boolean): void;

        // Class property signals of Gio-2.0.Gio.TcpConnection

        connect(
            sigName: 'notify::graceful-disconnect',
            callback: ($obj: TcpConnection, pspec: GObject.ParamSpec) => void
        ): number;

        // Overloads of connect

        /**
         * Connect `connection` to the specified remote address.
         * @param address a #GSocketAddress specifying the remote address.
         * @param cancellable a %GCancellable or %NULL
         * @returns %TRUE if the connection succeeded, %FALSE on error
         */
        connect(
            address: SocketAddress,
            cancellable: Cancellable | null
        ): boolean;
        connect_after(
            sigName: 'notify::graceful-disconnect',
            callback: ($obj: TcpConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::graceful-disconnect', ...args: any[]): void;
        connect(
            sigName: 'notify::socket',
            callback: ($obj: TcpConnection, pspec: GObject.ParamSpec) => void
        ): number;

        // Overloads of connect

        /**
         * Connect `connection` to the specified remote address.
         * @param address a #GSocketAddress specifying the remote address.
         * @param cancellable a %GCancellable or %NULL
         * @returns %TRUE if the connection succeeded, %FALSE on error
         */
        connect(
            address: SocketAddress,
            cancellable: Cancellable | null
        ): boolean;
        connect_after(
            sigName: 'notify::socket',
            callback: ($obj: TcpConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::socket', ...args: any[]): void;
        connect(
            sigName: 'notify::closed',
            callback: ($obj: TcpConnection, pspec: GObject.ParamSpec) => void
        ): number;

        // Overloads of connect

        /**
         * Connect `connection` to the specified remote address.
         * @param address a #GSocketAddress specifying the remote address.
         * @param cancellable a %GCancellable or %NULL
         * @returns %TRUE if the connection succeeded, %FALSE on error
         */
        connect(
            address: SocketAddress,
            cancellable: Cancellable | null
        ): boolean;
        connect_after(
            sigName: 'notify::closed',
            callback: ($obj: TcpConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::closed', ...args: any[]): void;
        connect(
            sigName: 'notify::input-stream',
            callback: ($obj: TcpConnection, pspec: GObject.ParamSpec) => void
        ): number;

        // Overloads of connect

        /**
         * Connect `connection` to the specified remote address.
         * @param address a #GSocketAddress specifying the remote address.
         * @param cancellable a %GCancellable or %NULL
         * @returns %TRUE if the connection succeeded, %FALSE on error
         */
        connect(
            address: SocketAddress,
            cancellable: Cancellable | null
        ): boolean;
        connect_after(
            sigName: 'notify::input-stream',
            callback: ($obj: TcpConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::input-stream', ...args: any[]): void;
        connect(
            sigName: 'notify::output-stream',
            callback: ($obj: TcpConnection, pspec: GObject.ParamSpec) => void
        ): number;

        // Overloads of connect

        /**
         * Connect `connection` to the specified remote address.
         * @param address a #GSocketAddress specifying the remote address.
         * @param cancellable a %GCancellable or %NULL
         * @returns %TRUE if the connection succeeded, %FALSE on error
         */
        connect(
            address: SocketAddress,
            cancellable: Cancellable | null
        ): boolean;
        connect_after(
            sigName: 'notify::output-stream',
            callback: ($obj: TcpConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::output-stream', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;

        // Overloads of connect

        /**
         * Connect `connection` to the specified remote address.
         * @param address a #GSocketAddress specifying the remote address.
         * @param cancellable a %GCancellable or %NULL
         * @returns %TRUE if the connection succeeded, %FALSE on error
         */
        connect(
            address: SocketAddress,
            cancellable: Cancellable | null
        ): boolean;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * This is the subclass of #GSocketConnection that is created
     * for TCP/IP sockets.
     * @class
     */
    class TcpConnection extends SocketConnection {
        // Own properties of Gio-2.0.Gio.TcpConnection

        static name: string;
        static $gtype: GObject.GType<TcpConnection>;

        // Constructors of Gio-2.0.Gio.TcpConnection

        constructor(config?: TcpConnection.ConstructorProperties);
        _init(config?: TcpConnection.ConstructorProperties): void;
    }

    namespace TcpWrapperConnection {
        // Constructor properties interface

        interface ConstructorProperties
            extends TcpConnection.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.TcpWrapperConnection

            base_io_stream?: IOStream | null;
        }
    }

    interface TcpWrapperConnection {
        // Own properties of Gio-2.0.Gio.TcpWrapperConnection

        readonly base_io_stream: IOStream;

        // Own fields of Gio-2.0.Gio.TcpWrapperConnection

        parent_instance: TcpConnection &
            SocketConnection &
            IOStream &
            GObject.Object &
            GObject.Object;
        priv: any;

        // Owm methods of Gio-2.0.Gio.TcpWrapperConnection

        /**
         * Gets `conn'`s base #GIOStream
         * @returns @conn's base #GIOStream
         */
        get_base_io_stream(): IOStream;

        // Class property signals of Gio-2.0.Gio.TcpWrapperConnection

        connect(
            sigName: 'notify::base-io-stream',
            callback: (
                $obj: TcpWrapperConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;

        // Overloads of connect

        /**
         * Connect `connection` to the specified remote address.
         * @param address a #GSocketAddress specifying the remote address.
         * @param cancellable a %GCancellable or %NULL
         * @returns %TRUE if the connection succeeded, %FALSE on error
         */
        connect(
            address: SocketAddress,
            cancellable: Cancellable | null
        ): boolean;
        connect_after(
            sigName: 'notify::base-io-stream',
            callback: (
                $obj: TcpWrapperConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::base-io-stream', ...args: any[]): void;
        connect(
            sigName: 'notify::graceful-disconnect',
            callback: (
                $obj: TcpWrapperConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;

        // Overloads of connect

        /**
         * Connect `connection` to the specified remote address.
         * @param address a #GSocketAddress specifying the remote address.
         * @param cancellable a %GCancellable or %NULL
         * @returns %TRUE if the connection succeeded, %FALSE on error
         */
        connect(
            address: SocketAddress,
            cancellable: Cancellable | null
        ): boolean;
        connect_after(
            sigName: 'notify::graceful-disconnect',
            callback: (
                $obj: TcpWrapperConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::graceful-disconnect', ...args: any[]): void;
        connect(
            sigName: 'notify::socket',
            callback: (
                $obj: TcpWrapperConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;

        // Overloads of connect

        /**
         * Connect `connection` to the specified remote address.
         * @param address a #GSocketAddress specifying the remote address.
         * @param cancellable a %GCancellable or %NULL
         * @returns %TRUE if the connection succeeded, %FALSE on error
         */
        connect(
            address: SocketAddress,
            cancellable: Cancellable | null
        ): boolean;
        connect_after(
            sigName: 'notify::socket',
            callback: (
                $obj: TcpWrapperConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::socket', ...args: any[]): void;
        connect(
            sigName: 'notify::closed',
            callback: (
                $obj: TcpWrapperConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;

        // Overloads of connect

        /**
         * Connect `connection` to the specified remote address.
         * @param address a #GSocketAddress specifying the remote address.
         * @param cancellable a %GCancellable or %NULL
         * @returns %TRUE if the connection succeeded, %FALSE on error
         */
        connect(
            address: SocketAddress,
            cancellable: Cancellable | null
        ): boolean;
        connect_after(
            sigName: 'notify::closed',
            callback: (
                $obj: TcpWrapperConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::closed', ...args: any[]): void;
        connect(
            sigName: 'notify::input-stream',
            callback: (
                $obj: TcpWrapperConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;

        // Overloads of connect

        /**
         * Connect `connection` to the specified remote address.
         * @param address a #GSocketAddress specifying the remote address.
         * @param cancellable a %GCancellable or %NULL
         * @returns %TRUE if the connection succeeded, %FALSE on error
         */
        connect(
            address: SocketAddress,
            cancellable: Cancellable | null
        ): boolean;
        connect_after(
            sigName: 'notify::input-stream',
            callback: (
                $obj: TcpWrapperConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::input-stream', ...args: any[]): void;
        connect(
            sigName: 'notify::output-stream',
            callback: (
                $obj: TcpWrapperConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;

        // Overloads of connect

        /**
         * Connect `connection` to the specified remote address.
         * @param address a #GSocketAddress specifying the remote address.
         * @param cancellable a %GCancellable or %NULL
         * @returns %TRUE if the connection succeeded, %FALSE on error
         */
        connect(
            address: SocketAddress,
            cancellable: Cancellable | null
        ): boolean;
        connect_after(
            sigName: 'notify::output-stream',
            callback: (
                $obj: TcpWrapperConnection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::output-stream', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;

        // Overloads of connect

        /**
         * Connect `connection` to the specified remote address.
         * @param address a #GSocketAddress specifying the remote address.
         * @param cancellable a %GCancellable or %NULL
         * @returns %TRUE if the connection succeeded, %FALSE on error
         */
        connect(
            address: SocketAddress,
            cancellable: Cancellable | null
        ): boolean;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * A #GTcpWrapperConnection can be used to wrap a #GIOStream that is
     * based on a #GSocket, but which is not actually a
     * #GSocketConnection. This is used by #GSocketClient so that it can
     * always return a #GSocketConnection, even when the connection it has
     * actually created is not directly a #GSocketConnection.
     * @class
     */
    class TcpWrapperConnection extends TcpConnection {
        // Own properties of Gio-2.0.Gio.TcpWrapperConnection

        static name: string;
        static $gtype: GObject.GType<TcpWrapperConnection>;

        // Constructors of Gio-2.0.Gio.TcpWrapperConnection

        constructor(config?: TcpWrapperConnection.ConstructorProperties);
        /**
         * Wraps `base_io_stream` and `socket` together as a #GSocketConnection.
         * @constructor
         * @param base_io_stream the #GIOStream to wrap
         * @param socket the #GSocket associated with `base_io_stream`
         * @returns the new #GSocketConnection.
         */
        constructor(base_io_stream: IOStream, socket: Socket);
        /**
         * Wraps `base_io_stream` and `socket` together as a #GSocketConnection.
         * @constructor
         * @param base_io_stream the #GIOStream to wrap
         * @param socket the #GSocket associated with `base_io_stream`
         * @returns the new #GSocketConnection.
         */
        static new(
            base_io_stream: IOStream,
            socket: Socket
        ): TcpWrapperConnection;
        _init(config?: TcpWrapperConnection.ConstructorProperties): void;
    }

    namespace TestDBus {
        // Constructor properties interface

        interface ConstructorProperties
            extends GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.TestDBus

            /**
             * #GTestDBusFlags specifying the behaviour of the D-Bus session.
             */
            flags?: TestDBusFlags | null;
        }
    }

    interface TestDBus {
        // Own properties of Gio-2.0.Gio.TestDBus

        /**
         * #GTestDBusFlags specifying the behaviour of the D-Bus session.
         */
        readonly flags: TestDBusFlags;

        // Owm methods of Gio-2.0.Gio.TestDBus

        /**
         * Add a path where dbus-daemon will look up .service files. This can't be
         * called after g_test_dbus_up().
         * @param path path to a directory containing .service files
         */
        add_service_dir(path: string | null): void;
        /**
         * Stop the session bus started by g_test_dbus_up().
         *
         * This will wait for the singleton returned by g_bus_get() or g_bus_get_sync()
         * to be destroyed. This is done to ensure that the next unit test won't get a
         * leaked singleton from this test.
         */
        down(): void;
        /**
         * Get the address on which dbus-daemon is running. If g_test_dbus_up() has not
         * been called yet, %NULL is returned. This can be used with
         * g_dbus_connection_new_for_address().
         * @returns the address of the bus, or %NULL.
         */
        get_bus_address(): string | null;
        /**
         * Get the flags of the #GTestDBus object.
         * @returns the value of #GTestDBus:flags property
         */
        get_flags(): TestDBusFlags;
        /**
         * Stop the session bus started by g_test_dbus_up().
         *
         * Unlike g_test_dbus_down(), this won't verify the #GDBusConnection
         * singleton returned by g_bus_get() or g_bus_get_sync() is destroyed. Unit
         * tests wanting to verify behaviour after the session bus has been stopped
         * can use this function but should still call g_test_dbus_down() when done.
         */
        stop(): void;
        /**
         * Start a dbus-daemon instance and set DBUS_SESSION_BUS_ADDRESS. After this
         * call, it is safe for unit tests to start sending messages on the session bus.
         *
         * If this function is called from setup callback of g_test_add(),
         * g_test_dbus_down() must be called in its teardown callback.
         *
         * If this function is called from unit test's main(), then g_test_dbus_down()
         * must be called after g_test_run().
         */
        up(): void;

        // Class property signals of Gio-2.0.Gio.TestDBus

        connect(
            sigName: 'notify::flags',
            callback: ($obj: TestDBus, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::flags',
            callback: ($obj: TestDBus, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::flags', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * A helper class for testing code which uses D-Bus without touching the user's
     * session bus.
     *
     * Note that #GTestDBus modifies the users environment, calling setenv().
     * This is not thread-safe, so all #GTestDBus calls should be completed before
     * threads are spawned, or should have appropriate locking to ensure no access
     * conflicts to environment variables shared between #GTestDBus and other
     * threads.
     *
     * ## Creating unit tests using GTestDBus
     *
     * Testing of D-Bus services can be tricky because normally we only ever run
     * D-Bus services over an existing instance of the D-Bus daemon thus we
     * usually don't activate D-Bus services that are not yet installed into the
     * target system. The #GTestDBus object makes this easier for us by taking care
     * of the lower level tasks such as running a private D-Bus daemon and looking
     * up uninstalled services in customizable locations, typically in your source
     * code tree.
     *
     * The first thing you will need is a separate service description file for the
     * D-Bus daemon. Typically a `services` subdirectory of your `tests` directory
     * is a good place to put this file.
     *
     * The service file should list your service along with an absolute path to the
     * uninstalled service executable in your source tree. Using autotools we would
     * achieve this by adding a file such as `my-server.service.in` in the services
     * directory and have it processed by configure.
     *
     * ```
     *     [D-BUS Service]
     *     Name=org.gtk.GDBus.Examples.ObjectManager
     *     Exec=`abs_top_builddir@`/gio/tests/gdbus-example-objectmanager-server
     * ```
     *
     * You will also need to indicate this service directory in your test
     * fixtures, so you will need to pass the path while compiling your
     * test cases. Typically this is done with autotools with an added
     * preprocessor flag specified to compile your tests such as:
     *
     * ```
     *     -DTEST_SERVICES=\""$(abs_top_builddir)/tests/services"\"
     * ```
     *
     *     Once you have a service definition file which is local to your source tree,
     * you can proceed to set up a GTest fixture using the #GTestDBus scaffolding.
     *
     * An example of a test fixture for D-Bus services can be found
     * here:
     * [gdbus-test-fixture.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-test-fixture.c)
     *
     * Note that these examples only deal with isolating the D-Bus aspect of your
     * service. To successfully run isolated unit tests on your service you may need
     * some additional modifications to your test case fixture. For example; if your
     * service uses GSettings and installs a schema then it is important that your test service
     * not load the schema in the ordinary installed location (chances are that your service
     * and schema files are not yet installed, or worse; there is an older version of the
     * schema file sitting in the install location).
     *
     * Most of the time we can work around these obstacles using the
     * environment. Since the environment is inherited by the D-Bus daemon
     * created by #GTestDBus and then in turn inherited by any services the
     * D-Bus daemon activates, using the setup routine for your fixture is
     * a practical place to help sandbox your runtime environment. For the
     * rather typical GSettings case we can work around this by setting
     * `GSETTINGS_SCHEMA_DIR` to the in tree directory holding your schemas
     * in the above fixture_setup() routine.
     *
     * The GSettings schemas need to be locally pre-compiled for this to work. This can be achieved
     * by compiling the schemas locally as a step before running test cases, an autotools setup might
     * do the following in the directory holding schemas:
     *
     * ```
     *     all-am:
     *             $(GLIB_COMPILE_SCHEMAS) .
     *
     *     CLEANFILES += gschemas.compiled
     * ```
     *
     * @class
     */
    class TestDBus extends GObject.Object {
        // Own properties of Gio-2.0.Gio.TestDBus

        static name: string;
        static $gtype: GObject.GType<TestDBus>;

        // Constructors of Gio-2.0.Gio.TestDBus

        constructor(config?: TestDBus.ConstructorProperties);
        /**
         * Create a new #GTestDBus object.
         * @constructor
         * @param flags a #GTestDBusFlags
         * @returns a new #GTestDBus.
         */
        constructor(flags: TestDBusFlags);
        /**
         * Create a new #GTestDBus object.
         * @constructor
         * @param flags a #GTestDBusFlags
         * @returns a new #GTestDBus.
         */
        static new(flags: TestDBusFlags): TestDBus;
        _init(config?: TestDBus.ConstructorProperties): void;
        /**
         * Unset DISPLAY and DBUS_SESSION_BUS_ADDRESS env variables to ensure the test
         * won't use user's session bus.
         *
         * This is useful for unit tests that want to verify behaviour when no session
         * bus is running. It is not necessary to call this if unit test already calls
         * g_test_dbus_up() before acquiring the session bus.
         */
        static unset(): void;
    }

    namespace ThemedIcon {
        // Constructor properties interface

        interface ConstructorProperties
            extends Icon.ConstructorProperties,
                GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.ThemedIcon

            /**
             * The icon name.
             */
            name?: string | null;
            /**
             * A %NULL-terminated array of icon names.
             */
            names?: string[] | null;
            /**
             * Whether to use the default fallbacks found by shortening the icon name
             * at '-' characters. If the "names" array has more than one element,
             * ignores any past the first.
             *
             * For example, if the icon name was "gnome-dev-cdrom-audio", the array
             * would become
             *
             * ```c
             * {
             *   "gnome-dev-cdrom-audio",
             *   "gnome-dev-cdrom",
             *   "gnome-dev",
             *   "gnome",
             *   NULL
             * };
             * ```
             *
             */
            use_default_fallbacks?: boolean | null;
        }
    }

    interface ThemedIcon extends Icon {
        // Own properties of Gio-2.0.Gio.ThemedIcon

        /**
         * The icon name.
         */
        readonly name: string | null;
        /**
         * A %NULL-terminated array of icon names.
         */
        readonly names: string[];
        /**
         * Whether to use the default fallbacks found by shortening the icon name
         * at '-' characters. If the "names" array has more than one element,
         * ignores any past the first.
         *
         * For example, if the icon name was "gnome-dev-cdrom-audio", the array
         * would become
         *
         * ```c
         * {
         *   "gnome-dev-cdrom-audio",
         *   "gnome-dev-cdrom",
         *   "gnome-dev",
         *   "gnome",
         *   NULL
         * };
         * ```
         *
         */
        readonly use_default_fallbacks: boolean;

        // Owm methods of Gio-2.0.Gio.ThemedIcon

        /**
         * Append a name to the list of icons from within `icon`.
         *
         * Note that doing so invalidates the hash computed by prior calls
         * to g_icon_hash().
         * @param iconname name of icon to append to list of icons from within `icon`.
         */
        append_name(iconname: string | null): void;
        /**
         * Gets the names of icons from within `icon`.
         * @returns a list of icon names.
         */
        get_names(): string[];
        /**
         * Prepend a name to the list of icons from within `icon`.
         *
         * Note that doing so invalidates the hash computed by prior calls
         * to g_icon_hash().
         * @param iconname name of icon to prepend to list of icons from within `icon`.
         */
        prepend_name(iconname: string | null): void;

        // Class property signals of Gio-2.0.Gio.ThemedIcon

        connect(
            sigName: 'notify::name',
            callback: ($obj: ThemedIcon, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::name',
            callback: ($obj: ThemedIcon, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::name', ...args: any[]): void;
        connect(
            sigName: 'notify::names',
            callback: ($obj: ThemedIcon, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::names',
            callback: ($obj: ThemedIcon, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::names', ...args: any[]): void;
        connect(
            sigName: 'notify::use-default-fallbacks',
            callback: ($obj: ThemedIcon, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::use-default-fallbacks',
            callback: ($obj: ThemedIcon, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::use-default-fallbacks', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GThemedIcon is an implementation of #GIcon that supports icon themes.
     * #GThemedIcon contains a list of all of the icons present in an icon
     * theme, so that icons can be looked up quickly. #GThemedIcon does
     * not provide actual pixmaps for icons, just the icon names.
     * Ideally something like gtk_icon_theme_choose_icon() should be used to
     * resolve the list of names so that fallback icons work nicely with
     * themes that inherit other themes.
     * @class
     */
    class ThemedIcon extends GObject.Object {
        // Own properties of Gio-2.0.Gio.ThemedIcon

        static name: string;
        static $gtype: GObject.GType<ThemedIcon>;

        // Constructors of Gio-2.0.Gio.ThemedIcon

        constructor(config?: ThemedIcon.ConstructorProperties);
        /**
         * Creates a new themed icon for `iconname`.
         * @constructor
         * @param iconname a string containing an icon name.
         * @returns a new #GThemedIcon.
         */
        constructor(iconname: string | null);
        /**
         * Creates a new themed icon for `iconname`.
         * @constructor
         * @param iconname a string containing an icon name.
         * @returns a new #GThemedIcon.
         */
        static new(iconname: string | null): ThemedIcon;
        /**
         * Creates a new themed icon for `iconnames`.
         * @constructor
         * @param iconnames an array of strings containing icon names.
         * @returns a new #GThemedIcon
         */
        static new_from_names(iconnames: string[]): ThemedIcon;
        /**
         * Creates a new themed icon for `iconname,` and all the names
         * that can be created by shortening `iconname` at '-' characters.
         *
         * In the following example, `icon1` and `icon2` are equivalent:
         *
         * ```c
         * const char *names[] = {
         *   "gnome-dev-cdrom-audio",
         *   "gnome-dev-cdrom",
         *   "gnome-dev",
         *   "gnome"
         * };
         *
         * icon1 = g_themed_icon_new_from_names (names, 4);
         * icon2 = g_themed_icon_new_with_default_fallbacks ("gnome-dev-cdrom-audio");
         * ```
         *
         * @constructor
         * @param iconname a string containing an icon name
         * @returns a new #GThemedIcon.
         */
        static new_with_default_fallbacks(iconname: string | null): ThemedIcon;
        _init(config?: ThemedIcon.ConstructorProperties): void;
    }

    namespace ThreadedSocketService {
        // Signal callback interfaces

        /**
         * Signal callback interface for `run`
         */
        interface RunSignalCallback {
            (
                $obj: ThreadedSocketService,
                connection: SocketConnection,
                source_object: GObject.Object | null
            ): boolean;
        }

        // Constructor properties interface

        interface ConstructorProperties
            extends SocketService.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.ThreadedSocketService

            max_threads?: number | null;
        }
    }

    interface ThreadedSocketService {
        // Own properties of Gio-2.0.Gio.ThreadedSocketService

        readonly max_threads: number;

        // Own fields of Gio-2.0.Gio.ThreadedSocketService

        parent_instance: SocketService &
            SocketListener &
            GObject.Object &
            GObject.Object;
        priv: any;

        // Own virtual methods of Gio-2.0.Gio.ThreadedSocketService

        vfunc_run(
            connection: SocketConnection,
            source_object: GObject.Object
        ): boolean;

        // Own signals of Gio-2.0.Gio.ThreadedSocketService

        connect(
            sigName: 'run',
            callback: ThreadedSocketService.RunSignalCallback
        ): number;
        connect_after(
            sigName: 'run',
            callback: ThreadedSocketService.RunSignalCallback
        ): number;
        emit(
            sigName: 'run',
            connection: SocketConnection,
            source_object: GObject.Object | null,
            ...args: any[]
        ): void;

        // Class property signals of Gio-2.0.Gio.ThreadedSocketService

        connect(
            sigName: 'notify::max-threads',
            callback: (
                $obj: ThreadedSocketService,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::max-threads',
            callback: (
                $obj: ThreadedSocketService,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::max-threads', ...args: any[]): void;
        connect(
            sigName: 'notify::active',
            callback: (
                $obj: ThreadedSocketService,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::active',
            callback: (
                $obj: ThreadedSocketService,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::active', ...args: any[]): void;
        connect(
            sigName: 'notify::listen-backlog',
            callback: (
                $obj: ThreadedSocketService,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::listen-backlog',
            callback: (
                $obj: ThreadedSocketService,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::listen-backlog', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * A #GThreadedSocketService is a simple subclass of #GSocketService
     * that handles incoming connections by creating a worker thread and
     * dispatching the connection to it by emitting the
     * #GThreadedSocketService::run signal in the new thread.
     *
     * The signal handler may perform blocking IO and need not return
     * until the connection is closed.
     *
     * The service is implemented using a thread pool, so there is a
     * limited amount of threads available to serve incoming requests.
     * The service automatically stops the #GSocketService from accepting
     * new connections when all threads are busy.
     *
     * As with #GSocketService, you may connect to #GThreadedSocketService::run,
     * or subclass and override the default handler.
     * @class
     */
    class ThreadedSocketService extends SocketService {
        // Own properties of Gio-2.0.Gio.ThreadedSocketService

        static name: string;
        static $gtype: GObject.GType<ThreadedSocketService>;

        // Constructors of Gio-2.0.Gio.ThreadedSocketService

        constructor(config?: ThreadedSocketService.ConstructorProperties);
        /**
         * Creates a new #GThreadedSocketService with no listeners. Listeners
         * must be added with one of the #GSocketListener "add" methods.
         * @constructor
         * @param max_threads the maximal number of threads to execute concurrently   handling incoming clients, -1 means no limit
         * @returns a new #GSocketService.
         */
        constructor(max_threads: number);
        /**
         * Creates a new #GThreadedSocketService with no listeners. Listeners
         * must be added with one of the #GSocketListener "add" methods.
         * @constructor
         * @param max_threads the maximal number of threads to execute concurrently   handling incoming clients, -1 means no limit
         * @returns a new #GSocketService.
         */
        static new(max_threads: number): ThreadedSocketService;

        // Overloads of new

        /**
         * Creates a new #GSocketService with no sockets to listen for.
         * New listeners can be added with e.g. g_socket_listener_add_address()
         * or g_socket_listener_add_inet_port().
         *
         * New services are created active, there is no need to call
         * g_socket_service_start(), unless g_socket_service_stop() has been
         * called before.
         * @constructor
         * @returns a new #GSocketService.
         */
        static new(): SocketService;
        /**
         * Creates a new #GSocketListener with no sockets to listen for.
         * New listeners can be added with e.g. g_socket_listener_add_address()
         * or g_socket_listener_add_inet_port().
         * @constructor
         * @returns a new #GSocketListener.
         */
        static new(): SocketListener;
        _init(config?: ThreadedSocketService.ConstructorProperties): void;
    }

    namespace TlsCertificate {
        // Constructor properties interface

        interface ConstructorProperties
            extends GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.TlsCertificate

            /**
             * The DER (binary) encoded representation of the certificate.
             * This property and the #GTlsCertificate:certificate-pem property
             * represent the same data, just in different forms.
             */
            certificate?: Uint8Array | null;
            /**
             * The PEM (ASCII) encoded representation of the certificate.
             * This property and the #GTlsCertificate:certificate
             * property represent the same data, just in different forms.
             */
            certificate_pem?: string | null;
            /**
             * A #GTlsCertificate representing the entity that issued this
             * certificate. If %NULL, this means that the certificate is either
             * self-signed, or else the certificate of the issuer is not
             * available.
             *
             * Beware the issuer certificate may not be the same as the
             * certificate that would actually be used to construct a valid
             * certification path during certificate verification.
             * [RFC 4158](https://datatracker.ietf.org/doc/html/rfc4158) explains
             * why an issuer certificate cannot be naively assumed to be part of the
             * the certification path (though GLib's TLS backends may not follow the
             * path building strategies outlined in this RFC). Due to the complexity
             * of certification path building, GLib does not provide any way to know
             * which certification path will actually be used. Accordingly, this
             * property cannot be used to make security-related decisions. Only
             * GLib itself should make security decisions about TLS certificates.
             */
            issuer?: TlsCertificate | null;
            /**
             * An optional password used when constructed with GTlsCertificate:pkcs12-data.
             */
            password?: string | null;
            /**
             * A URI referencing the [PKCS \#11](https://docs.oasis-open.org/pkcs11/pkcs11-base/v3.0/os/pkcs11-base-v3.0-os.html)
             * objects containing an X.509 certificate and optionally a private key.
             *
             * If %NULL, the certificate is either not backed by PKCS \#11 or the
             * #GTlsBackend does not support PKCS \#11.
             */
            pkcs11_uri?: string | null;
            /**
             * The PKCS #12 formatted data used to construct the object.
             *
             * See also: g_tls_certificate_new_from_pkcs12()
             */
            pkcs12_data?: Uint8Array | null;
            /**
             * The DER (binary) encoded representation of the certificate's
             * private key, in either [PKCS \#1 format](https://datatracker.ietf.org/doc/html/rfc8017)
             * or unencrypted [PKCS \#8 format.](https://datatracker.ietf.org/doc/html/rfc5208)
             * PKCS \#8 format is supported since 2.32; earlier releases only
             * support PKCS \#1. You can use the `openssl rsa` tool to convert
             * PKCS \#8 keys to PKCS \#1.
             *
             * This property (or the #GTlsCertificate:private-key-pem property)
             * can be set when constructing a key (for example, from a file).
             * Since GLib 2.70, it is now also readable; however, be aware that if
             * the private key is backed by a PKCS \#11 URI  for example, if it
             * is stored on a smartcard  then this property will be %NULL. If so,
             * the private key must be referenced via its PKCS \#11 URI,
             * #GTlsCertificate:private-key-pkcs11-uri. You must check both
             * properties to see if the certificate really has a private key.
             * When this property is read, the output format will be unencrypted
             * PKCS \#8.
             */
            private_key?: Uint8Array | null;
            /**
             * The PEM (ASCII) encoded representation of the certificate's
             * private key in either [PKCS \#1 format](https://datatracker.ietf.org/doc/html/rfc8017)
             * ("`BEGIN RSA PRIVATE KEY`") or unencrypted
             * [PKCS \#8 format](https://datatracker.ietf.org/doc/html/rfc5208)
             * ("`BEGIN PRIVATE KEY`"). PKCS \#8 format is supported since 2.32;
             * earlier releases only support PKCS \#1. You can use the `openssl rsa`
             * tool to convert PKCS \#8 keys to PKCS \#1.
             *
             * This property (or the #GTlsCertificate:private-key property)
             * can be set when constructing a key (for example, from a file).
             * Since GLib 2.70, it is now also readable; however, be aware that if
             * the private key is backed by a PKCS \#11 URI - for example, if it
             * is stored on a smartcard - then this property will be %NULL. If so,
             * the private key must be referenced via its PKCS \#11 URI,
             * #GTlsCertificate:private-key-pkcs11-uri. You must check both
             * properties to see if the certificate really has a private key.
             * When this property is read, the output format will be unencrypted
             * PKCS \#8.
             */
            private_key_pem?: string | null;
            /**
             * A URI referencing a [PKCS \#11](https://docs.oasis-open.org/pkcs11/pkcs11-base/v3.0/os/pkcs11-base-v3.0-os.html)
             * object containing a private key.
             */
            private_key_pkcs11_uri?: string | null;
        }
    }

    interface TlsCertificate {
        // Own properties of Gio-2.0.Gio.TlsCertificate

        /**
         * The DER (binary) encoded representation of the certificate.
         * This property and the #GTlsCertificate:certificate-pem property
         * represent the same data, just in different forms.
         */
        readonly certificate: Uint8Array;
        /**
         * The PEM (ASCII) encoded representation of the certificate.
         * This property and the #GTlsCertificate:certificate
         * property represent the same data, just in different forms.
         */
        readonly certificate_pem: string | null;
        /**
         * The DNS names from the certificate's Subject Alternative Names (SANs),
         * %NULL if unavailable.
         */
        readonly dns_names: any[];
        /**
         * The IP addresses from the certificate's Subject Alternative Names (SANs),
         * %NULL if unavailable.
         */
        readonly ip_addresses: any[];
        /**
         * A #GTlsCertificate representing the entity that issued this
         * certificate. If %NULL, this means that the certificate is either
         * self-signed, or else the certificate of the issuer is not
         * available.
         *
         * Beware the issuer certificate may not be the same as the
         * certificate that would actually be used to construct a valid
         * certification path during certificate verification.
         * [RFC 4158](https://datatracker.ietf.org/doc/html/rfc4158) explains
         * why an issuer certificate cannot be naively assumed to be part of the
         * the certification path (though GLib's TLS backends may not follow the
         * path building strategies outlined in this RFC). Due to the complexity
         * of certification path building, GLib does not provide any way to know
         * which certification path will actually be used. Accordingly, this
         * property cannot be used to make security-related decisions. Only
         * GLib itself should make security decisions about TLS certificates.
         */
        readonly issuer: TlsCertificate;
        /**
         * The issuer from the certificate,
         * %NULL if unavailable.
         */
        readonly issuer_name: string | null;
        /**
         * The time at which this cert is no longer valid,
         * %NULL if unavailable.
         */
        readonly not_valid_after: GLib.DateTime;
        /**
         * The time at which this cert is considered to be valid,
         * %NULL if unavailable.
         */
        readonly not_valid_before: GLib.DateTime;
        /**
         * An optional password used when constructed with GTlsCertificate:pkcs12-data.
         */
        readonly password: string | null;
        /**
         * A URI referencing the [PKCS \#11](https://docs.oasis-open.org/pkcs11/pkcs11-base/v3.0/os/pkcs11-base-v3.0-os.html)
         * objects containing an X.509 certificate and optionally a private key.
         *
         * If %NULL, the certificate is either not backed by PKCS \#11 or the
         * #GTlsBackend does not support PKCS \#11.
         */
        readonly pkcs11_uri: string | null;
        /**
         * The PKCS #12 formatted data used to construct the object.
         *
         * See also: g_tls_certificate_new_from_pkcs12()
         */
        readonly pkcs12_data: Uint8Array;
        /**
         * The DER (binary) encoded representation of the certificate's
         * private key, in either [PKCS \#1 format](https://datatracker.ietf.org/doc/html/rfc8017)
         * or unencrypted [PKCS \#8 format.](https://datatracker.ietf.org/doc/html/rfc5208)
         * PKCS \#8 format is supported since 2.32; earlier releases only
         * support PKCS \#1. You can use the `openssl rsa` tool to convert
         * PKCS \#8 keys to PKCS \#1.
         *
         * This property (or the #GTlsCertificate:private-key-pem property)
         * can be set when constructing a key (for example, from a file).
         * Since GLib 2.70, it is now also readable; however, be aware that if
         * the private key is backed by a PKCS \#11 URI  for example, if it
         * is stored on a smartcard  then this property will be %NULL. If so,
         * the private key must be referenced via its PKCS \#11 URI,
         * #GTlsCertificate:private-key-pkcs11-uri. You must check both
         * properties to see if the certificate really has a private key.
         * When this property is read, the output format will be unencrypted
         * PKCS \#8.
         */
        readonly private_key: Uint8Array;
        /**
         * The PEM (ASCII) encoded representation of the certificate's
         * private key in either [PKCS \#1 format](https://datatracker.ietf.org/doc/html/rfc8017)
         * ("`BEGIN RSA PRIVATE KEY`") or unencrypted
         * [PKCS \#8 format](https://datatracker.ietf.org/doc/html/rfc5208)
         * ("`BEGIN PRIVATE KEY`"). PKCS \#8 format is supported since 2.32;
         * earlier releases only support PKCS \#1. You can use the `openssl rsa`
         * tool to convert PKCS \#8 keys to PKCS \#1.
         *
         * This property (or the #GTlsCertificate:private-key property)
         * can be set when constructing a key (for example, from a file).
         * Since GLib 2.70, it is now also readable; however, be aware that if
         * the private key is backed by a PKCS \#11 URI - for example, if it
         * is stored on a smartcard - then this property will be %NULL. If so,
         * the private key must be referenced via its PKCS \#11 URI,
         * #GTlsCertificate:private-key-pkcs11-uri. You must check both
         * properties to see if the certificate really has a private key.
         * When this property is read, the output format will be unencrypted
         * PKCS \#8.
         */
        readonly private_key_pem: string | null;
        /**
         * A URI referencing a [PKCS \#11](https://docs.oasis-open.org/pkcs11/pkcs11-base/v3.0/os/pkcs11-base-v3.0-os.html)
         * object containing a private key.
         */
        readonly private_key_pkcs11_uri: string | null;
        /**
         * The subject from the cert,
         * %NULL if unavailable.
         */
        readonly subject_name: string | null;

        // Own fields of Gio-2.0.Gio.TlsCertificate

        parent_instance: GObject.Object;
        priv: TlsCertificatePrivate;

        // Owm methods of Gio-2.0.Gio.TlsCertificate

        /**
         * Gets the value of #GTlsCertificate:dns-names.
         * @returns A #GPtrArray of #GBytes elements, or %NULL if it's not available.
         */
        get_dns_names(): GLib.Bytes[] | null;
        /**
         * Gets the value of #GTlsCertificate:ip-addresses.
         * @returns A #GPtrArray of #GInetAddress elements, or %NULL if it's not available.
         */
        get_ip_addresses(): InetAddress[] | null;
        /**
         * Gets the #GTlsCertificate representing `cert'`s issuer, if known
         * @returns The certificate of @cert's issuer, or %NULL if @cert is self-signed or signed with an unknown certificate.
         */
        get_issuer(): TlsCertificate | null;
        /**
         * Returns the issuer name from the certificate.
         * @returns The issuer name, or %NULL if it's not available.
         */
        get_issuer_name(): string | null;
        /**
         * Returns the time at which the certificate became or will become invalid.
         * @returns The not-valid-after date, or %NULL if it's not available.
         */
        get_not_valid_after(): GLib.DateTime | null;
        /**
         * Returns the time at which the certificate became or will become valid.
         * @returns The not-valid-before date, or %NULL if it's not available.
         */
        get_not_valid_before(): GLib.DateTime | null;
        /**
         * Returns the subject name from the certificate.
         * @returns The subject name, or %NULL if it's not available.
         */
        get_subject_name(): string | null;
        /**
         * Check if two #GTlsCertificate objects represent the same certificate.
         * The raw DER byte data of the two certificates are checked for equality.
         * This has the effect that two certificates may compare equal even if
         * their #GTlsCertificate:issuer, #GTlsCertificate:private-key, or
         * #GTlsCertificate:private-key-pem properties differ.
         * @param cert_two second certificate to compare
         * @returns whether the same or not
         */
        is_same(cert_two: TlsCertificate): boolean;
        /**
         * This verifies `cert` and returns a set of #GTlsCertificateFlags
         * indicating any problems found with it. This can be used to verify a
         * certificate outside the context of making a connection, or to
         * check a certificate against a CA that is not part of the system
         * CA database.
         *
         * If `cert` is valid, %G_TLS_CERTIFICATE_NO_FLAGS is returned.
         *
         * If `identity` is not %NULL, `cert'`s name(s) will be compared against
         * it, and %G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the return
         * value if it does not match. If `identity` is %NULL, that bit will
         * never be set in the return value.
         *
         * If `trusted_ca` is not %NULL, then `cert` (or one of the certificates
         * in its chain) must be signed by it, or else
         * %G_TLS_CERTIFICATE_UNKNOWN_CA will be set in the return value. If
         * `trusted_ca` is %NULL, that bit will never be set in the return
         * value.
         *
         * GLib guarantees that if certificate verification fails, at least one
         * error will be set in the return value, but it does not guarantee
         * that all possible errors will be set. Accordingly, you may not safely
         * decide to ignore any particular type of error. For example, it would
         * be incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
         * expired certificates, because this could potentially be the only
         * error flag set even if other problems exist with the certificate.
         *
         * Because TLS session context is not used, #GTlsCertificate may not
         * perform as many checks on the certificates as #GTlsConnection would.
         * For example, certificate constraints may not be honored, and
         * revocation checks may not be performed. The best way to verify TLS
         * certificates used by a TLS connection is to let #GTlsConnection
         * handle the verification.
         * @param identity the expected peer identity
         * @param trusted_ca the certificate of a trusted authority
         * @returns the appropriate #GTlsCertificateFlags
         */
        verify(
            identity: SocketConnectable | null,
            trusted_ca: TlsCertificate | null
        ): TlsCertificateFlags;

        // Own virtual methods of Gio-2.0.Gio.TlsCertificate

        /**
         * This verifies `cert` and returns a set of #GTlsCertificateFlags
         * indicating any problems found with it. This can be used to verify a
         * certificate outside the context of making a connection, or to
         * check a certificate against a CA that is not part of the system
         * CA database.
         *
         * If `cert` is valid, %G_TLS_CERTIFICATE_NO_FLAGS is returned.
         *
         * If `identity` is not %NULL, `cert'`s name(s) will be compared against
         * it, and %G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the return
         * value if it does not match. If `identity` is %NULL, that bit will
         * never be set in the return value.
         *
         * If `trusted_ca` is not %NULL, then `cert` (or one of the certificates
         * in its chain) must be signed by it, or else
         * %G_TLS_CERTIFICATE_UNKNOWN_CA will be set in the return value. If
         * `trusted_ca` is %NULL, that bit will never be set in the return
         * value.
         *
         * GLib guarantees that if certificate verification fails, at least one
         * error will be set in the return value, but it does not guarantee
         * that all possible errors will be set. Accordingly, you may not safely
         * decide to ignore any particular type of error. For example, it would
         * be incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
         * expired certificates, because this could potentially be the only
         * error flag set even if other problems exist with the certificate.
         *
         * Because TLS session context is not used, #GTlsCertificate may not
         * perform as many checks on the certificates as #GTlsConnection would.
         * For example, certificate constraints may not be honored, and
         * revocation checks may not be performed. The best way to verify TLS
         * certificates used by a TLS connection is to let #GTlsConnection
         * handle the verification.
         * @virtual
         * @param identity the expected peer identity
         * @param trusted_ca the certificate of a trusted authority
         * @returns the appropriate #GTlsCertificateFlags
         */
        vfunc_verify(
            identity: SocketConnectable | null,
            trusted_ca: TlsCertificate | null
        ): TlsCertificateFlags;

        // Class property signals of Gio-2.0.Gio.TlsCertificate

        connect(
            sigName: 'notify::certificate',
            callback: ($obj: TlsCertificate, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::certificate',
            callback: ($obj: TlsCertificate, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::certificate', ...args: any[]): void;
        connect(
            sigName: 'notify::certificate-pem',
            callback: ($obj: TlsCertificate, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::certificate-pem',
            callback: ($obj: TlsCertificate, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::certificate-pem', ...args: any[]): void;
        connect(
            sigName: 'notify::dns-names',
            callback: ($obj: TlsCertificate, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::dns-names',
            callback: ($obj: TlsCertificate, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::dns-names', ...args: any[]): void;
        connect(
            sigName: 'notify::ip-addresses',
            callback: ($obj: TlsCertificate, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::ip-addresses',
            callback: ($obj: TlsCertificate, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::ip-addresses', ...args: any[]): void;
        connect(
            sigName: 'notify::issuer',
            callback: ($obj: TlsCertificate, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::issuer',
            callback: ($obj: TlsCertificate, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::issuer', ...args: any[]): void;
        connect(
            sigName: 'notify::issuer-name',
            callback: ($obj: TlsCertificate, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::issuer-name',
            callback: ($obj: TlsCertificate, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::issuer-name', ...args: any[]): void;
        connect(
            sigName: 'notify::not-valid-after',
            callback: ($obj: TlsCertificate, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::not-valid-after',
            callback: ($obj: TlsCertificate, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::not-valid-after', ...args: any[]): void;
        connect(
            sigName: 'notify::not-valid-before',
            callback: ($obj: TlsCertificate, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::not-valid-before',
            callback: ($obj: TlsCertificate, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::not-valid-before', ...args: any[]): void;
        connect(
            sigName: 'notify::password',
            callback: ($obj: TlsCertificate, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::password',
            callback: ($obj: TlsCertificate, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::password', ...args: any[]): void;
        connect(
            sigName: 'notify::pkcs11-uri',
            callback: ($obj: TlsCertificate, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::pkcs11-uri',
            callback: ($obj: TlsCertificate, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::pkcs11-uri', ...args: any[]): void;
        connect(
            sigName: 'notify::pkcs12-data',
            callback: ($obj: TlsCertificate, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::pkcs12-data',
            callback: ($obj: TlsCertificate, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::pkcs12-data', ...args: any[]): void;
        connect(
            sigName: 'notify::private-key',
            callback: ($obj: TlsCertificate, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::private-key',
            callback: ($obj: TlsCertificate, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::private-key', ...args: any[]): void;
        connect(
            sigName: 'notify::private-key-pem',
            callback: ($obj: TlsCertificate, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::private-key-pem',
            callback: ($obj: TlsCertificate, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::private-key-pem', ...args: any[]): void;
        connect(
            sigName: 'notify::private-key-pkcs11-uri',
            callback: ($obj: TlsCertificate, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::private-key-pkcs11-uri',
            callback: ($obj: TlsCertificate, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::private-key-pkcs11-uri', ...args: any[]): void;
        connect(
            sigName: 'notify::subject-name',
            callback: ($obj: TlsCertificate, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::subject-name',
            callback: ($obj: TlsCertificate, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::subject-name', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * A certificate used for TLS authentication and encryption.
     * This can represent either a certificate only (eg, the certificate
     * received by a client from a server), or the combination of
     * a certificate and a private key (which is needed when acting as a
     * #GTlsServerConnection).
     * @class
     */
    class TlsCertificate extends GObject.Object {
        // Own properties of Gio-2.0.Gio.TlsCertificate

        static name: string;
        static $gtype: GObject.GType<TlsCertificate>;

        // Constructors of Gio-2.0.Gio.TlsCertificate

        constructor(config?: TlsCertificate.ConstructorProperties);
        /**
         * Creates a #GTlsCertificate from the data in `file`.
         *
         * As of 2.72, if the filename ends in `.p12` or `.pfx` the data is loaded by
         * g_tls_certificate_new_from_pkcs12() otherwise it is loaded by
         * g_tls_certificate_new_from_pem(). See those functions for
         * exact details.
         *
         * If `file` cannot be read or parsed, the function will return %NULL and
         * set `error`.
         * @constructor
         * @param file file containing a certificate to import
         * @returns the new certificate, or %NULL on error
         */
        static new_from_file(file: string): TlsCertificate;
        /**
         * Creates a #GTlsCertificate from the data in `file`.
         *
         * If `file` cannot be read or parsed, the function will return %NULL and
         * set `error`.
         *
         * Any unknown file types will error with %G_IO_ERROR_NOT_SUPPORTED.
         * Currently only `.p12` and `.pfx` files are supported.
         * See g_tls_certificate_new_from_pkcs12() for more details.
         * @constructor
         * @param file file containing a certificate to import
         * @param password password for PKCS #12 files
         * @returns the new certificate, or %NULL on error
         */
        static new_from_file_with_password(
            file: string,
            password: string | null
        ): TlsCertificate;
        /**
         * Creates a #GTlsCertificate from the PEM-encoded data in `cert_file`
         * and `key_file`. The returned certificate will be the first certificate
         * found in `cert_file`. As of GLib 2.44, if `cert_file` contains more
         * certificates it will try to load a certificate chain. All
         * certificates will be verified in the order found (top-level
         * certificate should be the last one in the file) and the
         * #GTlsCertificate:issuer property of each certificate will be set
         * accordingly if the verification succeeds. If any certificate in the
         * chain cannot be verified, the first certificate in the file will
         * still be returned.
         *
         * If either file cannot be read or parsed, the function will return
         * %NULL and set `error`. Otherwise, this behaves like
         * g_tls_certificate_new_from_pem().
         * @constructor
         * @param cert_file file containing one or more PEM-encoded     certificates to import
         * @param key_file file containing a PEM-encoded private key     to import
         * @returns the new certificate, or %NULL on error
         */
        static new_from_files(
            cert_file: string,
            key_file: string
        ): TlsCertificate;
        /**
         * Creates a #GTlsCertificate from the PEM-encoded data in `data`. If
         * `data` includes both a certificate and a private key, then the
         * returned certificate will include the private key data as well. (See
         * the #GTlsCertificate:private-key-pem property for information about
         * supported formats.)
         *
         * The returned certificate will be the first certificate found in
         * `data`. As of GLib 2.44, if `data` contains more certificates it will
         * try to load a certificate chain. All certificates will be verified in
         * the order found (top-level certificate should be the last one in the
         * file) and the #GTlsCertificate:issuer property of each certificate
         * will be set accordingly if the verification succeeds. If any
         * certificate in the chain cannot be verified, the first certificate in
         * the file will still be returned.
         * @constructor
         * @param data PEM-encoded certificate data
         * @param length the length of `data,` or -1 if it's 0-terminated.
         * @returns the new certificate, or %NULL if @data is invalid
         */
        static new_from_pem(
            data: string | null,
            length: number
        ): TlsCertificate;
        /**
         * Creates a #GTlsCertificate from a
         * [PKCS \#11](https://docs.oasis-open.org/pkcs11/pkcs11-base/v3.0/os/pkcs11-base-v3.0-os.html) URI.
         *
         * An example `pkcs1`1_uri would be `pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My%20Client%20Certificate;id=%01`
         *
         * Where the tokens layout is:
         *
         *
         * ```
         * Object 0:
         *   URL: pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My%20Client%20Certificate;id=%01;object=private%20key;type=private
         *   Type: Private key (RSA-2048)
         *   ID: 01
         *
         * Object 1:
         *   URL: pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My%20Client%20Certificate;id=%01;object=Certificate%20for%20Authentication;type=cert
         *   Type: X.509 Certificate (RSA-2048)
         *   ID: 01
         * ```
         *
         *
         * In this case the certificate and private key would both be detected and used as expected.
         * `pkcs_uri` may also just reference an X.509 certificate object and then optionally
         * `private_key_pkcs1`1_uri allows using a private key exposed under a different URI.
         *
         * Note that the private key is not accessed until usage and may fail or require a PIN later.
         * @constructor
         * @param pkcs11_uri A PKCS \#11 URI
         * @param private_key_pkcs11_uri A PKCS \#11 URI
         * @returns the new certificate, or %NULL on error
         */
        static new_from_pkcs11_uris(
            pkcs11_uri: string | null,
            private_key_pkcs11_uri: string | null
        ): TlsCertificate;
        /**
         * Creates a #GTlsCertificate from the data in `data`. It must contain
         * a certificate and matching private key.
         *
         * If extra certificates are included they will be verified as a chain
         * and the #GTlsCertificate:issuer property will be set.
         * All other data will be ignored.
         *
         * You can pass as single password for all of the data which will be
         * used both for the PKCS #12 container as well as encrypted
         * private keys. If decryption fails it will error with
         * %G_TLS_ERROR_BAD_CERTIFICATE_PASSWORD.
         *
         * This constructor requires support in the current #GTlsBackend.
         * If support is missing it will error with
         * %G_IO_ERROR_NOT_SUPPORTED.
         *
         * Other parsing failures will error with %G_TLS_ERROR_BAD_CERTIFICATE.
         * @constructor
         * @param data DER-encoded PKCS #12 format certificate data
         * @param password optional password for encrypted certificate data
         * @returns the new certificate, or %NULL if @data is invalid
         */
        static new_from_pkcs12(
            data: Uint8Array,
            password: string | null
        ): TlsCertificate;
        _init(config?: TlsCertificate.ConstructorProperties): void;
        /**
         * Creates one or more #GTlsCertificates from the PEM-encoded
         * data in `file`. If `file` cannot be read or parsed, the function will
         * return %NULL and set `error`. If `file` does not contain any
         * PEM-encoded certificates, this will return an empty list and not
         * set `error`.
         * @param file file containing PEM-encoded certificates to import
         * @returns a #GList containing #GTlsCertificate objects. You must free the list and its contents when you are done with it.
         */
        static list_new_from_file(file: string): TlsCertificate[];
    }

    namespace TlsConnection {
        // Signal callback interfaces

        /**
         * Signal callback interface for `accept-certificate`
         */
        interface AcceptCertificateSignalCallback {
            (
                $obj: TlsConnection,
                peer_cert: TlsCertificate,
                errors: TlsCertificateFlags
            ): boolean;
        }

        // Constructor properties interface

        interface ConstructorProperties
            extends IOStream.ConstructorProperties,
                GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.TlsConnection

            /**
             * The list of application-layer protocols that the connection
             * advertises that it is willing to speak. See
             * g_tls_connection_set_advertised_protocols().
             */
            advertised_protocols?: string[] | null;
            /**
             * The #GIOStream that the connection wraps. The connection holds a reference
             * to this stream, and may run operations on the stream from other threads
             * throughout its lifetime. Consequently, after the #GIOStream has been
             * constructed, application code may only run its own operations on this
             * stream when no #GIOStream operations are running.
             */
            base_io_stream?: IOStream | null;
            /**
             * The connection's certificate; see
             * g_tls_connection_set_certificate().
             */
            certificate?: TlsCertificate | null;
            /**
             * The certificate database to use when verifying this TLS connection.
             * If no certificate database is set, then the default database will be
             * used. See g_tls_backend_get_default_database().
             *
             * When using a non-default database, #GTlsConnection must fall back to using
             * the #GTlsDatabase to perform certificate verification using
             * g_tls_database_verify_chain(), which means certificate verification will
             * not be able to make use of TLS session context. This may be less secure.
             * For example, if you create your own #GTlsDatabase that just wraps the
             * default #GTlsDatabase, you might expect that you have not changed anything,
             * but this is not true because you may have altered the behavior of
             * #GTlsConnection by causing it to use g_tls_database_verify_chain(). See the
             * documentation of g_tls_database_verify_chain() for more details on specific
             * security checks that may not be performed. Accordingly, setting a
             * non-default database is discouraged except for specialty applications with
             * unusual security requirements.
             */
            database?: TlsDatabase | null;
            /**
             * A #GTlsInteraction object to be used when the connection or certificate
             * database need to interact with the user. This will be used to prompt the
             * user for passwords where necessary.
             */
            interaction?: TlsInteraction | null;
            /**
             * The rehandshaking mode. See
             * g_tls_connection_set_rehandshake_mode().
             */
            rehandshake_mode?: TlsRehandshakeMode | null;
            /**
             * Whether or not proper TLS close notification is required.
             * See g_tls_connection_set_require_close_notify().
             */
            require_close_notify?: boolean | null;
            /**
             * Whether or not the system certificate database will be used to
             * verify peer certificates. See
             * g_tls_connection_set_use_system_certdb().
             */
            use_system_certdb?: boolean | null;
        }
    }

    interface TlsConnection {
        // Own properties of Gio-2.0.Gio.TlsConnection

        /**
         * The list of application-layer protocols that the connection
         * advertises that it is willing to speak. See
         * g_tls_connection_set_advertised_protocols().
         */
        advertised_protocols: string[];
        /**
         * The #GIOStream that the connection wraps. The connection holds a reference
         * to this stream, and may run operations on the stream from other threads
         * throughout its lifetime. Consequently, after the #GIOStream has been
         * constructed, application code may only run its own operations on this
         * stream when no #GIOStream operations are running.
         */
        readonly base_io_stream: IOStream;
        /**
         * The connection's certificate; see
         * g_tls_connection_set_certificate().
         */
        certificate: TlsCertificate;
        /**
         * The name of the TLS ciphersuite in use. See g_tls_connection_get_ciphersuite_name().
         */
        readonly ciphersuite_name: string | null;
        /**
         * The certificate database to use when verifying this TLS connection.
         * If no certificate database is set, then the default database will be
         * used. See g_tls_backend_get_default_database().
         *
         * When using a non-default database, #GTlsConnection must fall back to using
         * the #GTlsDatabase to perform certificate verification using
         * g_tls_database_verify_chain(), which means certificate verification will
         * not be able to make use of TLS session context. This may be less secure.
         * For example, if you create your own #GTlsDatabase that just wraps the
         * default #GTlsDatabase, you might expect that you have not changed anything,
         * but this is not true because you may have altered the behavior of
         * #GTlsConnection by causing it to use g_tls_database_verify_chain(). See the
         * documentation of g_tls_database_verify_chain() for more details on specific
         * security checks that may not be performed. Accordingly, setting a
         * non-default database is discouraged except for specialty applications with
         * unusual security requirements.
         */
        database: TlsDatabase;
        /**
         * A #GTlsInteraction object to be used when the connection or certificate
         * database need to interact with the user. This will be used to prompt the
         * user for passwords where necessary.
         */
        interaction: TlsInteraction;
        /**
         * The application-layer protocol negotiated during the TLS
         * handshake. See g_tls_connection_get_negotiated_protocol().
         */
        readonly negotiated_protocol: string | null;
        /**
         * The connection's peer's certificate, after the TLS handshake has
         * completed or failed. Note in particular that this is not yet set
         * during the emission of #GTlsConnection::accept-certificate.
         *
         * (You can watch for a #GObject::notify signal on this property to
         * detect when a handshake has occurred.)
         */
        readonly peer_certificate: TlsCertificate;
        /**
         * The errors noticed while verifying
         * #GTlsConnection:peer-certificate. Normally this should be 0, but
         * it may not be if #GTlsClientConnection:validation-flags is not
         * %G_TLS_CERTIFICATE_VALIDATE_ALL, or if
         * #GTlsConnection::accept-certificate overrode the default
         * behavior.
         *
         * GLib guarantees that if certificate verification fails, at least
         * one error will be set, but it does not guarantee that all possible
         * errors will be set. Accordingly, you may not safely decide to
         * ignore any particular type of error. For example, it would be
         * incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
         * expired certificates, because this could potentially be the only
         * error flag set even if other problems exist with the certificate.
         */
        readonly peer_certificate_errors: TlsCertificateFlags;
        /**
         * The TLS protocol version in use. See g_tls_connection_get_protocol_version().
         */
        readonly protocol_version: TlsProtocolVersion;
        /**
         * The rehandshaking mode. See
         * g_tls_connection_set_rehandshake_mode().
         */
        rehandshake_mode: TlsRehandshakeMode;
        /**
         * Whether or not proper TLS close notification is required.
         * See g_tls_connection_set_require_close_notify().
         */
        require_close_notify: boolean;
        /**
         * Whether or not the system certificate database will be used to
         * verify peer certificates. See
         * g_tls_connection_set_use_system_certdb().
         */
        use_system_certdb: boolean;

        // Own fields of Gio-2.0.Gio.TlsConnection

        parent_instance: IOStream & GObject.Object;
        priv: TlsConnectionPrivate;

        // Owm methods of Gio-2.0.Gio.TlsConnection

        /**
         * Used by #GTlsConnection implementations to emit the
         * #GTlsConnection::accept-certificate signal.
         * @param peer_cert the peer's #GTlsCertificate
         * @param errors the problems with `peer_cert`
         * @returns %TRUE if one of the signal handlers has returned     %TRUE to accept @peer_cert
         */
        emit_accept_certificate(
            peer_cert: TlsCertificate,
            errors: TlsCertificateFlags
        ): boolean;
        /**
         * Gets `conn'`s certificate, as set by
         * g_tls_connection_set_certificate().
         * @returns @conn's certificate, or %NULL
         */
        get_certificate(): TlsCertificate | null;
        /**
         * Query the TLS backend for TLS channel binding data of `type` for `conn`.
         *
         * This call retrieves TLS channel binding data as specified in RFC
         * [5056](https://tools.ietf.org/html/rfc5056), RFC
         * [5929](https://tools.ietf.org/html/rfc5929), and related RFCs.  The
         * binding data is returned in `data`.  The `data` is resized by the callee
         * using #GByteArray buffer management and will be freed when the `data`
         * is destroyed by g_byte_array_unref(). If `data` is %NULL, it will only
         * check whether TLS backend is able to fetch the data (e.g. whether `type`
         * is supported by the TLS backend). It does not guarantee that the data
         * will be available though.  That could happen if TLS connection does not
         * support `type` or the binding data is not available yet due to additional
         * negotiation or input required.
         * @param type #GTlsChannelBindingType type of data to fetch
         * @returns %TRUE on success, %FALSE otherwise
         */
        get_channel_binding_data(
            type: TlsChannelBindingType
        ): [/* returnType */ boolean, /* data */ Uint8Array];
        /**
         * Returns the name of the current TLS ciphersuite, or %NULL if the
         * connection has not handshaked or has been closed. Beware that the TLS
         * backend may use any of multiple different naming conventions, because
         * OpenSSL and GnuTLS have their own ciphersuite naming conventions that
         * are different from each other and different from the standard, IANA-
         * registered ciphersuite names. The ciphersuite name is intended to be
         * displayed to the user for informative purposes only, and parsing it
         * is not recommended.
         * @returns The name of the current TLS ciphersuite, or %NULL
         */
        get_ciphersuite_name(): string | null;
        /**
         * Gets the certificate database that `conn` uses to verify
         * peer certificates. See g_tls_connection_set_database().
         * @returns the certificate database that @conn uses or %NULL
         */
        get_database(): TlsDatabase | null;
        /**
         * Get the object that will be used to interact with the user. It will be used
         * for things like prompting the user for passwords. If %NULL is returned, then
         * no user interaction will occur for this connection.
         * @returns The interaction object.
         */
        get_interaction(): TlsInteraction | null;
        /**
         * Gets the name of the application-layer protocol negotiated during
         * the handshake.
         *
         * If the peer did not use the ALPN extension, or did not advertise a
         * protocol that matched one of `conn'`s protocols, or the TLS backend
         * does not support ALPN, then this will be %NULL. See
         * g_tls_connection_set_advertised_protocols().
         * @returns the negotiated protocol, or %NULL
         */
        get_negotiated_protocol(): string | null;
        /**
         * Gets `conn'`s peer's certificate after the handshake has completed
         * or failed. (It is not set during the emission of
         * #GTlsConnection::accept-certificate.)
         * @returns @conn's peer's certificate, or %NULL
         */
        get_peer_certificate(): TlsCertificate | null;
        /**
         * Gets the errors associated with validating `conn'`s peer's
         * certificate, after the handshake has completed or failed. (It is
         * not set during the emission of #GTlsConnection::accept-certificate.)
         *
         * See #GTlsConnection:peer-certificate-errors for more information.
         * @returns @conn's peer's certificate errors
         */
        get_peer_certificate_errors(): TlsCertificateFlags;
        /**
         * Returns the current TLS protocol version, which may be
         * %G_TLS_PROTOCOL_VERSION_UNKNOWN if the connection has not handshaked, or
         * has been closed, or if the TLS backend has implemented a protocol version
         * that is not a recognized #GTlsProtocolVersion.
         * @returns The current TLS protocol version
         */
        get_protocol_version(): TlsProtocolVersion;
        /**
         * Gets `conn` rehandshaking mode. See
         * g_tls_connection_set_rehandshake_mode() for details.
         * @returns %G_TLS_REHANDSHAKE_SAFELY
         */
        get_rehandshake_mode(): TlsRehandshakeMode;
        /**
         * Tests whether or not `conn` expects a proper TLS close notification
         * when the connection is closed. See
         * g_tls_connection_set_require_close_notify() for details.
         * @returns %TRUE if @conn requires a proper TLS close notification.
         */
        get_require_close_notify(): boolean;
        /**
         * Gets whether `conn` uses the system certificate database to verify
         * peer certificates. See g_tls_connection_set_use_system_certdb().
         * @returns whether @conn uses the system certificate database
         */
        get_use_system_certdb(): boolean;
        /**
         * Attempts a TLS handshake on `conn`.
         *
         * On the client side, it is never necessary to call this method;
         * although the connection needs to perform a handshake after
         * connecting (or after sending a "STARTTLS"-type command),
         * #GTlsConnection will handle this for you automatically when you try
         * to send or receive data on the connection. You can call
         * g_tls_connection_handshake() manually if you want to know whether
         * the initial handshake succeeded or failed (as opposed to just
         * immediately trying to use `conn` to read or write, in which case,
         * if it fails, it may not be possible to tell if it failed before or
         * after completing the handshake), but beware that servers may reject
         * client authentication after the handshake has completed, so a
         * successful handshake does not indicate the connection will be usable.
         *
         * Likewise, on the server side, although a handshake is necessary at
         * the beginning of the communication, you do not need to call this
         * function explicitly unless you want clearer error reporting.
         *
         * Previously, calling g_tls_connection_handshake() after the initial
         * handshake would trigger a rehandshake; however, this usage was
         * deprecated in GLib 2.60 because rehandshaking was removed from the
         * TLS protocol in TLS 1.3. Since GLib 2.64, calling this function after
         * the initial handshake will no longer do anything.
         *
         * When using a #GTlsConnection created by #GSocketClient, the
         * #GSocketClient performs the initial handshake, so calling this
         * function manually is not recommended.
         *
         * #GTlsConnection::accept_certificate may be emitted during the
         * handshake.
         * @param cancellable a #GCancellable, or %NULL
         * @returns success or failure
         */
        handshake(cancellable: Cancellable | null): boolean;
        /**
         * Asynchronously performs a TLS handshake on `conn`. See
         * g_tls_connection_handshake() for more information.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call when the handshake is complete
         */
        handshake_async(
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of handshake_async

        /**
         * Promisified version of {@link handshake_async}
         *
         * Asynchronously performs a TLS handshake on `conn`. See
         * g_tls_connection_handshake() for more information.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable a #GCancellable, or %NULL
         * @returns A Promise of: %TRUE on success, %FALSE on failure, in which case @error will be set.
         */
        handshake_async(
            io_priority: number,
            cancellable: Cancellable | null
        ): globalThis.Promise<boolean>;
        /**
         * Finish an asynchronous TLS handshake operation. See
         * g_tls_connection_handshake() for more information.
         * @param result a #GAsyncResult.
         * @returns %TRUE on success, %FALSE on failure, in which case @error will be set.
         */
        handshake_finish(result: AsyncResult): boolean;
        /**
         * Sets the list of application-layer protocols to advertise that the
         * caller is willing to speak on this connection. The
         * Application-Layer Protocol Negotiation (ALPN) extension will be
         * used to negotiate a compatible protocol with the peer; use
         * g_tls_connection_get_negotiated_protocol() to find the negotiated
         * protocol after the handshake.  Specifying %NULL for the the value
         * of `protocols` will disable ALPN negotiation.
         *
         * See [IANA TLS ALPN Protocol IDs](https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)
         * for a list of registered protocol IDs.
         * @param protocols a %NULL-terminated   array of ALPN protocol names (eg, "http/1.1", "h2"), or %NULL
         */
        set_advertised_protocols(protocols: string[] | null): void;
        /**
         * This sets the certificate that `conn` will present to its peer
         * during the TLS handshake. For a #GTlsServerConnection, it is
         * mandatory to set this, and that will normally be done at construct
         * time.
         *
         * For a #GTlsClientConnection, this is optional. If a handshake fails
         * with %G_TLS_ERROR_CERTIFICATE_REQUIRED, that means that the server
         * requires a certificate, and if you try connecting again, you should
         * call this method first. You can call
         * g_tls_client_connection_get_accepted_cas() on the failed connection
         * to get a list of Certificate Authorities that the server will
         * accept certificates from.
         *
         * (It is also possible that a server will allow the connection with
         * or without a certificate; in that case, if you don't provide a
         * certificate, you can tell that the server requested one by the fact
         * that g_tls_client_connection_get_accepted_cas() will return
         * non-%NULL.)
         * @param certificate the certificate to use for `conn`
         */
        set_certificate(certificate: TlsCertificate): void;
        /**
         * Sets the certificate database that is used to verify peer certificates.
         * This is set to the default database by default. See
         * g_tls_backend_get_default_database(). If set to %NULL, then
         * peer certificate validation will always set the
         * %G_TLS_CERTIFICATE_UNKNOWN_CA error (meaning
         * #GTlsConnection::accept-certificate will always be emitted on
         * client-side connections, unless that bit is not set in
         * #GTlsClientConnection:validation-flags).
         *
         * There are nonintuitive security implications when using a non-default
         * database. See #GTlsConnection:database for details.
         * @param database a #GTlsDatabase
         */
        set_database(database: TlsDatabase | null): void;
        /**
         * Set the object that will be used to interact with the user. It will be used
         * for things like prompting the user for passwords.
         *
         * The `interaction` argument will normally be a derived subclass of
         * #GTlsInteraction. %NULL can also be provided if no user interaction
         * should occur for this connection.
         * @param interaction an interaction object, or %NULL
         */
        set_interaction(interaction: TlsInteraction | null): void;
        /**
         * Since GLib 2.64, changing the rehandshake mode is no longer supported
         * and will have no effect. With TLS 1.3, rehandshaking has been removed from
         * the TLS protocol, replaced by separate post-handshake authentication and
         * rekey operations.
         * @param mode the rehandshaking mode
         */
        set_rehandshake_mode(mode: TlsRehandshakeMode): void;
        /**
         * Sets whether or not `conn` expects a proper TLS close notification
         * before the connection is closed. If this is %TRUE (the default),
         * then `conn` will expect to receive a TLS close notification from its
         * peer before the connection is closed, and will return a
         * %G_TLS_ERROR_EOF error if the connection is closed without proper
         * notification (since this may indicate a network error, or
         * man-in-the-middle attack).
         *
         * In some protocols, the application will know whether or not the
         * connection was closed cleanly based on application-level data
         * (because the application-level data includes a length field, or is
         * somehow self-delimiting); in this case, the close notify is
         * redundant and sometimes omitted. (TLS 1.1 explicitly allows this;
         * in TLS 1.0 it is technically an error, but often done anyway.) You
         * can use g_tls_connection_set_require_close_notify() to tell `conn`
         * to allow an "unannounced" connection close, in which case the close
         * will show up as a 0-length read, as in a non-TLS
         * #GSocketConnection, and it is up to the application to check that
         * the data has been fully received.
         *
         * Note that this only affects the behavior when the peer closes the
         * connection; when the application calls g_io_stream_close() itself
         * on `conn,` this will send a close notification regardless of the
         * setting of this property. If you explicitly want to do an unclean
         * close, you can close `conn'`s #GTlsConnection:base-io-stream rather
         * than closing `conn` itself, but note that this may only be done when no other
         * operations are pending on `conn` or the base I/O stream.
         * @param require_close_notify whether or not to require close notification
         */
        set_require_close_notify(require_close_notify: boolean): void;
        /**
         * Sets whether `conn` uses the system certificate database to verify
         * peer certificates. This is %TRUE by default. If set to %FALSE, then
         * peer certificate validation will always set the
         * %G_TLS_CERTIFICATE_UNKNOWN_CA error (meaning
         * #GTlsConnection::accept-certificate will always be emitted on
         * client-side connections, unless that bit is not set in
         * #GTlsClientConnection:validation-flags).
         * @param use_system_certdb whether to use the system certificate database
         */
        set_use_system_certdb(use_system_certdb: boolean): void;

        // Own virtual methods of Gio-2.0.Gio.TlsConnection

        vfunc_accept_certificate(
            peer_cert: TlsCertificate,
            errors: TlsCertificateFlags
        ): boolean;
        vfunc_get_binding_data(
            type: TlsChannelBindingType,
            data: Uint8Array
        ): boolean;
        /**
         * Gets the name of the application-layer protocol negotiated during
         * the handshake.
         *
         * If the peer did not use the ALPN extension, or did not advertise a
         * protocol that matched one of `conn'`s protocols, or the TLS backend
         * does not support ALPN, then this will be %NULL. See
         * g_tls_connection_set_advertised_protocols().
         * @virtual
         * @returns the negotiated protocol, or %NULL
         */
        vfunc_get_negotiated_protocol(): string | null;
        /**
         * Attempts a TLS handshake on `conn`.
         *
         * On the client side, it is never necessary to call this method;
         * although the connection needs to perform a handshake after
         * connecting (or after sending a "STARTTLS"-type command),
         * #GTlsConnection will handle this for you automatically when you try
         * to send or receive data on the connection. You can call
         * g_tls_connection_handshake() manually if you want to know whether
         * the initial handshake succeeded or failed (as opposed to just
         * immediately trying to use `conn` to read or write, in which case,
         * if it fails, it may not be possible to tell if it failed before or
         * after completing the handshake), but beware that servers may reject
         * client authentication after the handshake has completed, so a
         * successful handshake does not indicate the connection will be usable.
         *
         * Likewise, on the server side, although a handshake is necessary at
         * the beginning of the communication, you do not need to call this
         * function explicitly unless you want clearer error reporting.
         *
         * Previously, calling g_tls_connection_handshake() after the initial
         * handshake would trigger a rehandshake; however, this usage was
         * deprecated in GLib 2.60 because rehandshaking was removed from the
         * TLS protocol in TLS 1.3. Since GLib 2.64, calling this function after
         * the initial handshake will no longer do anything.
         *
         * When using a #GTlsConnection created by #GSocketClient, the
         * #GSocketClient performs the initial handshake, so calling this
         * function manually is not recommended.
         *
         * #GTlsConnection::accept_certificate may be emitted during the
         * handshake.
         * @virtual
         * @param cancellable a #GCancellable, or %NULL
         * @returns success or failure
         */
        vfunc_handshake(cancellable: Cancellable | null): boolean;
        /**
         * Asynchronously performs a TLS handshake on `conn`. See
         * g_tls_connection_handshake() for more information.
         * @virtual
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call when the handshake is complete
         */
        vfunc_handshake_async(
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finish an asynchronous TLS handshake operation. See
         * g_tls_connection_handshake() for more information.
         * @virtual
         * @param result a #GAsyncResult.
         * @returns %TRUE on success, %FALSE on failure, in which case @error will be set.
         */
        vfunc_handshake_finish(result: AsyncResult): boolean;

        // Own signals of Gio-2.0.Gio.TlsConnection

        connect(
            sigName: 'accept-certificate',
            callback: TlsConnection.AcceptCertificateSignalCallback
        ): number;
        connect_after(
            sigName: 'accept-certificate',
            callback: TlsConnection.AcceptCertificateSignalCallback
        ): number;
        emit(
            sigName: 'accept-certificate',
            peer_cert: TlsCertificate,
            errors: TlsCertificateFlags,
            ...args: any[]
        ): void;

        // Class property signals of Gio-2.0.Gio.TlsConnection

        connect(
            sigName: 'notify::advertised-protocols',
            callback: ($obj: TlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::advertised-protocols',
            callback: ($obj: TlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::advertised-protocols', ...args: any[]): void;
        connect(
            sigName: 'notify::base-io-stream',
            callback: ($obj: TlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::base-io-stream',
            callback: ($obj: TlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::base-io-stream', ...args: any[]): void;
        connect(
            sigName: 'notify::certificate',
            callback: ($obj: TlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::certificate',
            callback: ($obj: TlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::certificate', ...args: any[]): void;
        connect(
            sigName: 'notify::ciphersuite-name',
            callback: ($obj: TlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::ciphersuite-name',
            callback: ($obj: TlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::ciphersuite-name', ...args: any[]): void;
        connect(
            sigName: 'notify::database',
            callback: ($obj: TlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::database',
            callback: ($obj: TlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::database', ...args: any[]): void;
        connect(
            sigName: 'notify::interaction',
            callback: ($obj: TlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::interaction',
            callback: ($obj: TlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::interaction', ...args: any[]): void;
        connect(
            sigName: 'notify::negotiated-protocol',
            callback: ($obj: TlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::negotiated-protocol',
            callback: ($obj: TlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::negotiated-protocol', ...args: any[]): void;
        connect(
            sigName: 'notify::peer-certificate',
            callback: ($obj: TlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::peer-certificate',
            callback: ($obj: TlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::peer-certificate', ...args: any[]): void;
        connect(
            sigName: 'notify::peer-certificate-errors',
            callback: ($obj: TlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::peer-certificate-errors',
            callback: ($obj: TlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::peer-certificate-errors', ...args: any[]): void;
        connect(
            sigName: 'notify::protocol-version',
            callback: ($obj: TlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::protocol-version',
            callback: ($obj: TlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::protocol-version', ...args: any[]): void;
        connect(
            sigName: 'notify::rehandshake-mode',
            callback: ($obj: TlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::rehandshake-mode',
            callback: ($obj: TlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::rehandshake-mode', ...args: any[]): void;
        connect(
            sigName: 'notify::require-close-notify',
            callback: ($obj: TlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::require-close-notify',
            callback: ($obj: TlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::require-close-notify', ...args: any[]): void;
        connect(
            sigName: 'notify::use-system-certdb',
            callback: ($obj: TlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::use-system-certdb',
            callback: ($obj: TlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::use-system-certdb', ...args: any[]): void;
        connect(
            sigName: 'notify::closed',
            callback: ($obj: TlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::closed',
            callback: ($obj: TlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::closed', ...args: any[]): void;
        connect(
            sigName: 'notify::input-stream',
            callback: ($obj: TlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::input-stream',
            callback: ($obj: TlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::input-stream', ...args: any[]): void;
        connect(
            sigName: 'notify::output-stream',
            callback: ($obj: TlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::output-stream',
            callback: ($obj: TlsConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::output-stream', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GTlsConnection is the base TLS connection class type, which wraps
     * a #GIOStream and provides TLS encryption on top of it. Its
     * subclasses, #GTlsClientConnection and #GTlsServerConnection,
     * implement client-side and server-side TLS, respectively.
     *
     * For DTLS (Datagram TLS) support, see #GDtlsConnection.
     * @interface
     */
    class TlsConnection extends IOStream {
        // Own properties of Gio-2.0.Gio.TlsConnection

        static name: string;
        static $gtype: GObject.GType<TlsConnection>;

        // Constructors of Gio-2.0.Gio.TlsConnection

        constructor(config?: TlsConnection.ConstructorProperties);
        _init(config?: TlsConnection.ConstructorProperties): void;
    }

    namespace TlsDatabase {
        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface TlsDatabase {
        // Own fields of Gio-2.0.Gio.TlsDatabase

        parent_instance: GObject.Object;
        priv: TlsDatabasePrivate;

        // Owm methods of Gio-2.0.Gio.TlsDatabase

        /**
         * Create a handle string for the certificate. The database will only be able
         * to create a handle for certificates that originate from the database. In
         * cases where the database cannot create a handle for a certificate, %NULL
         * will be returned.
         *
         * This handle should be stable across various instances of the application,
         * and between applications. If a certificate is modified in the database,
         * then it is not guaranteed that this handle will continue to point to it.
         * @param certificate certificate for which to create a handle.
         * @returns a newly allocated string containing the handle.
         */
        create_certificate_handle(certificate: TlsCertificate): string | null;
        /**
         * Look up a certificate by its handle.
         *
         * The handle should have been created by calling
         * g_tls_database_create_certificate_handle() on a #GTlsDatabase object of
         * the same TLS backend. The handle is designed to remain valid across
         * instantiations of the database.
         *
         * If the handle is no longer valid, or does not point to a certificate in
         * this database, then %NULL will be returned.
         *
         * This function can block, use g_tls_database_lookup_certificate_for_handle_async() to perform
         * the lookup operation asynchronously.
         * @param handle a certificate handle
         * @param interaction used to interact with the user if necessary
         * @param flags Flags which affect the lookup.
         * @param cancellable a #GCancellable, or %NULL
         * @returns a newly allocated #GTlsCertificate, or %NULL. Use g_object_unref() to release the certificate.
         */
        lookup_certificate_for_handle(
            handle: string | null,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseLookupFlags,
            cancellable: Cancellable | null
        ): TlsCertificate | null;
        /**
         * Asynchronously look up a certificate by its handle in the database. See
         * g_tls_database_lookup_certificate_for_handle() for more information.
         * @param handle a certificate handle
         * @param interaction used to interact with the user if necessary
         * @param flags Flags which affect the lookup.
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call when the operation completes
         */
        lookup_certificate_for_handle_async(
            handle: string | null,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseLookupFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of lookup_certificate_for_handle_async

        /**
         * Promisified version of {@link lookup_certificate_for_handle_async}
         *
         * Asynchronously look up a certificate by its handle in the database. See
         * g_tls_database_lookup_certificate_for_handle() for more information.
         * @param handle a certificate handle
         * @param interaction used to interact with the user if necessary
         * @param flags Flags which affect the lookup.
         * @param cancellable a #GCancellable, or %NULL
         * @returns A Promise of: a newly allocated #GTlsCertificate object. Use g_object_unref() to release the certificate.
         */
        lookup_certificate_for_handle_async(
            handle: string | null,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseLookupFlags,
            cancellable: Cancellable | null
        ): globalThis.Promise<TlsCertificate>;
        /**
         * Finish an asynchronous lookup of a certificate by its handle. See
         * g_tls_database_lookup_certificate_for_handle() for more information.
         *
         * If the handle is no longer valid, or does not point to a certificate in
         * this database, then %NULL will be returned.
         * @param result a #GAsyncResult.
         * @returns a newly allocated #GTlsCertificate object. Use g_object_unref() to release the certificate.
         */
        lookup_certificate_for_handle_finish(
            result: AsyncResult
        ): TlsCertificate;
        /**
         * Look up the issuer of `certificate` in the database. The
         * #GTlsCertificate:issuer property of `certificate` is not modified, and
         * the two certificates are not hooked into a chain.
         *
         * This function can block. Use g_tls_database_lookup_certificate_issuer_async()
         * to perform the lookup operation asynchronously.
         *
         * Beware this function cannot be used to build certification paths. The
         * issuer certificate returned by this function may not be the same as
         * the certificate that would actually be used to construct a valid
         * certification path during certificate verification.
         * [RFC 4158](https://datatracker.ietf.org/doc/html/rfc4158) explains
         * why an issuer certificate cannot be naively assumed to be part of the
         * the certification path (though GLib's TLS backends may not follow the
         * path building strategies outlined in this RFC). Due to the complexity
         * of certification path building, GLib does not provide any way to know
         * which certification path will actually be used when verifying a TLS
         * certificate. Accordingly, this function cannot be used to make
         * security-related decisions. Only GLib itself should make security
         * decisions about TLS certificates.
         * @param certificate a #GTlsCertificate
         * @param interaction used to interact with the user if necessary
         * @param flags flags which affect the lookup operation
         * @param cancellable a #GCancellable, or %NULL
         * @returns a newly allocated issuer #GTlsCertificate, or %NULL. Use g_object_unref() to release the certificate.
         */
        lookup_certificate_issuer(
            certificate: TlsCertificate,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseLookupFlags,
            cancellable: Cancellable | null
        ): TlsCertificate;
        /**
         * Asynchronously look up the issuer of `certificate` in the database. See
         * g_tls_database_lookup_certificate_issuer() for more information.
         * @param certificate a #GTlsCertificate
         * @param interaction used to interact with the user if necessary
         * @param flags flags which affect the lookup operation
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call when the operation completes
         */
        lookup_certificate_issuer_async(
            certificate: TlsCertificate,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseLookupFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of lookup_certificate_issuer_async

        /**
         * Promisified version of {@link lookup_certificate_issuer_async}
         *
         * Asynchronously look up the issuer of `certificate` in the database. See
         * g_tls_database_lookup_certificate_issuer() for more information.
         * @param certificate a #GTlsCertificate
         * @param interaction used to interact with the user if necessary
         * @param flags flags which affect the lookup operation
         * @param cancellable a #GCancellable, or %NULL
         * @returns A Promise of: a newly allocated issuer #GTlsCertificate, or %NULL. Use g_object_unref() to release the certificate.
         */
        lookup_certificate_issuer_async(
            certificate: TlsCertificate,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseLookupFlags,
            cancellable: Cancellable | null
        ): globalThis.Promise<TlsCertificate>;
        /**
         * Finish an asynchronous lookup issuer operation. See
         * g_tls_database_lookup_certificate_issuer() for more information.
         * @param result a #GAsyncResult.
         * @returns a newly allocated issuer #GTlsCertificate, or %NULL. Use g_object_unref() to release the certificate.
         */
        lookup_certificate_issuer_finish(result: AsyncResult): TlsCertificate;
        /**
         * Look up certificates issued by this issuer in the database.
         *
         * This function can block, use g_tls_database_lookup_certificates_issued_by_async() to perform
         * the lookup operation asynchronously.
         * @param issuer_raw_dn a #GByteArray which holds the DER encoded issuer DN.
         * @param interaction used to interact with the user if necessary
         * @param flags Flags which affect the lookup operation.
         * @param cancellable a #GCancellable, or %NULL
         * @returns a newly allocated list of #GTlsCertificate objects. Use g_object_unref() on each certificate, and g_list_free() on the release the list.
         */
        lookup_certificates_issued_by(
            issuer_raw_dn: Uint8Array,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseLookupFlags,
            cancellable: Cancellable | null
        ): TlsCertificate[];
        /**
         * Asynchronously look up certificates issued by this issuer in the database. See
         * g_tls_database_lookup_certificates_issued_by() for more information.
         *
         * The database may choose to hold a reference to the issuer byte array for the duration
         * of this asynchronous operation. The byte array should not be modified during
         * this time.
         * @param issuer_raw_dn a #GByteArray which holds the DER encoded issuer DN.
         * @param interaction used to interact with the user if necessary
         * @param flags Flags which affect the lookup operation.
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call when the operation completes
         */
        lookup_certificates_issued_by_async(
            issuer_raw_dn: Uint8Array,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseLookupFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of lookup_certificates_issued_by_async

        /**
         * Promisified version of {@link lookup_certificates_issued_by_async}
         *
         * Asynchronously look up certificates issued by this issuer in the database. See
         * g_tls_database_lookup_certificates_issued_by() for more information.
         *
         * The database may choose to hold a reference to the issuer byte array for the duration
         * of this asynchronous operation. The byte array should not be modified during
         * this time.
         * @param issuer_raw_dn a #GByteArray which holds the DER encoded issuer DN.
         * @param interaction used to interact with the user if necessary
         * @param flags Flags which affect the lookup operation.
         * @param cancellable a #GCancellable, or %NULL
         * @returns A Promise of: a newly allocated list of #GTlsCertificate objects. Use g_object_unref() on each certificate, and g_list_free() on the release the list.
         */
        lookup_certificates_issued_by_async(
            issuer_raw_dn: Uint8Array,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseLookupFlags,
            cancellable: Cancellable | null
        ): globalThis.Promise<TlsCertificate[]>;
        /**
         * Finish an asynchronous lookup of certificates. See
         * g_tls_database_lookup_certificates_issued_by() for more information.
         * @param result a #GAsyncResult.
         * @returns a newly allocated list of #GTlsCertificate objects. Use g_object_unref() on each certificate, and g_list_free() on the release the list.
         */
        lookup_certificates_issued_by_finish(
            result: AsyncResult
        ): TlsCertificate[];
        /**
         * Determines the validity of a certificate chain, outside the context
         * of a TLS session.
         *
         * `chain` is a chain of #GTlsCertificate objects each pointing to the next
         * certificate in the chain by its #GTlsCertificate:issuer property.
         *
         * `purpose` describes the purpose (or usage) for which the certificate
         * is being used. Typically `purpose` will be set to %G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER
         * which means that the certificate is being used to authenticate a server
         * (and we are acting as the client).
         *
         * The `identity` is used to ensure the server certificate is valid for
         * the expected peer identity. If the identity does not match the
         * certificate, %G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the
         * return value. If `identity` is %NULL, that bit will never be set in
         * the return value. The peer identity may also be used to check for
         * pinned certificates (trust exceptions) in the database. These may
         * override the normal verification process on a host-by-host basis.
         *
         * Currently there are no `flags,` and %G_TLS_DATABASE_VERIFY_NONE should be
         * used.
         *
         * If `chain` is found to be valid, then the return value will be 0. If
         * `chain` is found to be invalid, then the return value will indicate at
         * least one problem found. If the function is unable to determine
         * whether `chain` is valid (for example, because `cancellable` is
         * triggered before it completes) then the return value will be
         * %G_TLS_CERTIFICATE_GENERIC_ERROR and `error` will be set accordingly.
         * `error` is not set when `chain` is successfully analyzed but found to
         * be invalid.
         *
         * GLib guarantees that if certificate verification fails, at least one
         * error will be set in the return value, but it does not guarantee
         * that all possible errors will be set. Accordingly, you may not safely
         * decide to ignore any particular type of error. For example, it would
         * be incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
         * expired certificates, because this could potentially be the only
         * error flag set even if other problems exist with the certificate.
         *
         * Prior to GLib 2.48, GLib's default TLS backend modified `chain` to
         * represent the certification path built by #GTlsDatabase during
         * certificate verification by adjusting the #GTlsCertificate:issuer
         * property of each certificate in `chain`. Since GLib 2.48, this no
         * longer occurs, so you cannot rely on #GTlsCertificate:issuer to
         * represent the actual certification path used during certificate
         * verification.
         *
         * Because TLS session context is not used, #GTlsDatabase may not
         * perform as many checks on the certificates as #GTlsConnection would.
         * For example, certificate constraints may not be honored, and
         * revocation checks may not be performed. The best way to verify TLS
         * certificates used by a TLS connection is to let #GTlsConnection
         * handle the verification.
         *
         * The TLS backend may attempt to look up and add missing certificates
         * to the chain. This may involve HTTP requests to download missing
         * certificates.
         *
         * This function can block. Use g_tls_database_verify_chain_async() to
         * perform the verification operation asynchronously.
         * @param chain a #GTlsCertificate chain
         * @param purpose the purpose that this certificate chain will be used for.
         * @param identity the expected peer identity
         * @param interaction used to interact with the user if necessary
         * @param flags additional verify flags
         * @param cancellable a #GCancellable, or %NULL
         * @returns the appropriate #GTlsCertificateFlags which represents the result of verification.
         */
        verify_chain(
            chain: TlsCertificate,
            purpose: string | null,
            identity: SocketConnectable | null,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseVerifyFlags,
            cancellable: Cancellable | null
        ): TlsCertificateFlags;
        /**
         * Asynchronously determines the validity of a certificate chain after
         * looking up and adding any missing certificates to the chain. See
         * g_tls_database_verify_chain() for more information.
         * @param chain a #GTlsCertificate chain
         * @param purpose the purpose that this certificate chain will be used for.
         * @param identity the expected peer identity
         * @param interaction used to interact with the user if necessary
         * @param flags additional verify flags
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call when the operation completes
         */
        verify_chain_async(
            chain: TlsCertificate,
            purpose: string | null,
            identity: SocketConnectable | null,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseVerifyFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of verify_chain_async

        /**
         * Promisified version of {@link verify_chain_async}
         *
         * Asynchronously determines the validity of a certificate chain after
         * looking up and adding any missing certificates to the chain. See
         * g_tls_database_verify_chain() for more information.
         * @param chain a #GTlsCertificate chain
         * @param purpose the purpose that this certificate chain will be used for.
         * @param identity the expected peer identity
         * @param interaction used to interact with the user if necessary
         * @param flags additional verify flags
         * @param cancellable a #GCancellable, or %NULL
         * @returns A Promise of: the appropriate #GTlsCertificateFlags which represents the result of verification.
         */
        verify_chain_async(
            chain: TlsCertificate,
            purpose: string | null,
            identity: SocketConnectable | null,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseVerifyFlags,
            cancellable: Cancellable | null
        ): globalThis.Promise<TlsCertificateFlags>;
        /**
         * Finish an asynchronous verify chain operation. See
         * g_tls_database_verify_chain() for more information.
         *
         * If `chain` is found to be valid, then the return value will be 0. If
         * `chain` is found to be invalid, then the return value will indicate
         * the problems found. If the function is unable to determine whether
         * `chain` is valid or not (eg, because `cancellable` is triggered
         * before it completes) then the return value will be
         * %G_TLS_CERTIFICATE_GENERIC_ERROR and `error` will be set
         * accordingly. `error` is not set when `chain` is successfully analyzed
         * but found to be invalid.
         * @param result a #GAsyncResult.
         * @returns the appropriate #GTlsCertificateFlags which represents the result of verification.
         */
        verify_chain_finish(result: AsyncResult): TlsCertificateFlags;

        // Own virtual methods of Gio-2.0.Gio.TlsDatabase

        /**
         * Create a handle string for the certificate. The database will only be able
         * to create a handle for certificates that originate from the database. In
         * cases where the database cannot create a handle for a certificate, %NULL
         * will be returned.
         *
         * This handle should be stable across various instances of the application,
         * and between applications. If a certificate is modified in the database,
         * then it is not guaranteed that this handle will continue to point to it.
         * @virtual
         * @param certificate certificate for which to create a handle.
         * @returns a newly allocated string containing the handle.
         */
        vfunc_create_certificate_handle(
            certificate: TlsCertificate
        ): string | null;
        /**
         * Look up a certificate by its handle.
         *
         * The handle should have been created by calling
         * g_tls_database_create_certificate_handle() on a #GTlsDatabase object of
         * the same TLS backend. The handle is designed to remain valid across
         * instantiations of the database.
         *
         * If the handle is no longer valid, or does not point to a certificate in
         * this database, then %NULL will be returned.
         *
         * This function can block, use g_tls_database_lookup_certificate_for_handle_async() to perform
         * the lookup operation asynchronously.
         * @virtual
         * @param handle a certificate handle
         * @param interaction used to interact with the user if necessary
         * @param flags Flags which affect the lookup.
         * @param cancellable a #GCancellable, or %NULL
         * @returns a newly allocated #GTlsCertificate, or %NULL. Use g_object_unref() to release the certificate.
         */
        vfunc_lookup_certificate_for_handle(
            handle: string | null,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseLookupFlags,
            cancellable: Cancellable | null
        ): TlsCertificate | null;
        /**
         * Asynchronously look up a certificate by its handle in the database. See
         * g_tls_database_lookup_certificate_for_handle() for more information.
         * @virtual
         * @param handle a certificate handle
         * @param interaction used to interact with the user if necessary
         * @param flags Flags which affect the lookup.
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call when the operation completes
         */
        vfunc_lookup_certificate_for_handle_async(
            handle: string | null,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseLookupFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finish an asynchronous lookup of a certificate by its handle. See
         * g_tls_database_lookup_certificate_for_handle() for more information.
         *
         * If the handle is no longer valid, or does not point to a certificate in
         * this database, then %NULL will be returned.
         * @virtual
         * @param result a #GAsyncResult.
         * @returns a newly allocated #GTlsCertificate object. Use g_object_unref() to release the certificate.
         */
        vfunc_lookup_certificate_for_handle_finish(
            result: AsyncResult
        ): TlsCertificate;
        /**
         * Look up the issuer of `certificate` in the database. The
         * #GTlsCertificate:issuer property of `certificate` is not modified, and
         * the two certificates are not hooked into a chain.
         *
         * This function can block. Use g_tls_database_lookup_certificate_issuer_async()
         * to perform the lookup operation asynchronously.
         *
         * Beware this function cannot be used to build certification paths. The
         * issuer certificate returned by this function may not be the same as
         * the certificate that would actually be used to construct a valid
         * certification path during certificate verification.
         * [RFC 4158](https://datatracker.ietf.org/doc/html/rfc4158) explains
         * why an issuer certificate cannot be naively assumed to be part of the
         * the certification path (though GLib's TLS backends may not follow the
         * path building strategies outlined in this RFC). Due to the complexity
         * of certification path building, GLib does not provide any way to know
         * which certification path will actually be used when verifying a TLS
         * certificate. Accordingly, this function cannot be used to make
         * security-related decisions. Only GLib itself should make security
         * decisions about TLS certificates.
         * @virtual
         * @param certificate a #GTlsCertificate
         * @param interaction used to interact with the user if necessary
         * @param flags flags which affect the lookup operation
         * @param cancellable a #GCancellable, or %NULL
         * @returns a newly allocated issuer #GTlsCertificate, or %NULL. Use g_object_unref() to release the certificate.
         */
        vfunc_lookup_certificate_issuer(
            certificate: TlsCertificate,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseLookupFlags,
            cancellable: Cancellable | null
        ): TlsCertificate;
        /**
         * Asynchronously look up the issuer of `certificate` in the database. See
         * g_tls_database_lookup_certificate_issuer() for more information.
         * @virtual
         * @param certificate a #GTlsCertificate
         * @param interaction used to interact with the user if necessary
         * @param flags flags which affect the lookup operation
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call when the operation completes
         */
        vfunc_lookup_certificate_issuer_async(
            certificate: TlsCertificate,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseLookupFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finish an asynchronous lookup issuer operation. See
         * g_tls_database_lookup_certificate_issuer() for more information.
         * @virtual
         * @param result a #GAsyncResult.
         * @returns a newly allocated issuer #GTlsCertificate, or %NULL. Use g_object_unref() to release the certificate.
         */
        vfunc_lookup_certificate_issuer_finish(
            result: AsyncResult
        ): TlsCertificate;
        /**
         * Look up certificates issued by this issuer in the database.
         *
         * This function can block, use g_tls_database_lookup_certificates_issued_by_async() to perform
         * the lookup operation asynchronously.
         * @virtual
         * @param issuer_raw_dn a #GByteArray which holds the DER encoded issuer DN.
         * @param interaction used to interact with the user if necessary
         * @param flags Flags which affect the lookup operation.
         * @param cancellable a #GCancellable, or %NULL
         * @returns a newly allocated list of #GTlsCertificate objects. Use g_object_unref() on each certificate, and g_list_free() on the release the list.
         */
        vfunc_lookup_certificates_issued_by(
            issuer_raw_dn: Uint8Array,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseLookupFlags,
            cancellable: Cancellable | null
        ): TlsCertificate[];
        /**
         * Asynchronously look up certificates issued by this issuer in the database. See
         * g_tls_database_lookup_certificates_issued_by() for more information.
         *
         * The database may choose to hold a reference to the issuer byte array for the duration
         * of this asynchronous operation. The byte array should not be modified during
         * this time.
         * @virtual
         * @param issuer_raw_dn a #GByteArray which holds the DER encoded issuer DN.
         * @param interaction used to interact with the user if necessary
         * @param flags Flags which affect the lookup operation.
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call when the operation completes
         */
        vfunc_lookup_certificates_issued_by_async(
            issuer_raw_dn: Uint8Array,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseLookupFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finish an asynchronous lookup of certificates. See
         * g_tls_database_lookup_certificates_issued_by() for more information.
         * @virtual
         * @param result a #GAsyncResult.
         * @returns a newly allocated list of #GTlsCertificate objects. Use g_object_unref() on each certificate, and g_list_free() on the release the list.
         */
        vfunc_lookup_certificates_issued_by_finish(
            result: AsyncResult
        ): TlsCertificate[];
        /**
         * Determines the validity of a certificate chain, outside the context
         * of a TLS session.
         *
         * `chain` is a chain of #GTlsCertificate objects each pointing to the next
         * certificate in the chain by its #GTlsCertificate:issuer property.
         *
         * `purpose` describes the purpose (or usage) for which the certificate
         * is being used. Typically `purpose` will be set to %G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER
         * which means that the certificate is being used to authenticate a server
         * (and we are acting as the client).
         *
         * The `identity` is used to ensure the server certificate is valid for
         * the expected peer identity. If the identity does not match the
         * certificate, %G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the
         * return value. If `identity` is %NULL, that bit will never be set in
         * the return value. The peer identity may also be used to check for
         * pinned certificates (trust exceptions) in the database. These may
         * override the normal verification process on a host-by-host basis.
         *
         * Currently there are no `flags,` and %G_TLS_DATABASE_VERIFY_NONE should be
         * used.
         *
         * If `chain` is found to be valid, then the return value will be 0. If
         * `chain` is found to be invalid, then the return value will indicate at
         * least one problem found. If the function is unable to determine
         * whether `chain` is valid (for example, because `cancellable` is
         * triggered before it completes) then the return value will be
         * %G_TLS_CERTIFICATE_GENERIC_ERROR and `error` will be set accordingly.
         * `error` is not set when `chain` is successfully analyzed but found to
         * be invalid.
         *
         * GLib guarantees that if certificate verification fails, at least one
         * error will be set in the return value, but it does not guarantee
         * that all possible errors will be set. Accordingly, you may not safely
         * decide to ignore any particular type of error. For example, it would
         * be incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
         * expired certificates, because this could potentially be the only
         * error flag set even if other problems exist with the certificate.
         *
         * Prior to GLib 2.48, GLib's default TLS backend modified `chain` to
         * represent the certification path built by #GTlsDatabase during
         * certificate verification by adjusting the #GTlsCertificate:issuer
         * property of each certificate in `chain`. Since GLib 2.48, this no
         * longer occurs, so you cannot rely on #GTlsCertificate:issuer to
         * represent the actual certification path used during certificate
         * verification.
         *
         * Because TLS session context is not used, #GTlsDatabase may not
         * perform as many checks on the certificates as #GTlsConnection would.
         * For example, certificate constraints may not be honored, and
         * revocation checks may not be performed. The best way to verify TLS
         * certificates used by a TLS connection is to let #GTlsConnection
         * handle the verification.
         *
         * The TLS backend may attempt to look up and add missing certificates
         * to the chain. This may involve HTTP requests to download missing
         * certificates.
         *
         * This function can block. Use g_tls_database_verify_chain_async() to
         * perform the verification operation asynchronously.
         * @virtual
         * @param chain a #GTlsCertificate chain
         * @param purpose the purpose that this certificate chain will be used for.
         * @param identity the expected peer identity
         * @param interaction used to interact with the user if necessary
         * @param flags additional verify flags
         * @param cancellable a #GCancellable, or %NULL
         * @returns the appropriate #GTlsCertificateFlags which represents the result of verification.
         */
        vfunc_verify_chain(
            chain: TlsCertificate,
            purpose: string | null,
            identity: SocketConnectable | null,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseVerifyFlags,
            cancellable: Cancellable | null
        ): TlsCertificateFlags;
        /**
         * Asynchronously determines the validity of a certificate chain after
         * looking up and adding any missing certificates to the chain. See
         * g_tls_database_verify_chain() for more information.
         * @virtual
         * @param chain a #GTlsCertificate chain
         * @param purpose the purpose that this certificate chain will be used for.
         * @param identity the expected peer identity
         * @param interaction used to interact with the user if necessary
         * @param flags additional verify flags
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call when the operation completes
         */
        vfunc_verify_chain_async(
            chain: TlsCertificate,
            purpose: string | null,
            identity: SocketConnectable | null,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseVerifyFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Finish an asynchronous verify chain operation. See
         * g_tls_database_verify_chain() for more information.
         *
         * If `chain` is found to be valid, then the return value will be 0. If
         * `chain` is found to be invalid, then the return value will indicate
         * the problems found. If the function is unable to determine whether
         * `chain` is valid or not (eg, because `cancellable` is triggered
         * before it completes) then the return value will be
         * %G_TLS_CERTIFICATE_GENERIC_ERROR and `error` will be set
         * accordingly. `error` is not set when `chain` is successfully analyzed
         * but found to be invalid.
         * @virtual
         * @param result a #GAsyncResult.
         * @returns the appropriate #GTlsCertificateFlags which represents the result of verification.
         */
        vfunc_verify_chain_finish(result: AsyncResult): TlsCertificateFlags;

        // Class property signals of Gio-2.0.Gio.TlsDatabase

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GTlsDatabase is used to look up certificates and other information
     * from a certificate or key store. It is an abstract base class which
     * TLS library specific subtypes override.
     *
     * A #GTlsDatabase may be accessed from multiple threads by the TLS backend.
     * All implementations are required to be fully thread-safe.
     *
     * Most common client applications will not directly interact with
     * #GTlsDatabase. It is used internally by #GTlsConnection.
     * @interface
     */
    class TlsDatabase extends GObject.Object {
        // Own properties of Gio-2.0.Gio.TlsDatabase

        static name: string;
        static $gtype: GObject.GType<TlsDatabase>;

        // Constructors of Gio-2.0.Gio.TlsDatabase

        constructor(config?: TlsDatabase.ConstructorProperties);
        _init(config?: TlsDatabase.ConstructorProperties): void;
    }

    namespace TlsInteraction {
        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface TlsInteraction {
        // Owm methods of Gio-2.0.Gio.TlsInteraction

        /**
         * Run synchronous interaction to ask the user for a password. In general,
         * g_tls_interaction_invoke_ask_password() should be used instead of this
         * function.
         *
         * Derived subclasses usually implement a password prompt, although they may
         * also choose to provide a password from elsewhere. The `password` value will
         * be filled in and then `callback` will be called. Alternatively the user may
         * abort this password request, which will usually abort the TLS connection.
         *
         * If the interaction is cancelled by the cancellation object, or by the
         * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
         * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
         * not support immediate cancellation.
         * @param password a #GTlsPassword object
         * @param cancellable an optional #GCancellable cancellation object
         * @returns The status of the ask password interaction.
         */
        ask_password(
            password: TlsPassword,
            cancellable: Cancellable | null
        ): TlsInteractionResult;
        /**
         * Run asynchronous interaction to ask the user for a password. In general,
         * g_tls_interaction_invoke_ask_password() should be used instead of this
         * function.
         *
         * Derived subclasses usually implement a password prompt, although they may
         * also choose to provide a password from elsewhere. The `password` value will
         * be filled in and then `callback` will be called. Alternatively the user may
         * abort this password request, which will usually abort the TLS connection.
         *
         * If the interaction is cancelled by the cancellation object, or by the
         * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
         * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
         * not support immediate cancellation.
         *
         * Certain implementations may not support immediate cancellation.
         * @param password a #GTlsPassword object
         * @param cancellable an optional #GCancellable cancellation object
         * @param callback will be called when the interaction completes
         */
        ask_password_async(
            password: TlsPassword,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of ask_password_async

        /**
         * Promisified version of {@link ask_password_async}
         *
         * Run asynchronous interaction to ask the user for a password. In general,
         * g_tls_interaction_invoke_ask_password() should be used instead of this
         * function.
         *
         * Derived subclasses usually implement a password prompt, although they may
         * also choose to provide a password from elsewhere. The `password` value will
         * be filled in and then `callback` will be called. Alternatively the user may
         * abort this password request, which will usually abort the TLS connection.
         *
         * If the interaction is cancelled by the cancellation object, or by the
         * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
         * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
         * not support immediate cancellation.
         *
         * Certain implementations may not support immediate cancellation.
         * @param password a #GTlsPassword object
         * @param cancellable an optional #GCancellable cancellation object
         * @returns A Promise of: The status of the ask password interaction.
         */
        ask_password_async(
            password: TlsPassword,
            cancellable: Cancellable | null
        ): globalThis.Promise<TlsInteractionResult>;
        /**
         * Complete an ask password user interaction request. This should be once
         * the g_tls_interaction_ask_password_async() completion callback is called.
         *
         * If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsPassword passed
         * to g_tls_interaction_ask_password() will have its password filled in.
         *
         * If the interaction is cancelled by the cancellation object, or by the
         * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
         * contains a %G_IO_ERROR_CANCELLED error code.
         * @param result the result passed to the callback
         * @returns The status of the ask password interaction.
         */
        ask_password_finish(result: AsyncResult): TlsInteractionResult;
        /**
         * Invoke the interaction to ask the user for a password. It invokes this
         * interaction in the main loop, specifically the #GMainContext returned by
         * g_main_context_get_thread_default() when the interaction is created. This
         * is called by called by #GTlsConnection or #GTlsDatabase to ask the user
         * for a password.
         *
         * Derived subclasses usually implement a password prompt, although they may
         * also choose to provide a password from elsewhere. The `password` value will
         * be filled in and then `callback` will be called. Alternatively the user may
         * abort this password request, which will usually abort the TLS connection.
         *
         * The implementation can either be a synchronous (eg: modal dialog) or an
         * asynchronous one (eg: modeless dialog). This function will take care of
         * calling which ever one correctly.
         *
         * If the interaction is cancelled by the cancellation object, or by the
         * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
         * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
         * not support immediate cancellation.
         * @param password a #GTlsPassword object
         * @param cancellable an optional #GCancellable cancellation object
         * @returns The status of the ask password interaction.
         */
        invoke_ask_password(
            password: TlsPassword,
            cancellable: Cancellable | null
        ): TlsInteractionResult;
        /**
         * Invoke the interaction to ask the user to choose a certificate to
         * use with the connection. It invokes this interaction in the main
         * loop, specifically the #GMainContext returned by
         * g_main_context_get_thread_default() when the interaction is
         * created. This is called by called by #GTlsConnection when the peer
         * requests a certificate during the handshake.
         *
         * Derived subclasses usually implement a certificate selector,
         * although they may also choose to provide a certificate from
         * elsewhere. Alternatively the user may abort this certificate
         * request, which may or may not abort the TLS connection.
         *
         * The implementation can either be a synchronous (eg: modal dialog) or an
         * asynchronous one (eg: modeless dialog). This function will take care of
         * calling which ever one correctly.
         *
         * If the interaction is cancelled by the cancellation object, or by the
         * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
         * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
         * not support immediate cancellation.
         * @param connection a #GTlsConnection object
         * @param flags flags providing more information about the request
         * @param cancellable an optional #GCancellable cancellation object
         * @returns The status of the certificate request interaction.
         */
        invoke_request_certificate(
            connection: TlsConnection,
            flags: TlsCertificateRequestFlags,
            cancellable: Cancellable | null
        ): TlsInteractionResult;
        /**
         * Run synchronous interaction to ask the user to choose a certificate to use
         * with the connection. In general, g_tls_interaction_invoke_request_certificate()
         * should be used instead of this function.
         *
         * Derived subclasses usually implement a certificate selector, although they may
         * also choose to provide a certificate from elsewhere. Alternatively the user may
         * abort this certificate request, which will usually abort the TLS connection.
         *
         * If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
         * passed to g_tls_interaction_request_certificate() will have had its
         * #GTlsConnection:certificate filled in.
         *
         * If the interaction is cancelled by the cancellation object, or by the
         * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
         * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
         * not support immediate cancellation.
         * @param connection a #GTlsConnection object
         * @param flags flags providing more information about the request
         * @param cancellable an optional #GCancellable cancellation object
         * @returns The status of the request certificate interaction.
         */
        request_certificate(
            connection: TlsConnection,
            flags: TlsCertificateRequestFlags,
            cancellable: Cancellable | null
        ): TlsInteractionResult;
        /**
         * Run asynchronous interaction to ask the user for a certificate to use with
         * the connection. In general, g_tls_interaction_invoke_request_certificate() should
         * be used instead of this function.
         *
         * Derived subclasses usually implement a certificate selector, although they may
         * also choose to provide a certificate from elsewhere. `callback` will be called
         * when the operation completes. Alternatively the user may abort this certificate
         * request, which will usually abort the TLS connection.
         * @param connection a #GTlsConnection object
         * @param flags flags providing more information about the request
         * @param cancellable an optional #GCancellable cancellation object
         * @param callback will be called when the interaction completes
         */
        request_certificate_async(
            connection: TlsConnection,
            flags: TlsCertificateRequestFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of request_certificate_async

        /**
         * Promisified version of {@link request_certificate_async}
         *
         * Run asynchronous interaction to ask the user for a certificate to use with
         * the connection. In general, g_tls_interaction_invoke_request_certificate() should
         * be used instead of this function.
         *
         * Derived subclasses usually implement a certificate selector, although they may
         * also choose to provide a certificate from elsewhere. `callback` will be called
         * when the operation completes. Alternatively the user may abort this certificate
         * request, which will usually abort the TLS connection.
         * @param connection a #GTlsConnection object
         * @param flags flags providing more information about the request
         * @param cancellable an optional #GCancellable cancellation object
         * @returns A Promise of: The status of the request certificate interaction.
         */
        request_certificate_async(
            connection: TlsConnection,
            flags: TlsCertificateRequestFlags,
            cancellable: Cancellable | null
        ): globalThis.Promise<TlsInteractionResult>;
        /**
         * Complete a request certificate user interaction request. This should be once
         * the g_tls_interaction_request_certificate_async() completion callback is called.
         *
         * If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
         * passed to g_tls_interaction_request_certificate_async() will have had its
         * #GTlsConnection:certificate filled in.
         *
         * If the interaction is cancelled by the cancellation object, or by the
         * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
         * contains a %G_IO_ERROR_CANCELLED error code.
         * @param result the result passed to the callback
         * @returns The status of the request certificate interaction.
         */
        request_certificate_finish(result: AsyncResult): TlsInteractionResult;

        // Own virtual methods of Gio-2.0.Gio.TlsInteraction

        /**
         * Run synchronous interaction to ask the user for a password. In general,
         * g_tls_interaction_invoke_ask_password() should be used instead of this
         * function.
         *
         * Derived subclasses usually implement a password prompt, although they may
         * also choose to provide a password from elsewhere. The `password` value will
         * be filled in and then `callback` will be called. Alternatively the user may
         * abort this password request, which will usually abort the TLS connection.
         *
         * If the interaction is cancelled by the cancellation object, or by the
         * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
         * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
         * not support immediate cancellation.
         * @virtual
         * @param password a #GTlsPassword object
         * @param cancellable an optional #GCancellable cancellation object
         * @returns The status of the ask password interaction.
         */
        vfunc_ask_password(
            password: TlsPassword,
            cancellable: Cancellable | null
        ): TlsInteractionResult;
        /**
         * Run asynchronous interaction to ask the user for a password. In general,
         * g_tls_interaction_invoke_ask_password() should be used instead of this
         * function.
         *
         * Derived subclasses usually implement a password prompt, although they may
         * also choose to provide a password from elsewhere. The `password` value will
         * be filled in and then `callback` will be called. Alternatively the user may
         * abort this password request, which will usually abort the TLS connection.
         *
         * If the interaction is cancelled by the cancellation object, or by the
         * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
         * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
         * not support immediate cancellation.
         *
         * Certain implementations may not support immediate cancellation.
         * @virtual
         * @param password a #GTlsPassword object
         * @param cancellable an optional #GCancellable cancellation object
         * @param callback will be called when the interaction completes
         */
        vfunc_ask_password_async(
            password: TlsPassword,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Complete an ask password user interaction request. This should be once
         * the g_tls_interaction_ask_password_async() completion callback is called.
         *
         * If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsPassword passed
         * to g_tls_interaction_ask_password() will have its password filled in.
         *
         * If the interaction is cancelled by the cancellation object, or by the
         * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
         * contains a %G_IO_ERROR_CANCELLED error code.
         * @virtual
         * @param result the result passed to the callback
         * @returns The status of the ask password interaction.
         */
        vfunc_ask_password_finish(result: AsyncResult): TlsInteractionResult;
        /**
         * Run synchronous interaction to ask the user to choose a certificate to use
         * with the connection. In general, g_tls_interaction_invoke_request_certificate()
         * should be used instead of this function.
         *
         * Derived subclasses usually implement a certificate selector, although they may
         * also choose to provide a certificate from elsewhere. Alternatively the user may
         * abort this certificate request, which will usually abort the TLS connection.
         *
         * If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
         * passed to g_tls_interaction_request_certificate() will have had its
         * #GTlsConnection:certificate filled in.
         *
         * If the interaction is cancelled by the cancellation object, or by the
         * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
         * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
         * not support immediate cancellation.
         * @virtual
         * @param connection a #GTlsConnection object
         * @param flags flags providing more information about the request
         * @param cancellable an optional #GCancellable cancellation object
         * @returns The status of the request certificate interaction.
         */
        vfunc_request_certificate(
            connection: TlsConnection,
            flags: TlsCertificateRequestFlags,
            cancellable: Cancellable | null
        ): TlsInteractionResult;
        /**
         * Run asynchronous interaction to ask the user for a certificate to use with
         * the connection. In general, g_tls_interaction_invoke_request_certificate() should
         * be used instead of this function.
         *
         * Derived subclasses usually implement a certificate selector, although they may
         * also choose to provide a certificate from elsewhere. `callback` will be called
         * when the operation completes. Alternatively the user may abort this certificate
         * request, which will usually abort the TLS connection.
         * @virtual
         * @param connection a #GTlsConnection object
         * @param flags flags providing more information about the request
         * @param cancellable an optional #GCancellable cancellation object
         * @param callback will be called when the interaction completes
         */
        vfunc_request_certificate_async(
            connection: TlsConnection,
            flags: TlsCertificateRequestFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;
        /**
         * Complete a request certificate user interaction request. This should be once
         * the g_tls_interaction_request_certificate_async() completion callback is called.
         *
         * If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
         * passed to g_tls_interaction_request_certificate_async() will have had its
         * #GTlsConnection:certificate filled in.
         *
         * If the interaction is cancelled by the cancellation object, or by the
         * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
         * contains a %G_IO_ERROR_CANCELLED error code.
         * @virtual
         * @param result the result passed to the callback
         * @returns The status of the request certificate interaction.
         */
        vfunc_request_certificate_finish(
            result: AsyncResult
        ): TlsInteractionResult;

        // Class property signals of Gio-2.0.Gio.TlsInteraction

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GTlsInteraction provides a mechanism for the TLS connection and database
     * code to interact with the user. It can be used to ask the user for passwords.
     *
     * To use a #GTlsInteraction with a TLS connection use
     * g_tls_connection_set_interaction().
     *
     * Callers should instantiate a derived class that implements the various
     * interaction methods to show the required dialogs.
     *
     * Callers should use the 'invoke' functions like
     * g_tls_interaction_invoke_ask_password() to run interaction methods. These
     * functions make sure that the interaction is invoked in the main loop
     * and not in the current thread, if the current thread is not running the
     * main loop.
     *
     * Derived classes can choose to implement whichever interactions methods they'd
     * like to support by overriding those virtual methods in their class
     * initialization function. Any interactions not implemented will return
     * %G_TLS_INTERACTION_UNHANDLED. If a derived class implements an async method,
     * it must also implement the corresponding finish method.
     * @class
     */
    class TlsInteraction extends GObject.Object {
        // Own properties of Gio-2.0.Gio.TlsInteraction

        static name: string;
        static $gtype: GObject.GType<TlsInteraction>;

        // Constructors of Gio-2.0.Gio.TlsInteraction

        constructor(config?: TlsInteraction.ConstructorProperties);
        _init(config?: TlsInteraction.ConstructorProperties): void;
    }

    namespace TlsPassword {
        // Constructor properties interface

        interface ConstructorProperties
            extends GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.TlsPassword

            description?: string | null;
            flags?: TlsPasswordFlags | null;
            warning?: string | null;
        }
    }

    interface TlsPassword {
        // Own properties of Gio-2.0.Gio.TlsPassword

        description: string | null;
        flags: TlsPasswordFlags;
        warning: string | null;

        // Own fields of Gio-2.0.Gio.TlsPassword

        parent_instance: GObject.Object;
        priv: TlsPasswordPrivate;

        // Owm methods of Gio-2.0.Gio.TlsPassword

        /**
         * Get a description string about what the password will be used for.
         * @returns The description of the password.
         */
        get_description(): string | null;
        /**
         * Get flags about the password.
         * @returns The flags about the password.
         */
        get_flags(): TlsPasswordFlags;
        /**
         * Get the password value. If `length` is not %NULL then it will be
         * filled in with the length of the password value. (Note that the
         * password value is not nul-terminated, so you can only pass %NULL
         * for `length` in contexts where you know the password will have a
         * certain fixed length.)
         * @returns The password value (owned by the password object).
         */
        get_value(): Uint8Array;
        /**
         * Get a user readable translated warning. Usually this warning is a
         * representation of the password flags returned from
         * g_tls_password_get_flags().
         * @returns The warning.
         */
        get_warning(): string | null;
        /**
         * Set a description string about what the password will be used for.
         * @param description The description of the password
         */
        set_description(description: string | null): void;
        /**
         * Set flags about the password.
         * @param flags The flags about the password
         */
        set_flags(flags: TlsPasswordFlags): void;
        /**
         * Set the value for this password. The `value` will be copied by the password
         * object.
         *
         * Specify the `length,` for a non-nul-terminated password. Pass -1 as
         * `length` if using a nul-terminated password, and `length` will be
         * calculated automatically. (Note that the terminating nul is not
         * considered part of the password in this case.)
         * @param value the new password value
         */
        set_value(value: Uint8Array): void;
        /**
         * Provide the value for this password.
         *
         * The `value` will be owned by the password object, and later freed using
         * the `destroy` function callback.
         *
         * Specify the `length,` for a non-nul-terminated password. Pass -1 as
         * `length` if using a nul-terminated password, and `length` will be
         * calculated automatically. (Note that the terminating nul is not
         * considered part of the password in this case.)
         * @param value the value for the password
         * @param destroy a function to use to free the password.
         */
        set_value_full(
            value: Uint8Array,
            destroy: GLib.DestroyNotify | null
        ): void;
        /**
         * Set a user readable translated warning. Usually this warning is a
         * representation of the password flags returned from
         * g_tls_password_get_flags().
         * @param warning The user readable warning
         */
        set_warning(warning: string | null): void;

        // Own virtual methods of Gio-2.0.Gio.TlsPassword

        vfunc_get_default_warning(): string | null;
        /**
         * Get the password value. If `length` is not %NULL then it will be
         * filled in with the length of the password value. (Note that the
         * password value is not nul-terminated, so you can only pass %NULL
         * for `length` in contexts where you know the password will have a
         * certain fixed length.)
         * @virtual
         * @returns The password value (owned by the password object).
         */
        vfunc_get_value(): Uint8Array;
        /**
         * Provide the value for this password.
         *
         * The `value` will be owned by the password object, and later freed using
         * the `destroy` function callback.
         *
         * Specify the `length,` for a non-nul-terminated password. Pass -1 as
         * `length` if using a nul-terminated password, and `length` will be
         * calculated automatically. (Note that the terminating nul is not
         * considered part of the password in this case.)
         * @virtual
         * @param value the value for the password
         * @param destroy a function to use to free the password.
         */
        vfunc_set_value(
            value: Uint8Array,
            destroy: GLib.DestroyNotify | null
        ): void;

        // Class property signals of Gio-2.0.Gio.TlsPassword

        connect(
            sigName: 'notify::description',
            callback: ($obj: TlsPassword, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::description',
            callback: ($obj: TlsPassword, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::description', ...args: any[]): void;
        connect(
            sigName: 'notify::flags',
            callback: ($obj: TlsPassword, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::flags',
            callback: ($obj: TlsPassword, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::flags', ...args: any[]): void;
        connect(
            sigName: 'notify::warning',
            callback: ($obj: TlsPassword, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::warning',
            callback: ($obj: TlsPassword, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::warning', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * Holds a password used in TLS.
     * @class
     */
    class TlsPassword extends GObject.Object {
        // Own properties of Gio-2.0.Gio.TlsPassword

        static name: string;
        static $gtype: GObject.GType<TlsPassword>;

        // Constructors of Gio-2.0.Gio.TlsPassword

        constructor(config?: TlsPassword.ConstructorProperties);
        /**
         * Create a new #GTlsPassword object.
         * @constructor
         * @param flags the password flags
         * @param description description of what the password is for
         * @returns The newly allocated password object
         */
        constructor(flags: TlsPasswordFlags, description: string | null);
        /**
         * Create a new #GTlsPassword object.
         * @constructor
         * @param flags the password flags
         * @param description description of what the password is for
         * @returns The newly allocated password object
         */
        static new(
            flags: TlsPasswordFlags,
            description: string | null
        ): TlsPassword;
        _init(config?: TlsPassword.ConstructorProperties): void;
    }

    namespace UnixConnection {
        // Constructor properties interface

        type ConstructorProperties = SocketConnection.ConstructorProperties;
    }

    interface UnixConnection {
        // Own fields of Gio-2.0.Gio.UnixConnection

        parent_instance: SocketConnection &
            IOStream &
            GObject.Object &
            GObject.Object;
        priv: any;

        // Owm methods of Gio-2.0.Gio.UnixConnection

        /**
         * Receives credentials from the sending end of the connection.  The
         * sending end has to call g_unix_connection_send_credentials() (or
         * similar) for this to work.
         *
         * As well as reading the credentials this also reads (and discards) a
         * single byte from the stream, as this is required for credentials
         * passing to work on some implementations.
         *
         * This method can be expected to be available on the following platforms:
         *
         * - Linux since GLib 2.26
         * - FreeBSD since GLib 2.26
         * - GNU/kFreeBSD since GLib 2.36
         * - Solaris, Illumos and OpenSolaris since GLib 2.40
         * - GNU/Hurd since GLib 2.40
         *
         * Other ways to exchange credentials with a foreign peer includes the
         * #GUnixCredentialsMessage type and g_socket_get_credentials() function.
         * @param cancellable A #GCancellable or %NULL.
         * @returns Received credentials on success (free with g_object_unref()), %NULL if @error is set.
         */
        receive_credentials(cancellable: Cancellable | null): Credentials;
        /**
         * Asynchronously receive credentials.
         *
         * For more details, see g_unix_connection_receive_credentials() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called. You can then call
         * g_unix_connection_receive_credentials_finish() to get the result of the operation.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        receive_credentials_async(
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of receive_credentials_async

        /**
         * Promisified version of {@link receive_credentials_async}
         *
         * Asynchronously receive credentials.
         *
         * For more details, see g_unix_connection_receive_credentials() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called. You can then call
         * g_unix_connection_receive_credentials_finish() to get the result of the operation.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns A Promise of: a #GCredentials, or %NULL on error.     Free the returned object with g_object_unref().
         */
        receive_credentials_async(
            cancellable: Cancellable | null
        ): globalThis.Promise<Credentials>;
        /**
         * Finishes an asynchronous receive credentials operation started with
         * g_unix_connection_receive_credentials_async().
         * @param result a #GAsyncResult.
         * @returns a #GCredentials, or %NULL on error.     Free the returned object with g_object_unref().
         */
        receive_credentials_finish(result: AsyncResult): Credentials;
        /**
         * Receives a file descriptor from the sending end of the connection.
         * The sending end has to call g_unix_connection_send_fd() for this
         * to work.
         *
         * As well as reading the fd this also reads a single byte from the
         * stream, as this is required for fd passing to work on some
         * implementations.
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @returns a file descriptor on success, -1 on error.
         */
        receive_fd(cancellable: Cancellable | null): number;
        /**
         * Passes the credentials of the current user the receiving side
         * of the connection. The receiving end has to call
         * g_unix_connection_receive_credentials() (or similar) to accept the
         * credentials.
         *
         * As well as sending the credentials this also writes a single NUL
         * byte to the stream, as this is required for credentials passing to
         * work on some implementations.
         *
         * This method can be expected to be available on the following platforms:
         *
         * - Linux since GLib 2.26
         * - FreeBSD since GLib 2.26
         * - GNU/kFreeBSD since GLib 2.36
         * - Solaris, Illumos and OpenSolaris since GLib 2.40
         * - GNU/Hurd since GLib 2.40
         *
         * Other ways to exchange credentials with a foreign peer includes the
         * #GUnixCredentialsMessage type and g_socket_get_credentials() function.
         * @param cancellable A #GCancellable or %NULL.
         * @returns %TRUE on success, %FALSE if @error is set.
         */
        send_credentials(cancellable: Cancellable | null): boolean;
        /**
         * Asynchronously send credentials.
         *
         * For more details, see g_unix_connection_send_credentials() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called. You can then call
         * g_unix_connection_send_credentials_finish() to get the result of the operation.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        send_credentials_async(
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback<this> | null
        ): void;

        // Overloads of send_credentials_async

        /**
         * Promisified version of {@link send_credentials_async}
         *
         * Asynchronously send credentials.
         *
         * For more details, see g_unix_connection_send_credentials() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called. You can then call
         * g_unix_connection_send_credentials_finish() to get the result of the operation.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns A Promise of: %TRUE if the operation was successful, otherwise %FALSE.
         */
        send_credentials_async(
            cancellable: Cancellable | null
        ): globalThis.Promise<boolean>;
        /**
         * Finishes an asynchronous send credentials operation started with
         * g_unix_connection_send_credentials_async().
         * @param result a #GAsyncResult.
         * @returns %TRUE if the operation was successful, otherwise %FALSE.
         */
        send_credentials_finish(result: AsyncResult): boolean;
        /**
         * Passes a file descriptor to the receiving side of the
         * connection. The receiving end has to call g_unix_connection_receive_fd()
         * to accept the file descriptor.
         *
         * As well as sending the fd this also writes a single byte to the
         * stream, as this is required for fd passing to work on some
         * implementations.
         * @param fd a file descriptor
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a %TRUE on success, %NULL on error.
         */
        send_fd(fd: number, cancellable: Cancellable | null): boolean;

        // Class property signals of Gio-2.0.Gio.UnixConnection

        connect(
            sigName: 'notify::socket',
            callback: ($obj: UnixConnection, pspec: GObject.ParamSpec) => void
        ): number;

        // Overloads of connect

        /**
         * Connect `connection` to the specified remote address.
         * @param address a #GSocketAddress specifying the remote address.
         * @param cancellable a %GCancellable or %NULL
         * @returns %TRUE if the connection succeeded, %FALSE on error
         */
        connect(
            address: SocketAddress,
            cancellable: Cancellable | null
        ): boolean;
        connect_after(
            sigName: 'notify::socket',
            callback: ($obj: UnixConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::socket', ...args: any[]): void;
        connect(
            sigName: 'notify::closed',
            callback: ($obj: UnixConnection, pspec: GObject.ParamSpec) => void
        ): number;

        // Overloads of connect

        /**
         * Connect `connection` to the specified remote address.
         * @param address a #GSocketAddress specifying the remote address.
         * @param cancellable a %GCancellable or %NULL
         * @returns %TRUE if the connection succeeded, %FALSE on error
         */
        connect(
            address: SocketAddress,
            cancellable: Cancellable | null
        ): boolean;
        connect_after(
            sigName: 'notify::closed',
            callback: ($obj: UnixConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::closed', ...args: any[]): void;
        connect(
            sigName: 'notify::input-stream',
            callback: ($obj: UnixConnection, pspec: GObject.ParamSpec) => void
        ): number;

        // Overloads of connect

        /**
         * Connect `connection` to the specified remote address.
         * @param address a #GSocketAddress specifying the remote address.
         * @param cancellable a %GCancellable or %NULL
         * @returns %TRUE if the connection succeeded, %FALSE on error
         */
        connect(
            address: SocketAddress,
            cancellable: Cancellable | null
        ): boolean;
        connect_after(
            sigName: 'notify::input-stream',
            callback: ($obj: UnixConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::input-stream', ...args: any[]): void;
        connect(
            sigName: 'notify::output-stream',
            callback: ($obj: UnixConnection, pspec: GObject.ParamSpec) => void
        ): number;

        // Overloads of connect

        /**
         * Connect `connection` to the specified remote address.
         * @param address a #GSocketAddress specifying the remote address.
         * @param cancellable a %GCancellable or %NULL
         * @returns %TRUE if the connection succeeded, %FALSE on error
         */
        connect(
            address: SocketAddress,
            cancellable: Cancellable | null
        ): boolean;
        connect_after(
            sigName: 'notify::output-stream',
            callback: ($obj: UnixConnection, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::output-stream', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;

        // Overloads of connect

        /**
         * Connect `connection` to the specified remote address.
         * @param address a #GSocketAddress specifying the remote address.
         * @param cancellable a %GCancellable or %NULL
         * @returns %TRUE if the connection succeeded, %FALSE on error
         */
        connect(
            address: SocketAddress,
            cancellable: Cancellable | null
        ): boolean;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * This is the subclass of #GSocketConnection that is created
     * for UNIX domain sockets.
     *
     * It contains functions to do some of the UNIX socket specific
     * functionality like passing file descriptors.
     *
     * Since GLib 2.72, #GUnixConnection is available on all platforms. It requires
     * underlying system support (such as Windows 10 with `AF_UNIX`) at run time.
     *
     * Before GLib 2.72, `<gio/gunixconnection.h>` belonged to the UNIX-specific GIO
     * interfaces, thus you had to use the `gio-unix-2.0.pc` pkg-config file when
     * using it. This is no longer necessary since GLib 2.72.
     * @class
     */
    class UnixConnection extends SocketConnection {
        // Own properties of Gio-2.0.Gio.UnixConnection

        static name: string;
        static $gtype: GObject.GType<UnixConnection>;

        // Constructors of Gio-2.0.Gio.UnixConnection

        constructor(config?: UnixConnection.ConstructorProperties);
        _init(config?: UnixConnection.ConstructorProperties): void;
    }

    namespace UnixCredentialsMessage {
        // Constructor properties interface

        interface ConstructorProperties
            extends SocketControlMessage.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.UnixCredentialsMessage

            /**
             * The credentials stored in the message.
             */
            credentials?: Credentials | null;
        }
    }

    interface UnixCredentialsMessage {
        // Own properties of Gio-2.0.Gio.UnixCredentialsMessage

        /**
         * The credentials stored in the message.
         */
        readonly credentials: Credentials;

        // Own fields of Gio-2.0.Gio.UnixCredentialsMessage

        parent_instance: SocketControlMessage & GObject.Object;
        priv: any;

        // Owm methods of Gio-2.0.Gio.UnixCredentialsMessage

        /**
         * Gets the credentials stored in `message`.
         * @returns A #GCredentials instance. Do not free, it is owned by @message.
         */
        get_credentials(): Credentials;

        // Class property signals of Gio-2.0.Gio.UnixCredentialsMessage

        connect(
            sigName: 'notify::credentials',
            callback: (
                $obj: UnixCredentialsMessage,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::credentials',
            callback: (
                $obj: UnixCredentialsMessage,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::credentials', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * This #GSocketControlMessage contains a #GCredentials instance.  It
     * may be sent using g_socket_send_message() and received using
     * g_socket_receive_message() over UNIX sockets (ie: sockets in the
     * %G_SOCKET_FAMILY_UNIX family).
     *
     * For an easier way to send and receive credentials over
     * stream-oriented UNIX sockets, see
     * g_unix_connection_send_credentials() and
     * g_unix_connection_receive_credentials(). To receive credentials of
     * a foreign process connected to a socket, use
     * g_socket_get_credentials().
     *
     * Since GLib 2.72, #GUnixCredentialMessage is available on all platforms. It
     * requires underlying system support (such as Windows 10 with `AF_UNIX`) at run
     * time.
     *
     * Before GLib 2.72, `<gio/gunixcredentialsmessage.h>` belonged to the UNIX-specific
     * GIO interfaces, thus you had to use the `gio-unix-2.0.pc` pkg-config file
     * when using it. This is no longer necessary since GLib 2.72.
     * @class
     */
    class UnixCredentialsMessage extends SocketControlMessage {
        // Own properties of Gio-2.0.Gio.UnixCredentialsMessage

        static name: string;
        static $gtype: GObject.GType<UnixCredentialsMessage>;

        // Constructors of Gio-2.0.Gio.UnixCredentialsMessage

        constructor(config?: UnixCredentialsMessage.ConstructorProperties);
        /**
         * Creates a new #GUnixCredentialsMessage with credentials matching the current processes.
         * @constructor
         * @returns a new #GUnixCredentialsMessage
         */
        constructor();
        /**
         * Creates a new #GUnixCredentialsMessage with credentials matching the current processes.
         * @constructor
         * @returns a new #GUnixCredentialsMessage
         */
        static new(): UnixCredentialsMessage;
        /**
         * Creates a new #GUnixCredentialsMessage holding `credentials`.
         * @constructor
         * @param credentials A #GCredentials object.
         * @returns a new #GUnixCredentialsMessage
         */
        static new_with_credentials(
            credentials: Credentials
        ): UnixCredentialsMessage;
        _init(config?: UnixCredentialsMessage.ConstructorProperties): void;
        /**
         * Checks if passing #GCredentials on a #GSocket is supported on this platform.
         * @returns %TRUE if supported, %FALSE otherwise
         */
        static is_supported(): boolean;
    }

    namespace UnixFDList {
        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface UnixFDList {
        // Own fields of Gio-2.0.Gio.UnixFDList

        parent_instance: GObject.Object;
        priv: UnixFDListPrivate;

        // Owm methods of Gio-2.0.Gio.UnixFDList

        /**
         * Adds a file descriptor to `list`.
         *
         * The file descriptor is duplicated using dup(). You keep your copy
         * of the descriptor and the copy contained in `list` will be closed
         * when `list` is finalized.
         *
         * A possible cause of failure is exceeding the per-process or
         * system-wide file descriptor limit.
         *
         * The index of the file descriptor in the list is returned.  If you use
         * this index with g_unix_fd_list_get() then you will receive back a
         * duplicated copy of the same file descriptor.
         * @param fd a valid open file descriptor
         * @returns the index of the appended fd in case of success, else -1          (and @error is set)
         */
        append(fd: number): number;
        /**
         * Gets a file descriptor out of `list`.
         *
         * `index_` specifies the index of the file descriptor to get.  It is a
         * programmer error for `index_` to be out of range; see
         * g_unix_fd_list_get_length().
         *
         * The file descriptor is duplicated using dup() and set as
         * close-on-exec before being returned.  You must call close() on it
         * when you are done.
         *
         * A possible cause of failure is exceeding the per-process or
         * system-wide file descriptor limit.
         * @param index_ the index into the list
         * @returns the file descriptor, or -1 in case of error
         */
        get(index_: number): number;
        /**
         * Gets the length of `list` (ie: the number of file descriptors
         * contained within).
         * @returns the length of @list
         */
        get_length(): number;
        /**
         * Returns the array of file descriptors that is contained in this
         * object.
         *
         * After this call, the descriptors remain the property of `list`.  The
         * caller must not close them and must not free the array.  The array is
         * valid only until `list` is changed in any way.
         *
         * If `length` is non-%NULL then it is set to the number of file
         * descriptors in the returned array. The returned array is also
         * terminated with -1.
         *
         * This function never returns %NULL. In case there are no file
         * descriptors contained in `list,` an empty array is returned.
         * @returns an array of file     descriptors
         */
        peek_fds(): number[];
        /**
         * Returns the array of file descriptors that is contained in this
         * object.
         *
         * After this call, the descriptors are no longer contained in
         * `list`. Further calls will return an empty list (unless more
         * descriptors have been added).
         *
         * The return result of this function must be freed with g_free().
         * The caller is also responsible for closing all of the file
         * descriptors.  The file descriptors in the array are set to
         * close-on-exec.
         *
         * If `length` is non-%NULL then it is set to the number of file
         * descriptors in the returned array. The returned array is also
         * terminated with -1.
         *
         * This function never returns %NULL. In case there are no file
         * descriptors contained in `list,` an empty array is returned.
         * @returns an array of file     descriptors
         */
        steal_fds(): number[];

        // Class property signals of Gio-2.0.Gio.UnixFDList

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * A #GUnixFDList contains a list of file descriptors.  It owns the file
     * descriptors that it contains, closing them when finalized.
     *
     * It may be wrapped in a #GUnixFDMessage and sent over a #GSocket in
     * the %G_SOCKET_FAMILY_UNIX family by using g_socket_send_message()
     * and received using g_socket_receive_message().
     *
     * Before 2.74, `<gio/gunixfdlist.h>` belonged to the UNIX-specific GIO
     * interfaces, thus you had to use the `gio-unix-2.0.pc` pkg-config file when
     * using it.
     *
     * Since 2.74, the API is available for Windows.
     * @class
     */
    class UnixFDList extends GObject.Object {
        // Own properties of Gio-2.0.Gio.UnixFDList

        static name: string;
        static $gtype: GObject.GType<UnixFDList>;

        // Constructors of Gio-2.0.Gio.UnixFDList

        constructor(config?: UnixFDList.ConstructorProperties);
        /**
         * Creates a new #GUnixFDList containing no file descriptors.
         * @constructor
         * @returns a new #GUnixFDList
         */
        constructor();
        /**
         * Creates a new #GUnixFDList containing no file descriptors.
         * @constructor
         * @returns a new #GUnixFDList
         */
        static new(): UnixFDList;
        /**
         * Creates a new #GUnixFDList containing the file descriptors given in
         * `fds`.  The file descriptors become the property of the new list and
         * may no longer be used by the caller.  The array itself is owned by
         * the caller.
         *
         * Each file descriptor in the array should be set to close-on-exec.
         *
         * If `n_fds` is -1 then `fds` must be terminated with -1.
         * @constructor
         * @param fds the initial list of file descriptors
         * @returns a new #GUnixFDList
         */
        static new_from_array(fds: number[]): UnixFDList;
        _init(config?: UnixFDList.ConstructorProperties): void;
    }

    namespace UnixFDMessage {
        // Constructor properties interface

        interface ConstructorProperties
            extends SocketControlMessage.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.UnixFDMessage

            fd_list?: UnixFDList | null;
        }
    }

    interface UnixFDMessage {
        // Own properties of Gio-2.0.Gio.UnixFDMessage

        readonly fd_list: UnixFDList;

        // Own fields of Gio-2.0.Gio.UnixFDMessage

        parent_instance: SocketControlMessage & GObject.Object;
        priv: any;

        // Owm methods of Gio-2.0.Gio.UnixFDMessage

        /**
         * Adds a file descriptor to `message`.
         *
         * The file descriptor is duplicated using dup(). You keep your copy
         * of the descriptor and the copy contained in `message` will be closed
         * when `message` is finalized.
         *
         * A possible cause of failure is exceeding the per-process or
         * system-wide file descriptor limit.
         * @param fd a valid open file descriptor
         * @returns %TRUE in case of success, else %FALSE (and @error is set)
         */
        append_fd(fd: number): boolean;
        /**
         * Gets the #GUnixFDList contained in `message`.  This function does not
         * return a reference to the caller, but the returned list is valid for
         * the lifetime of `message`.
         * @returns the #GUnixFDList from @message
         */
        get_fd_list(): UnixFDList;
        /**
         * Returns the array of file descriptors that is contained in this
         * object.
         *
         * After this call, the descriptors are no longer contained in
         * `message`. Further calls will return an empty list (unless more
         * descriptors have been added).
         *
         * The return result of this function must be freed with g_free().
         * The caller is also responsible for closing all of the file
         * descriptors.
         *
         * If `length` is non-%NULL then it is set to the number of file
         * descriptors in the returned array. The returned array is also
         * terminated with -1.
         *
         * This function never returns %NULL. In case there are no file
         * descriptors contained in `message,` an empty array is returned.
         * @returns an array of file     descriptors
         */
        steal_fds(): number[];

        // Class property signals of Gio-2.0.Gio.UnixFDMessage

        connect(
            sigName: 'notify::fd-list',
            callback: ($obj: UnixFDMessage, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::fd-list',
            callback: ($obj: UnixFDMessage, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::fd-list', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * This #GSocketControlMessage contains a #GUnixFDList.
     * It may be sent using g_socket_send_message() and received using
     * g_socket_receive_message() over UNIX sockets (ie: sockets in the
     * %G_SOCKET_FAMILY_UNIX family). The file descriptors are copied
     * between processes by the kernel.
     *
     * For an easier way to send and receive file descriptors over
     * stream-oriented UNIX sockets, see g_unix_connection_send_fd() and
     * g_unix_connection_receive_fd().
     *
     * Note that `<gio/gunixfdmessage.h>` belongs to the UNIX-specific GIO
     * interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config
     * file when using it.
     * @class
     */
    class UnixFDMessage extends SocketControlMessage {
        // Own properties of Gio-2.0.Gio.UnixFDMessage

        static name: string;
        static $gtype: GObject.GType<UnixFDMessage>;

        // Constructors of Gio-2.0.Gio.UnixFDMessage

        constructor(config?: UnixFDMessage.ConstructorProperties);
        /**
         * Creates a new #GUnixFDMessage containing an empty file descriptor
         * list.
         * @constructor
         * @returns a new #GUnixFDMessage
         */
        constructor();
        /**
         * Creates a new #GUnixFDMessage containing an empty file descriptor
         * list.
         * @constructor
         * @returns a new #GUnixFDMessage
         */
        static new(): UnixFDMessage;
        /**
         * Creates a new #GUnixFDMessage containing `list`.
         * @constructor
         * @param fd_list a #GUnixFDList
         * @returns a new #GUnixFDMessage
         */
        static new_with_fd_list(fd_list: UnixFDList): UnixFDMessage;
        _init(config?: UnixFDMessage.ConstructorProperties): void;
    }

    namespace UnixInputStream {
        // Constructor properties interface

        interface ConstructorProperties
            extends FileDescriptorBased.ConstructorProperties,
                PollableInputStream.ConstructorProperties,
                InputStream.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.UnixInputStream

            /**
             * Whether to close the file descriptor when the stream is closed.
             */
            close_fd?: boolean | null;
            /**
             * The file descriptor that the stream reads from.
             */
            fd?: number | null;
        }
    }

    interface UnixInputStream extends FileDescriptorBased, PollableInputStream {
        // Own properties of Gio-2.0.Gio.UnixInputStream

        /**
         * Whether to close the file descriptor when the stream is closed.
         */
        close_fd: boolean;
        /**
         * The file descriptor that the stream reads from.
         */
        readonly fd: number;

        // Own fields of Gio-2.0.Gio.UnixInputStream

        parent_instance: InputStream & GObject.Object;

        // Owm methods of Gio-2.0.Gio.UnixInputStream

        /**
         * Returns whether the file descriptor of `stream` will be
         * closed when the stream is closed.
         * @returns %TRUE if the file descriptor is closed when done
         */
        get_close_fd(): boolean;
        /**
         * Return the UNIX file descriptor that the stream reads from.
         * @returns The file descriptor of @stream
         */
        get_fd(): number;
        /**
         * Sets whether the file descriptor of `stream` shall be closed
         * when the stream is closed.
         * @param close_fd %TRUE to close the file descriptor when done
         */
        set_close_fd(close_fd: boolean): void;

        // Class property signals of Gio-2.0.Gio.UnixInputStream

        connect(
            sigName: 'notify::close-fd',
            callback: ($obj: UnixInputStream, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::close-fd',
            callback: ($obj: UnixInputStream, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::close-fd', ...args: any[]): void;
        connect(
            sigName: 'notify::fd',
            callback: ($obj: UnixInputStream, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::fd',
            callback: ($obj: UnixInputStream, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::fd', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GUnixInputStream implements #GInputStream for reading from a UNIX
     * file descriptor, including asynchronous operations. (If the file
     * descriptor refers to a socket or pipe, this will use poll() to do
     * asynchronous I/O. If it refers to a regular file, it will fall back
     * to doing asynchronous I/O in another thread.)
     *
     * Note that `<gio/gunixinputstream.h>` belongs to the UNIX-specific GIO
     * interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config
     * file when using it.
     * @class
     */
    class UnixInputStream extends InputStream {
        // Own properties of Gio-2.0.Gio.UnixInputStream

        static name: string;
        static $gtype: GObject.GType<UnixInputStream>;

        // Constructors of Gio-2.0.Gio.UnixInputStream

        constructor(config?: UnixInputStream.ConstructorProperties);
        /**
         * Creates a new #GUnixInputStream for the given `fd`.
         *
         * If `close_fd` is %TRUE, the file descriptor will be closed
         * when the stream is closed.
         * @constructor
         * @param fd a UNIX file descriptor
         * @param close_fd %TRUE to close the file descriptor when done
         * @returns a new #GUnixInputStream
         */
        constructor(fd: number, close_fd: boolean);
        /**
         * Creates a new #GUnixInputStream for the given `fd`.
         *
         * If `close_fd` is %TRUE, the file descriptor will be closed
         * when the stream is closed.
         * @constructor
         * @param fd a UNIX file descriptor
         * @param close_fd %TRUE to close the file descriptor when done
         * @returns a new #GUnixInputStream
         */
        static new(fd: number, close_fd: boolean): UnixInputStream;
        _init(config?: UnixInputStream.ConstructorProperties): void;
    }

    namespace UnixMountMonitor {
        // Signal callback interfaces

        /**
         * Signal callback interface for `mountpoints-changed`
         */
        interface MountpointsChangedSignalCallback {
            ($obj: UnixMountMonitor): void;
        }

        /**
         * Signal callback interface for `mounts-changed`
         */
        interface MountsChangedSignalCallback {
            ($obj: UnixMountMonitor): void;
        }

        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface UnixMountMonitor {
        // Owm methods of Gio-2.0.Gio.UnixMountMonitor

        /**
         * This function does nothing.
         *
         * Before 2.44, this was a partially-effective way of controlling the
         * rate at which events would be reported under some uncommon
         * circumstances.  Since `mount_monitor` is a singleton, it also meant
         * that calling this function would have side effects for other users of
         * the monitor.
         * @param limit_msec a integer with the limit in milliseconds to     poll for changes.
         */
        set_rate_limit(limit_msec: number): void;

        // Own signals of Gio-2.0.Gio.UnixMountMonitor

        connect(
            sigName: 'mountpoints-changed',
            callback: UnixMountMonitor.MountpointsChangedSignalCallback
        ): number;
        connect_after(
            sigName: 'mountpoints-changed',
            callback: UnixMountMonitor.MountpointsChangedSignalCallback
        ): number;
        emit(sigName: 'mountpoints-changed', ...args: any[]): void;
        connect(
            sigName: 'mounts-changed',
            callback: UnixMountMonitor.MountsChangedSignalCallback
        ): number;
        connect_after(
            sigName: 'mounts-changed',
            callback: UnixMountMonitor.MountsChangedSignalCallback
        ): number;
        emit(sigName: 'mounts-changed', ...args: any[]): void;

        // Class property signals of Gio-2.0.Gio.UnixMountMonitor

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * Watches #GUnixMounts for changes.
     * @class
     */
    class UnixMountMonitor extends GObject.Object {
        // Own properties of Gio-2.0.Gio.UnixMountMonitor

        static name: string;
        static $gtype: GObject.GType<UnixMountMonitor>;

        // Constructors of Gio-2.0.Gio.UnixMountMonitor

        constructor(config?: UnixMountMonitor.ConstructorProperties);
        /**
         * Deprecated alias for g_unix_mount_monitor_get().
         *
         * This function was never a true constructor, which is why it was
         * renamed.
         * @constructor
         * @returns a #GUnixMountMonitor.
         */
        constructor();
        /**
         * Deprecated alias for g_unix_mount_monitor_get().
         *
         * This function was never a true constructor, which is why it was
         * renamed.
         * @constructor
         * @returns a #GUnixMountMonitor.
         */
        static new(): UnixMountMonitor;
        _init(config?: UnixMountMonitor.ConstructorProperties): void;
        /**
         * Gets the #GUnixMountMonitor for the current thread-default main
         * context.
         *
         * The mount monitor can be used to monitor for changes to the list of
         * mounted filesystems as well as the list of mount points (ie: fstab
         * entries).
         *
         * You must only call g_object_unref() on the return value from under
         * the same main context as you called this function.
         * @returns the #GUnixMountMonitor.
         */
        static get(): UnixMountMonitor;
    }

    namespace UnixOutputStream {
        // Constructor properties interface

        interface ConstructorProperties
            extends FileDescriptorBased.ConstructorProperties,
                PollableOutputStream.ConstructorProperties,
                OutputStream.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.UnixOutputStream

            /**
             * Whether to close the file descriptor when the stream is closed.
             */
            close_fd?: boolean | null;
            /**
             * The file descriptor that the stream writes to.
             */
            fd?: number | null;
        }
    }

    interface UnixOutputStream
        extends FileDescriptorBased,
            PollableOutputStream {
        // Own properties of Gio-2.0.Gio.UnixOutputStream

        /**
         * Whether to close the file descriptor when the stream is closed.
         */
        close_fd: boolean;
        /**
         * The file descriptor that the stream writes to.
         */
        readonly fd: number;

        // Own fields of Gio-2.0.Gio.UnixOutputStream

        parent_instance: OutputStream & GObject.Object;

        // Owm methods of Gio-2.0.Gio.UnixOutputStream

        /**
         * Returns whether the file descriptor of `stream` will be
         * closed when the stream is closed.
         * @returns %TRUE if the file descriptor is closed when done
         */
        get_close_fd(): boolean;
        /**
         * Return the UNIX file descriptor that the stream writes to.
         * @returns The file descriptor of @stream
         */
        get_fd(): number;
        /**
         * Sets whether the file descriptor of `stream` shall be closed
         * when the stream is closed.
         * @param close_fd %TRUE to close the file descriptor when done
         */
        set_close_fd(close_fd: boolean): void;

        // Class property signals of Gio-2.0.Gio.UnixOutputStream

        connect(
            sigName: 'notify::close-fd',
            callback: ($obj: UnixOutputStream, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::close-fd',
            callback: ($obj: UnixOutputStream, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::close-fd', ...args: any[]): void;
        connect(
            sigName: 'notify::fd',
            callback: ($obj: UnixOutputStream, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::fd',
            callback: ($obj: UnixOutputStream, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::fd', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GUnixOutputStream implements #GOutputStream for writing to a UNIX
     * file descriptor, including asynchronous operations. (If the file
     * descriptor refers to a socket or pipe, this will use poll() to do
     * asynchronous I/O. If it refers to a regular file, it will fall back
     * to doing asynchronous I/O in another thread.)
     *
     * Note that `<gio/gunixoutputstream.h>` belongs to the UNIX-specific GIO
     * interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file
     * when using it.
     * @class
     */
    class UnixOutputStream extends OutputStream {
        // Own properties of Gio-2.0.Gio.UnixOutputStream

        static name: string;
        static $gtype: GObject.GType<UnixOutputStream>;

        // Constructors of Gio-2.0.Gio.UnixOutputStream

        constructor(config?: UnixOutputStream.ConstructorProperties);
        /**
         * Creates a new #GUnixOutputStream for the given `fd`.
         *
         * If `close_fd,` is %TRUE, the file descriptor will be closed when
         * the output stream is destroyed.
         * @constructor
         * @param fd a UNIX file descriptor
         * @param close_fd %TRUE to close the file descriptor when done
         * @returns a new #GOutputStream
         */
        constructor(fd: number, close_fd: boolean);
        /**
         * Creates a new #GUnixOutputStream for the given `fd`.
         *
         * If `close_fd,` is %TRUE, the file descriptor will be closed when
         * the output stream is destroyed.
         * @constructor
         * @param fd a UNIX file descriptor
         * @param close_fd %TRUE to close the file descriptor when done
         * @returns a new #GOutputStream
         */
        static new(fd: number, close_fd: boolean): UnixOutputStream;
        _init(config?: UnixOutputStream.ConstructorProperties): void;
    }

    namespace UnixSocketAddress {
        // Constructor properties interface

        interface ConstructorProperties
            extends SocketConnectable.ConstructorProperties,
                SocketAddress.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.UnixSocketAddress

            /**
             * Whether or not this is an abstract address
             */
            abstract?: boolean | null;
            address_type?: UnixSocketAddressType | null;
            path?: string | null;
            path_as_array?: Uint8Array | null;
        }
    }

    interface UnixSocketAddress extends SocketConnectable {
        // Own properties of Gio-2.0.Gio.UnixSocketAddress

        /**
         * Whether or not this is an abstract address
         */
        readonly abstract: boolean;
        readonly address_type: UnixSocketAddressType;
        readonly path: string | null;
        readonly path_as_array: Uint8Array;

        // Own fields of Gio-2.0.Gio.UnixSocketAddress

        parent_instance: SocketAddress & GObject.Object;

        // Owm methods of Gio-2.0.Gio.UnixSocketAddress

        /**
         * Gets `address'`s type.
         * @returns a #GUnixSocketAddressType
         */
        get_address_type(): UnixSocketAddressType;
        /**
         * Tests if `address` is abstract.
         * @returns %TRUE if the address is abstract, %FALSE otherwise
         */
        get_is_abstract(): boolean;
        /**
         * Gets `address'`s path, or for abstract sockets the "name".
         *
         * Guaranteed to be zero-terminated, but an abstract socket
         * may contain embedded zeros, and thus you should use
         * g_unix_socket_address_get_path_len() to get the true length
         * of this string.
         * @returns the path for @address
         */
        get_path(): string | null;
        /**
         * Gets the length of `address'`s path.
         *
         * For details, see g_unix_socket_address_get_path().
         * @returns the length of the path
         */
        get_path_len(): number;

        // Class property signals of Gio-2.0.Gio.UnixSocketAddress

        connect(
            sigName: 'notify::abstract',
            callback: (
                $obj: UnixSocketAddress,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::abstract',
            callback: (
                $obj: UnixSocketAddress,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::abstract', ...args: any[]): void;
        connect(
            sigName: 'notify::address-type',
            callback: (
                $obj: UnixSocketAddress,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::address-type',
            callback: (
                $obj: UnixSocketAddress,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::address-type', ...args: any[]): void;
        connect(
            sigName: 'notify::path',
            callback: (
                $obj: UnixSocketAddress,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::path',
            callback: (
                $obj: UnixSocketAddress,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::path', ...args: any[]): void;
        connect(
            sigName: 'notify::path-as-array',
            callback: (
                $obj: UnixSocketAddress,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::path-as-array',
            callback: (
                $obj: UnixSocketAddress,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::path-as-array', ...args: any[]): void;
        connect(
            sigName: 'notify::family',
            callback: (
                $obj: UnixSocketAddress,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::family',
            callback: (
                $obj: UnixSocketAddress,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::family', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * Support for UNIX-domain (also known as local) sockets.
     *
     * UNIX domain sockets are generally visible in the filesystem.
     * However, some systems support abstract socket names which are not
     * visible in the filesystem and not affected by the filesystem
     * permissions, visibility, etc. Currently this is only supported
     * under Linux. If you attempt to use abstract sockets on other
     * systems, function calls may return %G_IO_ERROR_NOT_SUPPORTED
     * errors. You can use g_unix_socket_address_abstract_names_supported()
     * to see if abstract names are supported.
     *
     * Since GLib 2.72, #GUnixSocketAddress is available on all platforms. It
     * requires underlying system support (such as Windows 10 with `AF_UNIX`) at
     * run time.
     *
     * Before GLib 2.72, `<gio/gunixsocketaddress.h>` belonged to the UNIX-specific
     * GIO interfaces, thus you had to use the `gio-unix-2.0.pc` pkg-config file
     * when using it. This is no longer necessary since GLib 2.72.
     * @class
     */
    class UnixSocketAddress extends SocketAddress {
        // Own properties of Gio-2.0.Gio.UnixSocketAddress

        static name: string;
        static $gtype: GObject.GType<UnixSocketAddress>;

        // Constructors of Gio-2.0.Gio.UnixSocketAddress

        constructor(config?: UnixSocketAddress.ConstructorProperties);
        /**
         * Creates a new #GUnixSocketAddress for `path`.
         *
         * To create abstract socket addresses, on systems that support that,
         * use g_unix_socket_address_new_abstract().
         * @constructor
         * @param path the socket path
         * @returns a new #GUnixSocketAddress
         */
        constructor(path: string | null);
        /**
         * Creates a new #GUnixSocketAddress for `path`.
         *
         * To create abstract socket addresses, on systems that support that,
         * use g_unix_socket_address_new_abstract().
         * @constructor
         * @param path the socket path
         * @returns a new #GUnixSocketAddress
         */
        static new(path: string | null): UnixSocketAddress;
        /**
         * Creates a new %G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED
         * #GUnixSocketAddress for `path`.
         * @constructor
         * @param path the abstract name
         * @returns a new #GUnixSocketAddress
         */
        static new_abstract(path: number[]): UnixSocketAddress;
        /**
         * Creates a new #GUnixSocketAddress of type `type` with name `path`.
         *
         * If `type` is %G_UNIX_SOCKET_ADDRESS_PATH, this is equivalent to
         * calling g_unix_socket_address_new().
         *
         * If `type` is %G_UNIX_SOCKET_ADDRESS_ANONYMOUS, `path` and `path_len` will be
         * ignored.
         *
         * If `path_type` is %G_UNIX_SOCKET_ADDRESS_ABSTRACT, then `path_len`
         * bytes of `path` will be copied to the socket's path, and only those
         * bytes will be considered part of the name. (If `path_len` is -1,
         * then `path` is assumed to be NUL-terminated.) For example, if `path`
         * was "test", then calling g_socket_address_get_native_size() on the
         * returned socket would return 7 (2 bytes of overhead, 1 byte for the
         * abstract-socket indicator byte, and 4 bytes for the name "test").
         *
         * If `path_type` is %G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED, then
         * `path_len` bytes of `path` will be copied to the socket's path, the
         * rest of the path will be padded with 0 bytes, and the entire
         * zero-padded buffer will be considered the name. (As above, if
         * `path_len` is -1, then `path` is assumed to be NUL-terminated.) In
         * this case, g_socket_address_get_native_size() will always return
         * the full size of a `struct sockaddr_un`, although
         * g_unix_socket_address_get_path_len() will still return just the
         * length of `path`.
         *
         * %G_UNIX_SOCKET_ADDRESS_ABSTRACT is preferred over
         * %G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED for new programs. Of course,
         * when connecting to a server created by another process, you must
         * use the appropriate type corresponding to how that process created
         * its listening socket.
         * @constructor
         * @param path the name
         * @param type a #GUnixSocketAddressType
         * @returns a new #GUnixSocketAddress
         */
        static new_with_type(
            path: number[],
            type: UnixSocketAddressType
        ): UnixSocketAddress;
        _init(config?: UnixSocketAddress.ConstructorProperties): void;
        /**
         * Checks if abstract UNIX domain socket names are supported.
         * @returns %TRUE if supported, %FALSE otherwise
         */
        static abstract_names_supported(): boolean;
    }

    namespace Vfs {
        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface Vfs {
        // Own fields of Gio-2.0.Gio.Vfs

        parent_instance: GObject.Object;

        // Owm methods of Gio-2.0.Gio.Vfs

        /**
         * Gets a #GFile for `path`.
         * @param path a string containing a VFS path.
         * @returns a #GFile.     Free the returned object with g_object_unref().
         */
        get_file_for_path(path: string | null): File;
        /**
         * Gets a #GFile for `uri`.
         *
         * This operation never fails, but the returned object
         * might not support any I/O operation if the URI
         * is malformed or if the URI scheme is not supported.
         * @param uri a string containing a URI
         * @returns a #GFile.     Free the returned object with g_object_unref().
         */
        get_file_for_uri(uri: string | null): File;
        /**
         * Gets a list of URI schemes supported by `vfs`.
         * @returns a %NULL-terminated array of strings.     The returned array belongs to GIO and must     not be freed or modified.
         */
        get_supported_uri_schemes(): string[];
        /**
         * Checks if the VFS is active.
         * @returns %TRUE if construction of the @vfs was successful     and it is now active.
         */
        is_active(): boolean;
        /**
         * This operation never fails, but the returned object might
         * not support any I/O operations if the `parse_name` cannot
         * be parsed by the #GVfs module.
         * @param parse_name a string to be parsed by the VFS module.
         * @returns a #GFile for the given @parse_name.     Free the returned object with g_object_unref().
         */
        parse_name(parse_name: string | null): File;
        /**
         * Registers `uri_func` and `parse_name_func` as the #GFile URI and parse name
         * lookup functions for URIs with a scheme matching `scheme`.
         * Note that `scheme` is registered only within the running application, as
         * opposed to desktop-wide as it happens with GVfs backends.
         *
         * When a #GFile is requested with an URI containing `scheme` (e.g. through
         * g_file_new_for_uri()), `uri_func` will be called to allow a custom
         * constructor. The implementation of `uri_func` should not be blocking, and
         * must not call g_vfs_register_uri_scheme() or g_vfs_unregister_uri_scheme().
         *
         * When g_file_parse_name() is called with a parse name obtained from such file,
         * `parse_name_func` will be called to allow the #GFile to be created again. In
         * that case, it's responsibility of `parse_name_func` to make sure the parse
         * name matches what the custom #GFile implementation returned when
         * g_file_get_parse_name() was previously called. The implementation of
         * `parse_name_func` should not be blocking, and must not call
         * g_vfs_register_uri_scheme() or g_vfs_unregister_uri_scheme().
         *
         * It's an error to call this function twice with the same scheme. To unregister
         * a custom URI scheme, use g_vfs_unregister_uri_scheme().
         * @param scheme an URI scheme, e.g. "http"
         * @param uri_func a #GVfsFileLookupFunc
         * @param parse_name_func a #GVfsFileLookupFunc
         * @returns %TRUE if @scheme was successfully registered, or %FALSE if a handler     for @scheme already exists.
         */
        register_uri_scheme(
            scheme: string | null,
            uri_func: VfsFileLookupFunc | null,
            parse_name_func: VfsFileLookupFunc | null
        ): boolean;
        /**
         * Unregisters the URI handler for `scheme` previously registered with
         * g_vfs_register_uri_scheme().
         * @param scheme an URI scheme, e.g. "http"
         * @returns %TRUE if @scheme was successfully unregistered, or %FALSE if a     handler for @scheme does not exist.
         */
        unregister_uri_scheme(scheme: string | null): boolean;

        // Own virtual methods of Gio-2.0.Gio.Vfs

        vfunc_add_writable_namespaces(list: FileAttributeInfoList): void;
        /**
         * Gets a #GFile for `path`.
         * @virtual
         * @param path a string containing a VFS path.
         * @returns a #GFile.     Free the returned object with g_object_unref().
         */
        vfunc_get_file_for_path(path: string | null): File;
        /**
         * Gets a #GFile for `uri`.
         *
         * This operation never fails, but the returned object
         * might not support any I/O operation if the URI
         * is malformed or if the URI scheme is not supported.
         * @virtual
         * @param uri a string containing a URI
         * @returns a #GFile.     Free the returned object with g_object_unref().
         */
        vfunc_get_file_for_uri(uri: string | null): File;
        /**
         * Gets a list of URI schemes supported by `vfs`.
         * @virtual
         * @returns a %NULL-terminated array of strings.     The returned array belongs to GIO and must     not be freed or modified.
         */
        vfunc_get_supported_uri_schemes(): string[];
        /**
         * Checks if the VFS is active.
         * @virtual
         * @returns %TRUE if construction of the @vfs was successful     and it is now active.
         */
        vfunc_is_active(): boolean;
        vfunc_local_file_add_info(
            filename: string | null,
            device: number,
            attribute_matcher: FileAttributeMatcher,
            info: FileInfo,
            cancellable: Cancellable | null,
            extra_data: any | null,
            free_extra_data: GLib.DestroyNotify
        ): void;
        vfunc_local_file_moved(
            source: string | null,
            dest: string | null
        ): void;
        vfunc_local_file_removed(filename: string | null): void;
        vfunc_local_file_set_attributes(
            filename: string | null,
            info: FileInfo,
            flags: FileQueryInfoFlags,
            cancellable: Cancellable | null
        ): boolean;
        /**
         * This operation never fails, but the returned object might
         * not support any I/O operations if the `parse_name` cannot
         * be parsed by the #GVfs module.
         * @virtual
         * @param parse_name a string to be parsed by the VFS module.
         * @returns a #GFile for the given @parse_name.     Free the returned object with g_object_unref().
         */
        vfunc_parse_name(parse_name: string | null): File;

        // Class property signals of Gio-2.0.Gio.Vfs

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * Entry point for using GIO functionality.
     * @class
     */
    class Vfs extends GObject.Object {
        // Own properties of Gio-2.0.Gio.Vfs

        static name: string;
        static $gtype: GObject.GType<Vfs>;

        // Constructors of Gio-2.0.Gio.Vfs

        constructor(config?: Vfs.ConstructorProperties);
        _init(config?: Vfs.ConstructorProperties): void;
        /**
         * Gets the default #GVfs for the system.
         * @returns a #GVfs, which will be the local     file system #GVfs if no other implementation is available.
         */
        static get_default(): Vfs;
        /**
         * Gets the local #GVfs for the system.
         * @returns a #GVfs.
         */
        static get_local(): Vfs;
    }

    namespace VolumeMonitor {
        // Signal callback interfaces

        /**
         * Signal callback interface for `drive-changed`
         */
        interface DriveChangedSignalCallback {
            ($obj: VolumeMonitor, drive: Drive): void;
        }

        /**
         * Signal callback interface for `drive-connected`
         */
        interface DriveConnectedSignalCallback {
            ($obj: VolumeMonitor, drive: Drive): void;
        }

        /**
         * Signal callback interface for `drive-disconnected`
         */
        interface DriveDisconnectedSignalCallback {
            ($obj: VolumeMonitor, drive: Drive): void;
        }

        /**
         * Signal callback interface for `drive-eject-button`
         */
        interface DriveEjectButtonSignalCallback {
            ($obj: VolumeMonitor, drive: Drive): void;
        }

        /**
         * Signal callback interface for `drive-stop-button`
         */
        interface DriveStopButtonSignalCallback {
            ($obj: VolumeMonitor, drive: Drive): void;
        }

        /**
         * Signal callback interface for `mount-added`
         */
        interface MountAddedSignalCallback {
            ($obj: VolumeMonitor, mount: Mount): void;
        }

        /**
         * Signal callback interface for `mount-changed`
         */
        interface MountChangedSignalCallback {
            ($obj: VolumeMonitor, mount: Mount): void;
        }

        /**
         * Signal callback interface for `mount-pre-unmount`
         */
        interface MountPreUnmountSignalCallback {
            ($obj: VolumeMonitor, mount: Mount): void;
        }

        /**
         * Signal callback interface for `mount-removed`
         */
        interface MountRemovedSignalCallback {
            ($obj: VolumeMonitor, mount: Mount): void;
        }

        /**
         * Signal callback interface for `volume-added`
         */
        interface VolumeAddedSignalCallback {
            ($obj: VolumeMonitor, volume: Volume): void;
        }

        /**
         * Signal callback interface for `volume-changed`
         */
        interface VolumeChangedSignalCallback {
            ($obj: VolumeMonitor, volume: Volume): void;
        }

        /**
         * Signal callback interface for `volume-removed`
         */
        interface VolumeRemovedSignalCallback {
            ($obj: VolumeMonitor, volume: Volume): void;
        }

        // Constructor properties interface

        type ConstructorProperties = GObject.Object.ConstructorProperties;
    }

    interface VolumeMonitor {
        // Own fields of Gio-2.0.Gio.VolumeMonitor

        parent_instance: GObject.Object;

        // Owm methods of Gio-2.0.Gio.VolumeMonitor

        /**
         * Gets a list of drives connected to the system.
         *
         * The returned list should be freed with g_list_free(), after
         * its elements have been unreffed with g_object_unref().
         * @returns a #GList of connected #GDrive objects.
         */
        get_connected_drives(): Drive[];
        /**
         * Finds a #GMount object by its UUID (see g_mount_get_uuid())
         * @param uuid the UUID to look for
         * @returns a #GMount or %NULL if no such mount is available.     Free the returned object with g_object_unref().
         */
        get_mount_for_uuid(uuid: string | null): Mount | null;
        /**
         * Gets a list of the mounts on the system.
         *
         * The returned list should be freed with g_list_free(), after
         * its elements have been unreffed with g_object_unref().
         * @returns a #GList of #GMount objects.
         */
        get_mounts(): Mount[];
        /**
         * Finds a #GVolume object by its UUID (see g_volume_get_uuid())
         * @param uuid the UUID to look for
         * @returns a #GVolume or %NULL if no such volume is available.     Free the returned object with g_object_unref().
         */
        get_volume_for_uuid(uuid: string | null): Volume | null;
        /**
         * Gets a list of the volumes on the system.
         *
         * The returned list should be freed with g_list_free(), after
         * its elements have been unreffed with g_object_unref().
         * @returns a #GList of #GVolume objects.
         */
        get_volumes(): Volume[];

        // Own virtual methods of Gio-2.0.Gio.VolumeMonitor

        vfunc_drive_changed(drive: Drive): void;
        vfunc_drive_connected(drive: Drive): void;
        vfunc_drive_disconnected(drive: Drive): void;
        vfunc_drive_eject_button(drive: Drive): void;
        vfunc_drive_stop_button(drive: Drive): void;
        /**
         * Gets a list of drives connected to the system.
         *
         * The returned list should be freed with g_list_free(), after
         * its elements have been unreffed with g_object_unref().
         * @virtual
         * @returns a #GList of connected #GDrive objects.
         */
        vfunc_get_connected_drives(): Drive[];
        /**
         * Finds a #GMount object by its UUID (see g_mount_get_uuid())
         * @virtual
         * @param uuid the UUID to look for
         * @returns a #GMount or %NULL if no such mount is available.     Free the returned object with g_object_unref().
         */
        vfunc_get_mount_for_uuid(uuid: string | null): Mount | null;
        /**
         * Gets a list of the mounts on the system.
         *
         * The returned list should be freed with g_list_free(), after
         * its elements have been unreffed with g_object_unref().
         * @virtual
         * @returns a #GList of #GMount objects.
         */
        vfunc_get_mounts(): Mount[];
        /**
         * Finds a #GVolume object by its UUID (see g_volume_get_uuid())
         * @virtual
         * @param uuid the UUID to look for
         * @returns a #GVolume or %NULL if no such volume is available.     Free the returned object with g_object_unref().
         */
        vfunc_get_volume_for_uuid(uuid: string | null): Volume | null;
        /**
         * Gets a list of the volumes on the system.
         *
         * The returned list should be freed with g_list_free(), after
         * its elements have been unreffed with g_object_unref().
         * @virtual
         * @returns a #GList of #GVolume objects.
         */
        vfunc_get_volumes(): Volume[];
        vfunc_mount_added(mount: Mount): void;
        vfunc_mount_changed(mount: Mount): void;
        vfunc_mount_pre_unmount(mount: Mount): void;
        vfunc_mount_removed(mount: Mount): void;
        vfunc_volume_added(volume: Volume): void;
        vfunc_volume_changed(volume: Volume): void;
        vfunc_volume_removed(volume: Volume): void;

        // Own signals of Gio-2.0.Gio.VolumeMonitor

        connect(
            sigName: 'drive-changed',
            callback: VolumeMonitor.DriveChangedSignalCallback
        ): number;
        connect_after(
            sigName: 'drive-changed',
            callback: VolumeMonitor.DriveChangedSignalCallback
        ): number;
        emit(sigName: 'drive-changed', drive: Drive, ...args: any[]): void;
        connect(
            sigName: 'drive-connected',
            callback: VolumeMonitor.DriveConnectedSignalCallback
        ): number;
        connect_after(
            sigName: 'drive-connected',
            callback: VolumeMonitor.DriveConnectedSignalCallback
        ): number;
        emit(sigName: 'drive-connected', drive: Drive, ...args: any[]): void;
        connect(
            sigName: 'drive-disconnected',
            callback: VolumeMonitor.DriveDisconnectedSignalCallback
        ): number;
        connect_after(
            sigName: 'drive-disconnected',
            callback: VolumeMonitor.DriveDisconnectedSignalCallback
        ): number;
        emit(sigName: 'drive-disconnected', drive: Drive, ...args: any[]): void;
        connect(
            sigName: 'drive-eject-button',
            callback: VolumeMonitor.DriveEjectButtonSignalCallback
        ): number;
        connect_after(
            sigName: 'drive-eject-button',
            callback: VolumeMonitor.DriveEjectButtonSignalCallback
        ): number;
        emit(sigName: 'drive-eject-button', drive: Drive, ...args: any[]): void;
        connect(
            sigName: 'drive-stop-button',
            callback: VolumeMonitor.DriveStopButtonSignalCallback
        ): number;
        connect_after(
            sigName: 'drive-stop-button',
            callback: VolumeMonitor.DriveStopButtonSignalCallback
        ): number;
        emit(sigName: 'drive-stop-button', drive: Drive, ...args: any[]): void;
        connect(
            sigName: 'mount-added',
            callback: VolumeMonitor.MountAddedSignalCallback
        ): number;
        connect_after(
            sigName: 'mount-added',
            callback: VolumeMonitor.MountAddedSignalCallback
        ): number;
        emit(sigName: 'mount-added', mount: Mount, ...args: any[]): void;
        connect(
            sigName: 'mount-changed',
            callback: VolumeMonitor.MountChangedSignalCallback
        ): number;
        connect_after(
            sigName: 'mount-changed',
            callback: VolumeMonitor.MountChangedSignalCallback
        ): number;
        emit(sigName: 'mount-changed', mount: Mount, ...args: any[]): void;
        connect(
            sigName: 'mount-pre-unmount',
            callback: VolumeMonitor.MountPreUnmountSignalCallback
        ): number;
        connect_after(
            sigName: 'mount-pre-unmount',
            callback: VolumeMonitor.MountPreUnmountSignalCallback
        ): number;
        emit(sigName: 'mount-pre-unmount', mount: Mount, ...args: any[]): void;
        connect(
            sigName: 'mount-removed',
            callback: VolumeMonitor.MountRemovedSignalCallback
        ): number;
        connect_after(
            sigName: 'mount-removed',
            callback: VolumeMonitor.MountRemovedSignalCallback
        ): number;
        emit(sigName: 'mount-removed', mount: Mount, ...args: any[]): void;
        connect(
            sigName: 'volume-added',
            callback: VolumeMonitor.VolumeAddedSignalCallback
        ): number;
        connect_after(
            sigName: 'volume-added',
            callback: VolumeMonitor.VolumeAddedSignalCallback
        ): number;
        emit(sigName: 'volume-added', volume: Volume, ...args: any[]): void;
        connect(
            sigName: 'volume-changed',
            callback: VolumeMonitor.VolumeChangedSignalCallback
        ): number;
        connect_after(
            sigName: 'volume-changed',
            callback: VolumeMonitor.VolumeChangedSignalCallback
        ): number;
        emit(sigName: 'volume-changed', volume: Volume, ...args: any[]): void;
        connect(
            sigName: 'volume-removed',
            callback: VolumeMonitor.VolumeRemovedSignalCallback
        ): number;
        connect_after(
            sigName: 'volume-removed',
            callback: VolumeMonitor.VolumeRemovedSignalCallback
        ): number;
        emit(sigName: 'volume-removed', volume: Volume, ...args: any[]): void;

        // Class property signals of Gio-2.0.Gio.VolumeMonitor

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GVolumeMonitor is for listing the user interesting devices and volumes
     * on the computer. In other words, what a file selector or file manager
     * would show in a sidebar.
     *
     * #GVolumeMonitor is not
     * [thread-default-context aware][g-main-context-push-thread-default],
     * and so should not be used other than from the main thread, with no
     * thread-default-context active.
     *
     * In order to receive updates about volumes and mounts monitored through GVFS,
     * a main loop must be running.
     * @class
     */
    class VolumeMonitor extends GObject.Object {
        // Own properties of Gio-2.0.Gio.VolumeMonitor

        static name: string;
        static $gtype: GObject.GType<VolumeMonitor>;

        // Constructors of Gio-2.0.Gio.VolumeMonitor

        constructor(config?: VolumeMonitor.ConstructorProperties);
        _init(config?: VolumeMonitor.ConstructorProperties): void;
        /**
         * This function should be called by any #GVolumeMonitor
         * implementation when a new #GMount object is created that is not
         * associated with a #GVolume object. It must be called just before
         * emitting the `mount_added` signal.
         *
         * If the return value is not %NULL, the caller must associate the
         * returned #GVolume object with the #GMount. This involves returning
         * it in its g_mount_get_volume() implementation. The caller must
         * also listen for the "removed" signal on the returned object
         * and give up its reference when handling that signal
         *
         * Similarly, if implementing g_volume_monitor_adopt_orphan_mount(),
         * the implementor must take a reference to `mount` and return it in
         * its g_volume_get_mount() implemented. Also, the implementor must
         * listen for the "unmounted" signal on `mount` and give up its
         * reference upon handling that signal.
         *
         * There are two main use cases for this function.
         *
         * One is when implementing a user space file system driver that reads
         * blocks of a block device that is already represented by the native
         * volume monitor (for example a CD Audio file system driver). Such
         * a driver will generate its own #GMount object that needs to be
         * associated with the #GVolume object that represents the volume.
         *
         * The other is for implementing a #GVolumeMonitor whose sole purpose
         * is to return #GVolume objects representing entries in the users
         * "favorite servers" list or similar.
         * @param mount a #GMount object to find a parent for
         * @returns the #GVolume object that is the parent for @mount or %NULL if no wants to adopt the #GMount.
         */
        static adopt_orphan_mount(mount: Mount): Volume;
        /**
         * Gets the volume monitor used by gio.
         * @returns a reference to the #GVolumeMonitor used by gio. Call    g_object_unref() when done with it.
         */
        static get(): VolumeMonitor;
    }

    namespace ZlibCompressor {
        // Constructor properties interface

        interface ConstructorProperties
            extends Converter.ConstructorProperties,
                GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.ZlibCompressor

            /**
             * If set to a non-%NULL #GFileInfo object, and #GZlibCompressor:format is
             * %G_ZLIB_COMPRESSOR_FORMAT_GZIP, the compressor will write the file name
             * and modification time from the file info to the GZIP header.
             */
            file_info?: FileInfo | null;
            format?: ZlibCompressorFormat | null;
            level?: number | null;
        }
    }

    interface ZlibCompressor extends Converter {
        // Own properties of Gio-2.0.Gio.ZlibCompressor

        /**
         * If set to a non-%NULL #GFileInfo object, and #GZlibCompressor:format is
         * %G_ZLIB_COMPRESSOR_FORMAT_GZIP, the compressor will write the file name
         * and modification time from the file info to the GZIP header.
         */
        file_info: FileInfo;
        readonly format: ZlibCompressorFormat;
        readonly level: number;

        // Owm methods of Gio-2.0.Gio.ZlibCompressor

        /**
         * Returns the #GZlibCompressor:file-info property.
         * @returns a #GFileInfo, or %NULL
         */
        get_file_info(): FileInfo | null;
        /**
         * Sets `file_info` in `compressor`. If non-%NULL, and `compressor'`s
         * #GZlibCompressor:format property is %G_ZLIB_COMPRESSOR_FORMAT_GZIP,
         * it will be used to set the file name and modification time in
         * the GZIP header of the compressed data.
         *
         * Note: it is an error to call this function while a compression is in
         * progress; it may only be called immediately after creation of `compressor,`
         * or after resetting it with g_converter_reset().
         * @param file_info a #GFileInfo
         */
        set_file_info(file_info: FileInfo | null): void;

        // Class property signals of Gio-2.0.Gio.ZlibCompressor

        connect(
            sigName: 'notify::file-info',
            callback: ($obj: ZlibCompressor, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::file-info',
            callback: ($obj: ZlibCompressor, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::file-info', ...args: any[]): void;
        connect(
            sigName: 'notify::format',
            callback: ($obj: ZlibCompressor, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::format',
            callback: ($obj: ZlibCompressor, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::format', ...args: any[]): void;
        connect(
            sigName: 'notify::level',
            callback: ($obj: ZlibCompressor, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::level',
            callback: ($obj: ZlibCompressor, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::level', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GZlibCompressor is an implementation of #GConverter that
     * compresses data using zlib.
     * @class
     */
    class ZlibCompressor extends GObject.Object {
        // Own properties of Gio-2.0.Gio.ZlibCompressor

        static name: string;
        static $gtype: GObject.GType<ZlibCompressor>;

        // Constructors of Gio-2.0.Gio.ZlibCompressor

        constructor(config?: ZlibCompressor.ConstructorProperties);
        /**
         * Creates a new #GZlibCompressor.
         * @constructor
         * @param format The format to use for the compressed data
         * @param level compression level (0-9), -1 for default
         * @returns a new #GZlibCompressor
         */
        constructor(format: ZlibCompressorFormat, level: number);
        /**
         * Creates a new #GZlibCompressor.
         * @constructor
         * @param format The format to use for the compressed data
         * @param level compression level (0-9), -1 for default
         * @returns a new #GZlibCompressor
         */
        static new(format: ZlibCompressorFormat, level: number): ZlibCompressor;
        _init(config?: ZlibCompressor.ConstructorProperties): void;
    }

    namespace ZlibDecompressor {
        // Constructor properties interface

        interface ConstructorProperties
            extends Converter.ConstructorProperties,
                GObject.Object.ConstructorProperties {
            // Own constructor properties of Gio-2.0.Gio.ZlibDecompressor

            format?: ZlibCompressorFormat | null;
        }
    }

    interface ZlibDecompressor extends Converter {
        // Own properties of Gio-2.0.Gio.ZlibDecompressor

        /**
         * A #GFileInfo containing the information found in the GZIP header
         * of the data stream processed, or %NULL if the header was not yet
         * fully processed, is not present at all, or the compressor's
         * #GZlibDecompressor:format property is not %G_ZLIB_COMPRESSOR_FORMAT_GZIP.
         */
        readonly file_info: FileInfo;
        readonly format: ZlibCompressorFormat;

        // Owm methods of Gio-2.0.Gio.ZlibDecompressor

        /**
         * Retrieves the #GFileInfo constructed from the GZIP header data
         * of compressed data processed by `compressor,` or %NULL if `decompressor'`s
         * #GZlibDecompressor:format property is not %G_ZLIB_COMPRESSOR_FORMAT_GZIP,
         * or the header data was not fully processed yet, or it not present in the
         * data stream at all.
         * @returns a #GFileInfo, or %NULL
         */
        get_file_info(): FileInfo | null;

        // Class property signals of Gio-2.0.Gio.ZlibDecompressor

        connect(
            sigName: 'notify::file-info',
            callback: ($obj: ZlibDecompressor, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::file-info',
            callback: ($obj: ZlibDecompressor, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::file-info', ...args: any[]): void;
        connect(
            sigName: 'notify::format',
            callback: ($obj: ZlibDecompressor, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::format',
            callback: ($obj: ZlibDecompressor, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::format', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * #GZlibDecompressor is an implementation of #GConverter that
     * decompresses data compressed with zlib.
     * @class
     */
    class ZlibDecompressor extends GObject.Object {
        // Own properties of Gio-2.0.Gio.ZlibDecompressor

        static name: string;
        static $gtype: GObject.GType<ZlibDecompressor>;

        // Constructors of Gio-2.0.Gio.ZlibDecompressor

        constructor(config?: ZlibDecompressor.ConstructorProperties);
        /**
         * Creates a new #GZlibDecompressor.
         * @constructor
         * @param format The format to use for the compressed data
         * @returns a new #GZlibDecompressor
         */
        constructor(format: ZlibCompressorFormat);
        /**
         * Creates a new #GZlibDecompressor.
         * @constructor
         * @param format The format to use for the compressed data
         * @returns a new #GZlibDecompressor
         */
        static new(format: ZlibCompressorFormat): ZlibDecompressor;
        _init(config?: ZlibDecompressor.ConstructorProperties): void;
    }

    interface ActionEntry {
        // Own fields of Gio-2.0.Gio.ActionEntry

        /**
         * the name of the action
         * @field
         */
        name: string | null;
        activate: (action: SimpleAction, parameter: GLib.Variant) => void;
        /**
         * the type of the parameter that must be passed to the
         *                  activate function for this action, given as a single
         *                  GVariant type string (or %NULL for no parameter)
         * @field
         */
        parameter_type: string | null;
        /**
         * the initial state for this action, given in
         *         [GVariant text format][gvariant-text].  The state is parsed
         *         with no extra type information, so type tags must be added to
         *         the string if they are necessary.  Stateless actions should
         *         give %NULL here.
         * @field
         */
        state: string | null;
        change_state: (action: SimpleAction, value: GLib.Variant) => void;
    }

    /**
     * This struct defines a single action.  It is for use with
     * g_action_map_add_action_entries().
     *
     * The order of the items in the structure are intended to reflect
     * frequency of use.  It is permissible to use an incomplete initialiser
     * in order to leave some of the later values as %NULL.  All values
     * after `name` are optional.  Additional optional fields may be added in
     * the future.
     *
     * See g_action_map_add_action_entries() for an example.
     * @record
     */
    class ActionEntry {
        // Own properties of Gio-2.0.Gio.ActionEntry

        static name: string;
    }

    interface ActionGroupInterface {
        // Own fields of Gio-2.0.Gio.ActionGroupInterface

        g_iface: GObject.TypeInterface;
        has_action: (
            action_group: ActionGroup,
            action_name: string | null
        ) => boolean;
        list_actions: (action_group: ActionGroup) => string[];
        get_action_enabled: (
            action_group: ActionGroup,
            action_name: string | null
        ) => boolean;
        get_action_parameter_type: (
            action_group: ActionGroup,
            action_name: string | null
        ) => GLib.VariantType | null;
        get_action_state_type: (
            action_group: ActionGroup,
            action_name: string | null
        ) => GLib.VariantType | null;
        get_action_state_hint: (
            action_group: ActionGroup,
            action_name: string | null
        ) => GLib.Variant | null;
        get_action_state: (
            action_group: ActionGroup,
            action_name: string | null
        ) => GLib.Variant | null;
        change_action_state: (
            action_group: ActionGroup,
            action_name: string | null,
            value: GLib.Variant
        ) => void;
        activate_action: (
            action_group: ActionGroup,
            action_name: string | null,
            parameter: GLib.Variant | null
        ) => void;
        action_added: (
            action_group: ActionGroup,
            action_name: string | null
        ) => void;
        action_removed: (
            action_group: ActionGroup,
            action_name: string | null
        ) => void;
        action_enabled_changed: (
            action_group: ActionGroup,
            action_name: string | null,
            enabled: boolean
        ) => void;
        action_state_changed: (
            action_group: ActionGroup,
            action_name: string | null,
            state: GLib.Variant
        ) => void;
        query_action: (
            action_group: ActionGroup,
            action_name: string | null
        ) => [
            /* returnType */ boolean,
            /* enabled */ boolean,
            /* parameter_type */ GLib.VariantType,
            /* state_type */ GLib.VariantType,
            /* state_hint */ GLib.Variant,
            /* state */ GLib.Variant
        ];
    }

    /**
     * The virtual function table for #GActionGroup.
     * @record
     */
    abstract class ActionGroupInterface {
        // Own properties of Gio-2.0.Gio.ActionGroupInterface

        static name: string;
    }

    interface ActionInterface {
        // Own fields of Gio-2.0.Gio.ActionInterface

        g_iface: GObject.TypeInterface;
        get_name: (action: Action) => string | null;
        get_parameter_type: (action: Action) => GLib.VariantType | null;
        get_state_type: (action: Action) => GLib.VariantType | null;
        get_state_hint: (action: Action) => GLib.Variant | null;
        get_enabled: (action: Action) => boolean;
        get_state: (action: Action) => GLib.Variant | null;
        change_state: (action: Action, value: GLib.Variant) => void;
        activate: (action: Action, parameter: GLib.Variant | null) => void;
    }

    /**
     * The virtual function table for #GAction.
     * @record
     */
    abstract class ActionInterface {
        // Own properties of Gio-2.0.Gio.ActionInterface

        static name: string;
    }

    interface ActionMapInterface {
        // Own fields of Gio-2.0.Gio.ActionMapInterface

        g_iface: GObject.TypeInterface;
        lookup_action: (
            action_map: ActionMap,
            action_name: string | null
        ) => Action | null;
        add_action: (action_map: ActionMap, action: Action) => void;
        remove_action: (
            action_map: ActionMap,
            action_name: string | null
        ) => void;
    }

    /**
     * The virtual function table for #GActionMap.
     * @record
     */
    abstract class ActionMapInterface {
        // Own properties of Gio-2.0.Gio.ActionMapInterface

        static name: string;
    }

    interface AppInfoIface {
        // Own fields of Gio-2.0.Gio.AppInfoIface

        /**
         * The parent interface.
         * @field
         */
        g_iface: GObject.TypeInterface;
        dup: (appinfo: AppInfo) => AppInfo;
        equal: (appinfo1: AppInfo, appinfo2: AppInfo) => boolean;
        get_id: (appinfo: AppInfo) => string | null;
        get_name: (appinfo: AppInfo) => string | null;
        get_description: (appinfo: AppInfo) => string | null;
        get_executable: (appinfo: AppInfo) => string;
        get_icon: (appinfo: AppInfo) => Icon | null;
        launch: (
            appinfo: AppInfo,
            files: File[] | null,
            context: AppLaunchContext | null
        ) => boolean;
        supports_uris: (appinfo: AppInfo) => boolean;
        supports_files: (appinfo: AppInfo) => boolean;
        launch_uris: (
            appinfo: AppInfo,
            uris: string[] | null,
            context: AppLaunchContext | null
        ) => boolean;
        should_show: (appinfo: AppInfo) => boolean;
        set_as_default_for_type: (
            appinfo: AppInfo,
            content_type: string | null
        ) => boolean;
        set_as_default_for_extension: (
            appinfo: AppInfo,
            extension: string
        ) => boolean;
        add_supports_type: (
            appinfo: AppInfo,
            content_type: string | null
        ) => boolean;
        can_remove_supports_type: (appinfo: AppInfo) => boolean;
        remove_supports_type: (
            appinfo: AppInfo,
            content_type: string | null
        ) => boolean;
        can_delete: (appinfo: AppInfo) => boolean;
        do_delete: (appinfo: AppInfo) => boolean;
        get_commandline: (appinfo: AppInfo) => string | null;
        get_display_name: (appinfo: AppInfo) => string | null;
        set_as_last_used_for_type: (
            appinfo: AppInfo,
            content_type: string | null
        ) => boolean;
        get_supported_types: (appinfo: AppInfo) => string[];
        launch_uris_async: (
            appinfo: AppInfo,
            uris: string[] | null,
            context: AppLaunchContext | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        launch_uris_finish: (appinfo: AppInfo, result: AsyncResult) => boolean;
    }

    /**
     * Application Information interface, for operating system portability.
     * @record
     */
    abstract class AppInfoIface {
        // Own properties of Gio-2.0.Gio.AppInfoIface

        static name: string;
    }

    interface AppLaunchContextClass {
        // Own fields of Gio-2.0.Gio.AppLaunchContextClass

        parent_class: GObject.ObjectClass;
        get_display: (
            context: AppLaunchContext,
            info: AppInfo,
            files: File[]
        ) => string | null;
        get_startup_notify_id: (
            context: AppLaunchContext,
            info: AppInfo,
            files: File[]
        ) => string | null;
        launch_failed: (
            context: AppLaunchContext,
            startup_notify_id: string | null
        ) => void;
        launched: (
            context: AppLaunchContext,
            info: AppInfo,
            platform_data: GLib.Variant
        ) => void;
        launch_started: (
            context: AppLaunchContext,
            info: AppInfo,
            platform_data: GLib.Variant
        ) => void;
    }

    abstract class AppLaunchContextClass {
        // Own properties of Gio-2.0.Gio.AppLaunchContextClass

        static name: string;
    }

    interface AppLaunchContextPrivate {}

    class AppLaunchContextPrivate {
        // Own properties of Gio-2.0.Gio.AppLaunchContextPrivate

        static name: string;
    }

    interface ApplicationClass {
        // Own fields of Gio-2.0.Gio.ApplicationClass

        startup: (application: Application) => void;
        activate: (application: Application) => void;
        open: (
            application: Application,
            files: File[],
            hint: string | null
        ) => void;
        command_line: (
            application: Application,
            command_line: ApplicationCommandLine
        ) => number;
        local_command_line: (
            application: Application,
            arguments_: string[]
        ) => [
            /* returnType */ boolean,
            /* arguments_ */ string[],
            /* exit_status */ number
        ];
        before_emit: (
            application: Application,
            platform_data: GLib.Variant
        ) => void;
        after_emit: (
            application: Application,
            platform_data: GLib.Variant
        ) => void;
        add_platform_data: (
            application: Application,
            builder: GLib.VariantBuilder
        ) => void;
        quit_mainloop: (application: Application) => void;
        run_mainloop: (application: Application) => void;
        shutdown: (application: Application) => void;
        dbus_register: (
            application: Application,
            connection: DBusConnection,
            object_path: string | null
        ) => boolean;
        dbus_unregister: (
            application: Application,
            connection: DBusConnection,
            object_path: string | null
        ) => void;
        handle_local_options: (
            application: Application,
            options: GLib.VariantDict
        ) => number;
        name_lost: (application: Application) => boolean;
    }

    /**
     * Virtual function table for #GApplication.
     * @record
     */
    abstract class ApplicationClass {
        // Own properties of Gio-2.0.Gio.ApplicationClass

        static name: string;
    }

    interface ApplicationCommandLineClass {
        // Own fields of Gio-2.0.Gio.ApplicationCommandLineClass

        print_literal: (
            cmdline: ApplicationCommandLine,
            message: string | null
        ) => void;
        printerr_literal: (
            cmdline: ApplicationCommandLine,
            message: string | null
        ) => void;
        get_stdin: (cmdline: ApplicationCommandLine) => InputStream | null;
    }

    /**
     * The #GApplicationCommandLineClass-struct
     * contains private data only.
     * @record
     */
    abstract class ApplicationCommandLineClass {
        // Own properties of Gio-2.0.Gio.ApplicationCommandLineClass

        static name: string;
    }

    interface ApplicationCommandLinePrivate {}

    class ApplicationCommandLinePrivate {
        // Own properties of Gio-2.0.Gio.ApplicationCommandLinePrivate

        static name: string;
    }

    interface ApplicationPrivate {}

    class ApplicationPrivate {
        // Own properties of Gio-2.0.Gio.ApplicationPrivate

        static name: string;
    }

    interface AsyncInitableIface {
        // Own fields of Gio-2.0.Gio.AsyncInitableIface

        /**
         * The parent interface.
         * @field
         */
        g_iface: GObject.TypeInterface;
        init_async: (
            initable: AsyncInitable,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        init_finish: (initable: AsyncInitable, res: AsyncResult) => boolean;
    }

    /**
     * Provides an interface for asynchronous initializing object such that
     * initialization may fail.
     * @record
     */
    abstract class AsyncInitableIface {
        // Own properties of Gio-2.0.Gio.AsyncInitableIface

        static name: string;
    }

    interface AsyncResultIface {
        // Own fields of Gio-2.0.Gio.AsyncResultIface

        /**
         * The parent interface.
         * @field
         */
        g_iface: GObject.TypeInterface;
        get_user_data: (res: AsyncResult) => any | null;
        get_source_object: (res: AsyncResult) => GObject.Object | null;
        is_tagged: (res: AsyncResult, source_tag: any | null) => boolean;
    }

    /**
     * Interface definition for #GAsyncResult.
     * @record
     */
    abstract class AsyncResultIface {
        // Own properties of Gio-2.0.Gio.AsyncResultIface

        static name: string;
    }

    interface BufferedInputStreamClass {
        // Own fields of Gio-2.0.Gio.BufferedInputStreamClass

        parent_class: FilterInputStreamClass;
        fill: (
            stream: BufferedInputStream,
            count: number,
            cancellable: Cancellable | null
        ) => number;
        fill_async: (
            stream: BufferedInputStream,
            count: number,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        fill_finish: (
            stream: BufferedInputStream,
            result: AsyncResult
        ) => number;
    }

    abstract class BufferedInputStreamClass {
        // Own properties of Gio-2.0.Gio.BufferedInputStreamClass

        static name: string;
    }

    interface BufferedInputStreamPrivate {}

    class BufferedInputStreamPrivate {
        // Own properties of Gio-2.0.Gio.BufferedInputStreamPrivate

        static name: string;
    }

    interface BufferedOutputStreamClass {
        // Own fields of Gio-2.0.Gio.BufferedOutputStreamClass

        parent_class: FilterOutputStreamClass;
    }

    abstract class BufferedOutputStreamClass {
        // Own properties of Gio-2.0.Gio.BufferedOutputStreamClass

        static name: string;
    }

    interface BufferedOutputStreamPrivate {}

    class BufferedOutputStreamPrivate {
        // Own properties of Gio-2.0.Gio.BufferedOutputStreamPrivate

        static name: string;
    }

    interface CancellableClass {
        // Own fields of Gio-2.0.Gio.CancellableClass

        parent_class: GObject.ObjectClass;
        cancelled: (cancellable: Cancellable | null) => void;
    }

    abstract class CancellableClass {
        // Own properties of Gio-2.0.Gio.CancellableClass

        static name: string;
    }

    interface CancellablePrivate {}

    class CancellablePrivate {
        // Own properties of Gio-2.0.Gio.CancellablePrivate

        static name: string;
    }

    interface CharsetConverterClass {
        // Own fields of Gio-2.0.Gio.CharsetConverterClass

        parent_class: GObject.ObjectClass;
    }

    abstract class CharsetConverterClass {
        // Own properties of Gio-2.0.Gio.CharsetConverterClass

        static name: string;
    }

    interface ConverterIface {
        // Own fields of Gio-2.0.Gio.ConverterIface

        /**
         * The parent interface.
         * @field
         */
        g_iface: GObject.TypeInterface;
        convert: (
            converter: Converter,
            inbuf: Uint8Array | null,
            outbuf: Uint8Array,
            flags: ConverterFlags
        ) => [
            /* returnType */ ConverterResult,
            /* bytes_read */ number,
            /* bytes_written */ number
        ];
        reset: (converter: Converter) => void;
    }

    /**
     * Provides an interface for converting data from one type
     * to another type. The conversion can be stateful
     * and may fail at any place.
     * @record
     */
    abstract class ConverterIface {
        // Own properties of Gio-2.0.Gio.ConverterIface

        static name: string;
    }

    interface ConverterInputStreamClass {
        // Own fields of Gio-2.0.Gio.ConverterInputStreamClass

        parent_class: FilterInputStreamClass;
    }

    abstract class ConverterInputStreamClass {
        // Own properties of Gio-2.0.Gio.ConverterInputStreamClass

        static name: string;
    }

    interface ConverterInputStreamPrivate {}

    class ConverterInputStreamPrivate {
        // Own properties of Gio-2.0.Gio.ConverterInputStreamPrivate

        static name: string;
    }

    interface ConverterOutputStreamClass {
        // Own fields of Gio-2.0.Gio.ConverterOutputStreamClass

        parent_class: FilterOutputStreamClass;
    }

    abstract class ConverterOutputStreamClass {
        // Own properties of Gio-2.0.Gio.ConverterOutputStreamClass

        static name: string;
    }

    interface ConverterOutputStreamPrivate {}

    class ConverterOutputStreamPrivate {
        // Own properties of Gio-2.0.Gio.ConverterOutputStreamPrivate

        static name: string;
    }

    interface CredentialsClass {}

    /**
     * Class structure for #GCredentials.
     * @record
     */
    abstract class CredentialsClass {
        // Own properties of Gio-2.0.Gio.CredentialsClass

        static name: string;
    }

    interface DBusAnnotationInfo {
        // Own fields of Gio-2.0.Gio.DBusAnnotationInfo

        /**
         * The reference count or -1 if statically allocated.
         * @field
         */
        ref_count: number;
        /**
         * The name of the annotation, e.g. "org.freedesktop.DBus.Deprecated".
         * @field
         */
        key: string | null;
        /**
         * The value of the annotation.
         * @field
         */
        value: string | null;
        /**
         * A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.
         * @field
         */
        annotations: DBusAnnotationInfo[];

        // Owm methods of Gio-2.0.Gio.DBusAnnotationInfo

        /**
         * If `info` is statically allocated does nothing. Otherwise increases
         * the reference count.
         * @returns The same @info.
         */
        ref(): DBusAnnotationInfo;
        /**
         * If `info` is statically allocated, does nothing. Otherwise decreases
         * the reference count of `info`. When its reference count drops to 0,
         * the memory used is freed.
         */
        unref(): void;
    }

    /**
     * Information about an annotation.
     * @record
     */
    class DBusAnnotationInfo {
        // Own properties of Gio-2.0.Gio.DBusAnnotationInfo

        static name: string;

        // Constructors of Gio-2.0.Gio.DBusAnnotationInfo

        /**
         * Looks up the value of an annotation.
         *
         * The cost of this function is O(n) in number of annotations.
         * @param annotations A %NULL-terminated array of annotations or %NULL.
         * @param name The name of the annotation to look up.
         * @returns The value or %NULL if not found. Do not free, it is owned by @annotations.
         */
        static lookup(
            annotations: DBusAnnotationInfo[] | null,
            name: string | null
        ): string | null;
    }

    interface DBusArgInfo {
        // Own fields of Gio-2.0.Gio.DBusArgInfo

        /**
         * The reference count or -1 if statically allocated.
         * @field
         */
        ref_count: number;
        /**
         * Name of the argument, e.g. `unix_user_id`.
         * @field
         */
        name: string | null;
        /**
         * D-Bus signature of the argument (a single complete type).
         * @field
         */
        signature: string | null;
        /**
         * A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.
         * @field
         */
        annotations: DBusAnnotationInfo[];

        // Owm methods of Gio-2.0.Gio.DBusArgInfo

        /**
         * If `info` is statically allocated does nothing. Otherwise increases
         * the reference count.
         * @returns The same @info.
         */
        ref(): DBusArgInfo;
        /**
         * If `info` is statically allocated, does nothing. Otherwise decreases
         * the reference count of `info`. When its reference count drops to 0,
         * the memory used is freed.
         */
        unref(): void;
    }

    /**
     * Information about an argument for a method or a signal.
     * @record
     */
    class DBusArgInfo {
        // Own properties of Gio-2.0.Gio.DBusArgInfo

        static name: string;
    }

    interface DBusErrorEntry {
        // Own fields of Gio-2.0.Gio.DBusErrorEntry

        /**
         * An error code.
         * @field
         */
        error_code: number;
        /**
         * The D-Bus error name to associate with `error_code`.
         * @field
         */
        dbus_error_name: string | null;
    }

    /**
     * Struct used in g_dbus_error_register_error_domain().
     * @record
     */
    class DBusErrorEntry {
        // Own properties of Gio-2.0.Gio.DBusErrorEntry

        static name: string;
    }

    interface DBusInterfaceIface {
        // Own fields of Gio-2.0.Gio.DBusInterfaceIface

        /**
         * The parent interface.
         * @field
         */
        parent_iface: GObject.TypeInterface;
        get_info: (interface_: DBusInterface) => DBusInterfaceInfo;
        get_object: (interface_: DBusInterface) => DBusObject | null;
        set_object: (
            interface_: DBusInterface,
            object: DBusObject | null
        ) => void;
        dup_object: (interface_: DBusInterface) => DBusObject | null;
    }

    /**
     * Base type for D-Bus interfaces.
     * @record
     */
    abstract class DBusInterfaceIface {
        // Own properties of Gio-2.0.Gio.DBusInterfaceIface

        static name: string;
    }

    interface DBusInterfaceInfo {
        // Own fields of Gio-2.0.Gio.DBusInterfaceInfo

        /**
         * The reference count or -1 if statically allocated.
         * @field
         */
        ref_count: number;
        /**
         * The name of the D-Bus interface, e.g. "org.freedesktop.DBus.Properties".
         * @field
         */
        name: string | null;
        /**
         * A pointer to a %NULL-terminated array of pointers to #GDBusMethodInfo structures or %NULL if there are no methods.
         * @field
         */
        methods: DBusMethodInfo[];
        /**
         * A pointer to a %NULL-terminated array of pointers to #GDBusSignalInfo structures or %NULL if there are no signals.
         * @field
         */
        signals: DBusSignalInfo[];
        /**
         * A pointer to a %NULL-terminated array of pointers to #GDBusPropertyInfo structures or %NULL if there are no properties.
         * @field
         */
        properties: DBusPropertyInfo[];
        /**
         * A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.
         * @field
         */
        annotations: DBusAnnotationInfo[];

        // Owm methods of Gio-2.0.Gio.DBusInterfaceInfo

        /**
         * Builds a lookup-cache to speed up
         * g_dbus_interface_info_lookup_method(),
         * g_dbus_interface_info_lookup_signal() and
         * g_dbus_interface_info_lookup_property().
         *
         * If this has already been called with `info,` the existing cache is
         * used and its use count is increased.
         *
         * Note that `info` cannot be modified until
         * g_dbus_interface_info_cache_release() is called.
         */
        cache_build(): void;
        /**
         * Decrements the usage count for the cache for `info` built by
         * g_dbus_interface_info_cache_build() (if any) and frees the
         * resources used by the cache if the usage count drops to zero.
         */
        cache_release(): void;
        /**
         * Appends an XML representation of `info` (and its children) to `string_builder`.
         *
         * This function is typically used for generating introspection XML
         * documents at run-time for handling the
         * `org.freedesktop.DBus.Introspectable.Introspect`
         * method.
         * @param indent Indentation level.
         * @param string_builder A #GString to to append XML data to.
         */
        generate_xml(indent: number, string_builder: GLib.String): void;
        /**
         * Looks up information about a method.
         *
         * The cost of this function is O(n) in number of methods unless
         * g_dbus_interface_info_cache_build() has been used on `info`.
         * @param name A D-Bus method name (typically in CamelCase)
         * @returns A #GDBusMethodInfo or %NULL if not found. Do not free, it is owned by @info.
         */
        lookup_method(name: string | null): DBusMethodInfo | null;
        /**
         * Looks up information about a property.
         *
         * The cost of this function is O(n) in number of properties unless
         * g_dbus_interface_info_cache_build() has been used on `info`.
         * @param name A D-Bus property name (typically in CamelCase).
         * @returns A #GDBusPropertyInfo or %NULL if not found. Do not free, it is owned by @info.
         */
        lookup_property(name: string | null): DBusPropertyInfo | null;
        /**
         * Looks up information about a signal.
         *
         * The cost of this function is O(n) in number of signals unless
         * g_dbus_interface_info_cache_build() has been used on `info`.
         * @param name A D-Bus signal name (typically in CamelCase)
         * @returns A #GDBusSignalInfo or %NULL if not found. Do not free, it is owned by @info.
         */
        lookup_signal(name: string | null): DBusSignalInfo | null;
        /**
         * If `info` is statically allocated does nothing. Otherwise increases
         * the reference count.
         * @returns The same @info.
         */
        ref(): DBusInterfaceInfo;
        /**
         * If `info` is statically allocated, does nothing. Otherwise decreases
         * the reference count of `info`. When its reference count drops to 0,
         * the memory used is freed.
         */
        unref(): void;
    }

    /**
     * Information about a D-Bus interface.
     * @record
     */
    class DBusInterfaceInfo {
        // Own properties of Gio-2.0.Gio.DBusInterfaceInfo

        static name: string;
        static new_for_xml(xml: string): DBusInterfaceInfo;
    }

    interface DBusInterfaceSkeletonClass {
        // Own fields of Gio-2.0.Gio.DBusInterfaceSkeletonClass

        /**
         * The parent class.
         * @field
         */
        parent_class: GObject.ObjectClass;
        get_info: (interface_: DBusInterfaceSkeleton) => DBusInterfaceInfo;
        get_vtable: (interface_: DBusInterfaceSkeleton) => DBusInterfaceVTable;
        get_properties: (interface_: DBusInterfaceSkeleton) => GLib.Variant;
        flush: (interface_: DBusInterfaceSkeleton) => void;
        g_authorize_method: (
            interface_: DBusInterfaceSkeleton,
            invocation: DBusMethodInvocation
        ) => boolean;
    }

    /**
     * Class structure for #GDBusInterfaceSkeleton.
     * @record
     */
    abstract class DBusInterfaceSkeletonClass {
        // Own properties of Gio-2.0.Gio.DBusInterfaceSkeletonClass

        static name: string;
    }

    interface DBusInterfaceSkeletonPrivate {}

    class DBusInterfaceSkeletonPrivate {
        // Own properties of Gio-2.0.Gio.DBusInterfaceSkeletonPrivate

        static name: string;
    }

    interface DBusInterfaceVTable {
        // Own fields of Gio-2.0.Gio.DBusInterfaceVTable

        /**
         * Function for handling incoming method calls.
         * @field
         */
        method_call: DBusInterfaceMethodCallFunc;
        /**
         * Function for getting a property.
         * @field
         */
        get_property: DBusInterfaceGetPropertyFunc;
        /**
         * Function for setting a property.
         * @field
         */
        set_property: DBusInterfaceSetPropertyFunc;
    }

    /**
     * Virtual table for handling properties and method calls for a D-Bus
     * interface.
     *
     * Since 2.38, if you want to handle getting/setting D-Bus properties
     * asynchronously, give %NULL as your get_property() or set_property()
     * function. The D-Bus call will be directed to your `method_call` function,
     * with the provided `interface_name` set to "org.freedesktop.DBus.Properties".
     *
     * Ownership of the #GDBusMethodInvocation object passed to the
     * method_call() function is transferred to your handler; you must
     * call one of the methods of #GDBusMethodInvocation to return a reply
     * (possibly empty), or an error. These functions also take ownership
     * of the passed-in invocation object, so unless the invocation
     * object has otherwise been referenced, it will be then be freed.
     * Calling one of these functions may be done within your
     * method_call() implementation but it also can be done at a later
     * point to handle the method asynchronously.
     *
     * The usual checks on the validity of the calls is performed. For
     * `Get` calls, an error is automatically returned if the property does
     * not exist or the permissions do not allow access. The same checks are
     * performed for `Set` calls, and the provided value is also checked for
     * being the correct type.
     *
     * For both `Get` and `Set` calls, the #GDBusMethodInvocation
     * passed to the `method_call` handler can be queried with
     * g_dbus_method_invocation_get_property_info() to get a pointer
     * to the #GDBusPropertyInfo of the property.
     *
     * If you have readable properties specified in your interface info,
     * you must ensure that you either provide a non-%NULL `get_property(`)
     * function or provide implementations of both the `Get` and `GetAll`
     * methods on org.freedesktop.DBus.Properties interface in your `method_call`
     * function. Note that the required return type of the `Get` call is
     * `(v)`, not the type of the property. `GetAll` expects a return value
     * of type `a{sv}`.
     *
     * If you have writable properties specified in your interface info,
     * you must ensure that you either provide a non-%NULL `set_property(`)
     * function or provide an implementation of the `Set` call. If implementing
     * the call, you must return the value of type %G_VARIANT_TYPE_UNIT.
     * @record
     */
    class DBusInterfaceVTable {
        // Own properties of Gio-2.0.Gio.DBusInterfaceVTable

        static name: string;
    }

    interface DBusMethodInfo {
        // Own fields of Gio-2.0.Gio.DBusMethodInfo

        /**
         * The reference count or -1 if statically allocated.
         * @field
         */
        ref_count: number;
        /**
         * The name of the D-Bus method, e.g. `RequestName`.
         * @field
         */
        name: string | null;
        /**
         * A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no in arguments.
         * @field
         */
        in_args: DBusArgInfo[];
        /**
         * A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no out arguments.
         * @field
         */
        out_args: DBusArgInfo[];
        /**
         * A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.
         * @field
         */
        annotations: DBusAnnotationInfo[];

        // Owm methods of Gio-2.0.Gio.DBusMethodInfo

        /**
         * If `info` is statically allocated does nothing. Otherwise increases
         * the reference count.
         * @returns The same @info.
         */
        ref(): DBusMethodInfo;
        /**
         * If `info` is statically allocated, does nothing. Otherwise decreases
         * the reference count of `info`. When its reference count drops to 0,
         * the memory used is freed.
         */
        unref(): void;
    }

    /**
     * Information about a method on an D-Bus interface.
     * @record
     */
    class DBusMethodInfo {
        // Own properties of Gio-2.0.Gio.DBusMethodInfo

        static name: string;
    }

    interface DBusNodeInfo {
        // Own fields of Gio-2.0.Gio.DBusNodeInfo

        /**
         * The reference count or -1 if statically allocated.
         * @field
         */
        ref_count: number;
        /**
         * The path of the node or %NULL if omitted. Note that this may be a relative path. See the D-Bus specification for more details.
         * @field
         */
        path: string | null;
        /**
         * A pointer to a %NULL-terminated array of pointers to #GDBusInterfaceInfo structures or %NULL if there are no interfaces.
         * @field
         */
        interfaces: DBusInterfaceInfo[];
        /**
         * A pointer to a %NULL-terminated array of pointers to #GDBusNodeInfo structures or %NULL if there are no nodes.
         * @field
         */
        nodes: DBusNodeInfo[];
        /**
         * A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.
         * @field
         */
        annotations: DBusAnnotationInfo[];

        // Owm methods of Gio-2.0.Gio.DBusNodeInfo

        /**
         * Appends an XML representation of `info` (and its children) to `string_builder`.
         *
         * This function is typically used for generating introspection XML documents at run-time for
         * handling the `org.freedesktop.DBus.Introspectable.Introspect`  method.
         * @param indent Indentation level.
         * @param string_builder A #GString to to append XML data to.
         */
        generate_xml(indent: number, string_builder: GLib.String): void;
        /**
         * Looks up information about an interface.
         *
         * The cost of this function is O(n) in number of interfaces.
         * @param name A D-Bus interface name.
         * @returns A #GDBusInterfaceInfo or %NULL if not found. Do not free, it is owned by @info.
         */
        lookup_interface(name: string | null): DBusInterfaceInfo | null;
        /**
         * If `info` is statically allocated does nothing. Otherwise increases
         * the reference count.
         * @returns The same @info.
         */
        ref(): DBusNodeInfo;
        /**
         * If `info` is statically allocated, does nothing. Otherwise decreases
         * the reference count of `info`. When its reference count drops to 0,
         * the memory used is freed.
         */
        unref(): void;
    }

    /**
     * Information about nodes in a remote object hierarchy.
     * @record
     */
    class DBusNodeInfo {
        // Own properties of Gio-2.0.Gio.DBusNodeInfo

        static name: string;

        // Constructors of Gio-2.0.Gio.DBusNodeInfo

        /**
         * Parses `xml_data` and returns a #GDBusNodeInfo representing the data.
         *
         * The introspection XML must contain exactly one top-level
         * <node> element.
         *
         * Note that this routine is using a
         * [GMarkup][glib-Simple-XML-Subset-Parser.description]-based
         * parser that only accepts a subset of valid XML documents.
         * @constructor
         * @param xml_data Valid D-Bus introspection XML.
         * @returns A #GDBusNodeInfo structure or %NULL if @error is set. Free with g_dbus_node_info_unref().
         */
        static new_for_xml(xml_data: string | null): DBusNodeInfo;
    }

    interface DBusObjectIface {
        // Own fields of Gio-2.0.Gio.DBusObjectIface

        /**
         * The parent interface.
         * @field
         */
        parent_iface: GObject.TypeInterface;
        get_object_path: (object: DBusObject) => string | null;
        get_interfaces: (object: DBusObject) => DBusInterface[];
        get_interface: (
            object: DBusObject,
            interface_name: string | null
        ) => DBusInterface | null;
        interface_added: (
            object: DBusObject,
            interface_: DBusInterface
        ) => void;
        interface_removed: (
            object: DBusObject,
            interface_: DBusInterface
        ) => void;
    }

    /**
     * Base object type for D-Bus objects.
     * @record
     */
    abstract class DBusObjectIface {
        // Own properties of Gio-2.0.Gio.DBusObjectIface

        static name: string;
    }

    interface DBusObjectManagerClientClass {
        // Own fields of Gio-2.0.Gio.DBusObjectManagerClientClass

        /**
         * The parent class.
         * @field
         */
        parent_class: GObject.ObjectClass;
        interface_proxy_signal: (
            manager: DBusObjectManagerClient,
            object_proxy: DBusObjectProxy,
            interface_proxy: DBusProxy,
            sender_name: string | null,
            signal_name: string | null,
            parameters: GLib.Variant
        ) => void;
        interface_proxy_properties_changed: (
            manager: DBusObjectManagerClient,
            object_proxy: DBusObjectProxy,
            interface_proxy: DBusProxy,
            changed_properties: GLib.Variant,
            invalidated_properties: string | null
        ) => void;
    }

    /**
     * Class structure for #GDBusObjectManagerClient.
     * @record
     */
    abstract class DBusObjectManagerClientClass {
        // Own properties of Gio-2.0.Gio.DBusObjectManagerClientClass

        static name: string;
    }

    interface DBusObjectManagerClientPrivate {}

    class DBusObjectManagerClientPrivate {
        // Own properties of Gio-2.0.Gio.DBusObjectManagerClientPrivate

        static name: string;
    }

    interface DBusObjectManagerIface {
        // Own fields of Gio-2.0.Gio.DBusObjectManagerIface

        /**
         * The parent interface.
         * @field
         */
        parent_iface: GObject.TypeInterface;
        get_object_path: (manager: DBusObjectManager) => string | null;
        get_objects: (manager: DBusObjectManager) => DBusObject[];
        get_object: (
            manager: DBusObjectManager,
            object_path: string | null
        ) => DBusObject | null;
        get_interface: (
            manager: DBusObjectManager,
            object_path: string | null,
            interface_name: string | null
        ) => DBusInterface | null;
        object_added: (manager: DBusObjectManager, object: DBusObject) => void;
        object_removed: (
            manager: DBusObjectManager,
            object: DBusObject
        ) => void;
        interface_added: (
            manager: DBusObjectManager,
            object: DBusObject,
            interface_: DBusInterface
        ) => void;
        interface_removed: (
            manager: DBusObjectManager,
            object: DBusObject,
            interface_: DBusInterface
        ) => void;
    }

    /**
     * Base type for D-Bus object managers.
     * @record
     */
    abstract class DBusObjectManagerIface {
        // Own properties of Gio-2.0.Gio.DBusObjectManagerIface

        static name: string;
    }

    interface DBusObjectManagerServerClass {
        // Own fields of Gio-2.0.Gio.DBusObjectManagerServerClass

        /**
         * The parent class.
         * @field
         */
        parent_class: GObject.ObjectClass;
    }

    /**
     * Class structure for #GDBusObjectManagerServer.
     * @record
     */
    abstract class DBusObjectManagerServerClass {
        // Own properties of Gio-2.0.Gio.DBusObjectManagerServerClass

        static name: string;
    }

    interface DBusObjectManagerServerPrivate {}

    class DBusObjectManagerServerPrivate {
        // Own properties of Gio-2.0.Gio.DBusObjectManagerServerPrivate

        static name: string;
    }

    interface DBusObjectProxyClass {
        // Own fields of Gio-2.0.Gio.DBusObjectProxyClass

        /**
         * The parent class.
         * @field
         */
        parent_class: GObject.ObjectClass;
    }

    /**
     * Class structure for #GDBusObjectProxy.
     * @record
     */
    abstract class DBusObjectProxyClass {
        // Own properties of Gio-2.0.Gio.DBusObjectProxyClass

        static name: string;
    }

    interface DBusObjectProxyPrivate {}

    class DBusObjectProxyPrivate {
        // Own properties of Gio-2.0.Gio.DBusObjectProxyPrivate

        static name: string;
    }

    interface DBusObjectSkeletonClass {
        // Own fields of Gio-2.0.Gio.DBusObjectSkeletonClass

        /**
         * The parent class.
         * @field
         */
        parent_class: GObject.ObjectClass;
        authorize_method: (
            object: DBusObjectSkeleton,
            interface_: DBusInterfaceSkeleton,
            invocation: DBusMethodInvocation
        ) => boolean;
    }

    /**
     * Class structure for #GDBusObjectSkeleton.
     * @record
     */
    abstract class DBusObjectSkeletonClass {
        // Own properties of Gio-2.0.Gio.DBusObjectSkeletonClass

        static name: string;
    }

    interface DBusObjectSkeletonPrivate {}

    class DBusObjectSkeletonPrivate {
        // Own properties of Gio-2.0.Gio.DBusObjectSkeletonPrivate

        static name: string;
    }

    interface DBusPropertyInfo {
        // Own fields of Gio-2.0.Gio.DBusPropertyInfo

        /**
         * The reference count or -1 if statically allocated.
         * @field
         */
        ref_count: number;
        /**
         * The name of the D-Bus property, e.g. "SupportedFilesystems".
         * @field
         */
        name: string | null;
        /**
         * The D-Bus signature of the property (a single complete type).
         * @field
         */
        signature: string | null;
        /**
         * Access control flags for the property.
         * @field
         */
        flags: DBusPropertyInfoFlags;
        /**
         * A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.
         * @field
         */
        annotations: DBusAnnotationInfo[];

        // Owm methods of Gio-2.0.Gio.DBusPropertyInfo

        /**
         * If `info` is statically allocated does nothing. Otherwise increases
         * the reference count.
         * @returns The same @info.
         */
        ref(): DBusPropertyInfo;
        /**
         * If `info` is statically allocated, does nothing. Otherwise decreases
         * the reference count of `info`. When its reference count drops to 0,
         * the memory used is freed.
         */
        unref(): void;
    }

    /**
     * Information about a D-Bus property on a D-Bus interface.
     * @record
     */
    class DBusPropertyInfo {
        // Own properties of Gio-2.0.Gio.DBusPropertyInfo

        static name: string;
    }

    interface DBusProxyClass {
        // Own fields of Gio-2.0.Gio.DBusProxyClass

        g_properties_changed: (
            proxy: DBusProxy,
            changed_properties: GLib.Variant,
            invalidated_properties: string | null
        ) => void;
        g_signal: (
            proxy: DBusProxy,
            sender_name: string | null,
            signal_name: string | null,
            parameters: GLib.Variant
        ) => void;
    }

    /**
     * Class structure for #GDBusProxy.
     * @record
     */
    abstract class DBusProxyClass {
        // Own properties of Gio-2.0.Gio.DBusProxyClass

        static name: string;
    }

    interface DBusProxyPrivate {}

    class DBusProxyPrivate {
        // Own properties of Gio-2.0.Gio.DBusProxyPrivate

        static name: string;
    }

    interface DBusSignalInfo {
        // Own fields of Gio-2.0.Gio.DBusSignalInfo

        /**
         * The reference count or -1 if statically allocated.
         * @field
         */
        ref_count: number;
        /**
         * The name of the D-Bus signal, e.g. "NameOwnerChanged".
         * @field
         */
        name: string | null;
        /**
         * A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no arguments.
         * @field
         */
        args: DBusArgInfo[];
        /**
         * A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.
         * @field
         */
        annotations: DBusAnnotationInfo[];

        // Owm methods of Gio-2.0.Gio.DBusSignalInfo

        /**
         * If `info` is statically allocated does nothing. Otherwise increases
         * the reference count.
         * @returns The same @info.
         */
        ref(): DBusSignalInfo;
        /**
         * If `info` is statically allocated, does nothing. Otherwise decreases
         * the reference count of `info`. When its reference count drops to 0,
         * the memory used is freed.
         */
        unref(): void;
    }

    /**
     * Information about a signal on a D-Bus interface.
     * @record
     */
    class DBusSignalInfo {
        // Own properties of Gio-2.0.Gio.DBusSignalInfo

        static name: string;
    }

    interface DBusSubtreeVTable {
        // Own fields of Gio-2.0.Gio.DBusSubtreeVTable

        /**
         * Function for enumerating child nodes.
         * @field
         */
        enumerate: DBusSubtreeEnumerateFunc;
        /**
         * Function for introspecting a child node.
         * @field
         */
        introspect: DBusSubtreeIntrospectFunc;
        /**
         * Function for dispatching a remote call on a child node.
         * @field
         */
        dispatch: DBusSubtreeDispatchFunc;
    }

    /**
     * Virtual table for handling subtrees registered with g_dbus_connection_register_subtree().
     * @record
     */
    class DBusSubtreeVTable {
        // Own properties of Gio-2.0.Gio.DBusSubtreeVTable

        static name: string;
    }

    interface DataInputStreamClass {
        // Own fields of Gio-2.0.Gio.DataInputStreamClass

        parent_class: BufferedInputStreamClass;
    }

    abstract class DataInputStreamClass {
        // Own properties of Gio-2.0.Gio.DataInputStreamClass

        static name: string;
    }

    interface DataInputStreamPrivate {}

    class DataInputStreamPrivate {
        // Own properties of Gio-2.0.Gio.DataInputStreamPrivate

        static name: string;
    }

    interface DataOutputStreamClass {
        // Own fields of Gio-2.0.Gio.DataOutputStreamClass

        parent_class: FilterOutputStreamClass;
    }

    abstract class DataOutputStreamClass {
        // Own properties of Gio-2.0.Gio.DataOutputStreamClass

        static name: string;
    }

    interface DataOutputStreamPrivate {}

    class DataOutputStreamPrivate {
        // Own properties of Gio-2.0.Gio.DataOutputStreamPrivate

        static name: string;
    }

    interface DatagramBasedInterface {
        // Own fields of Gio-2.0.Gio.DatagramBasedInterface

        /**
         * The parent interface.
         * @field
         */
        g_iface: GObject.TypeInterface;
        receive_messages: (
            datagram_based: DatagramBased,
            messages: InputMessage[],
            flags: number,
            timeout: number,
            cancellable: Cancellable | null
        ) => number;
        send_messages: (
            datagram_based: DatagramBased,
            messages: OutputMessage[],
            flags: number,
            timeout: number,
            cancellable: Cancellable | null
        ) => number;
        create_source: (
            datagram_based: DatagramBased,
            condition: GLib.IOCondition,
            cancellable: Cancellable | null
        ) => GLib.Source;
        condition_check: (
            datagram_based: DatagramBased,
            condition: GLib.IOCondition
        ) => GLib.IOCondition;
        condition_wait: (
            datagram_based: DatagramBased,
            condition: GLib.IOCondition,
            timeout: number,
            cancellable: Cancellable | null
        ) => boolean;
    }

    /**
     * Provides an interface for socket-like objects which have datagram semantics,
     * following the Berkeley sockets API. The interface methods are thin wrappers
     * around the corresponding virtual methods, and no pre-processing of inputs is
     * implemented  so implementations of this API must handle all functionality
     * documented in the interface methods.
     * @record
     */
    abstract class DatagramBasedInterface {
        // Own properties of Gio-2.0.Gio.DatagramBasedInterface

        static name: string;
    }

    interface DebugControllerDBusClass {
        // Own fields of Gio-2.0.Gio.DebugControllerDBusClass

        /**
         * The parent class.
         * @field
         */
        parent_class: GObject.ObjectClass;
        authorize: (
            controller: DebugControllerDBus,
            invocation: DBusMethodInvocation
        ) => boolean;
        padding: any[];
    }

    /**
     * The virtual function table for #GDebugControllerDBus.
     * @record
     */
    abstract class DebugControllerDBusClass {
        // Own properties of Gio-2.0.Gio.DebugControllerDBusClass

        static name: string;
    }

    interface DebugControllerInterface {}

    /**
     * The virtual function table for #GDebugController.
     * @record
     */
    abstract class DebugControllerInterface {
        // Own properties of Gio-2.0.Gio.DebugControllerInterface

        static name: string;
    }

    interface DesktopAppInfoClass {
        // Own fields of Gio-2.0.Gio.DesktopAppInfoClass

        parent_class: GObject.ObjectClass;
    }

    abstract class DesktopAppInfoClass {
        // Own properties of Gio-2.0.Gio.DesktopAppInfoClass

        static name: string;
    }

    interface DesktopAppInfoLookupIface {
        // Own fields of Gio-2.0.Gio.DesktopAppInfoLookupIface

        g_iface: GObject.TypeInterface;
        get_default_for_uri_scheme: (
            lookup: DesktopAppInfoLookup,
            uri_scheme: string | null
        ) => AppInfo | null;
    }

    /**
     * Interface that is used by backends to associate default
     * handlers with URI schemes.
     * @record
     */
    abstract class DesktopAppInfoLookupIface {
        // Own properties of Gio-2.0.Gio.DesktopAppInfoLookupIface

        static name: string;
    }

    interface DriveIface {
        // Own fields of Gio-2.0.Gio.DriveIface

        /**
         * The parent interface.
         * @field
         */
        g_iface: GObject.TypeInterface;
        changed: (drive: Drive) => void;
        disconnected: (drive: Drive) => void;
        eject_button: (drive: Drive) => void;
        get_name: (drive: Drive) => string | null;
        get_icon: (drive: Drive) => Icon;
        has_volumes: (drive: Drive) => boolean;
        get_volumes: (drive: Drive) => Volume[];
        is_media_removable: (drive: Drive) => boolean;
        has_media: (drive: Drive) => boolean;
        is_media_check_automatic: (drive: Drive) => boolean;
        can_eject: (drive: Drive) => boolean;
        can_poll_for_media: (drive: Drive) => boolean;
        eject: (
            drive: Drive,
            flags: MountUnmountFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        eject_finish: (drive: Drive, result: AsyncResult) => boolean;
        poll_for_media: (
            drive: Drive,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        poll_for_media_finish: (drive: Drive, result: AsyncResult) => boolean;
        get_identifier: (drive: Drive, kind: string | null) => string | null;
        enumerate_identifiers: (drive: Drive) => string[];
        get_start_stop_type: (drive: Drive) => DriveStartStopType;
        can_start: (drive: Drive) => boolean;
        can_start_degraded: (drive: Drive) => boolean;
        start: (
            drive: Drive,
            flags: DriveStartFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        start_finish: (drive: Drive, result: AsyncResult) => boolean;
        can_stop: (drive: Drive) => boolean;
        stop: (
            drive: Drive,
            flags: MountUnmountFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        stop_finish: (drive: Drive, result: AsyncResult) => boolean;
        stop_button: (drive: Drive) => void;
        eject_with_operation: (
            drive: Drive,
            flags: MountUnmountFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        eject_with_operation_finish: (
            drive: Drive,
            result: AsyncResult
        ) => boolean;
        get_sort_key: (drive: Drive) => string | null;
        get_symbolic_icon: (drive: Drive) => Icon;
        is_removable: (drive: Drive) => boolean;
    }

    /**
     * Interface for creating #GDrive implementations.
     * @record
     */
    abstract class DriveIface {
        // Own properties of Gio-2.0.Gio.DriveIface

        static name: string;
    }

    interface DtlsClientConnectionInterface {
        // Own fields of Gio-2.0.Gio.DtlsClientConnectionInterface

        /**
         * The parent interface.
         * @field
         */
        g_iface: GObject.TypeInterface;
    }

    /**
     * vtable for a #GDtlsClientConnection implementation.
     * @record
     */
    abstract class DtlsClientConnectionInterface {
        // Own properties of Gio-2.0.Gio.DtlsClientConnectionInterface

        static name: string;
    }

    interface DtlsConnectionInterface {
        // Own fields of Gio-2.0.Gio.DtlsConnectionInterface

        /**
         * The parent interface.
         * @field
         */
        g_iface: GObject.TypeInterface;
        accept_certificate: (
            connection: DtlsConnection,
            peer_cert: TlsCertificate,
            errors: TlsCertificateFlags
        ) => boolean;
        handshake: (
            conn: DtlsConnection,
            cancellable: Cancellable | null
        ) => boolean;
        handshake_async: (
            conn: DtlsConnection,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        handshake_finish: (
            conn: DtlsConnection,
            result: AsyncResult
        ) => boolean;
        shutdown: (
            conn: DtlsConnection,
            shutdown_read: boolean,
            shutdown_write: boolean,
            cancellable: Cancellable | null
        ) => boolean;
        shutdown_async: (
            conn: DtlsConnection,
            shutdown_read: boolean,
            shutdown_write: boolean,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        shutdown_finish: (conn: DtlsConnection, result: AsyncResult) => boolean;
        set_advertised_protocols: (
            conn: DtlsConnection,
            protocols: string[] | null
        ) => void;
        get_negotiated_protocol: (conn: DtlsConnection) => string | null;
        get_binding_data: (
            conn: DtlsConnection,
            type: TlsChannelBindingType,
            data: Uint8Array
        ) => boolean;
    }

    /**
     * Virtual method table for a #GDtlsConnection implementation.
     * @record
     */
    abstract class DtlsConnectionInterface {
        // Own properties of Gio-2.0.Gio.DtlsConnectionInterface

        static name: string;
    }

    interface DtlsServerConnectionInterface {
        // Own fields of Gio-2.0.Gio.DtlsServerConnectionInterface

        /**
         * The parent interface.
         * @field
         */
        g_iface: GObject.TypeInterface;
    }

    /**
     * vtable for a #GDtlsServerConnection implementation.
     * @record
     */
    abstract class DtlsServerConnectionInterface {
        // Own properties of Gio-2.0.Gio.DtlsServerConnectionInterface

        static name: string;
    }

    interface EmblemClass {}

    abstract class EmblemClass {
        // Own properties of Gio-2.0.Gio.EmblemClass

        static name: string;
    }

    interface EmblemedIconClass {
        // Own fields of Gio-2.0.Gio.EmblemedIconClass

        parent_class: GObject.ObjectClass;
    }

    abstract class EmblemedIconClass {
        // Own properties of Gio-2.0.Gio.EmblemedIconClass

        static name: string;
    }

    interface EmblemedIconPrivate {}

    class EmblemedIconPrivate {
        // Own properties of Gio-2.0.Gio.EmblemedIconPrivate

        static name: string;
    }

    interface FileAttributeInfo {
        // Own fields of Gio-2.0.Gio.FileAttributeInfo

        /**
         * the name of the attribute.
         * @field
         */
        name: string | null;
        /**
         * the #GFileAttributeType type of the attribute.
         * @field
         */
        type: FileAttributeType;
        /**
         * a set of #GFileAttributeInfoFlags.
         * @field
         */
        flags: FileAttributeInfoFlags;
    }

    /**
     * Information about a specific attribute.
     * @record
     */
    class FileAttributeInfo {
        // Own properties of Gio-2.0.Gio.FileAttributeInfo

        static name: string;
    }

    interface FileAttributeInfoList {
        // Own fields of Gio-2.0.Gio.FileAttributeInfoList

        /**
         * an array of #GFileAttributeInfos.
         * @field
         */
        infos: FileAttributeInfo;
        /**
         * the number of values in the array.
         * @field
         */
        n_infos: number;

        // Owm methods of Gio-2.0.Gio.FileAttributeInfoList

        /**
         * Adds a new attribute with `name` to the `list,` setting
         * its `type` and `flags`.
         * @param name the name of the attribute to add.
         * @param type the #GFileAttributeType for the attribute.
         * @param flags #GFileAttributeInfoFlags for the attribute.
         */
        add(
            name: string | null,
            type: FileAttributeType,
            flags: FileAttributeInfoFlags
        ): void;
        /**
         * Makes a duplicate of a file attribute info list.
         * @returns a copy of the given @list.
         */
        dup(): FileAttributeInfoList;
        /**
         * Gets the file attribute with the name `name` from `list`.
         * @param name the name of the attribute to look up.
         * @returns a #GFileAttributeInfo for the @name, or %NULL if an attribute isn't found.
         */
        lookup(name: string | null): FileAttributeInfo;
        /**
         * References a file attribute info list.
         * @returns #GFileAttributeInfoList or %NULL on error.
         */
        ref(): FileAttributeInfoList;
        /**
         * Removes a reference from the given `list`. If the reference count
         * falls to zero, the `list` is deleted.
         */
        unref(): void;
    }

    /**
     * Acts as a lightweight registry for possible valid file attributes.
     * The registry stores Key-Value pair formats as #GFileAttributeInfos.
     * @record
     */
    class FileAttributeInfoList {
        // Own properties of Gio-2.0.Gio.FileAttributeInfoList

        static name: string;

        // Constructors of Gio-2.0.Gio.FileAttributeInfoList

        /**
         * Creates a new file attribute info list.
         * @constructor
         * @returns a #GFileAttributeInfoList.
         */
        constructor();
        /**
         * Creates a new file attribute info list.
         * @constructor
         * @returns a #GFileAttributeInfoList.
         */
        static new(): FileAttributeInfoList;
    }

    interface FileAttributeMatcher {
        // Owm methods of Gio-2.0.Gio.FileAttributeMatcher

        /**
         * Checks if the matcher will match all of the keys in a given namespace.
         * This will always return %TRUE if a wildcard character is in use (e.g. if
         * matcher was created with "standard::*" and `ns` is "standard", or if matcher was created
         * using "*" and namespace is anything.)
         *
         * TODO: this is awkwardly worded.
         * @param ns a string containing a file attribute namespace.
         * @returns %TRUE if the matcher matches all of the entries in the given @ns, %FALSE otherwise.
         */
        enumerate_namespace(ns: string | null): boolean;
        /**
         * Gets the next matched attribute from a #GFileAttributeMatcher.
         * @returns a string containing the next attribute or, %NULL if no more attribute exist.
         */
        enumerate_next(): string | null;
        /**
         * Checks if an attribute will be matched by an attribute matcher. If
         * the matcher was created with the "*" matching string, this function
         * will always return %TRUE.
         * @param attribute a file attribute key.
         * @returns %TRUE if @attribute matches @matcher. %FALSE otherwise.
         */
        matches(attribute: string | null): boolean;
        /**
         * Checks if an attribute matcher only matches a given attribute. Always
         * returns %FALSE if "*" was used when creating the matcher.
         * @param attribute a file attribute key.
         * @returns %TRUE if the matcher only matches @attribute. %FALSE otherwise.
         */
        matches_only(attribute: string | null): boolean;
        /**
         * References a file attribute matcher.
         * @returns a #GFileAttributeMatcher.
         */
        ref(): FileAttributeMatcher;
        /**
         * Subtracts all attributes of `subtract` from `matcher` and returns
         * a matcher that supports those attributes.
         *
         * Note that currently it is not possible to remove a single
         * attribute when the `matcher` matches the whole namespace - or remove
         * a namespace or attribute when the matcher matches everything. This
         * is a limitation of the current implementation, but may be fixed
         * in the future.
         * @param subtract The matcher to subtract
         * @returns A file attribute matcher matching all attributes of     @matcher that are not matched by @subtract
         */
        subtract(
            subtract: FileAttributeMatcher | null
        ): FileAttributeMatcher | null;
        /**
         * Prints what the matcher is matching against. The format will be
         * equal to the format passed to g_file_attribute_matcher_new().
         * The output however, might not be identical, as the matcher may
         * decide to use a different order or omit needless parts.
         * @returns a string describing the attributes the matcher matches   against or %NULL if @matcher was %NULL.
         */
        to_string(): string | null;
        /**
         * Unreferences `matcher`. If the reference count falls below 1,
         * the `matcher` is automatically freed.
         */
        unref(): void;
    }

    /**
     * Determines if a string matches a file attribute.
     * @record
     */
    class FileAttributeMatcher {
        // Own properties of Gio-2.0.Gio.FileAttributeMatcher

        static name: string;

        // Constructors of Gio-2.0.Gio.FileAttributeMatcher

        /**
         * Creates a new file attribute matcher, which matches attributes
         * against a given string. #GFileAttributeMatchers are reference
         * counted structures, and are created with a reference count of 1. If
         * the number of references falls to 0, the #GFileAttributeMatcher is
         * automatically destroyed.
         *
         * The `attributes` string should be formatted with specific keys separated
         * from namespaces with a double colon. Several "namespace::key" strings may be
         * concatenated with a single comma (e.g. "standard::type,standard::is-hidden").
         * The wildcard "*" may be used to match all keys and namespaces, or
         * "namespace::*" will match all keys in a given namespace.
         *
         * ## Examples of file attribute matcher strings and results
         *
         * - `"*"`: matches all attributes.
         * - `"standard::is-hidden"`: matches only the key is-hidden in the
         *   standard namespace.
         * - `"standard::type,unix::*"`: matches the type key in the standard
         *   namespace and all keys in the unix namespace.
         * @constructor
         * @param attributes an attribute string to match.
         * @returns a #GFileAttributeMatcher
         */
        constructor(attributes: string | null);
        /**
         * Creates a new file attribute matcher, which matches attributes
         * against a given string. #GFileAttributeMatchers are reference
         * counted structures, and are created with a reference count of 1. If
         * the number of references falls to 0, the #GFileAttributeMatcher is
         * automatically destroyed.
         *
         * The `attributes` string should be formatted with specific keys separated
         * from namespaces with a double colon. Several "namespace::key" strings may be
         * concatenated with a single comma (e.g. "standard::type,standard::is-hidden").
         * The wildcard "*" may be used to match all keys and namespaces, or
         * "namespace::*" will match all keys in a given namespace.
         *
         * ## Examples of file attribute matcher strings and results
         *
         * - `"*"`: matches all attributes.
         * - `"standard::is-hidden"`: matches only the key is-hidden in the
         *   standard namespace.
         * - `"standard::type,unix::*"`: matches the type key in the standard
         *   namespace and all keys in the unix namespace.
         * @constructor
         * @param attributes an attribute string to match.
         * @returns a #GFileAttributeMatcher
         */
        static new(attributes: string | null): FileAttributeMatcher;
    }

    interface FileDescriptorBasedIface {
        // Own fields of Gio-2.0.Gio.FileDescriptorBasedIface

        /**
         * The parent interface.
         * @field
         */
        g_iface: GObject.TypeInterface;
        get_fd: (fd_based: FileDescriptorBased) => number;
    }

    /**
     * An interface for file descriptor based io objects.
     * @record
     */
    abstract class FileDescriptorBasedIface {
        // Own properties of Gio-2.0.Gio.FileDescriptorBasedIface

        static name: string;
    }

    interface FileEnumeratorClass {
        // Own fields of Gio-2.0.Gio.FileEnumeratorClass

        parent_class: GObject.ObjectClass;
        next_file: (
            enumerator: FileEnumerator,
            cancellable: Cancellable | null
        ) => FileInfo | null;
        close_fn: (
            enumerator: FileEnumerator,
            cancellable: Cancellable | null
        ) => boolean;
        next_files_async: (
            enumerator: FileEnumerator,
            num_files: number,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        next_files_finish: (
            enumerator: FileEnumerator,
            result: AsyncResult
        ) => FileInfo[];
        close_async: (
            enumerator: FileEnumerator,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        close_finish: (
            enumerator: FileEnumerator,
            result: AsyncResult
        ) => boolean;
    }

    abstract class FileEnumeratorClass {
        // Own properties of Gio-2.0.Gio.FileEnumeratorClass

        static name: string;
    }

    interface FileEnumeratorPrivate {}

    class FileEnumeratorPrivate {
        // Own properties of Gio-2.0.Gio.FileEnumeratorPrivate

        static name: string;
    }

    interface FileIOStreamClass {
        // Own fields of Gio-2.0.Gio.FileIOStreamClass

        parent_class: IOStreamClass;
        tell: (stream: FileIOStream) => number;
        can_seek: (stream: FileIOStream) => boolean;
        seek: (
            stream: FileIOStream,
            offset: number,
            type: GLib.SeekType,
            cancellable: Cancellable | null
        ) => boolean;
        can_truncate: (stream: FileIOStream) => boolean;
        truncate_fn: (
            stream: FileIOStream,
            size: number,
            cancellable: Cancellable | null
        ) => boolean;
        query_info: (
            stream: FileIOStream,
            attributes: string | null,
            cancellable: Cancellable | null
        ) => FileInfo;
        query_info_async: (
            stream: FileIOStream,
            attributes: string | null,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        query_info_finish: (
            stream: FileIOStream,
            result: AsyncResult
        ) => FileInfo;
        get_etag: (stream: FileIOStream) => string | null;
    }

    abstract class FileIOStreamClass {
        // Own properties of Gio-2.0.Gio.FileIOStreamClass

        static name: string;
    }

    interface FileIOStreamPrivate {}

    class FileIOStreamPrivate {
        // Own properties of Gio-2.0.Gio.FileIOStreamPrivate

        static name: string;
    }

    interface FileIconClass {}

    abstract class FileIconClass {
        // Own properties of Gio-2.0.Gio.FileIconClass

        static name: string;
    }

    interface FileIface {
        // Own fields of Gio-2.0.Gio.FileIface

        /**
         * The parent interface.
         * @field
         */
        g_iface: GObject.TypeInterface;
        dup: (file: File) => File;
        hash: (file: File) => number;
        equal: (file1: File, file2: File) => boolean;
        is_native: (file: File) => boolean;
        has_uri_scheme: (file: File, uri_scheme: string | null) => boolean;
        get_uri_scheme: (file: File) => string | null;
        get_basename: (file: File) => string | null;
        get_path: (file: File) => string | null;
        get_uri: (file: File) => string | null;
        get_parse_name: (file: File) => string | null;
        get_parent: (file: File) => File | null;
        prefix_matches: (prefix: File, file: File) => boolean;
        get_relative_path: (parent: File, descendant: File) => string | null;
        resolve_relative_path: (file: File, relative_path: string) => File;
        get_child_for_display_name: (
            file: File,
            display_name: string | null
        ) => File;
        enumerate_children: (
            file: File,
            attributes: string | null,
            flags: FileQueryInfoFlags,
            cancellable: Cancellable | null
        ) => FileEnumerator;
        enumerate_children_async: (
            file: File,
            attributes: string | null,
            flags: FileQueryInfoFlags,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        enumerate_children_finish: (
            file: File,
            res: AsyncResult
        ) => FileEnumerator;
        query_info: (
            file: File,
            attributes: string | null,
            flags: FileQueryInfoFlags,
            cancellable: Cancellable | null
        ) => FileInfo;
        query_info_async: (
            file: File,
            attributes: string | null,
            flags: FileQueryInfoFlags,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        query_info_finish: (file: File, res: AsyncResult) => FileInfo;
        query_filesystem_info: (
            file: File,
            attributes: string | null,
            cancellable: Cancellable | null
        ) => FileInfo;
        query_filesystem_info_async: (
            file: File,
            attributes: string | null,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        query_filesystem_info_finish: (
            file: File,
            res: AsyncResult
        ) => FileInfo;
        find_enclosing_mount: (
            file: File,
            cancellable: Cancellable | null
        ) => Mount;
        find_enclosing_mount_async: (
            file: File,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        find_enclosing_mount_finish: (file: File, res: AsyncResult) => Mount;
        set_display_name: (
            file: File,
            display_name: string | null,
            cancellable: Cancellable | null
        ) => File;
        set_display_name_async: (
            file: File,
            display_name: string | null,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        set_display_name_finish: (file: File, res: AsyncResult) => File;
        query_settable_attributes: (
            file: File,
            cancellable: Cancellable | null
        ) => FileAttributeInfoList;
        query_writable_namespaces: (
            file: File,
            cancellable: Cancellable | null
        ) => FileAttributeInfoList;
        set_attribute: (
            file: File,
            attribute: string | null,
            type: FileAttributeType,
            value_p: any | null,
            flags: FileQueryInfoFlags,
            cancellable: Cancellable | null
        ) => boolean;
        set_attributes_from_info: (
            file: File,
            info: FileInfo,
            flags: FileQueryInfoFlags,
            cancellable: Cancellable | null
        ) => boolean;
        set_attributes_async: (
            file: File,
            info: FileInfo,
            flags: FileQueryInfoFlags,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        set_attributes_finish: (
            file: File,
            result: AsyncResult
        ) => [/* returnType */ boolean, /* info */ FileInfo];
        read_fn: (
            file: File,
            cancellable: Cancellable | null
        ) => FileInputStream;
        read_async: (
            file: File,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        read_finish: (file: File, res: AsyncResult) => FileInputStream;
        append_to: (
            file: File,
            flags: FileCreateFlags,
            cancellable: Cancellable | null
        ) => FileOutputStream;
        append_to_async: (
            file: File,
            flags: FileCreateFlags,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        append_to_finish: (file: File, res: AsyncResult) => FileOutputStream;
        create: (
            file: File,
            flags: FileCreateFlags,
            cancellable: Cancellable | null
        ) => FileOutputStream;
        create_async: (
            file: File,
            flags: FileCreateFlags,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        create_finish: (file: File, res: AsyncResult) => FileOutputStream;
        replace: (
            file: File,
            etag: string | null,
            make_backup: boolean,
            flags: FileCreateFlags,
            cancellable: Cancellable | null
        ) => FileOutputStream;
        replace_async: (
            file: File,
            etag: string | null,
            make_backup: boolean,
            flags: FileCreateFlags,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        replace_finish: (file: File, res: AsyncResult) => FileOutputStream;
        delete_file: (file: File, cancellable: Cancellable | null) => boolean;
        delete_file_async: (
            file: File,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        delete_file_finish: (file: File, result: AsyncResult) => boolean;
        trash: (file: File, cancellable: Cancellable | null) => boolean;
        trash_async: (
            file: File,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        trash_finish: (file: File, result: AsyncResult) => boolean;
        make_directory: (
            file: File,
            cancellable: Cancellable | null
        ) => boolean;
        make_directory_async: (
            file: File,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        make_directory_finish: (file: File, result: AsyncResult) => boolean;
        make_symbolic_link: (
            file: File,
            symlink_value: string,
            cancellable: Cancellable | null
        ) => boolean;
        make_symbolic_link_async: (
            file: File,
            symlink_value: string,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        make_symbolic_link_finish: (file: File, result: AsyncResult) => boolean;
        copy: (
            source: File,
            destination: File,
            flags: FileCopyFlags,
            cancellable: Cancellable | null,
            progress_callback: FileProgressCallback | null
        ) => boolean;
        copy_async: (
            source: File,
            destination: File,
            flags: FileCopyFlags,
            io_priority: number,
            cancellable: Cancellable | null,
            progress_callback: FileProgressCallback | null,
            callback: AsyncReadyCallback | null
        ) => void;
        copy_finish: (file: File, res: AsyncResult) => boolean;
        move: (
            source: File,
            destination: File,
            flags: FileCopyFlags,
            cancellable: Cancellable | null,
            progress_callback: FileProgressCallback | null
        ) => boolean;
        move_async: (
            source: File,
            destination: File,
            flags: FileCopyFlags,
            io_priority: number,
            cancellable: Cancellable | null,
            progress_callback: FileProgressCallback | null,
            callback: AsyncReadyCallback | null
        ) => void;
        move_finish: (file: File, result: AsyncResult) => boolean;
        mount_mountable: (
            file: File,
            flags: MountMountFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        mount_mountable_finish: (file: File, result: AsyncResult) => File;
        unmount_mountable: (
            file: File,
            flags: MountUnmountFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        unmount_mountable_finish: (file: File, result: AsyncResult) => boolean;
        eject_mountable: (
            file: File,
            flags: MountUnmountFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        eject_mountable_finish: (file: File, result: AsyncResult) => boolean;
        mount_enclosing_volume: (
            location: File,
            flags: MountMountFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        mount_enclosing_volume_finish: (
            location: File,
            result: AsyncResult
        ) => boolean;
        monitor_dir: (
            file: File,
            flags: FileMonitorFlags,
            cancellable: Cancellable | null
        ) => FileMonitor;
        monitor_file: (
            file: File,
            flags: FileMonitorFlags,
            cancellable: Cancellable | null
        ) => FileMonitor;
        open_readwrite: (
            file: File,
            cancellable: Cancellable | null
        ) => FileIOStream;
        open_readwrite_async: (
            file: File,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        open_readwrite_finish: (file: File, res: AsyncResult) => FileIOStream;
        create_readwrite: (
            file: File,
            flags: FileCreateFlags,
            cancellable: Cancellable | null
        ) => FileIOStream;
        create_readwrite_async: (
            file: File,
            flags: FileCreateFlags,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        create_readwrite_finish: (file: File, res: AsyncResult) => FileIOStream;
        replace_readwrite: (
            file: File,
            etag: string | null,
            make_backup: boolean,
            flags: FileCreateFlags,
            cancellable: Cancellable | null
        ) => FileIOStream;
        replace_readwrite_async: (
            file: File,
            etag: string | null,
            make_backup: boolean,
            flags: FileCreateFlags,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        replace_readwrite_finish: (
            file: File,
            res: AsyncResult
        ) => FileIOStream;
        start_mountable: (
            file: File,
            flags: DriveStartFlags,
            start_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        start_mountable_finish: (file: File, result: AsyncResult) => boolean;
        stop_mountable: (
            file: File,
            flags: MountUnmountFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        stop_mountable_finish: (file: File, result: AsyncResult) => boolean;
        /**
         * a boolean that indicates whether the #GFile implementation supports thread-default contexts. Since 2.22.
         * @field
         */
        supports_thread_contexts: boolean;
        unmount_mountable_with_operation: (
            file: File,
            flags: MountUnmountFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        unmount_mountable_with_operation_finish: (
            file: File,
            result: AsyncResult
        ) => boolean;
        eject_mountable_with_operation: (
            file: File,
            flags: MountUnmountFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        eject_mountable_with_operation_finish: (
            file: File,
            result: AsyncResult
        ) => boolean;
        poll_mountable: (
            file: File,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        poll_mountable_finish: (file: File, result: AsyncResult) => boolean;
        measure_disk_usage_finish: (
            file: File,
            result: AsyncResult
        ) => [
            /* returnType */ boolean,
            /* disk_usage */ number,
            /* num_dirs */ number,
            /* num_files */ number
        ];
    }

    /**
     * An interface for writing VFS file handles.
     * @record
     */
    abstract class FileIface {
        // Own properties of Gio-2.0.Gio.FileIface

        static name: string;
    }

    interface FileInfoClass {}

    abstract class FileInfoClass {
        // Own properties of Gio-2.0.Gio.FileInfoClass

        static name: string;
    }

    interface FileInputStreamClass {
        // Own fields of Gio-2.0.Gio.FileInputStreamClass

        parent_class: InputStreamClass;
        tell: (stream: FileInputStream) => number;
        can_seek: (stream: FileInputStream) => boolean;
        seek: (
            stream: FileInputStream,
            offset: number,
            type: GLib.SeekType,
            cancellable: Cancellable | null
        ) => boolean;
        query_info: (
            stream: FileInputStream,
            attributes: string | null,
            cancellable: Cancellable | null
        ) => FileInfo;
        query_info_async: (
            stream: FileInputStream,
            attributes: string | null,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        query_info_finish: (
            stream: FileInputStream,
            result: AsyncResult
        ) => FileInfo;
    }

    abstract class FileInputStreamClass {
        // Own properties of Gio-2.0.Gio.FileInputStreamClass

        static name: string;
    }

    interface FileInputStreamPrivate {}

    class FileInputStreamPrivate {
        // Own properties of Gio-2.0.Gio.FileInputStreamPrivate

        static name: string;
    }

    interface FileMonitorClass {
        // Own fields of Gio-2.0.Gio.FileMonitorClass

        parent_class: GObject.ObjectClass;
        changed: (
            monitor: FileMonitor,
            file: File,
            other_file: File,
            event_type: FileMonitorEvent
        ) => void;
        cancel: (monitor: FileMonitor) => boolean;
    }

    abstract class FileMonitorClass {
        // Own properties of Gio-2.0.Gio.FileMonitorClass

        static name: string;
    }

    interface FileMonitorPrivate {}

    class FileMonitorPrivate {
        // Own properties of Gio-2.0.Gio.FileMonitorPrivate

        static name: string;
    }

    interface FileOutputStreamClass {
        // Own fields of Gio-2.0.Gio.FileOutputStreamClass

        parent_class: OutputStreamClass;
        tell: (stream: FileOutputStream) => number;
        can_seek: (stream: FileOutputStream) => boolean;
        seek: (
            stream: FileOutputStream,
            offset: number,
            type: GLib.SeekType,
            cancellable: Cancellable | null
        ) => boolean;
        can_truncate: (stream: FileOutputStream) => boolean;
        truncate_fn: (
            stream: FileOutputStream,
            size: number,
            cancellable: Cancellable | null
        ) => boolean;
        query_info: (
            stream: FileOutputStream,
            attributes: string | null,
            cancellable: Cancellable | null
        ) => FileInfo;
        query_info_async: (
            stream: FileOutputStream,
            attributes: string | null,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        query_info_finish: (
            stream: FileOutputStream,
            result: AsyncResult
        ) => FileInfo;
        get_etag: (stream: FileOutputStream) => string | null;
    }

    abstract class FileOutputStreamClass {
        // Own properties of Gio-2.0.Gio.FileOutputStreamClass

        static name: string;
    }

    interface FileOutputStreamPrivate {}

    class FileOutputStreamPrivate {
        // Own properties of Gio-2.0.Gio.FileOutputStreamPrivate

        static name: string;
    }

    interface FilenameCompleterClass {
        // Own fields of Gio-2.0.Gio.FilenameCompleterClass

        parent_class: GObject.ObjectClass;
        got_completion_data: (filename_completer: FilenameCompleter) => void;
    }

    abstract class FilenameCompleterClass {
        // Own properties of Gio-2.0.Gio.FilenameCompleterClass

        static name: string;
    }

    interface FilterInputStreamClass {
        // Own fields of Gio-2.0.Gio.FilterInputStreamClass

        parent_class: InputStreamClass;
    }

    abstract class FilterInputStreamClass {
        // Own properties of Gio-2.0.Gio.FilterInputStreamClass

        static name: string;
    }

    interface FilterOutputStreamClass {
        // Own fields of Gio-2.0.Gio.FilterOutputStreamClass

        parent_class: OutputStreamClass;
    }

    abstract class FilterOutputStreamClass {
        // Own properties of Gio-2.0.Gio.FilterOutputStreamClass

        static name: string;
    }

    interface IOExtension {
        // Owm methods of Gio-2.0.Gio.IOExtension

        /**
         * Gets the name under which `extension` was registered.
         *
         * Note that the same type may be registered as extension
         * for multiple extension points, under different names.
         * @returns the name of @extension.
         */
        get_name(): string | null;
        /**
         * Gets the priority with which `extension` was registered.
         * @returns the priority of @extension
         */
        get_priority(): number;
        /**
         * Gets the type associated with `extension`.
         * @returns the type of @extension
         */
        get_type(): GObject.GType;
    }

    /**
     * #GIOExtension is an opaque data structure and can only be accessed
     * using the following functions.
     * @record
     */
    class IOExtension {
        // Own properties of Gio-2.0.Gio.IOExtension

        static name: string;
    }

    interface IOExtensionPoint {
        // Owm methods of Gio-2.0.Gio.IOExtensionPoint

        /**
         * Finds a #GIOExtension for an extension point by name.
         * @param name the name of the extension to get
         * @returns the #GIOExtension for @extension_point that has the    given name, or %NULL if there is no extension with that name
         */
        get_extension_by_name(name: string | null): IOExtension;
        /**
         * Gets a list of all extensions that implement this extension point.
         * The list is sorted by priority, beginning with the highest priority.
         * @returns a #GList of     #GIOExtensions. The list is owned by GIO and should not be     modified.
         */
        get_extensions(): IOExtension[];
        /**
         * Gets the required type for `extension_point`.
         * @returns the #GType that all implementations must have,   or %G_TYPE_INVALID if the extension point has no required type
         */
        get_required_type(): GObject.GType;
        /**
         * Sets the required type for `extension_point` to `type`.
         * All implementations must henceforth have this type.
         * @param type the #GType to require
         */
        set_required_type(type: GObject.GType): void;
    }

    /**
     * #GIOExtensionPoint is an opaque data structure and can only be accessed
     * using the following functions.
     * @record
     */
    class IOExtensionPoint {
        // Own properties of Gio-2.0.Gio.IOExtensionPoint

        static name: string;

        // Constructors of Gio-2.0.Gio.IOExtensionPoint

        /**
         * Registers `type` as extension for the extension point with name
         * `extension_point_name`.
         *
         * If `type` has already been registered as an extension for this
         * extension point, the existing #GIOExtension object is returned.
         * @param extension_point_name the name of the extension point
         * @param type the #GType to register as extension
         * @param extension_name the name for the extension
         * @param priority the priority for the extension
         * @returns a #GIOExtension object for #GType
         */
        static implement(
            extension_point_name: string | null,
            type: GObject.GType,
            extension_name: string | null,
            priority: number
        ): IOExtension;
        /**
         * Looks up an existing extension point.
         * @param name the name of the extension point
         * @returns the #GIOExtensionPoint, or %NULL if there    is no registered extension point with the given name.
         */
        static lookup(name: string | null): IOExtensionPoint;
        /**
         * Registers an extension point.
         * @param name The name of the extension point
         * @returns the new #GIOExtensionPoint. This object is    owned by GIO and should not be freed.
         */
        static register(name: string | null): IOExtensionPoint;
    }

    interface IOModuleClass {}

    abstract class IOModuleClass {
        // Own properties of Gio-2.0.Gio.IOModuleClass

        static name: string;
    }

    interface IOModuleScope {
        // Owm methods of Gio-2.0.Gio.IOModuleScope

        /**
         * Block modules with the given `basename` from being loaded when
         * this scope is used with g_io_modules_scan_all_in_directory_with_scope()
         * or g_io_modules_load_all_in_directory_with_scope().
         * @param basename the basename to block
         */
        block(basename: string | null): void;
        /**
         * Free a module scope.
         */
        free(): void;
    }

    /**
     * Represents a scope for loading IO modules. A scope can be used for blocking
     * duplicate modules, or blocking a module you don't want to load.
     *
     * The scope can be used with g_io_modules_load_all_in_directory_with_scope()
     * or g_io_modules_scan_all_in_directory_with_scope().
     * @record
     */
    class IOModuleScope {
        // Own properties of Gio-2.0.Gio.IOModuleScope

        static name: string;
    }

    interface IOSchedulerJob {
        // Owm methods of Gio-2.0.Gio.IOSchedulerJob

        /**
         * Used from an I/O job to send a callback to be run in the thread
         * that the job was started from, waiting for the result (and thus
         * blocking the I/O job).
         * @param func a #GSourceFunc callback that will be called in the original thread
         * @returns The return value of @func
         */
        send_to_mainloop(func: GLib.SourceFunc): boolean;
        /**
         * Used from an I/O job to send a callback to be run asynchronously in
         * the thread that the job was started from. The callback will be run
         * when the main loop is available, but at that time the I/O job might
         * have finished. The return value from the callback is ignored.
         *
         * Note that if you are passing the `user_data` from g_io_scheduler_push_job()
         * on to this function you have to ensure that it is not freed before
         * `func` is called, either by passing %NULL as `notify` to
         * g_io_scheduler_push_job() or by using refcounting for `user_data`.
         * @param func a #GSourceFunc callback that will be called in the original thread
         */
        send_to_mainloop_async(func: GLib.SourceFunc): void;
    }

    /**
     * Opaque class for defining and scheduling IO jobs.
     * @record
     */
    class IOSchedulerJob {
        // Own properties of Gio-2.0.Gio.IOSchedulerJob

        static name: string;
    }

    interface IOStreamAdapter {}

    class IOStreamAdapter {
        // Own properties of Gio-2.0.Gio.IOStreamAdapter

        static name: string;
    }

    interface IOStreamClass {
        // Own fields of Gio-2.0.Gio.IOStreamClass

        parent_class: GObject.ObjectClass;
        get_input_stream: (stream: IOStream) => InputStream;
        get_output_stream: (stream: IOStream) => OutputStream;
        close_fn: (
            stream: IOStream,
            cancellable: Cancellable | null
        ) => boolean;
        close_async: (
            stream: IOStream,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        close_finish: (stream: IOStream, result: AsyncResult) => boolean;
    }

    abstract class IOStreamClass {
        // Own properties of Gio-2.0.Gio.IOStreamClass

        static name: string;
    }

    interface IOStreamPrivate {}

    class IOStreamPrivate {
        // Own properties of Gio-2.0.Gio.IOStreamPrivate

        static name: string;
    }

    interface IconIface {
        // Own fields of Gio-2.0.Gio.IconIface

        /**
         * The parent interface.
         * @field
         */
        g_iface: GObject.TypeInterface;
        hash: (icon: Icon) => number;
        equal: (icon1: Icon | null, icon2: Icon | null) => boolean;
        to_tokens: (
            icon: Icon
        ) => [
            /* returnType */ boolean,
            /* tokens */ string[],
            /* out_version */ number
        ];
        serialize: (icon: Icon) => GLib.Variant | null;
    }

    /**
     * GIconIface is used to implement GIcon types for various
     * different systems. See #GThemedIcon and #GLoadableIcon for
     * examples of how to implement this interface.
     * @record
     */
    abstract class IconIface {
        // Own properties of Gio-2.0.Gio.IconIface

        static name: string;
    }

    interface InetAddressClass {
        // Own fields of Gio-2.0.Gio.InetAddressClass

        parent_class: GObject.ObjectClass;
        to_string: (address: InetAddress) => string | null;
        to_bytes: (address: InetAddress) => number;
    }

    abstract class InetAddressClass {
        // Own properties of Gio-2.0.Gio.InetAddressClass

        static name: string;
    }

    interface InetAddressMaskClass {
        // Own fields of Gio-2.0.Gio.InetAddressMaskClass

        parent_class: GObject.ObjectClass;
    }

    abstract class InetAddressMaskClass {
        // Own properties of Gio-2.0.Gio.InetAddressMaskClass

        static name: string;
    }

    interface InetAddressMaskPrivate {}

    class InetAddressMaskPrivate {
        // Own properties of Gio-2.0.Gio.InetAddressMaskPrivate

        static name: string;
    }

    interface InetAddressPrivate {}

    class InetAddressPrivate {
        // Own properties of Gio-2.0.Gio.InetAddressPrivate

        static name: string;
    }

    interface InetSocketAddressClass {
        // Own fields of Gio-2.0.Gio.InetSocketAddressClass

        parent_class: SocketAddressClass;
    }

    abstract class InetSocketAddressClass {
        // Own properties of Gio-2.0.Gio.InetSocketAddressClass

        static name: string;
    }

    interface InetSocketAddressPrivate {}

    class InetSocketAddressPrivate {
        // Own properties of Gio-2.0.Gio.InetSocketAddressPrivate

        static name: string;
    }

    interface InitableIface {
        // Own fields of Gio-2.0.Gio.InitableIface

        /**
         * The parent interface.
         * @field
         */
        g_iface: GObject.TypeInterface;
        init: (initable: Initable, cancellable: Cancellable | null) => boolean;
    }

    /**
     * Provides an interface for initializing object such that initialization
     * may fail.
     * @record
     */
    abstract class InitableIface {
        // Own properties of Gio-2.0.Gio.InitableIface

        static name: string;
    }

    interface InputMessage {
        // Own fields of Gio-2.0.Gio.InputMessage

        /**
         * return location
         *   for a #GSocketAddress, or %NULL
         * @field
         */
        address: SocketAddress;
        /**
         * pointer to an
         *   array of input vectors
         * @field
         */
        vectors: InputVector[];
        /**
         * the number of input vectors pointed to by `vectors`
         * @field
         */
        num_vectors: number;
        /**
         * will be set to the number of bytes that have been
         *   received
         * @field
         */
        bytes_received: number;
        /**
         * collection of #GSocketMsgFlags for the received message,
         *   outputted by the call
         * @field
         */
        flags: number;
        /**
         * return location for a
         *   caller-allocated array of #GSocketControlMessages, or %NULL
         * @field
         */
        control_messages: SocketControlMessage[];
        /**
         * return location for the number of
         *   elements in `control_messages`
         * @field
         */
        num_control_messages: number;
    }

    /**
     * Structure used for scatter/gather data input when receiving multiple
     * messages or packets in one go. You generally pass in an array of empty
     * #GInputVectors and the operation will use all the buffers as if they
     * were one buffer, and will set `bytes_received` to the total number of bytes
     * received across all #GInputVectors.
     *
     * This structure closely mirrors `struct mmsghdr` and `struct msghdr` from
     * the POSIX sockets API (see `man 2 recvmmsg`).
     *
     * If `address` is non-%NULL then it is set to the source address the message
     * was received from, and the caller must free it afterwards.
     *
     * If `control_messages` is non-%NULL then it is set to an array of control
     * messages received with the message (if any), and the caller must free it
     * afterwards. `num_control_messages` is set to the number of elements in
     * this array, which may be zero.
     *
     * Flags relevant to this message will be returned in `flags`. For example,
     * `MSG_EOR` or `MSG_TRUNC`.
     * @record
     */
    class InputMessage {
        // Own properties of Gio-2.0.Gio.InputMessage

        static name: string;
    }

    interface InputStreamClass {
        // Own fields of Gio-2.0.Gio.InputStreamClass

        parent_class: GObject.ObjectClass;
        read_fn: (
            stream: InputStream,
            buffer: any | null,
            count: number,
            cancellable: Cancellable | null
        ) => number;
        skip: (
            stream: InputStream,
            count: number,
            cancellable: Cancellable | null
        ) => number;
        close_fn: (
            stream: InputStream,
            cancellable: Cancellable | null
        ) => boolean;
        read_async: (
            stream: InputStream,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => /* buffer */ Uint8Array | null;
        read_finish: (stream: InputStream, result: AsyncResult) => number;
        skip_async: (
            stream: InputStream,
            count: number,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        skip_finish: (stream: InputStream, result: AsyncResult) => number;
        close_async: (
            stream: InputStream,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        close_finish: (stream: InputStream, result: AsyncResult) => boolean;
    }

    abstract class InputStreamClass {
        // Own properties of Gio-2.0.Gio.InputStreamClass

        static name: string;
    }

    interface InputStreamPrivate {}

    class InputStreamPrivate {
        // Own properties of Gio-2.0.Gio.InputStreamPrivate

        static name: string;
    }

    interface InputVector {
        // Own fields of Gio-2.0.Gio.InputVector

        /**
         * Pointer to a buffer where data will be written.
         * @field
         */
        buffer: any;
        /**
         * the available size in `buffer`.
         * @field
         */
        size: number;
    }

    /**
     * Structure used for scatter/gather data input.
     * You generally pass in an array of #GInputVectors
     * and the operation will store the read data starting in the
     * first buffer, switching to the next as needed.
     * @record
     */
    class InputVector {
        // Own properties of Gio-2.0.Gio.InputVector

        static name: string;
    }

    interface ListModelInterface {
        // Own fields of Gio-2.0.Gio.ListModelInterface

        /**
         * parent #GTypeInterface
         * @field
         */
        g_iface: GObject.TypeInterface;
        get_item_type: (list: ListModel) => GObject.GType;
        get_n_items: (list: ListModel) => number;
        get_item: (list: ListModel, position: number) => GObject.Object | null;
    }

    /**
     * The virtual function table for #GListModel.
     * @record
     */
    abstract class ListModelInterface {
        // Own properties of Gio-2.0.Gio.ListModelInterface

        static name: string;
    }

    interface ListStoreClass {
        // Own fields of Gio-2.0.Gio.ListStoreClass

        parent_class: GObject.ObjectClass;
    }

    abstract class ListStoreClass {
        // Own properties of Gio-2.0.Gio.ListStoreClass

        static name: string;
    }

    interface LoadableIconIface {
        // Own fields of Gio-2.0.Gio.LoadableIconIface

        /**
         * The parent interface.
         * @field
         */
        g_iface: GObject.TypeInterface;
        load: (
            icon: LoadableIcon,
            size: number,
            cancellable: Cancellable | null
        ) => [/* returnType */ InputStream, /* type */ string | null];
        load_async: (
            icon: LoadableIcon,
            size: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        load_finish: (
            icon: LoadableIcon,
            res: AsyncResult
        ) => [/* returnType */ InputStream, /* type */ string | null];
    }

    /**
     * Interface for icons that can be loaded as a stream.
     * @record
     */
    abstract class LoadableIconIface {
        // Own properties of Gio-2.0.Gio.LoadableIconIface

        static name: string;
    }

    interface MemoryInputStreamClass {
        // Own fields of Gio-2.0.Gio.MemoryInputStreamClass

        parent_class: InputStreamClass;
    }

    abstract class MemoryInputStreamClass {
        // Own properties of Gio-2.0.Gio.MemoryInputStreamClass

        static name: string;
    }

    interface MemoryInputStreamPrivate {}

    class MemoryInputStreamPrivate {
        // Own properties of Gio-2.0.Gio.MemoryInputStreamPrivate

        static name: string;
    }

    interface MemoryMonitorInterface {
        // Own fields of Gio-2.0.Gio.MemoryMonitorInterface

        low_memory_warning: (
            monitor: MemoryMonitor,
            level: MemoryMonitorWarningLevel
        ) => void;
    }

    /**
     * The virtual function table for #GMemoryMonitor.
     * @record
     */
    abstract class MemoryMonitorInterface {
        // Own properties of Gio-2.0.Gio.MemoryMonitorInterface

        static name: string;
    }

    interface MemoryOutputStreamClass {
        // Own fields of Gio-2.0.Gio.MemoryOutputStreamClass

        parent_class: OutputStreamClass;
    }

    abstract class MemoryOutputStreamClass {
        // Own properties of Gio-2.0.Gio.MemoryOutputStreamClass

        static name: string;
    }

    interface MemoryOutputStreamPrivate {}

    class MemoryOutputStreamPrivate {
        // Own properties of Gio-2.0.Gio.MemoryOutputStreamPrivate

        static name: string;
    }

    interface MenuAttributeIterClass {
        // Own fields of Gio-2.0.Gio.MenuAttributeIterClass

        parent_class: GObject.ObjectClass;
        get_next: (
            iter: MenuAttributeIter
        ) => [
            /* returnType */ boolean,
            /* out_name */ string | null,
            /* value */ GLib.Variant
        ];
    }

    abstract class MenuAttributeIterClass {
        // Own properties of Gio-2.0.Gio.MenuAttributeIterClass

        static name: string;
    }

    interface MenuAttributeIterPrivate {}

    class MenuAttributeIterPrivate {
        // Own properties of Gio-2.0.Gio.MenuAttributeIterPrivate

        static name: string;
    }

    interface MenuLinkIterClass {
        // Own fields of Gio-2.0.Gio.MenuLinkIterClass

        parent_class: GObject.ObjectClass;
        get_next: (
            iter: MenuLinkIter
        ) => [
            /* returnType */ boolean,
            /* out_link */ string | null,
            /* value */ MenuModel
        ];
    }

    abstract class MenuLinkIterClass {
        // Own properties of Gio-2.0.Gio.MenuLinkIterClass

        static name: string;
    }

    interface MenuLinkIterPrivate {}

    class MenuLinkIterPrivate {
        // Own properties of Gio-2.0.Gio.MenuLinkIterPrivate

        static name: string;
    }

    interface MenuModelClass {
        // Own fields of Gio-2.0.Gio.MenuModelClass

        parent_class: GObject.ObjectClass;
        is_mutable: (model: MenuModel) => boolean;
        get_n_items: (model: MenuModel) => number;
        get_item_attributes: (
            model: MenuModel,
            item_index: number
        ) => /* attributes */ GLib.HashTable;
        iterate_item_attributes: (
            model: MenuModel,
            item_index: number
        ) => MenuAttributeIter;
        get_item_attribute_value: (
            model: MenuModel,
            item_index: number,
            attribute: string | null,
            expected_type: GLib.VariantType | null
        ) => GLib.Variant | null;
        get_item_links: (
            model: MenuModel,
            item_index: number
        ) => /* links */ GLib.HashTable;
        iterate_item_links: (
            model: MenuModel,
            item_index: number
        ) => MenuLinkIter;
        get_item_link: (
            model: MenuModel,
            item_index: number,
            link: string | null
        ) => MenuModel | null;
    }

    abstract class MenuModelClass {
        // Own properties of Gio-2.0.Gio.MenuModelClass

        static name: string;
    }

    interface MenuModelPrivate {}

    class MenuModelPrivate {
        // Own properties of Gio-2.0.Gio.MenuModelPrivate

        static name: string;
    }

    interface MountIface {
        // Own fields of Gio-2.0.Gio.MountIface

        /**
         * The parent interface.
         * @field
         */
        g_iface: GObject.TypeInterface;
        changed: (mount: Mount) => void;
        unmounted: (mount: Mount) => void;
        get_root: (mount: Mount) => File;
        get_name: (mount: Mount) => string | null;
        get_icon: (mount: Mount) => Icon;
        get_uuid: (mount: Mount) => string | null;
        get_volume: (mount: Mount) => Volume | null;
        get_drive: (mount: Mount) => Drive | null;
        can_unmount: (mount: Mount) => boolean;
        can_eject: (mount: Mount) => boolean;
        unmount: (
            mount: Mount,
            flags: MountUnmountFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        unmount_finish: (mount: Mount, result: AsyncResult) => boolean;
        eject: (
            mount: Mount,
            flags: MountUnmountFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        eject_finish: (mount: Mount, result: AsyncResult) => boolean;
        remount: (
            mount: Mount,
            flags: MountMountFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        remount_finish: (mount: Mount, result: AsyncResult) => boolean;
        guess_content_type: (
            mount: Mount,
            force_rescan: boolean,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        guess_content_type_finish: (
            mount: Mount,
            result: AsyncResult
        ) => string[];
        guess_content_type_sync: (
            mount: Mount,
            force_rescan: boolean,
            cancellable: Cancellable | null
        ) => string[];
        pre_unmount: (mount: Mount) => void;
        unmount_with_operation: (
            mount: Mount,
            flags: MountUnmountFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        unmount_with_operation_finish: (
            mount: Mount,
            result: AsyncResult
        ) => boolean;
        eject_with_operation: (
            mount: Mount,
            flags: MountUnmountFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        eject_with_operation_finish: (
            mount: Mount,
            result: AsyncResult
        ) => boolean;
        get_default_location: (mount: Mount) => File;
        get_sort_key: (mount: Mount) => string | null;
        get_symbolic_icon: (mount: Mount) => Icon;
    }

    /**
     * Interface for implementing operations for mounts.
     * @record
     */
    abstract class MountIface {
        // Own properties of Gio-2.0.Gio.MountIface

        static name: string;
    }

    interface MountOperationClass {
        // Own fields of Gio-2.0.Gio.MountOperationClass

        parent_class: GObject.ObjectClass;
        ask_password: (
            op: MountOperation,
            message: string | null,
            default_user: string | null,
            default_domain: string | null,
            flags: AskPasswordFlags
        ) => void;
        ask_question: (
            op: MountOperation,
            message: string | null,
            choices: string[]
        ) => void;
        reply: (op: MountOperation, result: MountOperationResult) => void;
        aborted: (op: MountOperation) => void;
        show_processes: (
            op: MountOperation,
            message: string | null,
            processes: GLib.Pid[],
            choices: string[]
        ) => void;
        show_unmount_progress: (
            op: MountOperation,
            message: string | null,
            time_left: number,
            bytes_left: number
        ) => void;
    }

    abstract class MountOperationClass {
        // Own properties of Gio-2.0.Gio.MountOperationClass

        static name: string;
    }

    interface MountOperationPrivate {}

    class MountOperationPrivate {
        // Own properties of Gio-2.0.Gio.MountOperationPrivate

        static name: string;
    }

    interface NativeSocketAddressClass {
        // Own fields of Gio-2.0.Gio.NativeSocketAddressClass

        parent_class: SocketAddressClass;
    }

    abstract class NativeSocketAddressClass {
        // Own properties of Gio-2.0.Gio.NativeSocketAddressClass

        static name: string;
    }

    interface NativeSocketAddressPrivate {}

    class NativeSocketAddressPrivate {
        // Own properties of Gio-2.0.Gio.NativeSocketAddressPrivate

        static name: string;
    }

    interface NativeVolumeMonitorClass {
        // Own fields of Gio-2.0.Gio.NativeVolumeMonitorClass

        parent_class: VolumeMonitorClass;
    }

    abstract class NativeVolumeMonitorClass {
        // Own properties of Gio-2.0.Gio.NativeVolumeMonitorClass

        static name: string;
    }

    interface NetworkAddressClass {
        // Own fields of Gio-2.0.Gio.NetworkAddressClass

        parent_class: GObject.ObjectClass;
    }

    abstract class NetworkAddressClass {
        // Own properties of Gio-2.0.Gio.NetworkAddressClass

        static name: string;
    }

    interface NetworkAddressPrivate {}

    class NetworkAddressPrivate {
        // Own properties of Gio-2.0.Gio.NetworkAddressPrivate

        static name: string;
    }

    interface NetworkMonitorInterface {
        // Own fields of Gio-2.0.Gio.NetworkMonitorInterface

        /**
         * The parent interface.
         * @field
         */
        g_iface: GObject.TypeInterface;
        network_changed: (
            monitor: NetworkMonitor,
            network_available: boolean
        ) => void;
        can_reach: (
            monitor: NetworkMonitor,
            connectable: SocketConnectable,
            cancellable: Cancellable | null
        ) => boolean;
        can_reach_async: (
            monitor: NetworkMonitor,
            connectable: SocketConnectable,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        can_reach_finish: (
            monitor: NetworkMonitor,
            result: AsyncResult
        ) => boolean;
    }

    /**
     * The virtual function table for #GNetworkMonitor.
     * @record
     */
    abstract class NetworkMonitorInterface {
        // Own properties of Gio-2.0.Gio.NetworkMonitorInterface

        static name: string;
    }

    interface NetworkServiceClass {
        // Own fields of Gio-2.0.Gio.NetworkServiceClass

        parent_class: GObject.ObjectClass;
    }

    abstract class NetworkServiceClass {
        // Own properties of Gio-2.0.Gio.NetworkServiceClass

        static name: string;
    }

    interface NetworkServicePrivate {}

    class NetworkServicePrivate {
        // Own properties of Gio-2.0.Gio.NetworkServicePrivate

        static name: string;
    }

    interface OutputMessage {
        // Own fields of Gio-2.0.Gio.OutputMessage

        /**
         * a #GSocketAddress, or %NULL
         * @field
         */
        address: SocketAddress;
        /**
         * pointer to an array of output vectors
         * @field
         */
        vectors: OutputVector;
        /**
         * the number of output vectors pointed to by `vectors`.
         * @field
         */
        num_vectors: number;
        /**
         * initialize to 0. Will be set to the number of bytes
         *     that have been sent
         * @field
         */
        bytes_sent: number;
        /**
         * a pointer
         *   to an array of #GSocketControlMessages, or %NULL.
         * @field
         */
        control_messages: SocketControlMessage[];
        /**
         * number of elements in `control_messages`.
         * @field
         */
        num_control_messages: number;
    }

    /**
     * Structure used for scatter/gather data output when sending multiple
     * messages or packets in one go. You generally pass in an array of
     * #GOutputVectors and the operation will use all the buffers as if they
     * were one buffer.
     *
     * If `address` is %NULL then the message is sent to the default receiver
     * (as previously set by g_socket_connect()).
     * @record
     */
    class OutputMessage {
        // Own properties of Gio-2.0.Gio.OutputMessage

        static name: string;
    }

    interface OutputStreamClass {
        // Own fields of Gio-2.0.Gio.OutputStreamClass

        parent_class: GObject.ObjectClass;
        write_fn: (
            stream: OutputStream,
            buffer: Uint8Array | null,
            cancellable: Cancellable | null
        ) => number;
        splice: (
            stream: OutputStream,
            source: InputStream,
            flags: OutputStreamSpliceFlags,
            cancellable: Cancellable | null
        ) => number;
        flush: (
            stream: OutputStream,
            cancellable: Cancellable | null
        ) => boolean;
        close_fn: (
            stream: OutputStream,
            cancellable: Cancellable | null
        ) => boolean;
        write_async: (
            stream: OutputStream,
            buffer: Uint8Array | null,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        write_finish: (stream: OutputStream, result: AsyncResult) => number;
        splice_async: (
            stream: OutputStream,
            source: InputStream,
            flags: OutputStreamSpliceFlags,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        splice_finish: (stream: OutputStream, result: AsyncResult) => number;
        flush_async: (
            stream: OutputStream,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        flush_finish: (stream: OutputStream, result: AsyncResult) => boolean;
        close_async: (
            stream: OutputStream,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        close_finish: (stream: OutputStream, result: AsyncResult) => boolean;
        writev_fn: (
            stream: OutputStream,
            vectors: OutputVector[],
            cancellable: Cancellable | null
        ) => [/* returnType */ boolean, /* bytes_written */ number];
        writev_async: (
            stream: OutputStream,
            vectors: OutputVector[],
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        writev_finish: (
            stream: OutputStream,
            result: AsyncResult
        ) => [/* returnType */ boolean, /* bytes_written */ number];
    }

    abstract class OutputStreamClass {
        // Own properties of Gio-2.0.Gio.OutputStreamClass

        static name: string;
    }

    interface OutputStreamPrivate {}

    class OutputStreamPrivate {
        // Own properties of Gio-2.0.Gio.OutputStreamPrivate

        static name: string;
    }

    interface OutputVector {
        // Own fields of Gio-2.0.Gio.OutputVector

        /**
         * Pointer to a buffer of data to read.
         * @field
         */
        buffer: any;
        /**
         * the size of `buffer`.
         * @field
         */
        size: number;
    }

    /**
     * Structure used for scatter/gather data output.
     * You generally pass in an array of #GOutputVectors
     * and the operation will use all the buffers as if they were
     * one buffer.
     * @record
     */
    class OutputVector {
        // Own properties of Gio-2.0.Gio.OutputVector

        static name: string;
    }

    interface PermissionClass {
        // Own fields of Gio-2.0.Gio.PermissionClass

        parent_class: GObject.ObjectClass;
        acquire: (
            permission: Permission,
            cancellable: Cancellable | null
        ) => boolean;
        acquire_async: (
            permission: Permission,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        acquire_finish: (
            permission: Permission,
            result: AsyncResult
        ) => boolean;
        release: (
            permission: Permission,
            cancellable: Cancellable | null
        ) => boolean;
        release_async: (
            permission: Permission,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        release_finish: (
            permission: Permission,
            result: AsyncResult
        ) => boolean;
        reserved: any[];
    }

    abstract class PermissionClass {
        // Own properties of Gio-2.0.Gio.PermissionClass

        static name: string;
    }

    interface PermissionPrivate {}

    class PermissionPrivate {
        // Own properties of Gio-2.0.Gio.PermissionPrivate

        static name: string;
    }

    interface PollableInputStreamInterface {
        // Own fields of Gio-2.0.Gio.PollableInputStreamInterface

        /**
         * The parent interface.
         * @field
         */
        g_iface: GObject.TypeInterface;
        can_poll: (stream: PollableInputStream) => boolean;
        is_readable: (stream: PollableInputStream) => boolean;
        create_source: (
            stream: PollableInputStream,
            cancellable: Cancellable | null
        ) => GLib.Source;
        read_nonblocking: (
            stream: PollableInputStream
        ) => [/* returnType */ number, /* buffer */ Uint8Array | null];
    }

    /**
     * The interface for pollable input streams.
     *
     * The default implementation of `can_poll` always returns %TRUE.
     *
     * The default implementation of `read_nonblocking` calls
     * g_pollable_input_stream_is_readable(), and then calls
     * g_input_stream_read() if it returns %TRUE. This means you only need
     * to override it if it is possible that your `is_readable`
     * implementation may return %TRUE when the stream is not actually
     * readable.
     * @record
     */
    abstract class PollableInputStreamInterface {
        // Own properties of Gio-2.0.Gio.PollableInputStreamInterface

        static name: string;
    }

    interface PollableOutputStreamInterface {
        // Own fields of Gio-2.0.Gio.PollableOutputStreamInterface

        /**
         * The parent interface.
         * @field
         */
        g_iface: GObject.TypeInterface;
        can_poll: (stream: PollableOutputStream) => boolean;
        is_writable: (stream: PollableOutputStream) => boolean;
        create_source: (
            stream: PollableOutputStream,
            cancellable: Cancellable | null
        ) => GLib.Source;
        write_nonblocking: (
            stream: PollableOutputStream,
            buffer: Uint8Array | null
        ) => number;
        writev_nonblocking: (
            stream: PollableOutputStream,
            vectors: OutputVector[]
        ) => [/* returnType */ PollableReturn, /* bytes_written */ number];
    }

    /**
     * The interface for pollable output streams.
     *
     * The default implementation of `can_poll` always returns %TRUE.
     *
     * The default implementation of `write_nonblocking` calls
     * g_pollable_output_stream_is_writable(), and then calls
     * g_output_stream_write() if it returns %TRUE. This means you only
     * need to override it if it is possible that your `is_writable`
     * implementation may return %TRUE when the stream is not actually
     * writable.
     *
     * The default implementation of `writev_nonblocking` calls
     * g_pollable_output_stream_write_nonblocking() for each vector, and converts
     * its return value and error (if set) to a #GPollableReturn. You should
     * override this where possible to avoid having to allocate a #GError to return
     * %G_IO_ERROR_WOULD_BLOCK.
     * @record
     */
    abstract class PollableOutputStreamInterface {
        // Own properties of Gio-2.0.Gio.PollableOutputStreamInterface

        static name: string;
    }

    interface PowerProfileMonitorInterface {}

    /**
     * The virtual function table for #GPowerProfileMonitor.
     * @record
     */
    abstract class PowerProfileMonitorInterface {
        // Own properties of Gio-2.0.Gio.PowerProfileMonitorInterface

        static name: string;
    }

    interface ProxyAddressClass {
        // Own fields of Gio-2.0.Gio.ProxyAddressClass

        parent_class: InetSocketAddressClass;
    }

    /**
     * Class structure for #GProxyAddress.
     * @record
     */
    abstract class ProxyAddressClass {
        // Own properties of Gio-2.0.Gio.ProxyAddressClass

        static name: string;
    }

    interface ProxyAddressEnumeratorClass {}

    /**
     * Class structure for #GProxyAddressEnumerator.
     * @record
     */
    abstract class ProxyAddressEnumeratorClass {
        // Own properties of Gio-2.0.Gio.ProxyAddressEnumeratorClass

        static name: string;
    }

    interface ProxyAddressEnumeratorPrivate {}

    class ProxyAddressEnumeratorPrivate {
        // Own properties of Gio-2.0.Gio.ProxyAddressEnumeratorPrivate

        static name: string;
    }

    interface ProxyAddressPrivate {}

    class ProxyAddressPrivate {
        // Own properties of Gio-2.0.Gio.ProxyAddressPrivate

        static name: string;
    }

    interface ProxyInterface {
        // Own fields of Gio-2.0.Gio.ProxyInterface

        /**
         * The parent interface.
         * @field
         */
        g_iface: GObject.TypeInterface;
        // Has conflict: connect: (proxy: Proxy, connection: IOStream, proxy_address: ProxyAddress, cancellable: Cancellable | null) => IOStream
        connect_async: (
            proxy: Proxy,
            connection: IOStream,
            proxy_address: ProxyAddress,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        connect_finish: (proxy: Proxy, result: AsyncResult) => IOStream;
        supports_hostname: (proxy: Proxy) => boolean;
    }

    /**
     * Provides an interface for handling proxy connection and payload.
     * @record
     */
    abstract class ProxyInterface {
        // Own properties of Gio-2.0.Gio.ProxyInterface

        static name: string;
    }

    interface ProxyResolverInterface {
        // Own fields of Gio-2.0.Gio.ProxyResolverInterface

        /**
         * The parent interface.
         * @field
         */
        g_iface: GObject.TypeInterface;
        is_supported: (resolver: ProxyResolver) => boolean;
        lookup: (
            resolver: ProxyResolver,
            uri: string | null,
            cancellable: Cancellable | null
        ) => string[];
        lookup_async: (
            resolver: ProxyResolver,
            uri: string | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        lookup_finish: (
            resolver: ProxyResolver,
            result: AsyncResult
        ) => string[];
    }

    /**
     * The virtual function table for #GProxyResolver.
     * @record
     */
    abstract class ProxyResolverInterface {
        // Own properties of Gio-2.0.Gio.ProxyResolverInterface

        static name: string;
    }

    interface RemoteActionGroupInterface {
        // Own fields of Gio-2.0.Gio.RemoteActionGroupInterface

        g_iface: GObject.TypeInterface;
        activate_action_full: (
            remote: RemoteActionGroup,
            action_name: string | null,
            parameter: GLib.Variant | null,
            platform_data: GLib.Variant
        ) => void;
        change_action_state_full: (
            remote: RemoteActionGroup,
            action_name: string | null,
            value: GLib.Variant,
            platform_data: GLib.Variant
        ) => void;
    }

    /**
     * The virtual function table for #GRemoteActionGroup.
     * @record
     */
    abstract class RemoteActionGroupInterface {
        // Own properties of Gio-2.0.Gio.RemoteActionGroupInterface

        static name: string;
    }

    interface ResolverClass {
        // Own fields of Gio-2.0.Gio.ResolverClass

        parent_class: GObject.ObjectClass;
        reload: (resolver: Resolver) => void;
        lookup_by_name: (
            resolver: Resolver,
            hostname: string | null,
            cancellable: Cancellable | null
        ) => InetAddress[];
        lookup_by_name_async: (
            resolver: Resolver,
            hostname: string | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        lookup_by_name_finish: (
            resolver: Resolver,
            result: AsyncResult
        ) => InetAddress[];
        lookup_by_address: (
            resolver: Resolver,
            address: InetAddress,
            cancellable: Cancellable | null
        ) => string | null;
        lookup_by_address_async: (
            resolver: Resolver,
            address: InetAddress,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        lookup_by_address_finish: (
            resolver: Resolver,
            result: AsyncResult
        ) => string | null;
        lookup_service_async: (
            resolver: Resolver,
            rrname: string | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        lookup_service_finish: (
            resolver: Resolver,
            result: AsyncResult
        ) => SrvTarget[];
        lookup_records: (
            resolver: Resolver,
            rrname: string | null,
            record_type: ResolverRecordType,
            cancellable: Cancellable | null
        ) => GLib.Variant[];
        lookup_records_async: (
            resolver: Resolver,
            rrname: string | null,
            record_type: ResolverRecordType,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        lookup_records_finish: (
            resolver: Resolver,
            result: AsyncResult
        ) => GLib.Variant[];
        lookup_by_name_with_flags_async: (
            resolver: Resolver,
            hostname: string | null,
            flags: ResolverNameLookupFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        lookup_by_name_with_flags_finish: (
            resolver: Resolver,
            result: AsyncResult
        ) => InetAddress[];
        lookup_by_name_with_flags: (
            resolver: Resolver,
            hostname: string | null,
            flags: ResolverNameLookupFlags,
            cancellable: Cancellable | null
        ) => InetAddress[];
    }

    abstract class ResolverClass {
        // Own properties of Gio-2.0.Gio.ResolverClass

        static name: string;
    }

    interface ResolverPrivate {}

    class ResolverPrivate {
        // Own properties of Gio-2.0.Gio.ResolverPrivate

        static name: string;
    }

    interface Resource {
        // Owm methods of Gio-2.0.Gio.Resource

        /**
         * Registers the resource with the process-global set of resources.
         * Once a resource is registered the files in it can be accessed
         * with the global resource lookup functions like g_resources_lookup_data().
         */
        _register(): void;
        /**
         * Unregisters the resource from the process-global set of resources.
         */
        _unregister(): void;
        /**
         * Returns all the names of children at the specified `path` in the resource.
         * The return result is a %NULL terminated list of strings which should
         * be released with g_strfreev().
         *
         * If `path` is invalid or does not exist in the #GResource,
         * %G_RESOURCE_ERROR_NOT_FOUND will be returned.
         *
         * `lookup_flags` controls the behaviour of the lookup.
         * @param path A pathname inside the resource
         * @param lookup_flags A #GResourceLookupFlags
         * @returns an array of constant strings
         */
        enumerate_children(
            path: string | null,
            lookup_flags: ResourceLookupFlags
        ): string[];
        /**
         * Looks for a file at the specified `path` in the resource and
         * if found returns information about it.
         *
         * `lookup_flags` controls the behaviour of the lookup.
         * @param path A pathname inside the resource
         * @param lookup_flags A #GResourceLookupFlags
         * @returns %TRUE if the file was found. %FALSE if there were errors
         */
        get_info(
            path: string | null,
            lookup_flags: ResourceLookupFlags
        ): [/* returnType */ boolean, /* size */ number, /* flags */ number];
        /**
         * Looks for a file at the specified `path` in the resource and
         * returns a #GBytes that lets you directly access the data in
         * memory.
         *
         * The data is always followed by a zero byte, so you
         * can safely use the data as a C string. However, that byte
         * is not included in the size of the GBytes.
         *
         * For uncompressed resource files this is a pointer directly into
         * the resource bundle, which is typically in some readonly data section
         * in the program binary. For compressed files we allocate memory on
         * the heap and automatically uncompress the data.
         *
         * `lookup_flags` controls the behaviour of the lookup.
         * @param path A pathname inside the resource
         * @param lookup_flags A #GResourceLookupFlags
         * @returns #GBytes or %NULL on error.     Free the returned object with g_bytes_unref()
         */
        lookup_data(
            path: string | null,
            lookup_flags: ResourceLookupFlags
        ): GLib.Bytes;
        /**
         * Looks for a file at the specified `path` in the resource and
         * returns a #GInputStream that lets you read the data.
         *
         * `lookup_flags` controls the behaviour of the lookup.
         * @param path A pathname inside the resource
         * @param lookup_flags A #GResourceLookupFlags
         * @returns #GInputStream or %NULL on error.     Free the returned object with g_object_unref()
         */
        open_stream(
            path: string | null,
            lookup_flags: ResourceLookupFlags
        ): InputStream;
        /**
         * Atomically increments the reference count of `resource` by one. This
         * function is MT-safe and may be called from any thread.
         * @returns The passed in #GResource
         */
        ref(): Resource;
        /**
         * Atomically decrements the reference count of `resource` by one. If the
         * reference count drops to 0, all memory allocated by the resource is
         * released. This function is MT-safe and may be called from any
         * thread.
         */
        unref(): void;
    }

    /**
     * Applications and libraries often contain binary or textual data that is
     * really part of the application, rather than user data. For instance
     * #GtkBuilder .ui files, splashscreen images, GMenu markup XML, CSS files,
     * icons, etc. These are often shipped as files in `$datadir/appname`, or
     * manually included as literal strings in the code.
     *
     * The #GResource API and the [glib-compile-resources][glib-compile-resources] program
     * provide a convenient and efficient alternative to this which has some nice properties. You
     * maintain the files as normal files, so its easy to edit them, but during the build the files
     * are combined into a binary bundle that is linked into the executable. This means that loading
     * the resource files are efficient (as they are already in memory, shared with other instances) and
     * simple (no need to check for things like I/O errors or locate the files in the filesystem). It
     * also makes it easier to create relocatable applications.
     *
     * Resource files can also be marked as compressed. Such files will be included in the resource bundle
     * in a compressed form, but will be automatically uncompressed when the resource is used. This
     * is very useful e.g. for larger text files that are parsed once (or rarely) and then thrown away.
     *
     * Resource files can also be marked to be preprocessed, by setting the value of the
     * `preprocess` attribute to a comma-separated list of preprocessing options.
     * The only options currently supported are:
     *
     * `xml-stripblanks` which will use the xmllint command
     * to strip ignorable whitespace from the XML file. For this to work,
     * the `XMLLINT` environment variable must be set to the full path to
     * the xmllint executable, or xmllint must be in the `PATH`; otherwise
     * the preprocessing step is skipped.
     *
     * `to-pixdata` (deprecated since gdk-pixbuf 2.32) which will use the
     * `gdk-pixbuf-pixdata` command to convert images to the #GdkPixdata format,
     * which allows you to create pixbufs directly using the data inside the
     * resource file, rather than an (uncompressed) copy of it. For this, the
     * `gdk-pixbuf-pixdata` program must be in the `PATH`, or the
     * `GDK_PIXBUF_PIXDATA` environment variable must be set to the full path to the
     * `gdk-pixbuf-pixdata` executable; otherwise the resource compiler will abort.
     * `to-pixdata` has been deprecated since gdk-pixbuf 2.32, as #GResource
     * supports embedding modern image formats just as well. Instead of using it,
     * embed a PNG or SVG file in your #GResource.
     *
     * `json-stripblanks` which will use the `json-glib-format` command to strip
     * ignorable whitespace from the JSON file. For this to work, the
     * `JSON_GLIB_FORMAT` environment variable must be set to the full path to the
     * `json-glib-format` executable, or it must be in the `PATH`;
     * otherwise the preprocessing step is skipped. In addition, at least version
     * 1.6 of `json-glib-format` is required.
     *
     * Resource files will be exported in the GResource namespace using the
     * combination of the given `prefix` and the filename from the `file` element.
     * The `alias` attribute can be used to alter the filename to expose them at a
     * different location in the resource namespace. Typically, this is used to
     * include files from a different source directory without exposing the source
     * directory in the resource namespace, as in the example below.
     *
     * Resource bundles are created by the [glib-compile-resources][glib-compile-resources] program
     * which takes an XML file that describes the bundle, and a set of files that the XML references. These
     * are combined into a binary resource bundle.
     *
     * An example resource description:
     *
     * ```
     * <?xml version="1.0" encoding="UTF-8"?>
     * <gresources>
     *   <gresource prefix="/org/gtk/Example">
     *     <file>data/splashscreen.png</file>
     *     <file compressed="true">dialog.ui</file>
     *     <file preprocess="xml-stripblanks">menumarkup.xml</file>
     *     <file alias="example.css">data/example.css</file>
     *   </gresource>
     * </gresources>
     * ```
     *
     *
     * This will create a resource bundle with the following files:
     *
     * ```
     * /org/gtk/Example/data/splashscreen.png
     * /org/gtk/Example/dialog.ui
     * /org/gtk/Example/menumarkup.xml
     * /org/gtk/Example/example.css
     * ```
     *
     *
     * Note that all resources in the process share the same namespace, so use Java-style
     * path prefixes (like in the above example) to avoid conflicts.
     *
     * You can then use [glib-compile-resources][glib-compile-resources] to compile the XML to a
     * binary bundle that you can load with g_resource_load(). However, its more common to use the --generate-source and
     * --generate-header arguments to create a source file and header to link directly into your application.
     * This will generate `get_resource()`, `register_resource()` and
     * `unregister_resource()` functions, prefixed by the `--c-name` argument passed
     * to [glib-compile-resources][glib-compile-resources]. `get_resource()` returns
     * the generated #GResource object. The register and unregister functions
     * register the resource so its files can be accessed using
     * g_resources_lookup_data().
     *
     * Once a #GResource has been created and registered all the data in it can be accessed globally in the process by
     * using API calls like g_resources_open_stream() to stream the data or g_resources_lookup_data() to get a direct pointer
     * to the data. You can also use URIs like "resource:///org/gtk/Example/data/splashscreen.png" with #GFile to access
     * the resource data.
     *
     * Some higher-level APIs, such as #GtkApplication, will automatically load
     * resources from certain well-known paths in the resource namespace as a
     * convenience. See the documentation for those APIs for details.
     *
     * There are two forms of the generated source, the default version uses the compiler support for constructor
     * and destructor functions (where available) to automatically create and register the #GResource on startup
     * or library load time. If you pass `--manual-register`, two functions to register/unregister the resource are created
     * instead. This requires an explicit initialization call in your application/library, but it works on all platforms,
     * even on the minor ones where constructors are not supported. (Constructor support is available for at least Win32, Mac OS and Linux.)
     *
     * Note that resource data can point directly into the data segment of e.g. a library, so if you are unloading libraries
     * during runtime you need to be very careful with keeping around pointers to data from a resource, as this goes away
     * when the library is unloaded. However, in practice this is not generally a problem, since most resource accesses
     * are for your own resources, and resource data is often used once, during parsing, and then released.
     *
     * When debugging a program or testing a change to an installed version, it is often useful to be able to
     * replace resources in the program or library, without recompiling, for debugging or quick hacking and testing
     * purposes. Since GLib 2.50, it is possible to use the `G_RESOURCE_OVERLAYS` environment variable to selectively overlay
     * resources with replacements from the filesystem.  It is a %G_SEARCHPATH_SEPARATOR-separated list of substitutions to perform
     * during resource lookups. It is ignored when running in a setuid process.
     *
     * A substitution has the form
     *
     *
     * ```
     *    /org/gtk/libgtk=/home/desrt/gtk-overlay
     * ```
     *
     *
     * The part before the `=` is the resource subpath for which the overlay applies.  The part after is a
     * filesystem path which contains files and subdirectories as you would like to be loaded as resources with the
     * equivalent names.
     *
     * In the example above, if an application tried to load a resource with the resource path
     * `/org/gtk/libgtk/ui/gtkdialog.ui` then GResource would check the filesystem path
     * `/home/desrt/gtk-overlay/ui/gtkdialog.ui`.  If a file was found there, it would be used instead.  This is an
     * overlay, not an outright replacement, which means that if a file is not found at that path, the built-in
     * version will be used instead.  Whiteouts are not currently supported.
     *
     * Substitutions must start with a slash, and must not contain a trailing slash before the '='.  The path after
     * the slash should ideally be absolute, but this is not strictly required.  It is possible to overlay the
     * location of a single resource with an individual file.
     * @record
     */
    class Resource {
        // Own properties of Gio-2.0.Gio.Resource

        static name: string;

        // Constructors of Gio-2.0.Gio.Resource

        /**
         * Creates a GResource from a reference to the binary resource bundle.
         * This will keep a reference to `data` while the resource lives, so
         * the data should not be modified or freed.
         *
         * If you want to use this resource in the global resource namespace you need
         * to register it with g_resources_register().
         *
         * Note: `data` must be backed by memory that is at least pointer aligned.
         * Otherwise this function will internally create a copy of the memory since
         * GLib 2.56, or in older versions fail and exit the process.
         *
         * If `data` is empty or corrupt, %G_RESOURCE_ERROR_INTERNAL will be returned.
         * @constructor
         * @param data A #GBytes
         * @returns a new #GResource, or %NULL on error
         */
        static new_from_data(data: GLib.Bytes): Resource;
        /**
         * Loads a binary resource bundle and creates a #GResource representation of it, allowing
         * you to query it for data.
         *
         * If you want to use this resource in the global resource namespace you need
         * to register it with g_resources_register().
         *
         * If `filename` is empty or the data in it is corrupt,
         * %G_RESOURCE_ERROR_INTERNAL will be returned. If `filename` doesnt exist, or
         * there is an error in reading it, an error from g_mapped_file_new() will be
         * returned.
         * @param filename the path of a filename to load, in the GLib filename encoding
         * @returns a new #GResource, or %NULL on error
         */
        static load(filename: string): Resource;
    }

    interface SeekableIface {
        // Own fields of Gio-2.0.Gio.SeekableIface

        /**
         * The parent interface.
         * @field
         */
        g_iface: GObject.TypeInterface;
        tell: (seekable: Seekable) => number;
        can_seek: (seekable: Seekable) => boolean;
        seek: (
            seekable: Seekable,
            offset: number,
            type: GLib.SeekType,
            cancellable: Cancellable | null
        ) => boolean;
        can_truncate: (seekable: Seekable) => boolean;
        truncate_fn: (
            seekable: Seekable,
            offset: number,
            cancellable: Cancellable | null
        ) => boolean;
    }

    /**
     * Provides an interface for implementing seekable functionality on I/O Streams.
     * @record
     */
    abstract class SeekableIface {
        // Own properties of Gio-2.0.Gio.SeekableIface

        static name: string;
    }

    interface SettingsBackendClass {
        // Own fields of Gio-2.0.Gio.SettingsBackendClass

        parent_class: GObject.ObjectClass;
        read: (
            backend: SettingsBackend,
            key: string | null,
            expected_type: GLib.VariantType,
            default_value: boolean
        ) => GLib.Variant;
        get_writable: (backend: SettingsBackend, key: string | null) => boolean;
        write: (
            backend: SettingsBackend,
            key: string | null,
            value: GLib.Variant,
            origin_tag: any | null
        ) => boolean;
        write_tree: (
            backend: SettingsBackend,
            tree: GLib.Tree,
            origin_tag: any | null
        ) => boolean;
        reset: (
            backend: SettingsBackend,
            key: string | null,
            origin_tag: any | null
        ) => void;
        subscribe: (backend: SettingsBackend, name: string | null) => void;
        unsubscribe: (backend: SettingsBackend, name: string | null) => void;
        sync: (backend: SettingsBackend) => void;
        read_user_value: (
            backend: SettingsBackend,
            key: string | null,
            expected_type: GLib.VariantType
        ) => GLib.Variant;
    }

    /**
     * Class structure for #GSettingsBackend.
     * @record
     */
    abstract class SettingsBackendClass {
        // Own properties of Gio-2.0.Gio.SettingsBackendClass

        static name: string;
    }

    interface SettingsBackendPrivate {}

    class SettingsBackendPrivate {
        // Own properties of Gio-2.0.Gio.SettingsBackendPrivate

        static name: string;
    }

    interface SettingsClass {
        // Own fields of Gio-2.0.Gio.SettingsClass

        parent_class: GObject.ObjectClass;
        writable_changed: (settings: Settings, key: string | null) => void;
        changed: (settings: Settings, key: string | null) => void;
        writable_change_event: (settings: Settings, key: GLib.Quark) => boolean;
        change_event: (
            settings: Settings,
            keys: GLib.Quark,
            n_keys: number
        ) => boolean;
        padding: any[];
    }

    abstract class SettingsClass {
        // Own properties of Gio-2.0.Gio.SettingsClass

        static name: string;
    }

    interface SettingsPrivate {}

    class SettingsPrivate {
        // Own properties of Gio-2.0.Gio.SettingsPrivate

        static name: string;
    }

    interface SettingsSchema {
        // Owm methods of Gio-2.0.Gio.SettingsSchema

        /**
         * Get the ID of `schema`.
         * @returns the ID
         */
        get_id(): string | null;
        /**
         * Gets the key named `name` from `schema`.
         *
         * It is a programmer error to request a key that does not exist.  See
         * g_settings_schema_list_keys().
         * @param name the name of a key
         * @returns the #GSettingsSchemaKey for @name
         */
        get_key(name: string | null): SettingsSchemaKey;
        /**
         * Gets the path associated with `schema,` or %NULL.
         *
         * Schemas may be single-instance or relocatable.  Single-instance
         * schemas correspond to exactly one set of keys in the backend
         * database: those located at the path returned by this function.
         *
         * Relocatable schemas can be referenced by other schemas and can
         * therefore describe multiple sets of keys at different locations.  For
         * relocatable schemas, this function will return %NULL.
         * @returns the path of the schema, or %NULL
         */
        get_path(): string | null;
        /**
         * Checks if `schema` has a key named `name`.
         * @param name the name of a key
         * @returns %TRUE if such a key exists
         */
        has_key(name: string | null): boolean;
        /**
         * Gets the list of children in `schema`.
         *
         * You should free the return value with g_strfreev() when you are done
         * with it.
         * @returns a list of    the children on @settings, in no defined order
         */
        list_children(): string[];
        /**
         * Introspects the list of keys on `schema`.
         *
         * You should probably not be calling this function from "normal" code
         * (since you should already know what keys are in your schema).  This
         * function is intended for introspection reasons.
         * @returns a list   of the keys on @schema, in no defined order
         */
        list_keys(): string[];
        /**
         * Increase the reference count of `schema,` returning a new reference.
         * @returns a new reference to @schema
         */
        ref(): SettingsSchema;
        /**
         * Decrease the reference count of `schema,` possibly freeing it.
         */
        unref(): void;
    }

    /**
     * The #GSettingsSchemaSource and #GSettingsSchema APIs provide a
     * mechanism for advanced control over the loading of schemas and a
     * mechanism for introspecting their content.
     *
     * Plugin loading systems that wish to provide plugins a way to access
     * settings face the problem of how to make the schemas for these
     * settings visible to GSettings.  Typically, a plugin will want to ship
     * the schema along with itself and it won't be installed into the
     * standard system directories for schemas.
     *
     * #GSettingsSchemaSource provides a mechanism for dealing with this by
     * allowing the creation of a new 'schema source' from which schemas can
     * be acquired.  This schema source can then become part of the metadata
     * associated with the plugin and queried whenever the plugin requires
     * access to some settings.
     *
     * Consider the following example:
     *
     *
     * ```c
     * typedef struct
     * {
     *    ...
     *    GSettingsSchemaSource *schema_source;
     *    ...
     * } Plugin;
     *
     * Plugin *
     * initialise_plugin (const gchar *dir)
     * {
     *   Plugin *plugin;
     *
     *   ...
     *
     *   plugin->schema_source =
     *     g_settings_schema_source_new_from_directory (dir,
     *       g_settings_schema_source_get_default (), FALSE, NULL);
     *
     *   ...
     *
     *   return plugin;
     * }
     *
     * ...
     *
     * GSettings *
     * plugin_get_settings (Plugin      *plugin,
     *                      const gchar *schema_id)
     * {
     *   GSettingsSchema *schema;
     *
     *   if (schema_id == NULL)
     *     schema_id = plugin->identifier;
     *
     *   schema = g_settings_schema_source_lookup (plugin->schema_source,
     *                                             schema_id, FALSE);
     *
     *   if (schema == NULL)
     *     {
     *       ... disable the plugin or abort, etc ...
     *     }
     *
     *   return g_settings_new_full (schema, NULL, NULL);
     * }
     * ```
     *
     *
     * The code above shows how hooks should be added to the code that
     * initialises (or enables) the plugin to create the schema source and
     * how an API can be added to the plugin system to provide a convenient
     * way for the plugin to access its settings, using the schemas that it
     * ships.
     *
     * From the standpoint of the plugin, it would need to ensure that it
     * ships a gschemas.compiled file as part of itself, and then simply do
     * the following:
     *
     *
     * ```c
     * {
     *   GSettings *settings;
     *   gint some_value;
     *
     *   settings = plugin_get_settings (self, NULL);
     *   some_value = g_settings_get_int (settings, "some-value");
     *   ...
     * }
     * ```
     *
     *
     * It's also possible that the plugin system expects the schema source
     * files (ie: .gschema.xml files) instead of a gschemas.compiled file.
     * In that case, the plugin loading system must compile the schemas for
     * itself before attempting to create the settings source.
     * @record
     */
    class SettingsSchema {
        // Own properties of Gio-2.0.Gio.SettingsSchema

        static name: string;
    }

    interface SettingsSchemaKey {
        // Owm methods of Gio-2.0.Gio.SettingsSchemaKey

        /**
         * Gets the default value for `key`.
         *
         * Note that this is the default value according to the schema.  System
         * administrator defaults and lockdown are not visible via this API.
         * @returns the default value for the key
         */
        get_default_value(): GLib.Variant;
        /**
         * Gets the description for `key`.
         *
         * If no description has been provided in the schema for `key,` returns
         * %NULL.
         *
         * The description can be one sentence to several paragraphs in length.
         * Paragraphs are delimited with a double newline.  Descriptions can be
         * translated and the value returned from this function is is the
         * current locale.
         *
         * This function is slow.  The summary and description information for
         * the schemas is not stored in the compiled schema database so this
         * function has to parse all of the source XML files in the schema
         * directory.
         * @returns the description for @key, or %NULL
         */
        get_description(): string | null;
        /**
         * Gets the name of `key`.
         * @returns the name of @key.
         */
        get_name(): string | null;
        /**
         * Queries the range of a key.
         *
         * This function will return a #GVariant that fully describes the range
         * of values that are valid for `key`.
         *
         * The type of #GVariant returned is `(sv)`. The string describes
         * the type of range restriction in effect. The type and meaning of
         * the value contained in the variant depends on the string.
         *
         * If the string is `'type'` then the variant contains an empty array.
         * The element type of that empty array is the expected type of value
         * and all values of that type are valid.
         *
         * If the string is `'enum'` then the variant contains an array
         * enumerating the possible values. Each item in the array is
         * a possible valid value and no other values are valid.
         *
         * If the string is `'flags'` then the variant contains an array. Each
         * item in the array is a value that may appear zero or one times in an
         * array to be used as the value for this key. For example, if the
         * variant contained the array `['x', 'y']` then the valid values for
         * the key would be `[]`, `['x']`, `['y']`, `['x', 'y']` and
         * `['y', 'x']`.
         *
         * Finally, if the string is `'range'` then the variant contains a pair
         * of like-typed values -- the minimum and maximum permissible values
         * for this key.
         *
         * This information should not be used by normal programs.  It is
         * considered to be a hint for introspection purposes.  Normal programs
         * should already know what is permitted by their own schema.  The
         * format may change in any way in the future -- but particularly, new
         * forms may be added to the possibilities described above.
         *
         * You should free the returned value with g_variant_unref() when it is
         * no longer needed.
         * @returns a #GVariant describing the range
         */
        get_range(): GLib.Variant;
        /**
         * Gets the summary for `key`.
         *
         * If no summary has been provided in the schema for `key,` returns
         * %NULL.
         *
         * The summary is a short description of the purpose of the key; usually
         * one short sentence.  Summaries can be translated and the value
         * returned from this function is is the current locale.
         *
         * This function is slow.  The summary and description information for
         * the schemas is not stored in the compiled schema database so this
         * function has to parse all of the source XML files in the schema
         * directory.
         * @returns the summary for @key, or %NULL
         */
        get_summary(): string | null;
        /**
         * Gets the #GVariantType of `key`.
         * @returns the type of @key
         */
        get_value_type(): GLib.VariantType;
        /**
         * Checks if the given `value` is within the
         * permitted range for `key`.
         *
         * It is a programmer error if `value` is not of the correct type  you
         * must check for this first.
         * @param value the value to check
         * @returns %TRUE if @value is valid for @key
         */
        range_check(value: GLib.Variant): boolean;
        /**
         * Increase the reference count of `key,` returning a new reference.
         * @returns a new reference to @key
         */
        ref(): SettingsSchemaKey;
        /**
         * Decrease the reference count of `key,` possibly freeing it.
         */
        unref(): void;
    }

    /**
     * #GSettingsSchemaKey is an opaque data structure and can only be accessed
     * using the following functions.
     * @record
     */
    class SettingsSchemaKey {
        // Own properties of Gio-2.0.Gio.SettingsSchemaKey

        static name: string;
    }

    interface SettingsSchemaSource {
        // Owm methods of Gio-2.0.Gio.SettingsSchemaSource

        /**
         * Lists the schemas in a given source.
         *
         * If `recursive` is %TRUE then include parent sources.  If %FALSE then
         * only include the schemas from one source (ie: one directory).  You
         * probably want %TRUE.
         *
         * Non-relocatable schemas are those for which you can call
         * g_settings_new().  Relocatable schemas are those for which you must
         * use g_settings_new_with_path().
         *
         * Do not call this function from normal programs.  This is designed for
         * use by database editors, commandline tools, etc.
         * @param recursive if we should recurse
         */
        list_schemas(
            recursive: boolean
        ): [/* non_relocatable */ string[], /* relocatable */ string[]];
        /**
         * Looks up a schema with the identifier `schema_id` in `source`.
         *
         * This function is not required for normal uses of #GSettings but it
         * may be useful to authors of plugin management systems or to those who
         * want to introspect the content of schemas.
         *
         * If the schema isn't found directly in `source` and `recursive` is %TRUE
         * then the parent sources will also be checked.
         *
         * If the schema isn't found, %NULL is returned.
         * @param schema_id a schema ID
         * @param recursive %TRUE if the lookup should be recursive
         * @returns a new #GSettingsSchema
         */
        lookup(
            schema_id: string | null,
            recursive: boolean
        ): SettingsSchema | null;
        /**
         * Increase the reference count of `source,` returning a new reference.
         * @returns a new reference to @source
         */
        ref(): SettingsSchemaSource;
        /**
         * Decrease the reference count of `source,` possibly freeing it.
         */
        unref(): void;
    }

    /**
     * This is an opaque structure type.  You may not access it directly.
     * @record
     */
    class SettingsSchemaSource {
        // Own properties of Gio-2.0.Gio.SettingsSchemaSource

        static name: string;

        // Constructors of Gio-2.0.Gio.SettingsSchemaSource

        /**
         * Attempts to create a new schema source corresponding to the contents
         * of the given directory.
         *
         * This function is not required for normal uses of #GSettings but it
         * may be useful to authors of plugin management systems.
         *
         * The directory should contain a file called `gschemas.compiled` as
         * produced by the [glib-compile-schemas][glib-compile-schemas] tool.
         *
         * If `trusted` is %TRUE then `gschemas.compiled` is trusted not to be
         * corrupted. This assumption has a performance advantage, but can result
         * in crashes or inconsistent behaviour in the case of a corrupted file.
         * Generally, you should set `trusted` to %TRUE for files installed by the
         * system and to %FALSE for files in the home directory.
         *
         * In either case, an empty file or some types of corruption in the file will
         * result in %G_FILE_ERROR_INVAL being returned.
         *
         * If `parent` is non-%NULL then there are two effects.
         *
         * First, if g_settings_schema_source_lookup() is called with the
         * `recursive` flag set to %TRUE and the schema can not be found in the
         * source, the lookup will recurse to the parent.
         *
         * Second, any references to other schemas specified within this
         * source (ie: `child` or `extends`) references may be resolved
         * from the `parent`.
         *
         * For this second reason, except in very unusual situations, the
         * `parent` should probably be given as the default schema source, as
         * returned by g_settings_schema_source_get_default().
         * @constructor
         * @param directory the filename of a directory
         * @param parent a #GSettingsSchemaSource, or %NULL
         * @param trusted %TRUE, if the directory is trusted
         */
        static new_from_directory(
            directory: string,
            parent: SettingsSchemaSource | null,
            trusted: boolean
        ): SettingsSchemaSource;
        /**
         * Gets the default system schema source.
         *
         * This function is not required for normal uses of #GSettings but it
         * may be useful to authors of plugin management systems or to those who
         * want to introspect the content of schemas.
         *
         * If no schemas are installed, %NULL will be returned.
         *
         * The returned source may actually consist of multiple schema sources
         * from different directories, depending on which directories were given
         * in `XDG_DATA_DIRS` and `GSETTINGS_SCHEMA_DIR`. For this reason, all
         * lookups performed against the default source should probably be done
         * recursively.
         * @returns the default schema source
         */
        static get_default(): SettingsSchemaSource | null;
    }

    interface SimpleActionGroupClass {}

    abstract class SimpleActionGroupClass {
        // Own properties of Gio-2.0.Gio.SimpleActionGroupClass

        static name: string;
    }

    interface SimpleActionGroupPrivate {}

    class SimpleActionGroupPrivate {
        // Own properties of Gio-2.0.Gio.SimpleActionGroupPrivate

        static name: string;
    }

    interface SimpleAsyncResultClass {}

    abstract class SimpleAsyncResultClass {
        // Own properties of Gio-2.0.Gio.SimpleAsyncResultClass

        static name: string;
    }

    interface SimpleProxyResolverClass {
        // Own fields of Gio-2.0.Gio.SimpleProxyResolverClass

        parent_class: GObject.ObjectClass;
    }

    abstract class SimpleProxyResolverClass {
        // Own properties of Gio-2.0.Gio.SimpleProxyResolverClass

        static name: string;
    }

    interface SimpleProxyResolverPrivate {}

    class SimpleProxyResolverPrivate {
        // Own properties of Gio-2.0.Gio.SimpleProxyResolverPrivate

        static name: string;
    }

    interface SocketAddressClass {
        // Own fields of Gio-2.0.Gio.SocketAddressClass

        parent_class: GObject.ObjectClass;
        get_family: (address: SocketAddress) => SocketFamily;
        get_native_size: (address: SocketAddress) => number;
        to_native: (
            address: SocketAddress,
            dest: any | null,
            destlen: number
        ) => boolean;
    }

    abstract class SocketAddressClass {
        // Own properties of Gio-2.0.Gio.SocketAddressClass

        static name: string;
    }

    interface SocketAddressEnumeratorClass {
        // Own fields of Gio-2.0.Gio.SocketAddressEnumeratorClass

        next: (
            enumerator: SocketAddressEnumerator,
            cancellable: Cancellable | null
        ) => SocketAddress | null;
        next_async: (
            enumerator: SocketAddressEnumerator,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        next_finish: (
            enumerator: SocketAddressEnumerator,
            result: AsyncResult
        ) => SocketAddress | null;
    }

    /**
     * Class structure for #GSocketAddressEnumerator.
     * @record
     */
    abstract class SocketAddressEnumeratorClass {
        // Own properties of Gio-2.0.Gio.SocketAddressEnumeratorClass

        static name: string;
    }

    interface SocketClass {
        // Own fields of Gio-2.0.Gio.SocketClass

        parent_class: GObject.ObjectClass;
    }

    abstract class SocketClass {
        // Own properties of Gio-2.0.Gio.SocketClass

        static name: string;
    }

    interface SocketClientClass {
        // Own fields of Gio-2.0.Gio.SocketClientClass

        parent_class: GObject.ObjectClass;
        event: (
            client: SocketClient,
            event: SocketClientEvent,
            connectable: SocketConnectable,
            connection: IOStream
        ) => void;
    }

    abstract class SocketClientClass {
        // Own properties of Gio-2.0.Gio.SocketClientClass

        static name: string;
    }

    interface SocketClientPrivate {}

    class SocketClientPrivate {
        // Own properties of Gio-2.0.Gio.SocketClientPrivate

        static name: string;
    }

    interface SocketConnectableIface {
        // Own fields of Gio-2.0.Gio.SocketConnectableIface

        /**
         * The parent interface.
         * @field
         */
        g_iface: GObject.TypeInterface;
        enumerate: (connectable: SocketConnectable) => SocketAddressEnumerator;
        proxy_enumerate: (
            connectable: SocketConnectable
        ) => SocketAddressEnumerator;
        to_string: (connectable: SocketConnectable) => string | null;
    }

    /**
     * Provides an interface for returning a #GSocketAddressEnumerator
     * and #GProxyAddressEnumerator
     * @record
     */
    abstract class SocketConnectableIface {
        // Own properties of Gio-2.0.Gio.SocketConnectableIface

        static name: string;
    }

    interface SocketConnectionClass {
        // Own fields of Gio-2.0.Gio.SocketConnectionClass

        parent_class: IOStreamClass;
    }

    abstract class SocketConnectionClass {
        // Own properties of Gio-2.0.Gio.SocketConnectionClass

        static name: string;
    }

    interface SocketConnectionPrivate {}

    class SocketConnectionPrivate {
        // Own properties of Gio-2.0.Gio.SocketConnectionPrivate

        static name: string;
    }

    interface SocketControlMessageClass {
        // Own fields of Gio-2.0.Gio.SocketControlMessageClass

        parent_class: GObject.ObjectClass;
        get_size: (message: SocketControlMessage) => number;
        get_level: (message: SocketControlMessage) => number;
        get_type: (message: SocketControlMessage) => number;
        serialize: (message: SocketControlMessage, data: any) => void;
    }

    /**
     * Class structure for #GSocketControlMessage.
     * @record
     */
    abstract class SocketControlMessageClass {
        // Own properties of Gio-2.0.Gio.SocketControlMessageClass

        static name: string;
    }

    interface SocketControlMessagePrivate {}

    class SocketControlMessagePrivate {
        // Own properties of Gio-2.0.Gio.SocketControlMessagePrivate

        static name: string;
    }

    interface SocketListenerClass {
        // Own fields of Gio-2.0.Gio.SocketListenerClass

        parent_class: GObject.ObjectClass;
        changed: (listener: SocketListener) => void;
        event: (
            listener: SocketListener,
            event: SocketListenerEvent,
            socket: Socket
        ) => void;
    }

    /**
     * Class structure for #GSocketListener.
     * @record
     */
    abstract class SocketListenerClass {
        // Own properties of Gio-2.0.Gio.SocketListenerClass

        static name: string;
    }

    interface SocketListenerPrivate {}

    class SocketListenerPrivate {
        // Own properties of Gio-2.0.Gio.SocketListenerPrivate

        static name: string;
    }

    interface SocketPrivate {}

    class SocketPrivate {
        // Own properties of Gio-2.0.Gio.SocketPrivate

        static name: string;
    }

    interface SocketServiceClass {
        // Own fields of Gio-2.0.Gio.SocketServiceClass

        parent_class: SocketListenerClass;
        incoming: (
            service: SocketService,
            connection: SocketConnection,
            source_object: GObject.Object
        ) => boolean;
    }

    /**
     * Class structure for #GSocketService.
     * @record
     */
    abstract class SocketServiceClass {
        // Own properties of Gio-2.0.Gio.SocketServiceClass

        static name: string;
    }

    interface SocketServicePrivate {}

    class SocketServicePrivate {
        // Own properties of Gio-2.0.Gio.SocketServicePrivate

        static name: string;
    }

    interface SrvTarget {
        // Owm methods of Gio-2.0.Gio.SrvTarget

        /**
         * Copies `target`
         * @returns a copy of @target
         */
        copy(): SrvTarget;
        /**
         * Frees `target`
         */
        free(): void;
        /**
         * Gets `target'`s hostname (in ASCII form; if you are going to present
         * this to the user, you should use g_hostname_is_ascii_encoded() to
         * check if it contains encoded Unicode segments, and use
         * g_hostname_to_unicode() to convert it if it does.)
         * @returns @target's hostname
         */
        get_hostname(): string | null;
        /**
         * Gets `target'`s port
         * @returns @target's port
         */
        get_port(): number;
        /**
         * Gets `target'`s priority. You should not need to look at this;
         * #GResolver already sorts the targets according to the algorithm in
         * RFC 2782.
         * @returns @target's priority
         */
        get_priority(): number;
        /**
         * Gets `target'`s weight. You should not need to look at this;
         * #GResolver already sorts the targets according to the algorithm in
         * RFC 2782.
         * @returns @target's weight
         */
        get_weight(): number;
    }

    /**
     * SRV (service) records are used by some network protocols to provide
     * service-specific aliasing and load-balancing. For example, XMPP
     * (Jabber) uses SRV records to locate the XMPP server for a domain;
     * rather than connecting directly to "example.com" or assuming a
     * specific server hostname like "xmpp.example.com", an XMPP client
     * would look up the "xmpp-client" SRV record for "example.com", and
     * then connect to whatever host was pointed to by that record.
     *
     * You can use g_resolver_lookup_service() or
     * g_resolver_lookup_service_async() to find the #GSrvTargets
     * for a given service. However, if you are simply planning to connect
     * to the remote service, you can use #GNetworkService's
     * #GSocketConnectable interface and not need to worry about
     * #GSrvTarget at all.
     * @record
     */
    class SrvTarget {
        // Own properties of Gio-2.0.Gio.SrvTarget

        static name: string;

        // Constructors of Gio-2.0.Gio.SrvTarget

        /**
         * Creates a new #GSrvTarget with the given parameters.
         *
         * You should not need to use this; normally #GSrvTargets are
         * created by #GResolver.
         * @constructor
         * @param hostname the host that the service is running on
         * @param port the port that the service is running on
         * @param priority the target's priority
         * @param weight the target's weight
         * @returns a new #GSrvTarget.
         */
        constructor(
            hostname: string | null,
            port: number,
            priority: number,
            weight: number
        );
        /**
         * Creates a new #GSrvTarget with the given parameters.
         *
         * You should not need to use this; normally #GSrvTargets are
         * created by #GResolver.
         * @constructor
         * @param hostname the host that the service is running on
         * @param port the port that the service is running on
         * @param priority the target's priority
         * @param weight the target's weight
         * @returns a new #GSrvTarget.
         */
        static new(
            hostname: string | null,
            port: number,
            priority: number,
            weight: number
        ): SrvTarget;
    }

    interface StaticResource {
        // Owm methods of Gio-2.0.Gio.StaticResource

        /**
         * Finalized a GResource initialized by g_static_resource_init().
         *
         * This is normally used by code generated by
         * [glib-compile-resources][glib-compile-resources]
         * and is not typically used by other code.
         */
        fini(): void;
        /**
         * Gets the GResource that was registered by a call to g_static_resource_init().
         *
         * This is normally used by code generated by
         * [glib-compile-resources][glib-compile-resources]
         * and is not typically used by other code.
         * @returns a #GResource
         */
        get_resource(): Resource;
        /**
         * Initializes a GResource from static data using a
         * GStaticResource.
         *
         * This is normally used by code generated by
         * [glib-compile-resources][glib-compile-resources]
         * and is not typically used by other code.
         */
        init(): void;
    }

    /**
     * #GStaticResource is an opaque data structure and can only be accessed
     * using the following functions.
     * @record
     */
    class StaticResource {
        // Own properties of Gio-2.0.Gio.StaticResource

        static name: string;
    }

    interface TaskClass {}

    abstract class TaskClass {
        // Own properties of Gio-2.0.Gio.TaskClass

        static name: string;
    }

    interface TcpConnectionClass {
        // Own fields of Gio-2.0.Gio.TcpConnectionClass

        parent_class: SocketConnectionClass;
    }

    abstract class TcpConnectionClass {
        // Own properties of Gio-2.0.Gio.TcpConnectionClass

        static name: string;
    }

    interface TcpConnectionPrivate {}

    class TcpConnectionPrivate {
        // Own properties of Gio-2.0.Gio.TcpConnectionPrivate

        static name: string;
    }

    interface TcpWrapperConnectionClass {
        // Own fields of Gio-2.0.Gio.TcpWrapperConnectionClass

        parent_class: TcpConnectionClass;
    }

    abstract class TcpWrapperConnectionClass {
        // Own properties of Gio-2.0.Gio.TcpWrapperConnectionClass

        static name: string;
    }

    interface TcpWrapperConnectionPrivate {}

    class TcpWrapperConnectionPrivate {
        // Own properties of Gio-2.0.Gio.TcpWrapperConnectionPrivate

        static name: string;
    }

    interface ThemedIconClass {}

    abstract class ThemedIconClass {
        // Own properties of Gio-2.0.Gio.ThemedIconClass

        static name: string;
    }

    interface ThreadedSocketServiceClass {
        // Own fields of Gio-2.0.Gio.ThreadedSocketServiceClass

        parent_class: SocketServiceClass;
        run: (
            service: ThreadedSocketService,
            connection: SocketConnection,
            source_object: GObject.Object
        ) => boolean;
    }

    abstract class ThreadedSocketServiceClass {
        // Own properties of Gio-2.0.Gio.ThreadedSocketServiceClass

        static name: string;
    }

    interface ThreadedSocketServicePrivate {}

    class ThreadedSocketServicePrivate {
        // Own properties of Gio-2.0.Gio.ThreadedSocketServicePrivate

        static name: string;
    }

    interface TlsBackendInterface {
        // Own fields of Gio-2.0.Gio.TlsBackendInterface

        /**
         * The parent interface.
         * @field
         */
        g_iface: GObject.TypeInterface;
        supports_tls: (backend: TlsBackend) => boolean;
        get_certificate_type: () => GObject.GType;
        get_client_connection_type: () => GObject.GType;
        get_server_connection_type: () => GObject.GType;
        get_file_database_type: () => GObject.GType;
        get_default_database: (backend: TlsBackend) => TlsDatabase;
        supports_dtls: (backend: TlsBackend) => boolean;
        get_dtls_client_connection_type: () => GObject.GType;
        get_dtls_server_connection_type: () => GObject.GType;
    }

    /**
     * Provides an interface for describing TLS-related types.
     * @record
     */
    abstract class TlsBackendInterface {
        // Own properties of Gio-2.0.Gio.TlsBackendInterface

        static name: string;
    }

    interface TlsCertificateClass {
        // Own fields of Gio-2.0.Gio.TlsCertificateClass

        parent_class: GObject.ObjectClass;
        verify: (
            cert: TlsCertificate,
            identity: SocketConnectable | null,
            trusted_ca: TlsCertificate | null
        ) => TlsCertificateFlags;
    }

    abstract class TlsCertificateClass {
        // Own properties of Gio-2.0.Gio.TlsCertificateClass

        static name: string;
    }

    interface TlsCertificatePrivate {}

    class TlsCertificatePrivate {
        // Own properties of Gio-2.0.Gio.TlsCertificatePrivate

        static name: string;
    }

    interface TlsClientConnectionInterface {
        // Own fields of Gio-2.0.Gio.TlsClientConnectionInterface

        /**
         * The parent interface.
         * @field
         */
        g_iface: GObject.TypeInterface;
        copy_session_state: (
            conn: TlsClientConnection,
            source: TlsClientConnection
        ) => void;
    }

    /**
     * vtable for a #GTlsClientConnection implementation.
     * @record
     */
    abstract class TlsClientConnectionInterface {
        // Own properties of Gio-2.0.Gio.TlsClientConnectionInterface

        static name: string;
    }

    interface TlsConnectionClass {
        // Own fields of Gio-2.0.Gio.TlsConnectionClass

        /**
         * The parent class.
         * @field
         */
        parent_class: IOStreamClass;
        accept_certificate: (
            connection: TlsConnection,
            peer_cert: TlsCertificate,
            errors: TlsCertificateFlags
        ) => boolean;
        handshake: (
            conn: TlsConnection,
            cancellable: Cancellable | null
        ) => boolean;
        handshake_async: (
            conn: TlsConnection,
            io_priority: number,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        handshake_finish: (conn: TlsConnection, result: AsyncResult) => boolean;
        get_binding_data: (
            conn: TlsConnection,
            type: TlsChannelBindingType,
            data: Uint8Array
        ) => boolean;
        get_negotiated_protocol: (conn: TlsConnection) => string | null;
    }

    /**
     * The class structure for the #GTlsConnection type.
     * @record
     */
    abstract class TlsConnectionClass {
        // Own properties of Gio-2.0.Gio.TlsConnectionClass

        static name: string;
    }

    interface TlsConnectionPrivate {}

    class TlsConnectionPrivate {
        // Own properties of Gio-2.0.Gio.TlsConnectionPrivate

        static name: string;
    }

    interface TlsDatabaseClass {
        // Own fields of Gio-2.0.Gio.TlsDatabaseClass

        parent_class: GObject.ObjectClass;
        verify_chain: (
            self: TlsDatabase,
            chain: TlsCertificate,
            purpose: string | null,
            identity: SocketConnectable | null,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseVerifyFlags,
            cancellable: Cancellable | null
        ) => TlsCertificateFlags;
        verify_chain_async: (
            self: TlsDatabase,
            chain: TlsCertificate,
            purpose: string | null,
            identity: SocketConnectable | null,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseVerifyFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        verify_chain_finish: (
            self: TlsDatabase,
            result: AsyncResult
        ) => TlsCertificateFlags;
        create_certificate_handle: (
            self: TlsDatabase,
            certificate: TlsCertificate
        ) => string | null;
        lookup_certificate_for_handle: (
            self: TlsDatabase,
            handle: string | null,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseLookupFlags,
            cancellable: Cancellable | null
        ) => TlsCertificate | null;
        lookup_certificate_for_handle_async: (
            self: TlsDatabase,
            handle: string | null,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseLookupFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        lookup_certificate_for_handle_finish: (
            self: TlsDatabase,
            result: AsyncResult
        ) => TlsCertificate;
        lookup_certificate_issuer: (
            self: TlsDatabase,
            certificate: TlsCertificate,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseLookupFlags,
            cancellable: Cancellable | null
        ) => TlsCertificate;
        lookup_certificate_issuer_async: (
            self: TlsDatabase,
            certificate: TlsCertificate,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseLookupFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        lookup_certificate_issuer_finish: (
            self: TlsDatabase,
            result: AsyncResult
        ) => TlsCertificate;
        lookup_certificates_issued_by: (
            self: TlsDatabase,
            issuer_raw_dn: Uint8Array,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseLookupFlags,
            cancellable: Cancellable | null
        ) => TlsCertificate[];
        lookup_certificates_issued_by_async: (
            self: TlsDatabase,
            issuer_raw_dn: Uint8Array,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseLookupFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        lookup_certificates_issued_by_finish: (
            self: TlsDatabase,
            result: AsyncResult
        ) => TlsCertificate[];
    }

    /**
     * The class for #GTlsDatabase. Derived classes should implement the various
     * virtual methods. _async and _finish methods have a default
     * implementation that runs the corresponding sync method in a thread.
     * @record
     */
    abstract class TlsDatabaseClass {
        // Own properties of Gio-2.0.Gio.TlsDatabaseClass

        static name: string;
    }

    interface TlsDatabasePrivate {}

    class TlsDatabasePrivate {
        // Own properties of Gio-2.0.Gio.TlsDatabasePrivate

        static name: string;
    }

    interface TlsFileDatabaseInterface {
        // Own fields of Gio-2.0.Gio.TlsFileDatabaseInterface

        /**
         * The parent interface.
         * @field
         */
        g_iface: GObject.TypeInterface;
    }

    /**
     * Provides an interface for #GTlsFileDatabase implementations.
     * @record
     */
    abstract class TlsFileDatabaseInterface {
        // Own properties of Gio-2.0.Gio.TlsFileDatabaseInterface

        static name: string;
    }

    interface TlsInteractionClass {
        // Own fields of Gio-2.0.Gio.TlsInteractionClass

        ask_password: (
            interaction: TlsInteraction,
            password: TlsPassword,
            cancellable: Cancellable | null
        ) => TlsInteractionResult;
        ask_password_async: (
            interaction: TlsInteraction,
            password: TlsPassword,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        ask_password_finish: (
            interaction: TlsInteraction,
            result: AsyncResult
        ) => TlsInteractionResult;
        request_certificate: (
            interaction: TlsInteraction,
            connection: TlsConnection,
            flags: TlsCertificateRequestFlags,
            cancellable: Cancellable | null
        ) => TlsInteractionResult;
        request_certificate_async: (
            interaction: TlsInteraction,
            connection: TlsConnection,
            flags: TlsCertificateRequestFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        request_certificate_finish: (
            interaction: TlsInteraction,
            result: AsyncResult
        ) => TlsInteractionResult;
    }

    /**
     * The class for #GTlsInteraction. Derived classes implement the various
     * virtual interaction methods to handle TLS interactions.
     *
     * Derived classes can choose to implement whichever interactions methods they'd
     * like to support by overriding those virtual methods in their class
     * initialization function. If a derived class implements an async method,
     * it must also implement the corresponding finish method.
     *
     * The synchronous interaction methods should implement to display modal dialogs,
     * and the asynchronous methods to display modeless dialogs.
     *
     * If the user cancels an interaction, then the result should be
     * %G_TLS_INTERACTION_FAILED and the error should be set with a domain of
     * %G_IO_ERROR and code of %G_IO_ERROR_CANCELLED.
     * @record
     */
    abstract class TlsInteractionClass {
        // Own properties of Gio-2.0.Gio.TlsInteractionClass

        static name: string;
    }

    interface TlsInteractionPrivate {}

    class TlsInteractionPrivate {
        // Own properties of Gio-2.0.Gio.TlsInteractionPrivate

        static name: string;
    }

    interface TlsPasswordClass {
        // Own fields of Gio-2.0.Gio.TlsPasswordClass

        parent_class: GObject.ObjectClass;
        get_value: (password: TlsPassword) => Uint8Array;
        set_value: (
            password: TlsPassword,
            value: Uint8Array,
            destroy: GLib.DestroyNotify | null
        ) => void;
        get_default_warning: (password: TlsPassword) => string | null;
    }

    /**
     * Class structure for #GTlsPassword.
     * @record
     */
    abstract class TlsPasswordClass {
        // Own properties of Gio-2.0.Gio.TlsPasswordClass

        static name: string;
    }

    interface TlsPasswordPrivate {}

    class TlsPasswordPrivate {
        // Own properties of Gio-2.0.Gio.TlsPasswordPrivate

        static name: string;
    }

    interface TlsServerConnectionInterface {
        // Own fields of Gio-2.0.Gio.TlsServerConnectionInterface

        /**
         * The parent interface.
         * @field
         */
        g_iface: GObject.TypeInterface;
    }

    /**
     * vtable for a #GTlsServerConnection implementation.
     * @record
     */
    abstract class TlsServerConnectionInterface {
        // Own properties of Gio-2.0.Gio.TlsServerConnectionInterface

        static name: string;
    }

    interface UnixConnectionClass {
        // Own fields of Gio-2.0.Gio.UnixConnectionClass

        parent_class: SocketConnectionClass;
    }

    abstract class UnixConnectionClass {
        // Own properties of Gio-2.0.Gio.UnixConnectionClass

        static name: string;
    }

    interface UnixConnectionPrivate {}

    class UnixConnectionPrivate {
        // Own properties of Gio-2.0.Gio.UnixConnectionPrivate

        static name: string;
    }

    interface UnixCredentialsMessageClass {
        // Own fields of Gio-2.0.Gio.UnixCredentialsMessageClass

        parent_class: SocketControlMessageClass;
    }

    /**
     * Class structure for #GUnixCredentialsMessage.
     * @record
     */
    abstract class UnixCredentialsMessageClass {
        // Own properties of Gio-2.0.Gio.UnixCredentialsMessageClass

        static name: string;
    }

    interface UnixCredentialsMessagePrivate {}

    class UnixCredentialsMessagePrivate {
        // Own properties of Gio-2.0.Gio.UnixCredentialsMessagePrivate

        static name: string;
    }

    interface UnixFDListClass {
        // Own fields of Gio-2.0.Gio.UnixFDListClass

        parent_class: GObject.ObjectClass;
    }

    abstract class UnixFDListClass {
        // Own properties of Gio-2.0.Gio.UnixFDListClass

        static name: string;
    }

    interface UnixFDListPrivate {}

    class UnixFDListPrivate {
        // Own properties of Gio-2.0.Gio.UnixFDListPrivate

        static name: string;
    }

    interface UnixFDMessageClass {
        // Own fields of Gio-2.0.Gio.UnixFDMessageClass

        parent_class: SocketControlMessageClass;
    }

    abstract class UnixFDMessageClass {
        // Own properties of Gio-2.0.Gio.UnixFDMessageClass

        static name: string;
    }

    interface UnixFDMessagePrivate {}

    class UnixFDMessagePrivate {
        // Own properties of Gio-2.0.Gio.UnixFDMessagePrivate

        static name: string;
    }

    interface UnixInputStreamClass {
        // Own fields of Gio-2.0.Gio.UnixInputStreamClass

        parent_class: InputStreamClass;
    }

    abstract class UnixInputStreamClass {
        // Own properties of Gio-2.0.Gio.UnixInputStreamClass

        static name: string;
    }

    interface UnixInputStreamPrivate {}

    class UnixInputStreamPrivate {
        // Own properties of Gio-2.0.Gio.UnixInputStreamPrivate

        static name: string;
    }

    interface UnixMountEntry {}

    /**
     * Defines a Unix mount entry (e.g. <filename>/media/cdrom</filename>).
     * This corresponds roughly to a mtab entry.
     * @record
     */
    class UnixMountEntry {
        // Own properties of Gio-2.0.Gio.UnixMountEntry

        static name: string;
    }

    interface UnixMountMonitorClass {}

    abstract class UnixMountMonitorClass {
        // Own properties of Gio-2.0.Gio.UnixMountMonitorClass

        static name: string;
    }

    interface UnixMountPoint {
        // Owm methods of Gio-2.0.Gio.UnixMountPoint

        /**
         * Compares two unix mount points.
         * @param mount2 a #GUnixMount.
         * @returns 1, 0 or -1 if @mount1 is greater than, equal to, or less than @mount2, respectively.
         */
        compare(mount2: UnixMountPoint): number;
        /**
         * Makes a copy of `mount_point`.
         * @returns a new #GUnixMountPoint
         */
        copy(): UnixMountPoint;
        /**
         * Frees a unix mount point.
         */
        free(): void;
        /**
         * Gets the device path for a unix mount point.
         * @returns a string containing the device path.
         */
        get_device_path(): string;
        /**
         * Gets the file system type for the mount point.
         * @returns a string containing the file system type.
         */
        get_fs_type(): string | null;
        /**
         * Gets the mount path for a unix mount point.
         * @returns a string containing the mount path.
         */
        get_mount_path(): string;
        /**
         * Gets the options for the mount point.
         * @returns a string containing the options.
         */
        get_options(): string | null;
        /**
         * Guesses whether a Unix mount point can be ejected.
         * @returns %TRUE if @mount_point is deemed to be ejectable.
         */
        guess_can_eject(): boolean;
        /**
         * Guesses the icon of a Unix mount point.
         * @returns a #GIcon
         */
        guess_icon(): Icon;
        /**
         * Guesses the name of a Unix mount point.
         * The result is a translated string.
         * @returns A newly allocated string that must     be freed with g_free()
         */
        guess_name(): string | null;
        /**
         * Guesses the symbolic icon of a Unix mount point.
         * @returns a #GIcon
         */
        guess_symbolic_icon(): Icon;
        /**
         * Checks if a unix mount point is a loopback device.
         * @returns %TRUE if the mount point is a loopback. %FALSE otherwise.
         */
        is_loopback(): boolean;
        /**
         * Checks if a unix mount point is read only.
         * @returns %TRUE if a mount point is read only.
         */
        is_readonly(): boolean;
        /**
         * Checks if a unix mount point is mountable by the user.
         * @returns %TRUE if the mount point is user mountable.
         */
        is_user_mountable(): boolean;
    }

    /**
     * Defines a Unix mount point (e.g. <filename>/dev</filename>).
     * This corresponds roughly to a fstab entry.
     * @record
     */
    class UnixMountPoint {
        // Own properties of Gio-2.0.Gio.UnixMountPoint

        static name: string;

        // Constructors of Gio-2.0.Gio.UnixMountPoint

        /**
         * Gets a #GUnixMountPoint for a given mount path. If `time_read` is set, it
         * will be filled with a unix timestamp for checking if the mount points have
         * changed since with g_unix_mount_points_changed_since().
         *
         * If more mount points have the same mount path, the last matching mount point
         * is returned.
         * @param mount_path path for a possible unix mount point.
         * @returns a #GUnixMountPoint, or %NULL if no match is found.
         */
        static at(
            mount_path: string
        ): [/* returnType */ UnixMountPoint | null, /* time_read */ number];
    }

    interface UnixOutputStreamClass {
        // Own fields of Gio-2.0.Gio.UnixOutputStreamClass

        parent_class: OutputStreamClass;
    }

    abstract class UnixOutputStreamClass {
        // Own properties of Gio-2.0.Gio.UnixOutputStreamClass

        static name: string;
    }

    interface UnixOutputStreamPrivate {}

    class UnixOutputStreamPrivate {
        // Own properties of Gio-2.0.Gio.UnixOutputStreamPrivate

        static name: string;
    }

    interface UnixSocketAddressClass {
        // Own fields of Gio-2.0.Gio.UnixSocketAddressClass

        parent_class: SocketAddressClass;
    }

    abstract class UnixSocketAddressClass {
        // Own properties of Gio-2.0.Gio.UnixSocketAddressClass

        static name: string;
    }

    interface UnixSocketAddressPrivate {}

    class UnixSocketAddressPrivate {
        // Own properties of Gio-2.0.Gio.UnixSocketAddressPrivate

        static name: string;
    }

    interface VfsClass {
        // Own fields of Gio-2.0.Gio.VfsClass

        parent_class: GObject.ObjectClass;
        is_active: (vfs: Vfs) => boolean;
        get_file_for_path: (vfs: Vfs, path: string | null) => File;
        get_file_for_uri: (vfs: Vfs, uri: string | null) => File;
        get_supported_uri_schemes: (vfs: Vfs) => string[];
        parse_name: (vfs: Vfs, parse_name: string | null) => File;
        local_file_add_info: (
            vfs: Vfs,
            filename: string | null,
            device: number,
            attribute_matcher: FileAttributeMatcher,
            info: FileInfo,
            cancellable: Cancellable | null,
            extra_data: any | null,
            free_extra_data: GLib.DestroyNotify
        ) => void;
        add_writable_namespaces: (
            vfs: Vfs,
            list: FileAttributeInfoList
        ) => void;
        local_file_set_attributes: (
            vfs: Vfs,
            filename: string | null,
            info: FileInfo,
            flags: FileQueryInfoFlags,
            cancellable: Cancellable | null
        ) => boolean;
        local_file_removed: (vfs: Vfs, filename: string | null) => void;
        local_file_moved: (
            vfs: Vfs,
            source: string | null,
            dest: string | null
        ) => void;
    }

    abstract class VfsClass {
        // Own properties of Gio-2.0.Gio.VfsClass

        static name: string;
    }

    interface VolumeIface {
        // Own fields of Gio-2.0.Gio.VolumeIface

        /**
         * The parent interface.
         * @field
         */
        g_iface: GObject.TypeInterface;
        changed: (volume: Volume) => void;
        removed: (volume: Volume) => void;
        get_name: (volume: Volume) => string | null;
        get_icon: (volume: Volume) => Icon;
        get_uuid: (volume: Volume) => string | null;
        get_drive: (volume: Volume) => Drive | null;
        get_mount: (volume: Volume) => Mount | null;
        can_mount: (volume: Volume) => boolean;
        can_eject: (volume: Volume) => boolean;
        mount_fn: (
            volume: Volume,
            flags: MountMountFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        mount_finish: (volume: Volume, result: AsyncResult) => boolean;
        eject: (
            volume: Volume,
            flags: MountUnmountFlags,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        eject_finish: (volume: Volume, result: AsyncResult) => boolean;
        get_identifier: (volume: Volume, kind: string | null) => string | null;
        enumerate_identifiers: (volume: Volume) => string[];
        should_automount: (volume: Volume) => boolean;
        get_activation_root: (volume: Volume) => File | null;
        eject_with_operation: (
            volume: Volume,
            flags: MountUnmountFlags,
            mount_operation: MountOperation | null,
            cancellable: Cancellable | null,
            callback: AsyncReadyCallback | null
        ) => void;
        eject_with_operation_finish: (
            volume: Volume,
            result: AsyncResult
        ) => boolean;
        get_sort_key: (volume: Volume) => string | null;
        get_symbolic_icon: (volume: Volume) => Icon;
    }

    /**
     * Interface for implementing operations for mountable volumes.
     * @record
     */
    abstract class VolumeIface {
        // Own properties of Gio-2.0.Gio.VolumeIface

        static name: string;
    }

    interface VolumeMonitorClass {
        // Own fields of Gio-2.0.Gio.VolumeMonitorClass

        parent_class: GObject.ObjectClass;
        volume_added: (volume_monitor: VolumeMonitor, volume: Volume) => void;
        volume_removed: (volume_monitor: VolumeMonitor, volume: Volume) => void;
        volume_changed: (volume_monitor: VolumeMonitor, volume: Volume) => void;
        mount_added: (volume_monitor: VolumeMonitor, mount: Mount) => void;
        mount_removed: (volume_monitor: VolumeMonitor, mount: Mount) => void;
        mount_pre_unmount: (
            volume_monitor: VolumeMonitor,
            mount: Mount
        ) => void;
        mount_changed: (volume_monitor: VolumeMonitor, mount: Mount) => void;
        drive_connected: (volume_monitor: VolumeMonitor, drive: Drive) => void;
        drive_disconnected: (
            volume_monitor: VolumeMonitor,
            drive: Drive
        ) => void;
        drive_changed: (volume_monitor: VolumeMonitor, drive: Drive) => void;
        is_supported: () => boolean;
        get_connected_drives: (volume_monitor: VolumeMonitor) => Drive[];
        get_volumes: (volume_monitor: VolumeMonitor) => Volume[];
        get_mounts: (volume_monitor: VolumeMonitor) => Mount[];
        get_volume_for_uuid: (
            volume_monitor: VolumeMonitor,
            uuid: string | null
        ) => Volume | null;
        get_mount_for_uuid: (
            volume_monitor: VolumeMonitor,
            uuid: string | null
        ) => Mount | null;
        drive_eject_button: (
            volume_monitor: VolumeMonitor,
            drive: Drive
        ) => void;
        drive_stop_button: (
            volume_monitor: VolumeMonitor,
            drive: Drive
        ) => void;
    }

    abstract class VolumeMonitorClass {
        // Own properties of Gio-2.0.Gio.VolumeMonitorClass

        static name: string;
    }

    interface ZlibCompressorClass {
        // Own fields of Gio-2.0.Gio.ZlibCompressorClass

        parent_class: GObject.ObjectClass;
    }

    abstract class ZlibCompressorClass {
        // Own properties of Gio-2.0.Gio.ZlibCompressorClass

        static name: string;
    }

    interface ZlibDecompressorClass {
        // Own fields of Gio-2.0.Gio.ZlibDecompressorClass

        parent_class: GObject.ObjectClass;
    }

    abstract class ZlibDecompressorClass {
        // Own properties of Gio-2.0.Gio.ZlibDecompressorClass

        static name: string;
    }

    /**
     * Name of the imported GIR library
     * @see https://gitlab.gnome.org/GNOME/gjs/-/blob/master/gi/ns.cpp#L188
     */
    const __name__: string;
    /**
     * Version of the imported GIR library
     * @see https://gitlab.gnome.org/GNOME/gjs/-/blob/master/gi/ns.cpp#L189
     */
    const __version__: string;
}

export default Gio;
// END
