/*
 * Type Definitions for Gjs (https://gjs.guide/)
 *
 * These type definitions are automatically generated, do not edit them by hand.
 * If you found a bug fix it in `ts-for-gir` or create a bug report on https://github.com/gjsify/ts-for-gir
 */

import './gcr-4-import.d.ts';
/**
 * Gcr-4
 */

import type Gio from './gio-2.0.js';
import type GObject from './gobject-2.0.js';
import type GLib from './glib-2.0.js';
import type Gck from './gck-2.js';

export namespace Gcr {
    /**
     * The status of a built certificate chain. Will be set to
     * %GCR_CERTIFICATE_CHAIN_UNKNOWN for certificate chains that have not been
     * built.
     */
    enum CertificateChainStatus {
        /**
         * The certificate chain's status is unknown.
         * When a chain is not yet built it has this status. If a chain is modified after
         * being built, it has this status.
         */
        UNKNOWN,
        /**
         * A full chain could not be loaded. The
         * chain does not end with a self-signed certificate, a trusted anchor, or a
         * pinned certificate.
         */
        INCOMPLETE,
        /**
         * The certificate chain contains a revoked
         * or otherwise explicitly distrusted certificate. The entire chain should
         * be distrusted.
         */
        DISTRUSTED,
        /**
         * The chain ends with a self-signed
         * certificate. No trust anchor was found.
         */
        SELFSIGNED,
        /**
         * The chain represents a pinned certificate. A
         * pinned certificate is an exception which trusts a given certificate
         * explicitly for a purpose and communication with a certain peer.
         */
        PINNED,
        /**
         * The chain ends with an anchored
         * certificate. The anchored certificate is not necessarily self-signed.
         */
        ANCHORED,
    }
    /**
     * The format of a certificate request. Currently only PKCS#10 is supported.
     */
    enum CertificateRequestFormat {
        /**
         * certificate request is in PKCS#10 format
         */
        CERTIFICATE_REQUEST_PKCS10,
    }
    /**
     * Values responding to error codes for parsing and serializing data.
     */
    enum DataError {
        /**
         * Failed to parse or serialize the data
         */
        FAILURE,
        /**
         * The data was unrecognized or unsupported
         */
        UNRECOGNIZED,
        /**
         * The operation was cancelled
         */
        CANCELLED,
        /**
         * The data was encrypted or locked and could not be unlocked.
         */
        LOCKED,
    }
    /**
     * The various format identifiers.
     */
    enum DataFormat {
        /**
         * Represents all the formats, when enabling or disabling
         */
        ALL,
        /**
         * Not a valid format
         */
        INVALID,
        /**
         * DER encoded private key
         */
        DER_PRIVATE_KEY,
        /**
         * DER encoded RSA private key
         */
        DER_PRIVATE_KEY_RSA,
        /**
         * DER encoded DSA private key
         */
        DER_PRIVATE_KEY_DSA,
        /**
         * DER encoded EC private key
         */
        DER_PRIVATE_KEY_EC,
        /**
         * DER encoded SubjectPublicKeyInfo
         */
        DER_SUBJECT_PUBLIC_KEY,
        /**
         * DER encoded X.509 certificate
         */
        DER_CERTIFICATE_X509,
        /**
         * DER encoded PKCS#7 container file which can contain certificates
         */
        DER_PKCS7,
        /**
         * DER encoded PKCS#8 file which can contain a key
         */
        DER_PKCS8,
        /**
         * Unencrypted DER encoded PKCS#8 file which can contain a key
         */
        DER_PKCS8_PLAIN,
        /**
         * Encrypted DER encoded PKCS#8 file which can contain a key
         */
        DER_PKCS8_ENCRYPTED,
        /**
         * DER encoded PKCS#10 certificate request file
         */
        DER_PKCS10,
        /**
         * DER encoded SPKAC as generated by HTML5 keygen element
         */
        DER_SPKAC,
        /**
         * OpenSSL style SPKAC data
         */
        BASE64_SPKAC,
        /**
         * DER encoded PKCS#12 file which can contain certificates and/or keys
         */
        DER_PKCS12,
        /**
         * OpenSSH v1 or v2 public key
         */
        OPENSSH_PUBLIC,
        /**
         * OpenPGP key packet(s)
         */
        OPENPGP_PACKET,
        /**
         * OpenPGP public or private key armor encoded data
         */
        OPENPGP_ARMOR,
        /**
         * An OpenSSL style PEM file with unspecified contents
         */
        PEM,
        /**
         * An OpenSSL style PEM file with a private RSA key
         */
        PEM_PRIVATE_KEY_RSA,
        /**
         * An OpenSSL style PEM file with a private DSA key
         */
        PEM_PRIVATE_KEY_DSA,
        /**
         * An OpenSSL style PEM file with an X.509 certificate
         */
        PEM_CERTIFICATE_X509,
        /**
         * An OpenSSL style PEM file containing PKCS#7
         */
        PEM_PKCS7,
        /**
         * Unencrypted OpenSSL style PEM file containing PKCS#8
         */
        PEM_PKCS8_PLAIN,
        /**
         * Encrypted OpenSSL style PEM file containing PKCS#8
         */
        PEM_PKCS8_ENCRYPTED,
        /**
         * An OpenSSL style PEM file containing PKCS#12
         */
        PEM_PKCS12,
        /**
         * An OpenSSL style PEM file with a private key
         */
        PEM_PRIVATE_KEY,
        /**
         * An OpenSSL style PEM file containing PKCS#10
         */
        PEM_PKCS10,
        /**
         * An OpenSSL style PEM file with a private EC key
         */
        PEM_PRIVATE_KEY_EC,
        /**
         * An OpenSSL style PEM file containing a SubjectPublicKeyInfo
         */
        PEM_PUBLIC_KEY,
    }
    /**
     * Various replies returned by [method`Prompt`.confirm] and friends.
     */
    enum PromptReply {
        /**
         * the prompt was cancelled
         */
        CANCEL,
        /**
         * the user replied with 'ok'
         */
        CONTINUE,
    }
    /**
     * No error returned by the #GcrSystemPrompt is suitable for display or
     * to the user.
     *
     * If the system prompter can only show one prompt at a time, and there is
     * already a prompt being displayed, and the timeout waiting to open the
     * prompt expires, then %GCR_SYSTEM_PROMPT_IN_PROGRESS is returned.
     */
    enum SystemPromptError {
        /**
         * another prompt is already in progress
         */
        SYSTEM_PROMPT_IN_PROGRESS,
    }
    /**
     * The mode for the system prompter. Most system prompters can only show
     * one prompt at a time and would use the %GCR_SYSTEM_PROMPTER_SINGLE mode.
     */
    enum SystemPrompterMode {
        /**
         * only one prompt shown at a time
         */
        SINGLE,
        /**
         * more than one prompt shown at a time
         */
        MULTIPLE,
    }
    /**
     * Flags to be used with the gcr_certificate_chain_build() operation.
     * @bitfield
     */
    enum CertificateChainFlags {
        /**
         * no flags
         */
        NONE,
        /**
         * If this flag is specified then no
         * lookups for anchors or pinned certificates are done, and the resulting chain
         * will be neither anchored or pinned. Additionally no missing certificate
         * authorities are looked up in PKCS#11.
         */
        NO_LOOKUPS,
    }
    enum CertificateSectionFlags {
        NONE,
        IMPORTANT,
    }
    /**
     * The major version number of the Gcr library.
     */
    const MAJOR_VERSION: number;
    /**
     * The micro version number of the Gcr library.
     */
    const MICRO_VERSION: number;
    /**
     * The minor version number of the Gcr library.
     */
    const MINOR_VERSION: number;
    /**
     * The purpose used to verify the client certificate in a TLS connection.
     */
    const PURPOSE_CLIENT_AUTH: string | null;
    /**
     * The purpose used to verify certificate used for the signature on signed code.
     */
    const PURPOSE_CODE_SIGNING: string | null;
    /**
     * The purpose used to verify certificates that are used in email communication
     * such as S/MIME.
     */
    const PURPOSE_EMAIL: string | null;
    /**
     * The purpose used to verify the server certificate in a TLS connection. This
     * is the most common purpose in use.
     */
    const PURPOSE_SERVER_AUTH: string | null;
    /**
     * The current secret exchange protocol. Key agreement is done using DH with the
     * 1536 bit IKE parameter group. Keys are derived using SHA256 with HKDF. The
     * transport encryption is done with 128 bit AES.
     */
    const SECRET_EXCHANGE_PROTOCOL_1: string | null;
    const UNLOCK_OPTION_ALWAYS: string | null;
    const UNLOCK_OPTION_IDLE: string | null;
    const UNLOCK_OPTION_SESSION: string | null;
    const UNLOCK_OPTION_TIMEOUT: string | null;
    function data_error_get_domain(): GLib.Quark;
    /**
     * Create a key fingerprint for a certificate, public key or private key.
     * Note that this is not a fingerprint of certificate data, which you would
     * use gcr_certificate_get_fingerprint() for.
     * @param attrs attributes for key or certificate
     * @param checksum_type the type of fingerprint to create
     * @returns the          fingerprint or %NULL if the input was invalid.
     */
    function fingerprint_from_attributes(
        attrs: Gck.Attributes,
        checksum_type: GLib.ChecksumType
    ): Uint8Array | null;
    /**
     * Create a key fingerprint for a DER encoded subjectPublicKeyInfo. The
     * fingerprint is created so that it will be identical for a key and its
     * corresponding certificate.
     *
     * Note that in the case of certificates this is not a fingerprint of the
     * actual certificate data, but rather of the public key contained in a
     * certificate.
     * @param key_info DER encoded subjectPublicKeyInfo structure
     * @param checksum_type the type of fingerprint to create
     * @returns the          fingerprint or %NULL if the input was invalid.
     */
    function fingerprint_from_subject_public_key_info(
        key_info: Uint8Array,
        checksum_type: GLib.ChecksumType
    ): Uint8Array | null;
    /**
     * Create a set of importers which can import this parsed item.
     * The parsed item is represented by the state of the GcrParser at the
     * time of calling this method.
     * @param parsed a parser with a parsed item to import
     * @returns a list of importers          which can import the parsed item, which should be freed with          g_object_unref(), or %NULL if no types of importers can be created
     */
    function importer_create_for_parsed(parsed: Parsed): Importer[];
    /**
     * Queues an additional item to be imported in all compattible importers
     * in the set. The parsed item is represented by the state of the #GcrParser
     * at the time of calling this method.
     *
     * If the parsed item is incompatible with an importer, then that the item
     * will not be queued on that importer.
     * @param importers a set of importers
     * @param parsed a parsed item
     * @returns a new set of importers          that queued the item.
     */
    function importer_queue_and_filter_for_parsed(
        importers: Importer[],
        parsed: Parsed
    ): Importer[];
    /**
     * Register an importer to handle parsed items that match the given attributes.
     * @param importer_type the GType of the importer being registered
     * @param attrs the attributes that this importer is compatible with
     */
    function importer_register(
        importer_type: GObject.GType,
        attrs: Gck.Attributes
    ): void;
    /**
     * Register built-in PKCS#11 and GnuPG importers.
     */
    function importer_register_well_known(): void;
    /**
     * Disconnect the mock prompter
     */
    function mock_prompter_disconnect(): void;
    /**
     * Queue an expected response on the mock prompter.
     *
     * Expects any prompt, and closes the prompt when it gets it.
     */
    function mock_prompter_expect_close(): void;
    /**
     * Queue an expected response on the mock prompter.
     *
     * Expects a confirmation prompt, and then cancels that prompt.
     */
    function mock_prompter_expect_confirm_cancel(): void;
    /**
     * Queue an expected response on the mock prompter.
     *
     * Expects a password prompt, and then cancels that prompt.
     */
    function mock_prompter_expect_password_cancel(): void;
    /**
     * Get the delay in milliseconds before the mock prompter completes
     * an expected prompt.
     * @returns the delay
     */
    function mock_prompter_get_delay_msec(): number;
    /**
     * Check if the mock prompter is expecting a response. This will be %TRUE
     * when one of the <literal>gcr_mock_prompter_expect_xxx<!-- -->()</literal>
     * functions have been used to queue an expected prompt, but that prompt
     * response has not be 'used' yet.
     * @returns whether expecting a prompt
     */
    function mock_prompter_is_expecting(): boolean;
    /**
     * Check if the mock prompter is showing any prompts.
     * @returns whether prompting
     */
    function mock_prompter_is_prompting(): boolean;
    /**
     * Set the delay in milliseconds before the mock prompter completes
     * an expected prompt.
     * @param delay_msec prompt response delay in milliseconds
     */
    function mock_prompter_set_delay_msec(delay_msec: number): void;
    /**
     * Start the mock prompter. This is often used from the
     * <literal>setup<!-- -->()</literal> function of tests.
     *
     * Starts the mock prompter in an additional thread. Use the returned DBus bus
     * name with gcr_system_prompt_open_for_prompter() to connect to this prompter.
     * @returns the bus name that the mock prompter is listening on
     */
    function mock_prompter_start(): string | null;
    /**
     * Stop the mock prompter. This is often used from the
     * <literal>teardown<!-- -->()</literal> function of tests.
     */
    function mock_prompter_stop(): void;
    /**
     * Unreferences a parsed item which was referenced with gcr_parsed_ref()
     * @param parsed a parsed item
     */
    function parsed_unref(parsed: any | null): void;
    /**
     * Add a #GckModule to the list of PKCS#11 modules that are used by the
     * GCR library.
     *
     * It is not normally necessary to call this function. The available
     * PKCS#11 modules installed on the system are automatically loaded
     * by the GCR library.
     * @param module a #GckModule
     */
    function pkcs11_add_module(module: Gck.Module): void;
    /**
     * Initialize a PKCS#11 module and add it to the modules that are
     * used by the GCR library. Note that is an error to initialize the same
     * PKCS#11 module twice.
     *
     * It is not normally necessary to call this function. The available
     * PKCS#11 modules installed on the system are automatically loaded
     * by the GCR library.
     * @param module_path the full file path of the PKCS#11 module
     * @param unused unused
     * @returns whether the module was sucessfully added.
     */
    function pkcs11_add_module_from_file(
        module_path: string | null,
        unused: any | null
    ): boolean;
    /**
     * List all the PKCS#11 modules that are used by the GCR library.
     * Each module is a [class`Gck`.Module] object.
     *
     * An empty list of modules will be returned if [func`pkcs1`1_set_modules],
     * or [func`pkcs1`1_initialize] has not yet run.
     * @returns a newly allocated list          of #GckModule objects
     */
    function pkcs11_get_modules(): Gck.Module[];
    /**
     * List all the PKCS#11 slots that are used by the GCR library for lookup
     * of trust assertions. Each slot is a [class`Gck`.Slot] object.
     *
     * This will return an empty list if the [func`pkcs1`1_initialize] function has
     * not yet been called.
     * @returns a list of #GckSlot          objects to use for lookup of trust, or the empty list if not          initialized or no appropriate trust stores could be found.
     */
    function pkcs11_get_trust_lookup_slots(): Gck.Slot[];
    /**
     * Get the PKCS#11 URIs that are used to identify which slots to use for
     * lookup trust assertions.
     * @returns the uri which identifies trust storage slot
     */
    function pkcs11_get_trust_lookup_uris(): string[] | null;
    /**
     * Selects an appropriate PKCS#11 slot to store trust assertions. The slot
     * to use is normally configured automatically by the system.
     *
     * This will only return a valid result after the [func`pkcs1`1_initialize]
     * method has been called.
     *
     * When done with the #GckSlot, use g_object_unref() to release it.
     * @returns the #GckSlot to use for trust          assertions, or null if not initialized or no appropriate          trust store could be found.
     */
    function pkcs11_get_trust_store_slot(): Gck.Slot | null;
    /**
     * Get the PKCS#11 URI that is used to identify which slot to use for
     * storing trust storage.
     * @returns the uri which identifies trust storage slot
     */
    function pkcs11_get_trust_store_uri(): string | null;
    /**
     * Asynchronously initialize the registered PKCS#11 modules.
     * @param cancellable optional cancellable used to cancel the operation
     * @returns whether the operation was successful or not.
     */
    function pkcs11_initialize(cancellable: Gio.Cancellable | null): boolean;
    /**
     * Asynchronously initialize the registered PKCS#11 modules.
     * @param cancellable optional cancellable used to cancel the operation
     * @param callback callback which will be called when the operation completes
     */
    function pkcs11_initialize_async<Z = unknown>(
        cancellable: Gio.Cancellable | null,
        callback: Gio.AsyncReadyCallback<Z> | null
    ): void;

    // Overloads of pkcs11_initialize_async

    /**
     * Promisified version of {@link pkcs11_initialize_async}
     *
     * Asynchronously initialize the registered PKCS#11 modules.
     * @param cancellable optional cancellable used to cancel the operation
     * @returns A Promise of: whether the operation was successful or not.
     */
    function pkcs11_initialize_async<Z = unknown>(
        cancellable: Gio.Cancellable | null
    ): globalThis.Promise<boolean>;
    /**
     * Complete the asynchronous operation to initialize the registered PKCS#11
     * modules.
     * @param result the asynchronous result
     * @returns whether the operation was successful or not.
     */
    function pkcs11_initialize_finish(result: Gio.AsyncResult): boolean;
    /**
     * Set the list of PKCS#11 modules that are used by the GCR library.
     * Each module in the list is a [class`Gck`.Module] object.
     *
     * It is not normally necessary to call this function. The available
     * PKCS#11 modules installed on the system are automatically loaded
     * by the GCR library.
     * @param modules a list of PKCS#11 modules
     */
    function pkcs11_set_modules(modules: Gck.Module[]): void;
    /**
     * Set the PKCS#11 URIs that are used to identify which slots to use for
     * lookup of trust assertions.
     *
     * It is not normally necessary to call this function. The relevant
     * PKCS#11 slots are automatically configured by the GCR library.
     * @param pkcs11_uris the uris which identifies trust lookup slots
     */
    function pkcs11_set_trust_lookup_uris(pkcs11_uris: string | null): void;
    /**
     * Set the PKCS#11 URI that is used to identify which slot to use for
     * storing trust assertions.
     *
     * It is not normally necessary to call this function. The relevant
     * PKCS#11 slot is automatically configured by the GCR library.
     * @param pkcs11_uri the uri which identifies trust storage slot
     */
    function pkcs11_set_trust_store_uri(pkcs11_uri: string | null): void;
    /**
     * Add a pinned `certificate` for connections to `peer` for `purpose`. A pinned
     * certificate overrides all other certificate verification and should be
     * used with care.
     *
     * If the same pinned certificate already exists, then this operation
     * does not add another, and succeeds without error.
     *
     * This call may block, see gcr_trust_add_pinned_certificate_async() for the
     * non-blocking version.
     * @param certificate a #GcrCertificate
     * @param purpose the purpose string
     * @param peer the peer for this pinned certificate
     * @param cancellable a #GCancellable
     * @returns %TRUE if the pinned certificate is recorded successfully
     */
    function trust_add_pinned_certificate(
        certificate: Certificate,
        purpose: string | null,
        peer: string | null,
        cancellable: Gio.Cancellable | null
    ): boolean;
    /**
     * Add a pinned certificate for communication with `peer` for `purpose`. A pinned
     * certificate overrides all other certificate verification and should be used
     * with care.
     *
     * If the same pinned certificate already exists, then this operation
     * does not add another, and succeeds without error.
     *
     * When the operation is finished, callback will be called. You can then call
     * [func`Gcr`.trust_add_pinned_certificate_finish] to get the result of the
     * operation.
     * @param certificate a #GcrCertificate
     * @param purpose the purpose string
     * @param peer the peer for this pinned certificate
     * @param cancellable a #GCancellable
     * @param callback a #GAsyncReadyCallback to call when the operation completes
     */
    function trust_add_pinned_certificate_async<Z = unknown>(
        certificate: Certificate,
        purpose: string | null,
        peer: string | null,
        cancellable: Gio.Cancellable | null,
        callback: Gio.AsyncReadyCallback<Z> | null
    ): void;

    // Overloads of trust_add_pinned_certificate_async

    /**
     * Promisified version of {@link trust_add_pinned_certificate_async}
     *
     * Add a pinned certificate for communication with `peer` for `purpose`. A pinned
     * certificate overrides all other certificate verification and should be used
     * with care.
     *
     * If the same pinned certificate already exists, then this operation
     * does not add another, and succeeds without error.
     *
     * When the operation is finished, callback will be called. You can then call
     * [func`Gcr`.trust_add_pinned_certificate_finish] to get the result of the
     * operation.
     * @param certificate a #GcrCertificate
     * @param purpose the purpose string
     * @param peer the peer for this pinned certificate
     * @param cancellable a #GCancellable
     * @returns A Promise of: %TRUE if the pinned certificate is recorded successfully
     */
    function trust_add_pinned_certificate_async<Z = unknown>(
        certificate: Certificate,
        purpose: string | null,
        peer: string | null,
        cancellable: Gio.Cancellable | null
    ): globalThis.Promise<boolean>;
    /**
     * Finishes an asynchronous operation started by
     * gcr_trust_add_pinned_certificate_async().
     * @param result the #GAsyncResult passed to the callback
     * @returns %TRUE if the pinned certificate is recorded successfully
     */
    function trust_add_pinned_certificate_finish(
        result: Gio.AsyncResult
    ): boolean;
    /**
     * Check if the `certificate` is a trust anchor for the given `purpose`. A trust
     * anchor is used to verify the signatures on other certificates when verifying
     * a certificate chain. Also known as a trusted certificate authority.
     *
     * This call may block, see [func`Gcr`.trust_is_certificate_anchored_async] for
     * the non-blocking version.
     *
     * In the case of an error, %FALSE is also returned. Check `error` to detect
     * if an error occurred.
     * @param certificate a #GcrCertificate to check
     * @param purpose the purpose string
     * @param cancellable a #GCancellable
     * @returns %TRUE if the certificate is a trust anchor
     */
    function trust_is_certificate_anchored(
        certificate: Certificate,
        purpose: string | null,
        cancellable: Gio.Cancellable | null
    ): boolean;
    /**
     * Check if the `certificate` is a trust anchor for the given `purpose`. A trust
     * anchor is used to verify the signatures on other certificates when verifying
     * a certificate chain. Also known as a trusted certificate authority.
     *
     * When the operation is finished, callback will be called. You can then call
     * gcr_trust_is_certificate_anchored_finish() to get the result of the operation.
     * @param certificate a #GcrCertificate to check
     * @param purpose the purpose string
     * @param cancellable a #GCancellable
     * @param callback a #GAsyncReadyCallback to call when the operation completes
     */
    function trust_is_certificate_anchored_async<Z = unknown>(
        certificate: Certificate,
        purpose: string | null,
        cancellable: Gio.Cancellable | null,
        callback: Gio.AsyncReadyCallback<Z> | null
    ): void;

    // Overloads of trust_is_certificate_anchored_async

    /**
     * Promisified version of {@link trust_is_certificate_anchored_async}
     *
     * Check if the `certificate` is a trust anchor for the given `purpose`. A trust
     * anchor is used to verify the signatures on other certificates when verifying
     * a certificate chain. Also known as a trusted certificate authority.
     *
     * When the operation is finished, callback will be called. You can then call
     * gcr_trust_is_certificate_anchored_finish() to get the result of the operation.
     * @param certificate a #GcrCertificate to check
     * @param purpose the purpose string
     * @param cancellable a #GCancellable
     * @returns A Promise of: %TRUE if the certificate is a trust anchor
     */
    function trust_is_certificate_anchored_async<Z = unknown>(
        certificate: Certificate,
        purpose: string | null,
        cancellable: Gio.Cancellable | null
    ): globalThis.Promise<boolean>;
    /**
     * Finishes an asynchronous operation started by
     * gcr_trust_is_certificate_anchored_async().
     *
     * In the case of an error, %FALSE is also returned. Check `error` to detect
     * if an error occurred.
     * @param result the #GAsyncResult passed to the callback
     * @returns %TRUE if the certificate is a trust anchor
     */
    function trust_is_certificate_anchored_finish(
        result: Gio.AsyncResult
    ): boolean;
    /**
     * Checks whether the certificate that can be uniquely identified with the
     * given `serial_nr` and `issuer` is marked as distrusted (for example by the
     * user, or because it's part of a CRL).
     *
     * Since we can't directly use [iface`Certificate]` to fetch these values, you
     * need to call these with the raw serial number and issuer as provided by the
     * PKCS#11 fields `CKA_SERIAL_NR` and `CKA_ISSUER`.
     * @param serial_nr The serial number of the certificate
     * @param issuer The raw issuer
     * @param cancellable a #GCancellable or %NULL
     * @returns %TRUE if the certificate is marked as distrusted
     */
    function trust_is_certificate_distrusted(
        serial_nr: Uint8Array,
        issuer: Uint8Array,
        cancellable: Gio.Cancellable | null
    ): boolean;
    /**
     * Asynchronously checks whether the certificate that can be uniquely
     * identified with the given `serial_nr` and `issuer` is marked as distrusted
     * (for example by the user, or because it's part of a CRL).
     *
     * Since we can't directly use [iface`Certificate]` to fetch these values, you
     * need to call these with the raw serial number and issuer as provided by the
     * PKCS#11 fields `CKA_SERIAL_NR` and `CKA_ISSUER`.
     *
     * When the operation is finished, `callback` will be called. You can then call
     * [func`trust_is_certificate_distrusted_finish]` to get the result of the
     * operation.
     * @param serial_nr The serial number of the certificate
     * @param issuer The raw issuer
     * @param cancellable a #GCancellable or %NULL
     * @param callback a #GAsyncReadyCallback to call when the operation completes
     */
    function trust_is_certificate_distrusted_async<Z = unknown>(
        serial_nr: Uint8Array,
        issuer: Uint8Array,
        cancellable: Gio.Cancellable | null,
        callback: Gio.AsyncReadyCallback<Z> | null
    ): void;

    // Overloads of trust_is_certificate_distrusted_async

    /**
     * Promisified version of {@link trust_is_certificate_distrusted_async}
     *
     * Asynchronously checks whether the certificate that can be uniquely
     * identified with the given `serial_nr` and `issuer` is marked as distrusted
     * (for example by the user, or because it's part of a CRL).
     *
     * Since we can't directly use [iface`Certificate]` to fetch these values, you
     * need to call these with the raw serial number and issuer as provided by the
     * PKCS#11 fields `CKA_SERIAL_NR` and `CKA_ISSUER`.
     *
     * When the operation is finished, `callback` will be called. You can then call
     * [func`trust_is_certificate_distrusted_finish]` to get the result of the
     * operation.
     * @param serial_nr The serial number of the certificate
     * @param issuer The raw issuer
     * @param cancellable a #GCancellable or %NULL
     * @returns A Promise of: %TRUE if the certificate is a trust anchor
     */
    function trust_is_certificate_distrusted_async<Z = unknown>(
        serial_nr: Uint8Array,
        issuer: Uint8Array,
        cancellable: Gio.Cancellable | null
    ): globalThis.Promise<boolean>;
    /**
     * Finishes an asynchronous operation started by
     * [func`trust_is_certificate_distrusted_async]`.
     *
     * In the case of an error, %FALSE is also returned. Check `error` to detect
     * if an error occurred.
     * @param result the #GAsyncResult passed to the callback
     * @returns %TRUE if the certificate is a trust anchor
     */
    function trust_is_certificate_distrusted_finish(
        result: Gio.AsyncResult
    ): boolean;
    /**
     * Check if `certificate` is pinned for `purpose` to communicate with `peer`.
     * A pinned certificate overrides all other certificate verification.
     *
     * This call may block, see gcr_trust_is_certificate_pinned_async() for the
     * non-blocking version.
     *
     * In the case of an error, %FALSE is also returned. Check `error` to detect
     * if an error occurred.
     * @param certificate a #GcrCertificate to check
     * @param purpose the purpose string
     * @param peer the peer for this pinned
     * @param cancellable a #GCancellable
     * @returns %TRUE if the certificate is pinned for the host and purpose
     */
    function trust_is_certificate_pinned(
        certificate: Certificate,
        purpose: string | null,
        peer: string | null,
        cancellable: Gio.Cancellable | null
    ): boolean;
    /**
     * Check if `certificate` is pinned for `purpose` to communicate with `peer`. A
     * pinned certificate overrides all other certificate verification.
     *
     * When the operation is finished, callback will be called. You can then call
     * [func`Gcr`.trust_is_certificate_pinned_finish] to get the result of the
     * operation.
     * @param certificate a #GcrCertificate to check
     * @param purpose the purpose string
     * @param peer the peer for this pinned
     * @param cancellable a #GCancellable
     * @param callback a #GAsyncReadyCallback to call when the operation completes
     */
    function trust_is_certificate_pinned_async<Z = unknown>(
        certificate: Certificate,
        purpose: string | null,
        peer: string | null,
        cancellable: Gio.Cancellable | null,
        callback: Gio.AsyncReadyCallback<Z> | null
    ): void;

    // Overloads of trust_is_certificate_pinned_async

    /**
     * Promisified version of {@link trust_is_certificate_pinned_async}
     *
     * Check if `certificate` is pinned for `purpose` to communicate with `peer`. A
     * pinned certificate overrides all other certificate verification.
     *
     * When the operation is finished, callback will be called. You can then call
     * [func`Gcr`.trust_is_certificate_pinned_finish] to get the result of the
     * operation.
     * @param certificate a #GcrCertificate to check
     * @param purpose the purpose string
     * @param peer the peer for this pinned
     * @param cancellable a #GCancellable
     * @returns A Promise of: %TRUE if the certificate is pinned.
     */
    function trust_is_certificate_pinned_async<Z = unknown>(
        certificate: Certificate,
        purpose: string | null,
        peer: string | null,
        cancellable: Gio.Cancellable | null
    ): globalThis.Promise<boolean>;
    /**
     * Finishes an asynchronous operation started by
     * gcr_trust_is_certificate_pinned_async().
     *
     * In the case of an error, %FALSE is also returned. Check `error` to detect
     * if an error occurred.
     * @param result the #GAsyncResult passed to the callback
     * @returns %TRUE if the certificate is pinned.
     */
    function trust_is_certificate_pinned_finish(
        result: Gio.AsyncResult
    ): boolean;
    /**
     * Remove a pinned certificate for communication with `peer` for `purpose`.
     *
     * If the same pinned certificate does not exist, or was already removed,
     * then this operation succeeds without error.
     *
     * This call may block, see gcr_trust_remove_pinned_certificate_async() for the
     * non-blocking version.
     * @param certificate a #GcrCertificate
     * @param purpose the purpose string
     * @param peer the peer for this pinned certificate
     * @param cancellable a #GCancellable
     * @returns %TRUE if the pinned certificate no longer exists
     */
    function trust_remove_pinned_certificate(
        certificate: Certificate,
        purpose: string | null,
        peer: string | null,
        cancellable: Gio.Cancellable | null
    ): boolean;
    /**
     * Remove a pinned certificate for communication with `peer` for `purpose`.
     *
     * If the same pinned certificate does not exist, or was already removed,
     * then this operation succeeds without error.
     *
     * When the operation is finished, callback will be called. You can then call
     * gcr_trust_remove_pinned_certificate_finish() to get the result of the
     * operation.
     * @param certificate a #GcrCertificate
     * @param purpose the purpose string
     * @param peer the peer for this pinned certificate
     * @param cancellable a #GCancellable
     * @param callback a #GAsyncReadyCallback to call when the operation completes
     */
    function trust_remove_pinned_certificate_async<Z = unknown>(
        certificate: Certificate,
        purpose: string | null,
        peer: string | null,
        cancellable: Gio.Cancellable | null,
        callback: Gio.AsyncReadyCallback<Z> | null
    ): void;

    // Overloads of trust_remove_pinned_certificate_async

    /**
     * Promisified version of {@link trust_remove_pinned_certificate_async}
     *
     * Remove a pinned certificate for communication with `peer` for `purpose`.
     *
     * If the same pinned certificate does not exist, or was already removed,
     * then this operation succeeds without error.
     *
     * When the operation is finished, callback will be called. You can then call
     * gcr_trust_remove_pinned_certificate_finish() to get the result of the
     * operation.
     * @param certificate a #GcrCertificate
     * @param purpose the purpose string
     * @param peer the peer for this pinned certificate
     * @param cancellable a #GCancellable
     * @returns A Promise of: %TRUE if the pinned certificate no longer exists
     */
    function trust_remove_pinned_certificate_async<Z = unknown>(
        certificate: Certificate,
        purpose: string | null,
        peer: string | null,
        cancellable: Gio.Cancellable | null
    ): globalThis.Promise<boolean>;
    /**
     * Finishes an asynchronous operation started by
     * gcr_trust_remove_pinned_certificate_async().
     * @param result the #GAsyncResult passed to the callback
     * @returns %TRUE if the pinned certificate no longer exists
     */
    function trust_remove_pinned_certificate_finish(
        result: Gio.AsyncResult
    ): boolean;
    module Certificate {
        // Constructor properties interface

        interface ConstructorProperties
            extends GObject.Object.ConstructorProperties {}
    }

    interface Certificate {
        // Own properties of Gcr-4.Gcr.Certificate

        /**
         * A readable description for this certificate
         */
        readonly description: string | null;
        /**
         * The expiry date of the certificate
         */
        readonly expiry_date: GLib.DateTime;
        /**
         * Common name part of the certificate issuer
         */
        readonly issuer_name: string | null;
        /**
         * A readable label for this certificate.
         */
        readonly label: string | null;
        readonly subject_name: string | null;

        // Owm methods of Gcr-4.Gcr.Certificate

        /**
         * Get the basic constraints for the certificate if present. If %FALSE is
         * returned then no basic constraints are present and the `is_ca` and
         * `path_len` arguments are not changed.
         * @returns whether basic constraints are present or not
         */
        get_basic_constraints(): [
            /* returnType */ boolean,
            /* is_ca */ boolean,
            /* path_len */ number
        ];
        /**
         * Gets the raw DER data for an X.509 certificate.
         * @returns raw DER data of the X.509 certificate
         */
        get_der_data(): Uint8Array;
        /**
         * Get the expiry date of this certificate.
         * @returns An expiry date of this certificate.
         */
        get_expiry_date(): GLib.DateTime | null;
        /**
         * Calculate the fingerprint for this certificate.
         *
         * The caller should free the returned data using g_free() when
         * it is no longer required.
         * @param type the type of algorithm for the fingerprint.
         * @returns the raw binary fingerprint
         */
        get_fingerprint(type: GLib.ChecksumType): Uint8Array | null;
        /**
         * Calculate the fingerprint for this certificate, and return it
         * as a hex string.
         *
         * The caller should free the returned data using g_free() when
         * it is no longer required.
         * @param type the type of algorithm for the fingerprint.
         * @returns an allocated hex string which contains the fingerprint.
         */
        get_fingerprint_hex(type: GLib.ChecksumType): string | null;
        /**
         * Get the list of sections from the certificate that can be shown to the user
         * interface.
         * @returns A #GList of #GcrCertificateSection
         */
        get_interface_elements(): CertificateSection[];
        /**
         * Get the issued date of this certificate.
         * @returns A issued date of this certificate.
         */
        get_issued_date(): GLib.DateTime | null;
        /**
         * Get the common name of the issuer of this certificate.
         *
         * The string returned should be freed by the caller when no longer
         * required.
         * @returns The allocated issuer CN, or %NULL if no issuer CN present.
         */
        get_issuer_cn(): string | null;
        /**
         * Get the full issuer DN of the certificate as a (mostly)
         * readable string.
         *
         * The string returned should be freed by the caller when no longer
         * required.
         * @returns The allocated issuer DN of the certificate.
         */
        get_issuer_dn(): string | null;
        /**
         * Get a name to represent the issuer of this certificate.
         *
         * This will try to lookup the common name, orianizational unit,
         * organization in that order.
         * @returns the allocated issuer name, or %NULL if no issuer name
         */
        get_issuer_name(): string | null;
        /**
         * Get a part of the DN of the issuer of this certificate.
         *
         * Examples of a `part` might be the 'OU' (organizational unit)
         * or the 'CN' (common name). Only the value of that part
         * of the DN is returned.
         *
         * The string returned should be freed by the caller when no longer
         * required.
         * @param part a DN type string or OID.
         * @returns the allocated part of the issuer DN, or %NULL if no          such part is present
         */
        get_issuer_part(part: string | null): string | null;
        /**
         * Get the raw DER data for the issuer DN of the certificate.
         *
         * The data should be freed by using g_free() when no longer required.
         * @returns allocated memory          containing the raw issuer
         */
        get_issuer_raw(): Uint8Array | null;
        /**
         * Get the key size in bits of the public key represented
         * by this certificate.
         * @returns The key size of the certificate.
         */
        get_key_size(): number;
        /**
         * Get the raw binary serial number of the certificate.
         *
         * The caller should free the returned data using g_free() when
         * it is no longer required.
         * @returns the raw binary serial number.
         */
        get_serial_number(): Uint8Array | null;
        /**
         * Get the serial number of the certificate as a hex string.
         *
         * The caller should free the returned data using g_free() when
         * it is no longer required.
         * @returns an allocated string containing the serial number as hex.
         */
        get_serial_number_hex(): string | null;
        /**
         * Get the common name of the subject of this certificate.
         *
         * The string returned should be freed by the caller when no longer
         * required.
         * @returns The allocated subject CN, or %NULL if no subject CN present.
         */
        get_subject_cn(): string | null;
        /**
         * Get the full subject DN of the certificate as a (mostly)
         * readable string.
         *
         * The string returned should be freed by the caller when no longer
         * required.
         * @returns The allocated subject DN of the certificate.
         */
        get_subject_dn(): string | null;
        /**
         * Get a name to represent the subject of this certificate.
         *
         * This will try to lookup the common name, orianizational unit,
         * organization in that order.
         * @returns the allocated subject name, or %NULL if no subject name
         */
        get_subject_name(): string | null;
        /**
         * Get a part of the DN of the subject of this certificate.
         *
         * Examples of a `part` might be the 'OU' (organizational unit)
         * or the 'CN' (common name). Only the value of that part
         * of the DN is returned.
         *
         * The string returned should be freed by the caller when no longer
         * required.
         * @param part a DN type string or OID.
         * @returns the allocated part of the subject DN, or %NULL if no          such part is present.
         */
        get_subject_part(part: string | null): string | null;
        /**
         * Get the raw DER data for the subject DN of the certificate.
         *
         * The data should be freed by using g_free() when no longer required.
         * @returns allocated memory          containing the raw subject
         */
        get_subject_raw(): Uint8Array | null;
        /**
         * Check if `issuer` could be the issuer of this certificate. This is done by
         * comparing the relevant subject and issuer fields. No signature check is
         * done. Proper verification of certificates must be done via a crypto
         * library.
         * @param issuer a possible issuer #GcrCertificate
         * @returns whether @issuer could be the issuer of the certificate.
         */
        is_issuer(issuer: Certificate): boolean;
        /**
         * Implementers of the #GcrCertificate mixin should call this function to notify
         * when the certificate has changed to emit notifications on the various
         * properties.
         */
        mixin_emit_notify(): void;

        // Own virtual methods of Gcr-4.Gcr.Certificate

        /**
         * Gets the raw DER data for an X.509 certificate.
         * @virtual
         * @returns raw DER data of the X.509 certificate
         */
        vfunc_get_der_data(): Uint8Array;

        // Class property signals of Gcr-4.Gcr.Certificate

        connect(
            sigName: 'notify::description',
            callback: ($obj: Certificate, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::description',
            callback: ($obj: Certificate, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::description', ...args: any[]): void;
        connect(
            sigName: 'notify::expiry-date',
            callback: ($obj: Certificate, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::expiry-date',
            callback: ($obj: Certificate, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::expiry-date', ...args: any[]): void;
        connect(
            sigName: 'notify::issuer-name',
            callback: ($obj: Certificate, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::issuer-name',
            callback: ($obj: Certificate, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::issuer-name', ...args: any[]): void;
        connect(
            sigName: 'notify::label',
            callback: ($obj: Certificate, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::label',
            callback: ($obj: Certificate, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::label', ...args: any[]): void;
        connect(
            sigName: 'notify::subject-name',
            callback: ($obj: Certificate, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::subject-name',
            callback: ($obj: Certificate, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::subject-name', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * An interface that represents an X.509 certificate.
     *
     * Objects can implement this interface to make a certificate usable with the
     * GCR library.
     *
     * Various methods are available to parse out relevant bits of the certificate.
     * However no verification of the validity of a certificate is done here. Use
     * your favorite crypto library to do this.
     *
     * You can use [class`SimpleCertificate]` to simply load a certificate for which
     * you already have the raw certificate data.
     *
     * The #GcrCertificate interface has several properties that must be implemented.
     * You can use a mixin to implement these properties if desired. See the
     * gcr_certificate_mixin_class_init() and gcr_certificate_mixin_get_property()
     * functions.
     * @interface
     */
    class Certificate extends GObject.Object {
        // Own properties of Gcr-4.Gcr.Certificate

        static name: string;
        static $gtype: GObject.GType<Certificate>;

        // Constructors of Gcr-4.Gcr.Certificate

        constructor(config?: Certificate.ConstructorProperties);
        _init(config?: Certificate.ConstructorProperties): void;
    }

    module ImportInteraction {
        // Constructor properties interface

        interface ConstructorProperties
            extends Gio.TlsInteraction.ConstructorProperties,
                GObject.Object.ConstructorProperties {}
    }

    interface ImportInteraction extends Gio.TlsInteraction {
        // Owm methods of Gcr-4.Gcr.ImportInteraction

        /**
         * Supplement attributes before import. This means prompting the user for
         * things like labels and the like. The needed attributes will have been passed
         * to gcr_import_interaction_supplement_prep().
         *
         * This method prompts the user and fills in the attributes. If the user or
         * cancellable cancels the operation the error should be set with %G_IO_ERROR_CANCELLED.
         * @param builder supplemented attributes
         * @param cancellable optional cancellable object
         * @returns %G_TLS_INTERACTION_HANDLED if successful or %G_TLS_INTERACTION_FAILED
         */
        supplement(
            builder: Gck.Builder,
            cancellable: Gio.Cancellable | null
        ): Gio.TlsInteractionResult;
        /**
         * Asynchronously supplement attributes before import. This means prompting the
         * user for things like labels and the like. The needed attributes will have
         * been passed to gcr_import_interaction_supplement_prep().
         *
         * This method prompts the user and fills in the attributes.
         * @param builder supplemented attributes
         * @param cancellable optional cancellable object
         * @param callback called when the operation completes
         */
        supplement_async(
            builder: Gck.Builder,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null
        ): void;

        // Overloads of supplement_async

        /**
         * Promisified version of {@link supplement_async}
         *
         * Asynchronously supplement attributes before import. This means prompting the
         * user for things like labels and the like. The needed attributes will have
         * been passed to gcr_import_interaction_supplement_prep().
         *
         * This method prompts the user and fills in the attributes.
         * @param builder supplemented attributes
         * @param cancellable optional cancellable object
         * @returns A Promise of: %G_TLS_INTERACTION_HANDLED if successful or %G_TLS_INTERACTION_FAILED
         */
        supplement_async(
            builder: Gck.Builder,
            cancellable: Gio.Cancellable | null
        ): globalThis.Promise<Gio.TlsInteractionResult>;
        /**
         * Complete operation to asynchronously supplement attributes before import.
         *
         * If the user or cancellable cancels the operation the error should be set
         * with %G_IO_ERROR_CANCELLED.
         * @param result the asynchronous result
         * @returns %G_TLS_INTERACTION_HANDLED if successful or %G_TLS_INTERACTION_FAILED
         */
        supplement_finish(result: Gio.AsyncResult): Gio.TlsInteractionResult;
        /**
         * Prepare for supplementing the given attributes before import. This means
         * prompting the user for things like labels and the like. The attributes
         * will contain attributes for values that the importer needs, either empty
         * or prefilled with suggested values.
         *
         * This method does not prompt the user, but rather just prepares the
         * interaction that these are the attributes that are needed.
         * @param builder attributes to supplement
         */
        supplement_prep(builder: Gck.Builder): void;

        // Own virtual methods of Gcr-4.Gcr.ImportInteraction

        /**
         * Supplement attributes before import. This means prompting the user for
         * things like labels and the like. The needed attributes will have been passed
         * to gcr_import_interaction_supplement_prep().
         *
         * This method prompts the user and fills in the attributes. If the user or
         * cancellable cancels the operation the error should be set with %G_IO_ERROR_CANCELLED.
         * @virtual
         * @param builder supplemented attributes
         * @param cancellable optional cancellable object
         * @returns %G_TLS_INTERACTION_HANDLED if successful or %G_TLS_INTERACTION_FAILED
         */
        vfunc_supplement(
            builder: Gck.Builder,
            cancellable: Gio.Cancellable | null
        ): Gio.TlsInteractionResult;
        /**
         * Asynchronously supplement attributes before import. This means prompting the
         * user for things like labels and the like. The needed attributes will have
         * been passed to gcr_import_interaction_supplement_prep().
         *
         * This method prompts the user and fills in the attributes.
         * @virtual
         * @param builder supplemented attributes
         * @param cancellable optional cancellable object
         * @param callback called when the operation completes
         */
        vfunc_supplement_async(
            builder: Gck.Builder,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null
        ): void;
        /**
         * Complete operation to asynchronously supplement attributes before import.
         *
         * If the user or cancellable cancels the operation the error should be set
         * with %G_IO_ERROR_CANCELLED.
         * @virtual
         * @param result the asynchronous result
         * @returns %G_TLS_INTERACTION_HANDLED if successful or %G_TLS_INTERACTION_FAILED
         */
        vfunc_supplement_finish(
            result: Gio.AsyncResult
        ): Gio.TlsInteractionResult;
        /**
         * Prepare for supplementing the given attributes before import. This means
         * prompting the user for things like labels and the like. The attributes
         * will contain attributes for values that the importer needs, either empty
         * or prefilled with suggested values.
         *
         * This method does not prompt the user, but rather just prepares the
         * interaction that these are the attributes that are needed.
         * @virtual
         * @param builder attributes to supplement
         */
        vfunc_supplement_prep(builder: Gck.Builder): void;

        // Class property signals of Gcr-4.Gcr.ImportInteraction

        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * This is an interface implemented by a caller performing an import. It allows
     * the importer to ask the caller for further information about the import.
     *
     * It must be implemented on a derived class of [class`Gio`.TlsInteraction]
     * @interface
     */
    class ImportInteraction extends GObject.Object {
        // Own properties of Gcr-4.Gcr.ImportInteraction

        static name: string;
        static $gtype: GObject.GType<ImportInteraction>;

        // Constructors of Gcr-4.Gcr.ImportInteraction

        constructor(config?: ImportInteraction.ConstructorProperties);
        _init(config?: ImportInteraction.ConstructorProperties): void;
    }

    module Importer {
        // Constructor properties interface

        interface ConstructorProperties
            extends GObject.Object.ConstructorProperties {
            // Own constructor properties of Gcr-4.Gcr.Importer

            /**
             * The interaction for the importer.
             */
            interaction?: Gio.TlsInteraction | null;
        }
    }

    interface Importer {
        // Own properties of Gcr-4.Gcr.Importer

        /**
         * The interaction for the importer.
         */
        interaction: Gio.TlsInteraction;
        /**
         * The label for the importer.
         */
        readonly label: string | null;
        /**
         * The URI of the location imported to.
         */
        readonly uri: string | null;

        // Owm methods of Gcr-4.Gcr.Importer

        /**
         * Get the interaction used to prompt the user when needed by this
         * importer.
         * @returns the interaction or %NULL
         */
        get_interaction(): Gio.TlsInteraction | null;
        /**
         * Import the queued items in the importer. This function returns immediately
         * and completes asynchronously.
         * @param cancellable a #GCancellable, or %NULL
         * @param callback called when the operation completes
         */
        import_async(
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null
        ): void;

        // Overloads of import_async

        /**
         * Promisified version of {@link import_async}
         *
         * Import the queued items in the importer. This function returns immediately
         * and completes asynchronously.
         * @param cancellable a #GCancellable, or %NULL
         * @returns A Promise of: whether the import succeeded or failed
         */
        import_async(
            cancellable: Gio.Cancellable | null
        ): globalThis.Promise<boolean>;
        /**
         * Complete an asynchronous operation to import queued items.
         * @param result an asynchronous result
         * @returns whether the import succeeded or failed
         */
        import_finish(result: Gio.AsyncResult): boolean;
        /**
         * Queues an additional item to be imported. The parsed item is represented
         * by the state of the [class`Parser]` at the time of calling this method.
         *
         * If the parsed item is incompatible with the importer, then this will
         * fail and the item will not be queued.
         * @param parsed a parsed item to import
         * @returns whether the item was queued or not
         */
        queue_for_parsed(parsed: Parsed): boolean;
        /**
         * Set the interaction used to prompt the user when needed by this
         * importer.
         * @param interaction the interaction used by the importer
         */
        set_interaction(interaction: Gio.TlsInteraction): void;

        // Own virtual methods of Gcr-4.Gcr.Importer

        /**
         * Import the queued items in the importer. This function returns immediately
         * and completes asynchronously.
         * @virtual
         * @param cancellable a #GCancellable, or %NULL
         * @param callback called when the operation completes
         */
        vfunc_import_async(
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null
        ): void;
        /**
         * Complete an asynchronous operation to import queued items.
         * @virtual
         * @param result an asynchronous result
         * @returns whether the import succeeded or failed
         */
        vfunc_import_finish(result: Gio.AsyncResult): boolean;
        /**
         * Queues an additional item to be imported. The parsed item is represented
         * by the state of the [class`Parser]` at the time of calling this method.
         *
         * If the parsed item is incompatible with the importer, then this will
         * fail and the item will not be queued.
         * @virtual
         * @param parsed a parsed item to import
         * @returns whether the item was queued or not
         */
        vfunc_queue_for_parsed(parsed: Parsed): boolean;

        // Class property signals of Gcr-4.Gcr.Importer

        connect(
            sigName: 'notify::interaction',
            callback: ($obj: Importer, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::interaction',
            callback: ($obj: Importer, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::interaction', ...args: any[]): void;
        connect(
            sigName: 'notify::label',
            callback: ($obj: Importer, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::label',
            callback: ($obj: Importer, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::label', ...args: any[]): void;
        connect(
            sigName: 'notify::uri',
            callback: ($obj: Importer, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::uri',
            callback: ($obj: Importer, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::uri', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * An interface which allows importing of certificates and keys. Each importer
     * is registered with a set of PKCS#11 attributes to match stuff that it can
     * import.
     *
     * An importer gets passed a [class`Parser]` and accesses the currently parsed
     * item. To create a set of importers that can import the currently parsed
     * item in a parser, use [func`Importer`.create_for_parsed]. The list of
     * importers returned has the parsed item queued for import.
     *
     * To queue additional items with a importer use
     * [method`Importer`.queue_for_parsed].  In addition you can try and queue an
     * additional item with a set of importers using the
     * [func`Importer`.queue_and_filter_for_parsed].
     *
     * To start the import, use [method`Importer`.import_async].
     * @interface
     */
    class Importer extends GObject.Object {
        // Own properties of Gcr-4.Gcr.Importer

        static name: string;
        static $gtype: GObject.GType<Importer>;

        // Constructors of Gcr-4.Gcr.Importer

        constructor(config?: Importer.ConstructorProperties);
        _init(config?: Importer.ConstructorProperties): void;
        /**
         * Create a set of importers which can import this parsed item.
         * The parsed item is represented by the state of the GcrParser at the
         * time of calling this method.
         * @param parsed a parser with a parsed item to import
         * @returns a list of importers          which can import the parsed item, which should be freed with          g_object_unref(), or %NULL if no types of importers can be created
         */
        static create_for_parsed(parsed: Parsed): Importer[];
        /**
         * Queues an additional item to be imported in all compattible importers
         * in the set. The parsed item is represented by the state of the #GcrParser
         * at the time of calling this method.
         *
         * If the parsed item is incompatible with an importer, then that the item
         * will not be queued on that importer.
         * @param importers a set of importers
         * @param parsed a parsed item
         * @returns a new set of importers          that queued the item.
         */
        static queue_and_filter_for_parsed(
            importers: Importer[],
            parsed: Parsed
        ): Importer[];
        /**
         * Register an importer to handle parsed items that match the given attributes.
         * @param importer_type the GType of the importer being registered
         * @param attrs the attributes that this importer is compatible with
         */
        static register(
            importer_type: GObject.GType,
            attrs: Gck.Attributes
        ): void;
        /**
         * Register built-in PKCS#11 and GnuPG importers.
         */
        static register_well_known(): void;
    }

    module Prompt {
        // Signal callback interfaces

        /**
         * Signal callback interface for `prompt-close`
         */
        interface PromptCloseSignalCallback {
            ($obj: Prompt): void;
        }

        // Constructor properties interface

        interface ConstructorProperties
            extends GObject.Object.ConstructorProperties {
            // Own constructor properties of Gcr-4.Gcr.Prompt

            /**
             * The string handle of the caller's window.
             *
             * The caller window indicates to the prompt which window is prompting the
             * user. The prompt may choose to ignore this information or use it in whatever
             * way it sees fit.
             *
             * In X11, this will be a stringified version of the XWindow handle; in
             * Wayland this is the result of an export using the XDG foreign
             * protocol.
             */
            caller_window?: string | null;
            /**
             * The label for the cancel button in the prompt.
             */
            cancel_label?: string | null;
            /**
             * Whether the additional choice is chosen or not.
             *
             * The additional choice would have been setup using #GcrPrompt:choice-label.
             */
            choice_chosen?: boolean | null;
            /**
             * The label for the additional choice.
             *
             * If this is a non-%NULL value then an additional boolean choice will be
             * displayed by the prompt allowing the user to select or deselect it.
             *
             * If %NULL, then no additional choice is displayed.
             *
             * The initial value of the choice can be set with #GcrPrompt:choice-chosen.
             */
            choice_label?: string | null;
            /**
             * The label for the continue button in the prompt.
             */
            continue_label?: string | null;
            /**
             * The detailed description of the prompt.
             *
             * A prompt implementation may choose not to display this detailed description.
             * The prompt message should contain relevant information.
             */
            description?: string | null;
            /**
             * The prompt message for the user.
             *
             * A prompt implementation should always display this message.
             */
            message?: string | null;
            /**
             * Whether the prompt will prompt for a new password.
             *
             * This will cause the prompt implementation to ask the user to confirm the
             * password and/or display other relevant user interface for creating a new
             * password.
             */
            password_new?: boolean | null;
            /**
             * The title of the prompt.
             *
             * A prompt implementation may choose not to display the prompt title. The
             * #GcrPrompt:message should contain relevant information.
             */
            title?: string | null;
            /**
             * A prompt warning displayed on the prompt, or %NULL for no warning.
             *
             * This is a warning like "The password is incorrect." usually displayed to the
             * user about a previous 'unsuccessful' prompt.
             */
            warning?: string | null;
        }
    }

    interface Prompt {
        // Own properties of Gcr-4.Gcr.Prompt

        /**
         * The string handle of the caller's window.
         *
         * The caller window indicates to the prompt which window is prompting the
         * user. The prompt may choose to ignore this information or use it in whatever
         * way it sees fit.
         *
         * In X11, this will be a stringified version of the XWindow handle; in
         * Wayland this is the result of an export using the XDG foreign
         * protocol.
         */
        caller_window: string | null;
        /**
         * The label for the cancel button in the prompt.
         */
        cancel_label: string | null;
        /**
         * Whether the additional choice is chosen or not.
         *
         * The additional choice would have been setup using #GcrPrompt:choice-label.
         */
        choice_chosen: boolean;
        /**
         * The label for the additional choice.
         *
         * If this is a non-%NULL value then an additional boolean choice will be
         * displayed by the prompt allowing the user to select or deselect it.
         *
         * If %NULL, then no additional choice is displayed.
         *
         * The initial value of the choice can be set with #GcrPrompt:choice-chosen.
         */
        choice_label: string | null;
        /**
         * The label for the continue button in the prompt.
         */
        continue_label: string | null;
        /**
         * The detailed description of the prompt.
         *
         * A prompt implementation may choose not to display this detailed description.
         * The prompt message should contain relevant information.
         */
        description: string | null;
        /**
         * The prompt message for the user.
         *
         * A prompt implementation should always display this message.
         */
        message: string | null;
        /**
         * Whether the prompt will prompt for a new password.
         *
         * This will cause the prompt implementation to ask the user to confirm the
         * password and/or display other relevant user interface for creating a new
         * password.
         */
        password_new: boolean;
        /**
         * Indication of the password strength.
         *
         * Prompts will return a zero value if the password is empty, and a value
         * greater than zero if the password has any characters.
         *
         * This is only valid after a successful prompt for a password.
         */
        readonly password_strength: number;
        /**
         * The title of the prompt.
         *
         * A prompt implementation may choose not to display the prompt title. The
         * #GcrPrompt:message should contain relevant information.
         */
        title: string | null;
        /**
         * A prompt warning displayed on the prompt, or %NULL for no warning.
         *
         * This is a warning like "The password is incorrect." usually displayed to the
         * user about a previous 'unsuccessful' prompt.
         */
        warning: string | null;

        // Owm methods of Gcr-4.Gcr.Prompt

        /**
         * Closes the prompt so that in can no longer be used to prompt. The various
         * prompt methods will return results as if the user dismissed the prompt.
         *
         * The prompt may also be closed by the implementor of the prompt object.
         *
         * This emits the [signal`Prompt:`:prompt-close] signal on the prompt object.
         */
        close(): void;
        /**
         * Prompts for confirmation asking a cancel/continue style question.
         * Set the various properties on the prompt before calling this function to
         * represent the question correctly.
         *
         * This method will block until the a response is returned from the prompter.
         *
         * %GCR_PROMPT_REPLY_CONTINUE will be returned if the user confirms the prompt. The
         * return value will also be %GCR_PROMPT_REPLY_CANCEL if the user cancels or if
         * an error occurs. Check the `error` argument to tell the difference.
         * @param cancellable optional cancellation object
         * @returns the reply from the prompt
         */
        confirm(cancellable: Gio.Cancellable | null): PromptReply;
        /**
         * Prompts for confirmation asking a cancel/continue style question.
         * Set the various properties on the prompt before calling this method to
         * represent the question correctly.
         *
         * This method will return immediately and complete asynchronously.
         * @param cancellable optional cancellation object
         * @param callback called when the operation completes
         */
        confirm_async(
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null
        ): void;

        // Overloads of confirm_async

        /**
         * Promisified version of {@link confirm_async}
         *
         * Prompts for confirmation asking a cancel/continue style question.
         * Set the various properties on the prompt before calling this method to
         * represent the question correctly.
         *
         * This method will return immediately and complete asynchronously.
         * @param cancellable optional cancellation object
         * @returns A Promise of: the reply from the prompt
         */
        confirm_async(
            cancellable: Gio.Cancellable | null
        ): globalThis.Promise<PromptReply>;
        /**
         * Complete an operation to prompt for confirmation.
         *
         * %GCR_PROMPT_REPLY_CONTINUE will be returned if the user confirms the prompt. The
         * return value will also be %GCR_PROMPT_REPLY_CANCEL if the user cancels or if
         * an error occurs. Check the `error` argument to tell the difference.
         * @param result asynchronous result passed to callback
         * @returns the reply from the prompt
         */
        confirm_finish(result: Gio.AsyncResult): PromptReply;
        /**
         * Prompts for confirmation asking a cancel/continue style question.
         * Set the various properties on the prompt before calling this function to
         * represent the question correctly.
         *
         * This method will block until the a response is returned from the prompter
         * and will run a main loop similar to a `gtk_dialog_run()`. The application
         * will remain responsive but care must be taken to handle reentrancy issues.
         *
         * %GCR_PROMPT_REPLY_CONTINUE will be returned if the user confirms the prompt. The
         * return value will also be %GCR_PROMPT_REPLY_CANCEL if the user cancels or if
         * an error occurs. Check the `error` argument to tell the difference.
         * @param cancellable optional cancellation object
         * @returns the reply from the prompt
         */
        confirm_run(cancellable: Gio.Cancellable | null): PromptReply;
        /**
         * Get the string handle of the caller's window.
         *
         * The caller window indicates to the prompt which window is prompting the
         * user. The prompt may choose to ignore this information or use it in whatever
         * way it sees fit.
         * @returns a newly allocated string containing the string          handle of the window.
         */
        get_caller_window(): string | null;
        /**
         * Get the label for the cancel button.
         *
         * This is the button that results in a %GCR_PROMPT_REPLY_CANCEL reply
         * from the prompt.
         * @returns a newly allocated string containing the label
         */
        get_cancel_label(): string | null;
        /**
         * Get whether the additional choice was chosen or not.
         *
         * The additional choice would have been setup using
         * gcr_prompt_set_choice_label().
         * @returns whether chosen
         */
        get_choice_chosen(): boolean;
        /**
         * Get the label for the additional choice.
         *
         * This will be %NULL if no additional choice is being displayed.
         * @returns a newly allocated string containing the additional          choice or %NULL
         */
        get_choice_label(): string | null;
        /**
         * Get the label for the continue button.
         *
         * This is the button that results in a %GCR_PROMPT_REPLY_CONTINUE reply
         * from the prompt.
         * @returns a newly allocated string containing the label
         */
        get_continue_label(): string | null;
        /**
         * Get the detailed description of the prompt.
         *
         * A prompt implementation may choose not to display this detailed description.
         * The prompt message should contain relevant information.
         * @returns a newly allocated string containing the detailed          description of the prompt
         */
        get_description(): string | null;
        /**
         * Gets the prompt message for the user.
         *
         * A prompt implementation should always display this message.
         * @returns a newly allocated string containing the detailed          description of the prompt
         */
        get_message(): string | null;
        /**
         * Get whether the prompt will prompt for a new password.
         *
         * This will cause the prompt implementation to ask the user to confirm the
         * password and/or display other relevant user interface for creating a new
         * password.
         * @returns whether in new password mode or not
         */
        get_password_new(): boolean;
        /**
         * Get indication of the password strength.
         *
         * Prompts will return a zero value if the password is empty, and a value
         * greater than zero if the password has any characters.
         *
         * This is only valid after a successful prompt for a password.
         * @returns zero if the password is empty, greater than zero if not
         */
        get_password_strength(): number;
        /**
         * Gets the title of the prompt.
         *
         * A prompt implementation may choose not to display the prompt title. The
         * prompt message should contain relevant information.
         * @returns a newly allocated string containing the prompt          title.
         */
        get_title(): string | null;
        /**
         * Get a prompt warning displayed on the prompt.
         *
         * This is a warning like "The password is incorrect." usually displayed to the
         * user about a previous 'unsuccessful' prompt.
         *
         * If this string is %NULL then no warning is displayed.
         * @returns a newly allocated string containing the prompt          warning, or %NULL if no warning
         */
        get_warning(): string | null;
        /**
         * Prompts for password. Set the various properties on the prompt before calling
         * this method to explain which password should be entered.
         *
         * This method will block until the a response is returned from the prompter.
         *
         * A password will be returned if the user enters a password successfully.
         * The returned password is valid until the next time a method is called
         * to display another prompt.
         *
         * %NULL will be returned if the user cancels or if an error occurs. Check the
         * `error` argument to tell the difference.
         * @param cancellable optional cancellation object
         * @returns the password owned by the prompt, or %NULL
         */
        password(cancellable: Gio.Cancellable | null): string | null;
        /**
         * Prompts for password. Set the various properties on the prompt before calling
         * this method to explain which password should be entered.
         *
         * This method will return immediately and complete asynchronously.
         * @param cancellable optional cancellation object
         * @param callback called when the operation completes
         */
        password_async(
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null
        ): void;

        // Overloads of password_async

        /**
         * Promisified version of {@link password_async}
         *
         * Prompts for password. Set the various properties on the prompt before calling
         * this method to explain which password should be entered.
         *
         * This method will return immediately and complete asynchronously.
         * @param cancellable optional cancellation object
         * @returns A Promise of: the password owned by the prompt, or %NULL
         */
        password_async(
            cancellable: Gio.Cancellable | null
        ): globalThis.Promise<string | null>;
        /**
         * Complete an operation to prompt for a password.
         *
         * A password will be returned if the user enters a password successfully.
         * The returned password is valid until the next time a method is called
         * to display another prompt.
         *
         * %NULL will be returned if the user cancels or if an error occurs. Check the
         * `error` argument to tell the difference.
         * @param result asynchronous result passed to callback
         * @returns the password owned by the prompt, or %NULL
         */
        password_finish(result: Gio.AsyncResult): string | null;
        /**
         * Prompts for password. Set the various properties on the prompt before calling
         * this method to explain which password should be entered.
         *
         * This method will block until the a response is returned from the prompter
         * and will run a main loop similar to a gtk_dialog_run(). The application
         * will remain responsive but care must be taken to handle reentrancy issues.
         *
         * A password will be returned if the user enters a password successfully.
         * The returned password is valid until the next time a method is called
         * to display another prompt.
         *
         * %NULL will be returned if the user cancels or if an error occurs. Check the
         * `error` argument to tell the difference.
         * @param cancellable optional cancellation object
         * @returns the password owned by the prompt, or %NULL
         */
        password_run(cancellable: Gio.Cancellable | null): string | null;
        /**
         * Reset the contents and properties of the prompt.
         */
        reset(): void;
        /**
         * Set the string handle of the caller's window.
         *
         * The caller window indicates to the prompt which window is prompting the
         * user. The prompt may choose to ignore this information or use it in whatever
         * way it sees fit.
         * @param window_id the window id
         */
        set_caller_window(window_id: string | null): void;
        /**
         * Set the label for the continue button.
         *
         * This is the button that results in a %GCR_PROMPT_REPLY_CANCEL reply
         * from the prompt.
         * @param cancel_label the label
         */
        set_cancel_label(cancel_label: string | null): void;
        /**
         * Set whether the additional choice is chosen or not.
         *
         * The additional choice should be set up using gcr_prompt_set_choice_label().
         * @param chosen whether chosen
         */
        set_choice_chosen(chosen: boolean): void;
        /**
         * Set the label for the additional choice.
         *
         * If this is a non-%NULL value then an additional boolean choice will be
         * displayed by the prompt allowing the user to select or deselect it.
         *
         * The initial value of the choice can be set with the
         * gcr_prompt_set_choice_label() method.
         *
         * If this is %NULL, then no additional choice is being displayed.
         * @param choice_label the additional choice or %NULL
         */
        set_choice_label(choice_label: string | null): void;
        /**
         * Set the label for the continue button.
         *
         * This is the button that results in a %GCR_PROMPT_REPLY_CONTINUE reply
         * from the prompt.
         * @param continue_label the label
         */
        set_continue_label(continue_label: string | null): void;
        /**
         * Set the detailed description of the prompt.
         *
         * A prompt implementation may choose not to display this detailed description.
         * Use gcr_prompt_set_message() to set a general message containing relevant
         * information.
         * @param description the detailed description
         */
        set_description(description: string | null): void;
        /**
         * Sets the prompt message for the user.
         *
         * A prompt implementation should always display this message.
         * @param message the prompt message
         */
        set_message(message: string | null): void;
        /**
         * Set whether the prompt will prompt for a new password.
         *
         * This will cause the prompt implementation to ask the user to confirm the
         * password and/or display other relevant user interface for creating a new
         * password.
         * @param new_password whether in new password mode or not
         */
        set_password_new(new_password: boolean): void;
        /**
         * Sets the title of the prompt.
         *
         * A prompt implementation may choose not to display the prompt title. The
         * prompt message should contain relevant information.
         * @param title the prompt title
         */
        set_title(title: string | null): void;
        /**
         * Set a prompt warning displayed on the prompt.
         *
         * This is a warning like "The password is incorrect." usually displayed to the
         * user about a previous 'unsuccessful' prompt.
         *
         * If this string is %NULL then no warning is displayed.
         * @param warning the warning or %NULL
         */
        set_warning(warning: string | null): void;

        // Own virtual methods of Gcr-4.Gcr.Prompt

        vfunc_prompt_close(): void;
        /**
         * Prompts for confirmation asking a cancel/continue style question.
         * Set the various properties on the prompt before calling this method to
         * represent the question correctly.
         *
         * This method will return immediately and complete asynchronously.
         * @virtual
         * @param cancellable optional cancellation object
         * @param callback called when the operation completes
         */
        vfunc_prompt_confirm_async(
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null
        ): void;
        /**
         * Complete an operation to prompt for confirmation.
         *
         * %GCR_PROMPT_REPLY_CONTINUE will be returned if the user confirms the prompt. The
         * return value will also be %GCR_PROMPT_REPLY_CANCEL if the user cancels or if
         * an error occurs. Check the `error` argument to tell the difference.
         * @virtual
         * @param result asynchronous result passed to callback
         * @returns the reply from the prompt
         */
        vfunc_prompt_confirm_finish(result: Gio.AsyncResult): PromptReply;
        /**
         * Prompts for password. Set the various properties on the prompt before calling
         * this method to explain which password should be entered.
         *
         * This method will return immediately and complete asynchronously.
         * @virtual
         * @param cancellable optional cancellation object
         * @param callback called when the operation completes
         */
        vfunc_prompt_password_async(
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null
        ): void;
        /**
         * Complete an operation to prompt for a password.
         *
         * A password will be returned if the user enters a password successfully.
         * The returned password is valid until the next time a method is called
         * to display another prompt.
         *
         * %NULL will be returned if the user cancels or if an error occurs. Check the
         * `error` argument to tell the difference.
         * @virtual
         * @param result asynchronous result passed to callback
         * @returns the password owned by the prompt, or %NULL
         */
        vfunc_prompt_password_finish(result: Gio.AsyncResult): string | null;

        // Own signals of Gcr-4.Gcr.Prompt

        connect(
            sigName: 'prompt-close',
            callback: Prompt.PromptCloseSignalCallback
        ): number;
        connect_after(
            sigName: 'prompt-close',
            callback: Prompt.PromptCloseSignalCallback
        ): number;
        emit(sigName: 'prompt-close', ...args: any[]): void;

        // Class property signals of Gcr-4.Gcr.Prompt

        connect(
            sigName: 'notify::caller-window',
            callback: ($obj: Prompt, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::caller-window',
            callback: ($obj: Prompt, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::caller-window', ...args: any[]): void;
        connect(
            sigName: 'notify::cancel-label',
            callback: ($obj: Prompt, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::cancel-label',
            callback: ($obj: Prompt, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::cancel-label', ...args: any[]): void;
        connect(
            sigName: 'notify::choice-chosen',
            callback: ($obj: Prompt, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::choice-chosen',
            callback: ($obj: Prompt, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::choice-chosen', ...args: any[]): void;
        connect(
            sigName: 'notify::choice-label',
            callback: ($obj: Prompt, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::choice-label',
            callback: ($obj: Prompt, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::choice-label', ...args: any[]): void;
        connect(
            sigName: 'notify::continue-label',
            callback: ($obj: Prompt, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::continue-label',
            callback: ($obj: Prompt, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::continue-label', ...args: any[]): void;
        connect(
            sigName: 'notify::description',
            callback: ($obj: Prompt, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::description',
            callback: ($obj: Prompt, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::description', ...args: any[]): void;
        connect(
            sigName: 'notify::message',
            callback: ($obj: Prompt, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::message',
            callback: ($obj: Prompt, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::message', ...args: any[]): void;
        connect(
            sigName: 'notify::password-new',
            callback: ($obj: Prompt, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::password-new',
            callback: ($obj: Prompt, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::password-new', ...args: any[]): void;
        connect(
            sigName: 'notify::password-strength',
            callback: ($obj: Prompt, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::password-strength',
            callback: ($obj: Prompt, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::password-strength', ...args: any[]): void;
        connect(
            sigName: 'notify::title',
            callback: ($obj: Prompt, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::title',
            callback: ($obj: Prompt, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::title', ...args: any[]): void;
        connect(
            sigName: 'notify::warning',
            callback: ($obj: Prompt, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::warning',
            callback: ($obj: Prompt, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::warning', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * A prompt displayed to the user. It is an interface with various
     * implementations.
     *
     * Various properties are set on the prompt, and then the prompt is displayed
     * the various prompt methods like [method`Prompt`.password_run].
     *
     * A `GcrPrompt` may be used to display multiple related prompts. Most
     * implementions do not hide the window between display of multiple related
     * prompts, and the #GcrPrompt must be closed or destroyed in order to make
     * it go away. This allows the user to see that the prompts are related.
     *
     * Use `GcrPromptDialog` (part of gcr-ui) to create an in-process GTK+ dialog
     * prompt. Use [class`SystemPrompt]` to create a system prompt in a prompter
     * process.
     *
     * The prompt implementation will always display the [property`Prompt:`message]
     * property, but may choose not to display the [property`Prompt:`description] or
     * [property`Prompt:`title] properties.
     * @interface
     */
    class Prompt extends GObject.Object {
        // Own properties of Gcr-4.Gcr.Prompt

        static name: string;
        static $gtype: GObject.GType<Prompt>;

        // Constructors of Gcr-4.Gcr.Prompt

        constructor(config?: Prompt.ConstructorProperties);
        _init(config?: Prompt.ConstructorProperties): void;
    }

    module CertificateChain {
        // Constructor properties interface

        interface ConstructorProperties
            extends GObject.Object.ConstructorProperties {}
    }

    interface CertificateChain {
        // Own properties of Gcr-4.Gcr.CertificateChain

        /**
         * The length of the certificate chain.
         */
        readonly length: number;

        // Own fields of Gcr-4.Gcr.CertificateChain

        parent: GObject.Object;

        // Owm methods of Gcr-4.Gcr.CertificateChain

        /**
         * Add `certificate` to the chain. The order of certificates in the chain are
         * important. The first certificate should be the endpoint certificate, and
         * then come the signers (certificate authorities) each in turn. If a root
         * certificate authority is present, it should come last.
         *
         * Adding a certificate an already built chain (see
         * gcr_certificate_chain_build()) resets the type of the certificate chain
         * to %GCR_CERTIFICATE_CHAIN_UNKNOWN
         * @param certificate a #GcrCertificate to add to the chain
         */
        add(certificate: Certificate): void;
        /**
         * Complete a certificate chain. Once a certificate chain has been built
         * its status can be examined.
         *
         * This operation will lookup missing certificates in PKCS#11
         * modules and also that each certificate in the chain is the signer of the
         * previous one. If a trust anchor, pinned certificate, or self-signed certificate
         * is found, then the chain is considered built. Any extra certificates are
         * removed from the chain.
         *
         * It's important to understand that building of a certificate chain does not
         * constitute verifying that chain. This is merely the first step towards
         * trust verification.
         *
         * The `purpose` is a string like %GCR_PURPOSE_CLIENT_AUTH and is the purpose
         * for which the certificate chain will be used. Trust anchors are looked up
         * for this purpose. This argument is required.
         *
         * The `peer` is usually the host name of the peer whith which this certificate
         * chain is being used. It is used to look up pinned certificates that have
         * been stored for this peer. If %NULL then no pinned certificates will
         * be considered.
         *
         * If the %GCR_CERTIFICATE_CHAIN_NO_LOOKUPS flag is specified then no
         * lookups for anchors or pinned certificates are done, and the resulting chain
         * will be neither anchored or pinned. Additionally no missing certificate
         * authorities are looked up in PKCS#11
         *
         * This call will block, see gcr_certificate_chain_build_async() for the
         * asynchronous version.
         * @param purpose the purpose the certificate chain will be used for
         * @param peer the peer the certificate chain will be used with, or %NULL
         * @param flags chain completion flags
         * @param cancellable a #GCancellable or %NULL
         * @returns whether the operation completed successfully
         */
        build(
            purpose: string | null,
            peer: string | null,
            flags: CertificateChainFlags,
            cancellable: Gio.Cancellable | null
        ): boolean;
        /**
         * Complete a certificate chain. Once a certificate chain has been built
         * its status can be examined.
         *
         * This will lookup missing certificates in PKCS#11
         * modules and also that each certificate in the chain is the signer of the
         * previous one. If a trust anchor, pinned certificate, or self-signed certificate
         * is found, then the chain is considered built. Any extra certificates are
         * removed from the chain.
         *
         * It's important to understand that building of a certificate chain does not
         * constitute verifying that chain. This is merely the first step towards
         * trust verification.
         *
         * The `purpose` is a string like %GCR_PURPOSE_CLIENT_AUTH and is the purpose
         * for which the certificate chain will be used. Trust anchors are looked up
         * for this purpose. This argument is required.
         *
         * The `peer` is usually the host name of the peer whith which this certificate
         * chain is being used. It is used to look up pinned certificates that have
         * been stored for this peer. If %NULL then no pinned certificates will
         * be considered.
         *
         * If the %GCR_CERTIFICATE_CHAIN_NO_LOOKUPS flag is specified then no
         * lookups for anchors or pinned certificates are done, and the resulting chain
         * will be neither anchored or pinned. Additionally no missing certificate
         * authorities are looked up in PKCS#11
         *
         * When the operation is finished, `callback` will be called. You can then call
         * gcr_certificate_chain_build_finish() to get the result of the operation.
         * @param purpose the purpose the certificate chain will be used for
         * @param peer the peer the certificate chain will be used with, or %NULL
         * @param flags chain completion flags
         * @param cancellable a #GCancellable or %NULL
         * @param callback this will be called when the operation completes.
         */
        build_async(
            purpose: string | null,
            peer: string | null,
            flags: CertificateChainFlags,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null
        ): void;

        // Overloads of build_async

        /**
         * Promisified version of {@link build_async}
         *
         * Complete a certificate chain. Once a certificate chain has been built
         * its status can be examined.
         *
         * This will lookup missing certificates in PKCS#11
         * modules and also that each certificate in the chain is the signer of the
         * previous one. If a trust anchor, pinned certificate, or self-signed certificate
         * is found, then the chain is considered built. Any extra certificates are
         * removed from the chain.
         *
         * It's important to understand that building of a certificate chain does not
         * constitute verifying that chain. This is merely the first step towards
         * trust verification.
         *
         * The `purpose` is a string like %GCR_PURPOSE_CLIENT_AUTH and is the purpose
         * for which the certificate chain will be used. Trust anchors are looked up
         * for this purpose. This argument is required.
         *
         * The `peer` is usually the host name of the peer whith which this certificate
         * chain is being used. It is used to look up pinned certificates that have
         * been stored for this peer. If %NULL then no pinned certificates will
         * be considered.
         *
         * If the %GCR_CERTIFICATE_CHAIN_NO_LOOKUPS flag is specified then no
         * lookups for anchors or pinned certificates are done, and the resulting chain
         * will be neither anchored or pinned. Additionally no missing certificate
         * authorities are looked up in PKCS#11
         *
         * When the operation is finished, `callback` will be called. You can then call
         * gcr_certificate_chain_build_finish() to get the result of the operation.
         * @param purpose the purpose the certificate chain will be used for
         * @param peer the peer the certificate chain will be used with, or %NULL
         * @param flags chain completion flags
         * @param cancellable a #GCancellable or %NULL
         * @returns A Promise of: whether the operation succeeded
         */
        build_async(
            purpose: string | null,
            peer: string | null,
            flags: CertificateChainFlags,
            cancellable: Gio.Cancellable | null
        ): globalThis.Promise<boolean>;
        /**
         * Finishes an asynchronous operation started by
         * gcr_certificate_chain_build_async().
         * @param result the #GAsyncResult passed to the callback
         * @returns whether the operation succeeded
         */
        build_finish(result: Gio.AsyncResult): boolean;
        /**
         * If the certificate chain has been built and is of status
         * %GCR_CERTIFICATE_CHAIN_ANCHORED, then this will return the anchor
         * certificate that was found. This is not necessarily a root certificate
         * authority. If an intermediate certificate authority in the chain was
         * found to be anchored, then that certificate will be returned.
         *
         * If an anchor is returned it does not mean that the certificate chain has
         * been verified, but merely that an anchor has been found.
         * @returns the anchor certificate, or %NULL if not anchored.
         */
        get_anchor(): Certificate;
        /**
         * Get a certificate in the chain. It is an error to call this function
         * with an invalid index.
         * @param index index of the certificate to get
         * @returns the certificate
         */
        get_certificate(index: number): Certificate;
        /**
         * Get the endpoint certificate in the chain. This is always the first
         * certificate in the chain. The endpoint certificate cannot be anchored.
         * @returns the endpoint certificate, or %NULL if the chain          is empty
         */
        get_endpoint(): Certificate;
        /**
         * Get the length of the certificate chain.
         * @returns the length of the certificate chain
         */
        get_length(): number;
        /**
         * Get the status of a certificate chain. If the certificate chain has not
         * been built, then the status will be %GCR_CERTIFICATE_CHAIN_UNKNOWN.
         *
         * A status of %GCR_CERTIFICATE_CHAIN_ANCHORED does not mean that the
         * certificate chain has been verified, but merely that an anchor has been
         * found.
         * @returns the status of the certificate chain.
         */
        get_status(): CertificateChainStatus;

        // Class property signals of Gcr-4.Gcr.CertificateChain

        connect(
            sigName: 'notify::length',
            callback: ($obj: CertificateChain, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::length',
            callback: ($obj: CertificateChain, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::length', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * Represents a chain of certificates, normally used to
     * validate the trust in a certificate. An X.509 certificate chain has one
     * endpoint certificate (the one for which trust is being verified) and then
     * in turn the certificate that issued each previous certificate in the chain.
     *
     * This functionality is for building of certificate chains not for validating
     * them. Use your favorite crypto library to validate trust in a certificate
     * chain once its built.
     *
     * The order of certificates in the chain should be first the endpoint
     * certificates and then the signing certificates.
     *
     * Create a new certificate chain with [ctor`CertificateChain`.new] and then
     * add the certificates with [method`CertificateChain`.add].
     *
     * You can then use [method`CertificateChain`.build] to build the remainder of
     * the chain. This will lookup missing certificates in PKCS#11 modules and
     * also check that each certificate in the chain is the signer of the previous
     * one. If a trust anchor, pinned certificate, or self-signed certificate is
     * found, then the chain is considered built. Any extra certificates are
     * removed from the chain.
     *
     * Once the certificate chain has been built, you can access its status
     * through [method`CertificateChain`.get_status]. The status signifies whether
     * the chain is anchored on a trust root, self-signed, incomplete etc. See
     * [enum`CertificateChainStatus]` for information on the various statuses.
     *
     * It's important to understand that the building of a certificate chain is
     * merely the first step towards verifying trust in a certificate.
     * @class
     */
    class CertificateChain extends GObject.Object {
        // Own properties of Gcr-4.Gcr.CertificateChain

        static name: string;
        static $gtype: GObject.GType<CertificateChain>;

        // Constructors of Gcr-4.Gcr.CertificateChain

        constructor(config?: CertificateChain.ConstructorProperties);
        /**
         * Create a new #GcrCertificateChain.
         * @constructor
         * @returns a newly allocated certificate chain
         */
        constructor();
        /**
         * Create a new #GcrCertificateChain.
         * @constructor
         * @returns a newly allocated certificate chain
         */
        static new(): CertificateChain;
        _init(config?: CertificateChain.ConstructorProperties): void;
    }

    module CertificateField {
        // Constructor properties interface

        interface ConstructorProperties
            extends GObject.Object.ConstructorProperties {
            // Own constructor properties of Gcr-4.Gcr.CertificateField

            label?: string | null;
            section?: CertificateSection | null;
        }
    }

    interface CertificateField {
        // Own properties of Gcr-4.Gcr.CertificateField

        readonly label: string | null;
        readonly section: CertificateSection;
        readonly value: any;

        // Owm methods of Gcr-4.Gcr.CertificateField

        /**
         * Get the display label of the field.
         * @returns the display label of the field
         */
        get_label(): string | null;
        /**
         * Get the parent #GcrCertificateSection.
         * @returns the parent #GcrCertificateSection
         */
        get_section(): CertificateSection;
        /**
         * Get the value of the field.
         *
         * The `value` will have been initialized to the `GType` the value should be
         * provided in.
         * @returns %TRUE if the value was set successfully.
         */
        get_value(): [/* returnType */ boolean, /* value */ any];
        /**
         * Get the type associated with the value.
         * @returns The `GType` of the value
         */
        get_value_type(): GObject.GType;

        // Class property signals of Gcr-4.Gcr.CertificateField

        connect(
            sigName: 'notify::label',
            callback: ($obj: CertificateField, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::label',
            callback: ($obj: CertificateField, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::label', ...args: any[]): void;
        connect(
            sigName: 'notify::section',
            callback: ($obj: CertificateField, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::section',
            callback: ($obj: CertificateField, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::section', ...args: any[]): void;
        connect(
            sigName: 'notify::value',
            callback: ($obj: CertificateField, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::value',
            callback: ($obj: CertificateField, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::value', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    class CertificateField extends GObject.Object {
        // Own properties of Gcr-4.Gcr.CertificateField

        static name: string;
        static $gtype: GObject.GType<CertificateField>;

        // Constructors of Gcr-4.Gcr.CertificateField

        constructor(config?: CertificateField.ConstructorProperties);
        _init(config?: CertificateField.ConstructorProperties): void;
    }

    module CertificateRequest {
        // Constructor properties interface

        interface ConstructorProperties
            extends GObject.Object.ConstructorProperties {
            // Own constructor properties of Gcr-4.Gcr.CertificateRequest

            /**
             * The private key that this certificate request is for.
             */
            private_key?: Gck.Object | null;
        }
    }

    interface CertificateRequest {
        // Own properties of Gcr-4.Gcr.CertificateRequest

        /**
         * The private key that this certificate request is for.
         */
        readonly private_key: Gck.Object;

        // Owm methods of Gcr-4.Gcr.CertificateRequest

        /**
         * Complete and sign a certificate request, so that it can be encoded
         * and sent to a certificate authority.
         *
         * This call may block as it signs the request using the private key.
         * @param cancellable a cancellation object
         * @returns whether certificate request was successfully completed or not
         */
        complete(cancellable: Gio.Cancellable | null): boolean;
        /**
         * Asynchronously complete and sign a certificate request, so that it can
         * be encoded and sent to a certificate authority.
         *
         * This call will return immediately and complete later.
         * @param cancellable a cancellation object
         * @param callback called when the operation completes
         */
        complete_async(
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null
        ): void;

        // Overloads of complete_async

        /**
         * Promisified version of {@link complete_async}
         *
         * Asynchronously complete and sign a certificate request, so that it can
         * be encoded and sent to a certificate authority.
         *
         * This call will return immediately and complete later.
         * @param cancellable a cancellation object
         * @returns A Promise of: whether certificate request was successfully completed or not
         */
        complete_async(
            cancellable: Gio.Cancellable | null
        ): globalThis.Promise<boolean>;
        /**
         * Finish an asynchronous operation to complete and sign a certificate
         * request.
         * @param result result of the asynchronous operation
         * @returns whether certificate request was successfully completed or not
         */
        complete_finish(result: Gio.AsyncResult): boolean;
        /**
         * Encode the certificate request. It must have been completed with
         * [method`CertificateRequest`.complete] or
         * [method`CertificateRequest`.complete_async].
         *
         * If `textual` is %FALSE, the output is a DER encoded certificate request.
         *
         * If `textual` is %TRUE, the output is encoded as text. For PKCS#10 requests
         * this is done using the OpenSSL style PEM encoding.
         * @param textual whether to encode output as text
         * @returns the encoded certificate request
         */
        encode(textual: boolean): Uint8Array;
        /**
         * Get the format of this certificate request.
         * @returns the format
         */
        get_format(): CertificateRequestFormat;
        /**
         * Get the private key this certificate request is for.
         * @returns the private key,
         */
        get_private_key(): Gck.Object;
        /**
         * Set the common name encoded in the certificate request.
         * @param cn common name to set on the request
         */
        set_cn(cn: string | null): void;

        // Class property signals of Gcr-4.Gcr.CertificateRequest

        connect(
            sigName: 'notify::private-key',
            callback: (
                $obj: CertificateRequest,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::private-key',
            callback: (
                $obj: CertificateRequest,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::private-key', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * An object that allows creation of certificate requests. A certificate
     * request is sent to a certificate authority to request an X.509 certificate.
     *
     * Use [func`CertificateRequest`.prepare] to create a blank certificate
     * request for a given private key. Set the common name on the certificate
     * request with [method`CertificateRequest`.set_cn], and then sign the request
     * with [method`CertificateRequest`.complete_async].
     * @class
     */
    class CertificateRequest extends GObject.Object {
        // Own properties of Gcr-4.Gcr.CertificateRequest

        static name: string;
        static $gtype: GObject.GType<CertificateRequest>;

        // Constructors of Gcr-4.Gcr.CertificateRequest

        constructor(config?: CertificateRequest.ConstructorProperties);
        _init(config?: CertificateRequest.ConstructorProperties): void;
        /**
         * Check whether [class`CertificateRequest]` is capable of creating a request
         * for the given `private_key`.
         * @param private_key a private key
         * @param cancellable cancellation object
         * @returns whether a request can be created
         */
        static capable(
            private_key: Gck.Object,
            cancellable: Gio.Cancellable | null
        ): boolean;
        /**
         * Asynchronously check whether [class`CertificateRequest]` is capable of
         * creating a request for the given `private_key`.
         * @param private_key a private key
         * @param cancellable cancellation object
         * @param callback will be called when the operation completes
         */
        static capable_async(
            private_key: Gck.Object,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<CertificateRequest> | null
        ): void;
        /**
         * Get the result for asynchronously check whether [class`CertificateRequest]` is
         * capable of creating a request for the given `private_key`.
         * @param result asynchronous result
         * @returns whether a request can be created
         */
        static capable_finish(result: Gio.AsyncResult): boolean;
        /**
         * Create a new certificate request, in the given format for the private key.
         * @param format the format for the certificate request
         * @param private_key the private key the the certificate is being requested for
         * @returns a new #GcrCertificate request
         */
        static prepare(
            format: CertificateRequestFormat,
            private_key: Gck.Object
        ): CertificateRequest;
    }

    module CertificateSection {
        // Constructor properties interface

        interface ConstructorProperties
            extends GObject.Object.ConstructorProperties {
            // Own constructor properties of Gcr-4.Gcr.CertificateSection

            label?: string | null;
        }
    }

    interface CertificateSection {
        // Own properties of Gcr-4.Gcr.CertificateSection

        readonly fields: Gio.ListModel;
        readonly label: string | null;

        // Owm methods of Gcr-4.Gcr.CertificateSection

        /**
         * Get the list of all the fields in this section.
         * @returns a #GListModel of #GcrCertificateField
         */
        get_fields(): Gio.ListModel;
        /**
         * Get the flags.
         * @returns the `GcrCertificateSectionFlags`
         */
        get_flags(): CertificateSectionFlags;
        /**
         * Get the displayable label of the section.
         * @returns the displayable label of the section
         */
        get_label(): string | null;

        // Class property signals of Gcr-4.Gcr.CertificateSection

        connect(
            sigName: 'notify::fields',
            callback: (
                $obj: CertificateSection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::fields',
            callback: (
                $obj: CertificateSection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::fields', ...args: any[]): void;
        connect(
            sigName: 'notify::label',
            callback: (
                $obj: CertificateSection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::label',
            callback: (
                $obj: CertificateSection,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::label', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    class CertificateSection extends GObject.Object {
        // Own properties of Gcr-4.Gcr.CertificateSection

        static name: string;
        static $gtype: GObject.GType<CertificateSection>;

        // Constructors of Gcr-4.Gcr.CertificateSection

        constructor(config?: CertificateSection.ConstructorProperties);
        _init(config?: CertificateSection.ConstructorProperties): void;
    }

    module Parser {
        // Signal callback interfaces

        /**
         * Signal callback interface for `authenticate`
         */
        interface AuthenticateSignalCallback {
            ($obj: Parser, count: number): boolean;
        }

        /**
         * Signal callback interface for `parsed`
         */
        interface ParsedSignalCallback {
            ($obj: Parser): void;
        }

        // Constructor properties interface

        interface ConstructorProperties
            extends GObject.Object.ConstructorProperties {}
    }

    interface Parser {
        // Own properties of Gcr-4.Gcr.Parser

        /**
         * Get the attributes that make up the currently parsed item. This is
         * generally only valid during a [signal`Parser:`:parsed] signal.
         */
        readonly parsed_attributes: Gck.Attributes;
        /**
         * The description of the type of the currently parsed item. This is generally
         * only valid during a [signal`Parser:`:parsed] signal.
         */
        readonly parsed_description: string | null;
        /**
         * The label of the currently parsed item. This is generally
         * only valid during a [signal`Parser:`:parsed] signal.
         */
        readonly parsed_label: string | null;

        // Own fields of Gcr-4.Gcr.Parser

        parent: GObject.Object;

        // Owm methods of Gcr-4.Gcr.Parser

        /**
         * Add a password to the set of passwords to try when parsing locked or encrypted
         * items. This is usually called from the [signal`Parser:`:authenticate] signal.
         * @param password a password to try
         */
        add_password(password: string | null): void;
        /**
         * Disable parsing of the given format. Use %GCR_FORMAT_ALL to disable all the formats.
         * @param format The format identifier
         */
        format_disable(format: DataFormat): void;
        /**
         * Enable parsing of the given format. Use %GCR_FORMAT_ALL to enable all the formats.
         * @param format The format identifier
         */
        format_enable(format: DataFormat): void;
        /**
         * Check whether the given format is supported by the parser.
         * @param format The format identifier
         * @returns Whether the format is supported.
         */
        format_supported(format: DataFormat): boolean;
        /**
         * Get the filename of the parser item.
         * @returns the filename set on the parser, or %NULL
         */
        get_filename(): string | null;
        /**
         * Get the currently parsed item
         * @returns the currently parsed item
         */
        get_parsed(): Parsed;
        /**
         * Get the attributes which make up the currently parsed item. This is generally
         * only valid during the [signal`Parser:`:parsed] signal.
         * @returns the attributes for the current item,          which are owned by the parser and should not be freed
         */
        get_parsed_attributes(): Gck.Attributes | null;
        /**
         * Get the raw data block that represents this parsed object. This is only
         * valid during the [signal`Parser:`:parsed] signal.
         * @returns the raw data          block of the currently parsed item; the value is owned by the parser          and should not be freed
         */
        get_parsed_block(): Uint8Array | null;
        /**
         * Get the raw data block that represents this parsed object. This is only
         * valid during the [signal`Parser:`:parsed] signal.
         * @returns the raw data block of the currently parsed item
         */
        get_parsed_bytes(): GLib.Bytes;
        /**
         * Get a description for the type of the currently parsed item. This is generally
         * only valid during the [signal`Parser:`:parsed] signal.
         * @returns the description for the current item; this is owned by          the parser and should not be freed
         */
        get_parsed_description(): string | null;
        /**
         * Get the format of the raw data block that represents this parsed object.
         * This corresponds with the data returned from
         * [method`Parser`.get_parsed_block].
         *
         * This is only valid during the [signal`Parser:`:parsed] signal.
         * @returns the data format of the currently parsed item
         */
        get_parsed_format(): DataFormat;
        /**
         * Get the label of the currently parsed item. This is generally only valid
         * during the [signal`Parser:`:parsed] signal.
         * @returns the label of the currently parsed item. The value is          owned by the parser and should not be freed.
         */
        get_parsed_label(): string | null;
        /**
         * Parse the data. The [signal`Parser:`:parsed] and
         * [signal`Parser:`:authenticate] signals may fire during the parsing.
         * @param data the data to parse
         * @returns Whether the data was parsed successfully or not.
         */
        parse_bytes(data: GLib.Bytes): boolean;
        /**
         * Parse the data. The [signal`Parser:`:parsed] and [signal`Parser:`:authenticate]
         * signals may fire during the parsing.
         *
         * A copy of the data will be made. Use [method`Parser`.parse_bytes] to avoid
         * this.
         * @param data the data to parse
         * @returns Whether the data was parsed successfully or not.
         */
        parse_data(data: Uint8Array): boolean;
        /**
         * Parse items from the data in a #GInputStream. This function may block while
         * reading from the input stream. Use [method`Parser`.parse_stream_async] for
         * a non-blocking variant.
         *
         * The [signal`Parser:`:parsed] and [signal`Parser:`:authenticate] signals
         * may fire during the parsing.
         * @param input The input stream
         * @param cancellable An optional cancellation object
         * @returns Whether the parsing completed successfully or not.
         */
        parse_stream(
            input: Gio.InputStream,
            cancellable: Gio.Cancellable | null
        ): boolean;
        /**
         * Parse items from the data in a #GInputStream. This function completes
         * asyncronously and doesn't block.
         *
         * The [signal`Parser:`:parsed] and [signal`Parser:`:authenticate] signals
         * may fire during the parsing.
         * @param input The input stream
         * @param cancellable An optional cancellation object
         * @param callback Called when the operation result is ready.
         */
        parse_stream_async(
            input: Gio.InputStream,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null
        ): void;

        // Overloads of parse_stream_async

        /**
         * Promisified version of {@link parse_stream_async}
         *
         * Parse items from the data in a #GInputStream. This function completes
         * asyncronously and doesn't block.
         *
         * The [signal`Parser:`:parsed] and [signal`Parser:`:authenticate] signals
         * may fire during the parsing.
         * @param input The input stream
         * @param cancellable An optional cancellation object
         * @returns A Promise of: Whether the parsing completed successfully or not.
         */
        parse_stream_async(
            input: Gio.InputStream,
            cancellable: Gio.Cancellable | null
        ): globalThis.Promise<boolean>;
        /**
         * Complete an operation to parse a stream.
         * @param result The operation result
         * @returns Whether the parsing completed successfully or not.
         */
        parse_stream_finish(result: Gio.AsyncResult): boolean;
        /**
         * Sets the filename of the parser item.
         * @param filename a string of the filename of the parser item
         */
        set_filename(filename: string | null): void;

        // Own virtual methods of Gcr-4.Gcr.Parser

        vfunc_authenticate(count: number): boolean;
        vfunc_parsed(): void;

        // Own signals of Gcr-4.Gcr.Parser

        connect(
            sigName: 'authenticate',
            callback: Parser.AuthenticateSignalCallback
        ): number;
        connect_after(
            sigName: 'authenticate',
            callback: Parser.AuthenticateSignalCallback
        ): number;
        emit(sigName: 'authenticate', count: number, ...args: any[]): void;
        connect(
            sigName: 'parsed',
            callback: Parser.ParsedSignalCallback
        ): number;
        connect_after(
            sigName: 'parsed',
            callback: Parser.ParsedSignalCallback
        ): number;
        emit(sigName: 'parsed', ...args: any[]): void;

        // Class property signals of Gcr-4.Gcr.Parser

        connect(
            sigName: 'notify::parsed-attributes',
            callback: ($obj: Parser, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::parsed-attributes',
            callback: ($obj: Parser, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::parsed-attributes', ...args: any[]): void;
        connect(
            sigName: 'notify::parsed-description',
            callback: ($obj: Parser, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::parsed-description',
            callback: ($obj: Parser, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::parsed-description', ...args: any[]): void;
        connect(
            sigName: 'notify::parsed-label',
            callback: ($obj: Parser, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::parsed-label',
            callback: ($obj: Parser, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::parsed-label', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * A parser for parsing various types of files or data.
     *
     * A `GcrParser` can parse various certificate and key files such as OpenSSL
     * PEM files, DER encoded certifictes, PKCS#8 keys and so on. Each various
     * format is identified by a value in the [enum`DataFormat]` enumeration.
     *
     * In order to parse data, a new parser is created with gcr_parser_new() and
     * then the [signal`Parser:`:authenticate] and [signal`Parser:`:parsed] signals
     * should be connected to. Data is then fed to the parser via
     * [method`Parser`.parse_data] or [method`Parser`.parse_stream].
     *
     * During the [signal`Parser:`:parsed] signal the attributes that make up the
     * currently parsed item can be retrieved using the
     * [method`Parser`.get_parsed_attributes] function.
     * @class
     */
    class Parser extends GObject.Object {
        // Own properties of Gcr-4.Gcr.Parser

        static name: string;
        static $gtype: GObject.GType<Parser>;

        // Constructors of Gcr-4.Gcr.Parser

        constructor(config?: Parser.ConstructorProperties);
        /**
         * Create a new #GcrParser
         * @constructor
         * @returns a newly allocated #GcrParser
         */
        constructor();
        /**
         * Create a new #GcrParser
         * @constructor
         * @returns a newly allocated #GcrParser
         */
        static new(): Parser;
        _init(config?: Parser.ConstructorProperties): void;
    }

    module Pkcs11Certificate {
        // Constructor properties interface

        interface ConstructorProperties
            extends Certificate.ConstructorProperties,
                Gck.Object.ConstructorProperties {
            // Own constructor properties of Gcr-4.Gcr.Pkcs11Certificate

            /**
             * Automatically loaded attributes for this certificate.
             */
            attributes?: Gck.Attributes | null;
        }
    }

    interface Pkcs11Certificate extends Certificate {
        // Own properties of Gcr-4.Gcr.Pkcs11Certificate

        /**
         * Automatically loaded attributes for this certificate.
         */
        readonly attributes: Gck.Attributes;

        // Own fields of Gcr-4.Gcr.Pkcs11Certificate

        parent: Gck.Object;

        // Owm methods of Gcr-4.Gcr.Pkcs11Certificate

        /**
         * Access the automatically loaded attributes for this certificate.
         * @returns the certificate attributes
         */
        get_attributes(): Gck.Attributes;

        // Conflicting methods

        /**
         * Get the data for the specified attribute from the object. For convenience
         * the returned data has a null terminator.
         *
         * This call may block for an indefinite period.
         * @param attr_type The attribute to get data for.
         * @param cancellable A #GCancellable or %NULL
         * @returns the resulting PKCS#11          attribute data, or %NULL if an error occurred
         */
        get_data(
            attr_type: number,
            cancellable: Gio.Cancellable | null
        ): Uint8Array;

        // Overloads of get_data

        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string | null): any | null;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string | null): any | null;

        // Class property signals of Gcr-4.Gcr.Pkcs11Certificate

        connect(
            sigName: 'notify::attributes',
            callback: (
                $obj: Pkcs11Certificate,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::attributes',
            callback: (
                $obj: Pkcs11Certificate,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::attributes', ...args: any[]): void;
        connect(
            sigName: 'notify::handle',
            callback: (
                $obj: Pkcs11Certificate,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::handle',
            callback: (
                $obj: Pkcs11Certificate,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::handle', ...args: any[]): void;
        connect(
            sigName: 'notify::module',
            callback: (
                $obj: Pkcs11Certificate,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::module',
            callback: (
                $obj: Pkcs11Certificate,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::module', ...args: any[]): void;
        connect(
            sigName: 'notify::session',
            callback: (
                $obj: Pkcs11Certificate,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::session',
            callback: (
                $obj: Pkcs11Certificate,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::session', ...args: any[]): void;
        connect(
            sigName: 'notify::description',
            callback: (
                $obj: Pkcs11Certificate,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::description',
            callback: (
                $obj: Pkcs11Certificate,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::description', ...args: any[]): void;
        connect(
            sigName: 'notify::expiry-date',
            callback: (
                $obj: Pkcs11Certificate,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::expiry-date',
            callback: (
                $obj: Pkcs11Certificate,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::expiry-date', ...args: any[]): void;
        connect(
            sigName: 'notify::issuer-name',
            callback: (
                $obj: Pkcs11Certificate,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::issuer-name',
            callback: (
                $obj: Pkcs11Certificate,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::issuer-name', ...args: any[]): void;
        connect(
            sigName: 'notify::label',
            callback: (
                $obj: Pkcs11Certificate,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::label',
            callback: (
                $obj: Pkcs11Certificate,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::label', ...args: any[]): void;
        connect(
            sigName: 'notify::subject-name',
            callback: (
                $obj: Pkcs11Certificate,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::subject-name',
            callback: (
                $obj: Pkcs11Certificate,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::subject-name', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * A certificate loaded from a PKCS#11 storage.
     * It is also a valid [class`Gck`.Object] and can be used as such.
     *
     * Use gcr_pkcs11_certificate_lookup_issuer() to lookup the issuer of a given
     * certificate in the PKCS#11 store.
     *
     * Various common PKCS#11 certificate attributes are automatically loaded and
     * are available via gcr_pkcs11_certificate_get_attributes().
     * @class
     */
    class Pkcs11Certificate extends Gck.Object {
        // Own properties of Gcr-4.Gcr.Pkcs11Certificate

        static name: string;
        static $gtype: GObject.GType<Pkcs11Certificate>;

        // Constructors of Gcr-4.Gcr.Pkcs11Certificate

        constructor(config?: Pkcs11Certificate.ConstructorProperties);
        _init(config?: Pkcs11Certificate.ConstructorProperties): void;
        /**
         * Lookup a certificate in the PKCS#11 storage by the given URI.
         *
         * This call may block, see gcr_pkcs11_certificate_new_from_uri_async() for the
         * non-blocking version.
         *
         * Will return %NULL if no certificate is found. Use `error` to determine
         * if an error occurred.
         * @param pkcs11_uri a A PKCS \#11 URI
         * @param cancellable a #GCancellable
         * @returns a new #GcrCertificate, or %NULL
         */
        static new_from_uri(
            pkcs11_uri: string | null,
            cancellable: Gio.Cancellable | null
        ): Certificate | null;
        /**
         * Lookup a certificate in the PKCS#11 storage by the given URI.
         *
         * When the operation is finished, callback will be called. You can then call
         * gcr_pkcs11_certificate_new_from_uri_finish() to get the result of the
         * operation.
         * @param pkcs11_uri a A PKCS \#11 URI
         * @param cancellable a #GCancellable
         * @param callback a #GAsyncReadyCallback to call when the operation completes
         */
        static new_from_uri_async(
            pkcs11_uri: string | null,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<Pkcs11Certificate> | null
        ): void;
        /**
         * Finishes an asynchronous operation started by
         * gcr_pkcs11_certificate_new_from_uri_async().
         *
         * Will return %NULL if no certificate is found. Use `error` to determine
         * if an error occurred.
         * @param result the #GAsyncResult passed to the callback
         * @returns a new #GcrCertificate, or %NULL
         */
        static new_from_uri_finish(result: Gio.AsyncResult): Certificate | null;
        /**
         * Lookup a the issuer of a `certificate` in the PKCS#11 storage. The
         * lookup is done using the issuer DN of the certificate. No certificate chain
         * verification is done. Use a crypto library to make trust decisions.
         *
         * This call may block, see gcr_pkcs11_certificate_lookup_issuer() for the
         * non-blocking version.
         *
         * Will return %NULL if no issuer certificate is found. Use `error` to determine
         * if an error occurred.
         * @param certificate a #GcrCertificate
         * @param cancellable a #GCancellable
         * @returns a new #GcrPkcs11Certificate, or %NULL
         */
        static lookup_issuer(
            certificate: Certificate,
            cancellable: Gio.Cancellable | null
        ): Certificate;
        /**
         * Lookup a the issuer of a `certificate` in the PKCS#11 storage. The
         * lookup is done using the issuer DN of the certificate. No certificate chain
         * verification is done. Use a crypto library to make trust decisions.
         *
         * When the operation is finished, callback will be called. You can then call
         * gcr_pkcs11_certificate_lookup_issuer_finish() to get the result of the
         * operation.
         * @param certificate a #GcrCertificate
         * @param cancellable a #GCancellable
         * @param callback a #GAsyncReadyCallback to call when the operation completes
         */
        static lookup_issuer_async(
            certificate: Certificate,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<Pkcs11Certificate> | null
        ): void;
        /**
         * Finishes an asynchronous operation started by
         * gcr_pkcs11_certificate_lookup_issuer_async().
         *
         * Will return %NULL if no issuer certificate is found. Use `error` to determine
         * if an error occurred.
         * @param result the #GAsyncResult passed to the callback
         * @returns a new #GcrPkcs11Certificate, or %NULL
         */
        static lookup_issuer_finish(result: Gio.AsyncResult): Certificate;
    }

    module SecretExchange {
        // Constructor properties interface

        interface ConstructorProperties
            extends GObject.Object.ConstructorProperties {
            // Own constructor properties of Gcr-4.Gcr.SecretExchange

            /**
             * The protocol being used for the exchange.
             *
             * Will be %NULL if no protocol was specified when creating this object,
             * and either [method`SecretExchange`.begin] or [method`SecretExchange`.receive]
             * have not been called successfully.
             */
            protocol?: string | null;
        }
    }

    interface SecretExchange {
        // Own properties of Gcr-4.Gcr.SecretExchange

        /**
         * The protocol being used for the exchange.
         *
         * Will be %NULL if no protocol was specified when creating this object,
         * and either [method`SecretExchange`.begin] or [method`SecretExchange`.receive]
         * have not been called successfully.
         */
        readonly protocol: string | null;

        // Owm methods of Gcr-4.Gcr.SecretExchange

        /**
         * Begin the secret exchange. The resulting string should be sent to the other
         * side of the exchange. The other side should use [method`SecretExchange`.receive]
         * to process the string.
         * @returns A newly allocated string to be sent to the other     side of the secret exchange
         */
        begin(): string | null;
        /**
         * Will return %NULL if no protocol was specified, and either
         * [method`SecretExchange`.begin] or [method`SecretExchange`.receive] have not
         * been called successfully.
         * @returns the protocol or %NULL
         */
        get_protocol(): string | null;
        /**
         * Returns the last secret received. If no secret has yet been received this
         * will return %NULL. The string is owned by the #GcrSecretExchange object
         * and will be valid until the next time that gcr_secret_exchange_receive()
         * is called on this object, or the object is destroyed.
         *
         * Depending on the secret passed into the other side of the secret exchange,
         * the result may be a binary string. It does however have a null terminator,
         * so if you're certain that it is does not contain arbitrary binary data,
         * it can be used as a string.
         * @returns the last secret received
         */
        get_secret(): string[];
        /**
         * Receive a string from the other side of secret exchange. This string will
         * have been created by [method`SecretExchange`.begin] or
         * [method`SecretExchange`.send].
         *
         * After this call completes successfully the value returned from
         * gcr_secret_exchange_get_secret() will have changed.
         * @param exchange the string received
         * @returns whether the string was successfully parsed and received
         */
        receive(exchange: string | null): boolean;
        /**
         * Send a reply to the other side of the secret exchange, optionally sending a
         * secret.
         *
         * [method`SecretExchange`.receive] must have been successfully called at least
         * once on this object. In other words this object must have received data
         * from the other side of the secret exchange, before we can send a secret.
         * @param secret optionally, a secret to send to the other side
         * @param secret_len length of `secret,` or -1 if null terminated
         * @returns a newly allocated string to be sent to the other     side of the secret exchange
         */
        send(secret: string | null, secret_len: number): string | null;

        // Own virtual methods of Gcr-4.Gcr.SecretExchange

        vfunc_derive_transport_key(peer: number, n_peer: number): boolean;
        vfunc_generate_exchange_key(
            scheme: string | null,
            public_key: number,
            n_public_key: number
        ): boolean;

        // Class property signals of Gcr-4.Gcr.SecretExchange

        connect(
            sigName: 'notify::protocol',
            callback: ($obj: SecretExchange, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::protocol',
            callback: ($obj: SecretExchange, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::protocol', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * Allows exchange of secrets between two processes on the same system without
     * exposing those secrets to things like loggers, non-pageable memory etc.
     *
     * This does not protect against active attacks like MITM attacks.
     *
     * Each side creates a secret exchange object, and one of the sides calls
     * [method`SecretExchange`.begin]. This creates a string, which should be passed
     * to the other side. Each side passes the strings it receives into
     * [method`SecretExchange`.receive].
     *
     * In order to send a reply (either with or without a secret) use
     * [method`SecretExchange`.send]. A side must have successfully called
     * [method`SecretExchange`.receive] before it can use
     * [method`SecretExchange`.send].
     *
     * The secret exchange objects can be used for multiple iterations of the
     * conversation, or for just one request/reply. The only limitation being that
     * the initial request cannot contain a secret.
     *
     * Caveat: Information about the approximate length (rounded up to the nearest
     * 16 bytes) may be leaked. If this is considered inacceptable, do not use
     * [class`SecretExchange]`.
     * @class
     */
    class SecretExchange extends GObject.Object {
        // Own properties of Gcr-4.Gcr.SecretExchange

        static name: string;
        static $gtype: GObject.GType<SecretExchange>;

        // Constructors of Gcr-4.Gcr.SecretExchange

        constructor(config?: SecretExchange.ConstructorProperties);
        /**
         * Create a new secret exchange object.
         *
         * Specify a protocol of %NULL to allow any protocol. This is especially
         * relevant on the side of the exchange that does not call
         * [method`SecretExchange`.begin], that is the originator. Currently the only
         * protocol supported is %GCR_SECRET_EXCHANGE_PROTOCOL_1.
         * @constructor
         * @param protocol the exchange protocol to use
         * @returns A new #GcrSecretExchange object
         */
        constructor(protocol: string | null);
        /**
         * Create a new secret exchange object.
         *
         * Specify a protocol of %NULL to allow any protocol. This is especially
         * relevant on the side of the exchange that does not call
         * [method`SecretExchange`.begin], that is the originator. Currently the only
         * protocol supported is %GCR_SECRET_EXCHANGE_PROTOCOL_1.
         * @constructor
         * @param protocol the exchange protocol to use
         * @returns A new #GcrSecretExchange object
         */
        static new(protocol: string | null): SecretExchange;
        _init(config?: SecretExchange.ConstructorProperties): void;
    }

    module SimpleCertificate {
        // Constructor properties interface

        interface ConstructorProperties
            extends Certificate.ConstructorProperties,
                GObject.Object.ConstructorProperties {}
    }

    interface SimpleCertificate extends Certificate {
        // Own fields of Gcr-4.Gcr.SimpleCertificate

        parent: GObject.Object;

        // Class property signals of Gcr-4.Gcr.SimpleCertificate

        connect(
            sigName: 'notify::description',
            callback: (
                $obj: SimpleCertificate,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::description',
            callback: (
                $obj: SimpleCertificate,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::description', ...args: any[]): void;
        connect(
            sigName: 'notify::expiry-date',
            callback: (
                $obj: SimpleCertificate,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::expiry-date',
            callback: (
                $obj: SimpleCertificate,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::expiry-date', ...args: any[]): void;
        connect(
            sigName: 'notify::issuer-name',
            callback: (
                $obj: SimpleCertificate,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::issuer-name',
            callback: (
                $obj: SimpleCertificate,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::issuer-name', ...args: any[]): void;
        connect(
            sigName: 'notify::label',
            callback: (
                $obj: SimpleCertificate,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::label',
            callback: (
                $obj: SimpleCertificate,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::label', ...args: any[]): void;
        connect(
            sigName: 'notify::subject-name',
            callback: (
                $obj: SimpleCertificate,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        connect_after(
            sigName: 'notify::subject-name',
            callback: (
                $obj: SimpleCertificate,
                pspec: GObject.ParamSpec
            ) => void
        ): number;
        emit(sigName: 'notify::subject-name', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * An implementation of [iface`Certificate]` which loads a certificate from DER
     * data already located in memory.
     *
     * To create an object, use the [ctor`SimpleCertificate`.new] or
     * [ctor`SimpleCertificate`.new_static] functions.
     * @class
     */
    class SimpleCertificate extends GObject.Object {
        // Own properties of Gcr-4.Gcr.SimpleCertificate

        static name: string;
        static $gtype: GObject.GType<SimpleCertificate>;

        // Constructors of Gcr-4.Gcr.SimpleCertificate

        constructor(config?: SimpleCertificate.ConstructorProperties);
        /**
         * Create a new #GcrSimpleCertificate for the raw DER data. The `data` memory is
         * copied so you can dispose of it after this function returns.
         * @constructor
         * @param data the raw DER certificate data
         * @returns a new #GcrSimpleCertificate
         */
        constructor(data: Uint8Array);
        /**
         * Create a new #GcrSimpleCertificate for the raw DER data. The `data` memory is
         * copied so you can dispose of it after this function returns.
         * @constructor
         * @param data the raw DER certificate data
         * @returns a new #GcrSimpleCertificate
         */
        static new(data: Uint8Array): SimpleCertificate;
        _init(config?: SimpleCertificate.ConstructorProperties): void;
    }

    module SshAskpass {
        // Constructor properties interface

        interface ConstructorProperties
            extends GObject.Object.ConstructorProperties {
            // Own constructor properties of Gcr-4.Gcr.SshAskpass

            /**
             * The interaction used to prompt for passwords.
             */
            interaction?: Gio.TlsInteraction | null;
        }
    }

    interface SshAskpass {
        // Own properties of Gcr-4.Gcr.SshAskpass

        /**
         * The interaction used to prompt for passwords.
         */
        readonly interaction: Gio.TlsInteraction;

        // Owm methods of Gcr-4.Gcr.SshAskpass

        /**
         * Get the interaction associated with this object.
         * @returns the interaction
         */
        get_interaction(): Gio.TlsInteraction;

        // Class property signals of Gcr-4.Gcr.SshAskpass

        connect(
            sigName: 'notify::interaction',
            callback: ($obj: SshAskpass, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::interaction',
            callback: ($obj: SshAskpass, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::interaction', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * When used as the setup function while spawning an ssh command like ssh-add
     * or ssh, this allows callbacks for passwords on the provided interaction.
     * @class
     */
    class SshAskpass extends GObject.Object {
        // Own properties of Gcr-4.Gcr.SshAskpass

        static name: string;
        static $gtype: GObject.GType<SshAskpass>;

        // Constructors of Gcr-4.Gcr.SshAskpass

        constructor(config?: SshAskpass.ConstructorProperties);
        /**
         * Create a new GcrSshAskpass object which can be used to spawn an
         * ssh command and prompt for any necessary passwords.
         *
         * Use the gcr_ssh_askpass_child_setup() function as a callback with
         * g_spawn_sync(), g_spawn_async() or g_spawn_async_with_pipes().
         * @constructor
         * @param interaction the interaction to use for prompting paswords
         * @returns A new #GcrSshAskpass object
         */
        constructor(interaction: Gio.TlsInteraction);
        /**
         * Create a new GcrSshAskpass object which can be used to spawn an
         * ssh command and prompt for any necessary passwords.
         *
         * Use the gcr_ssh_askpass_child_setup() function as a callback with
         * g_spawn_sync(), g_spawn_async() or g_spawn_async_with_pipes().
         * @constructor
         * @param interaction the interaction to use for prompting paswords
         * @returns A new #GcrSshAskpass object
         */
        static new(interaction: Gio.TlsInteraction): SshAskpass;
        _init(config?: SshAskpass.ConstructorProperties): void;
        /**
         * Use this function as a callback setup function passed to g_spawn_sync(),
         * g_spawn_async(), g_spawn_async_with_pipes().
         * @param askpass a #GcrSshAskpass object
         */
        static child_setup(askpass: any | null): void;
    }

    module SystemPrompt {
        // Constructor properties interface

        interface ConstructorProperties
            extends Prompt.ConstructorProperties,
                Gio.AsyncInitable.ConstructorProperties,
                Gio.Initable.ConstructorProperties,
                GObject.Object.ConstructorProperties {
            // Own constructor properties of Gcr-4.Gcr.SystemPrompt

            /**
             * The DBus bus name of the prompter to use for prompting, or %NULL
             * for the default prompter.
             */
            bus_name?: string | null;
            /**
             * The #GcrSecretExchange to use when transferring passwords. A default
             * secret exchange will be used if this is not set.
             */
            secret_exchange?: SecretExchange | null;
            /**
             * The timeout in seconds to wait when opening the prompt.
             */
            timeout_seconds?: number | null;
        }
    }

    interface SystemPrompt extends Prompt, Gio.AsyncInitable, Gio.Initable {
        // Own properties of Gcr-4.Gcr.SystemPrompt

        /**
         * The DBus bus name of the prompter to use for prompting, or %NULL
         * for the default prompter.
         */
        readonly bus_name: string | null;
        /**
         * The #GcrSecretExchange to use when transferring passwords. A default
         * secret exchange will be used if this is not set.
         */
        secret_exchange: SecretExchange;
        /**
         * The timeout in seconds to wait when opening the prompt.
         */
        readonly timeout_seconds: number;

        // Own fields of Gcr-4.Gcr.SystemPrompt

        parent: GObject.Object;

        // Owm methods of Gcr-4.Gcr.SystemPrompt

        /**
         * Close this prompt. After calling this function, no further prompts will
         * succeed on this object. The prompt object is not unreferenced by this
         * function, and you must unreference it once done.
         *
         * This call may block, use the gcr_system_prompt_close_async() to perform
         * this action indefinitely.
         *
         * Whether or not this function returns %TRUE, the system prompt object is
         * still closed and may not be further used.
         * @param cancellable an optional cancellation object
         * @returns whether close was cleanly completed
         */
        close(cancellable: Gio.Cancellable | null): boolean;

        // Overloads of close

        /**
         * Closes the prompt so that in can no longer be used to prompt. The various
         * prompt methods will return results as if the user dismissed the prompt.
         *
         * The prompt may also be closed by the implementor of the prompt object.
         *
         * This emits the [signal`Prompt:`:prompt-close] signal on the prompt object.
         */
        close(): void;
        /**
         * Close this prompt asynchronously. After calling this function, no further
         * methods may be called on this object. The prompt object is not unreferenced
         * by this function, and you must unreference it once done.
         *
         * This call returns immediately and completes asynchronously.
         * @param cancellable an optional cancellation object
         * @param callback called when the operation completes
         */
        close_async(
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null
        ): void;

        // Overloads of close_async

        /**
         * Promisified version of {@link close_async}
         *
         * Close this prompt asynchronously. After calling this function, no further
         * methods may be called on this object. The prompt object is not unreferenced
         * by this function, and you must unreference it once done.
         *
         * This call returns immediately and completes asynchronously.
         * @param cancellable an optional cancellation object
         * @returns A Promise of: whether close was cleanly completed
         */
        close_async(
            cancellable: Gio.Cancellable | null
        ): globalThis.Promise<boolean>;
        /**
         * Complete operation to close this prompt.
         *
         * Whether or not this function returns %TRUE, the system prompt object is
         * still closed and may not be further used.
         * @param result asynchronous operation result
         * @returns whether close was cleanly completed
         */
        close_finish(result: Gio.AsyncResult): boolean;
        /**
         * Get the current [class`SecretExchange]` used to transfer secrets in this prompt.
         * @returns the secret exchange
         */
        get_secret_exchange(): SecretExchange;

        // Class property signals of Gcr-4.Gcr.SystemPrompt

        connect(
            sigName: 'notify::bus-name',
            callback: ($obj: SystemPrompt, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::bus-name',
            callback: ($obj: SystemPrompt, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::bus-name', ...args: any[]): void;
        connect(
            sigName: 'notify::secret-exchange',
            callback: ($obj: SystemPrompt, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::secret-exchange',
            callback: ($obj: SystemPrompt, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::secret-exchange', ...args: any[]): void;
        connect(
            sigName: 'notify::timeout-seconds',
            callback: ($obj: SystemPrompt, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::timeout-seconds',
            callback: ($obj: SystemPrompt, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::timeout-seconds', ...args: any[]): void;
        connect(
            sigName: 'notify::caller-window',
            callback: ($obj: SystemPrompt, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::caller-window',
            callback: ($obj: SystemPrompt, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::caller-window', ...args: any[]): void;
        connect(
            sigName: 'notify::cancel-label',
            callback: ($obj: SystemPrompt, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::cancel-label',
            callback: ($obj: SystemPrompt, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::cancel-label', ...args: any[]): void;
        connect(
            sigName: 'notify::choice-chosen',
            callback: ($obj: SystemPrompt, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::choice-chosen',
            callback: ($obj: SystemPrompt, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::choice-chosen', ...args: any[]): void;
        connect(
            sigName: 'notify::choice-label',
            callback: ($obj: SystemPrompt, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::choice-label',
            callback: ($obj: SystemPrompt, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::choice-label', ...args: any[]): void;
        connect(
            sigName: 'notify::continue-label',
            callback: ($obj: SystemPrompt, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::continue-label',
            callback: ($obj: SystemPrompt, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::continue-label', ...args: any[]): void;
        connect(
            sigName: 'notify::description',
            callback: ($obj: SystemPrompt, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::description',
            callback: ($obj: SystemPrompt, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::description', ...args: any[]): void;
        connect(
            sigName: 'notify::message',
            callback: ($obj: SystemPrompt, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::message',
            callback: ($obj: SystemPrompt, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::message', ...args: any[]): void;
        connect(
            sigName: 'notify::password-new',
            callback: ($obj: SystemPrompt, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::password-new',
            callback: ($obj: SystemPrompt, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::password-new', ...args: any[]): void;
        connect(
            sigName: 'notify::password-strength',
            callback: ($obj: SystemPrompt, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::password-strength',
            callback: ($obj: SystemPrompt, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::password-strength', ...args: any[]): void;
        connect(
            sigName: 'notify::title',
            callback: ($obj: SystemPrompt, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::title',
            callback: ($obj: SystemPrompt, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::title', ...args: any[]): void;
        connect(
            sigName: 'notify::warning',
            callback: ($obj: SystemPrompt, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::warning',
            callback: ($obj: SystemPrompt, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::warning', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * A [iface`Prompt]` implementation which calls to the system prompter to
     * display prompts in a system modal fashion.
     *
     * Since the system prompter usually only displays one prompt at a time, you
     * may have to wait for the prompt to be displayed. Use [func`SystemPrompt`.open]
     * or a related function to open a prompt. Since this can take a long time, you
     * should always check that the prompt is still needed after it is opened. A
     * previous prompt may have already provided the information needed and you
     * may no longer need to prompt.
     *
     * Use [method`SystemPrompt`.close] to close the prompt when you're done with it.
     * @class
     */
    class SystemPrompt extends GObject.Object {
        // Own properties of Gcr-4.Gcr.SystemPrompt

        static name: string;
        static $gtype: GObject.GType<SystemPrompt>;

        // Constructors of Gcr-4.Gcr.SystemPrompt

        constructor(config?: SystemPrompt.ConstructorProperties);
        _init(config?: SystemPrompt.ConstructorProperties): void;
        static error_get_domain(): GLib.Quark;
        /**
         * Opens a system prompt with the default prompter.
         *
         * Most system prompters only allow showing one prompt at a time, and if
         * another prompt is shown then this method will block for up to
         * `timeout_seconds` seconds. If `timeout_seconds` is equal to -1, then this
         * will block indefinitely until the prompt can be opened. If `timeout_seconds`
         * expires, then this function will fail with a %GCR_SYSTEM_PROMPT_IN_PROGRESS
         * error.
         * @param timeout_seconds the number of seconds to wait to access the prompt, or -1
         * @param cancellable optional cancellation object
         * @returns the prompt, or %NULL if          prompt could not be opened
         */
        static open(
            timeout_seconds: number,
            cancellable: Gio.Cancellable | null
        ): SystemPrompt;
        /**
         * Asynchronously open a system prompt with the default system prompter.
         *
         * Most system prompters only allow showing one prompt at a time, and if
         * another prompt is shown then this method will block for up to
         * `timeout_seconds` seconds. If `timeout_seconds` is equal to -1, then this
         * will block indefinitely until the prompt can be opened. If `timeout_seconds`
         * expires, then this operation will fail with a %GCR_SYSTEM_PROMPT_IN_PROGRESS
         * error.
         * @param timeout_seconds the number of seconds to wait to access the prompt, or -1
         * @param cancellable optional cancellation object
         * @param callback called when the operation completes
         */
        static open_async(
            timeout_seconds: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<SystemPrompt> | null
        ): void;
        /**
         * Complete an operation to asynchronously open a system prompt.
         * @param result the asynchronous result
         * @returns the prompt, or %NULL if          prompt could not be opened
         */
        static open_finish(result: Gio.AsyncResult): SystemPrompt;
        /**
         * Opens a system prompt. If prompter_name is %NULL, then the default
         * system prompter is used.
         *
         * Most system prompters only allow showing one prompt at a time, and if
         * another prompt is shown then this method will block for up to
         * `timeout_seconds` seconds. If `timeout_seconds` is equal to -1, then this
         * will block indefinitely until the prompt can be opened. If `timeout_seconds`
         * expires, then this function will fail with a %GCR_SYSTEM_PROMPT_IN_PROGRESS
         * error.
         * @param prompter_name the prompter dbus name
         * @param timeout_seconds the number of seconds to wait to access the prompt, or -1
         * @param cancellable optional cancellation object
         * @returns the prompt, or %NULL if          prompt could not be opened
         */
        static open_for_prompter(
            prompter_name: string | null,
            timeout_seconds: number,
            cancellable: Gio.Cancellable | null
        ): SystemPrompt;
        /**
         * Opens a system prompt asynchronously. If prompter_name is %NULL, then the
         * default system prompter is used.
         *
         * Most system prompters only allow showing one prompt at a time, and if
         * another prompt is shown then this method will block for up to
         * `timeout_seconds` seconds. If `timeout_seconds` is equal to -1, then this
         * will block indefinitely until the prompt can be opened. If `timeout_seconds`
         * expires, then this operation will fail with a %GCR_SYSTEM_PROMPT_IN_PROGRESS
         * error.
         * @param prompter_name the prompter D-Bus name
         * @param timeout_seconds the number of seconds to wait to access the prompt, or -1
         * @param cancellable optional cancellation object
         * @param callback called when the operation completes
         */
        static open_for_prompter_async(
            prompter_name: string | null,
            timeout_seconds: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<SystemPrompt> | null
        ): void;
    }

    module SystemPrompter {
        // Signal callback interfaces

        /**
         * Signal callback interface for `new-prompt`
         */
        interface NewPromptSignalCallback {
            ($obj: SystemPrompter): Prompt;
        }

        // Constructor properties interface

        interface ConstructorProperties
            extends GObject.Object.ConstructorProperties {
            // Own constructor properties of Gcr-4.Gcr.SystemPrompter

            /**
             * The #GType for prompts created by this prompter. This must be a
             * #GcrPrompt implementation.
             */
            prompt_type?: GObject.GType | null;
        }
    }

    interface SystemPrompter {
        // Own properties of Gcr-4.Gcr.SystemPrompter

        /**
         * The #GType for prompts created by this prompter. This must be a
         * #GcrPrompt implementation.
         */
        readonly prompt_type: GObject.GType;
        /**
         * Whether the prompter is prompting or not.
         */
        readonly prompting: boolean;

        // Own fields of Gcr-4.Gcr.SystemPrompter

        parent: GObject.Object;

        // Owm methods of Gcr-4.Gcr.SystemPrompter

        /**
         * Get the mode for this prompter.
         *
         * Most system prompters only display one prompt at a time and therefore
         * return %GCR_SYSTEM_PROMPTER_SINGLE.
         * @returns the prompter mode
         */
        get_mode(): SystemPrompterMode;
        /**
         * Get the #GType for prompts created by this prompter.
         *
         * The returned #GType will be a #GcrPrompt implementation.
         * @returns the prompt #GType
         */
        get_prompt_type(): GObject.GType;
        /**
         * Get whether prompting or not.
         * @returns whether prompting or not
         */
        get_prompting(): boolean;
        /**
         * Register this system prompter on the DBus `connection`.
         *
         * This makes the prompter available for clients to call. The prompter will
         * remain registered until gcr_system_prompter_unregister() is called, or the
         * prompter is unreferenced.
         * @param connection a DBus connection
         */
        register(connection: Gio.DBusConnection): void;
        /**
         * Unregister this system prompter on the DBus `connection`.
         *
         * The prompter must have previously been registered with gcr_system_prompter_register().
         *
         * If `wait` is set then this function will wait until all prompts have been closed
         * or cancelled. This is usually only used by tests.
         * @param wait whether to wait for closing prompts
         */
        unregister(wait: boolean): void;

        // Own signals of Gcr-4.Gcr.SystemPrompter

        connect(
            sigName: 'new-prompt',
            callback: SystemPrompter.NewPromptSignalCallback
        ): number;
        connect_after(
            sigName: 'new-prompt',
            callback: SystemPrompter.NewPromptSignalCallback
        ): number;
        emit(sigName: 'new-prompt', ...args: any[]): void;

        // Class property signals of Gcr-4.Gcr.SystemPrompter

        connect(
            sigName: 'notify::prompt-type',
            callback: ($obj: SystemPrompter, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::prompt-type',
            callback: ($obj: SystemPrompter, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::prompt-type', ...args: any[]): void;
        connect(
            sigName: 'notify::prompting',
            callback: ($obj: SystemPrompter, pspec: GObject.ParamSpec) => void
        ): number;
        connect_after(
            sigName: 'notify::prompting',
            callback: ($obj: SystemPrompter, pspec: GObject.ParamSpec) => void
        ): number;
        emit(sigName: 'notify::prompting', ...args: any[]): void;
        connect(sigName: string, callback: (...args: any[]) => void): number;
        connect_after(
            sigName: string,
            callback: (...args: any[]) => void
        ): number;
        emit(sigName: string, ...args: any[]): void;
        disconnect(id: number): void;
    }

    /**
     * A prompter used by implementations of system prompts.
     *
     * This is a D-Bus service which is rarely implemented. Use [class`SystemPrompt]`
     * to display system prompts.
     *
     * The system prompter service responds to D-Bus requests to create system
     * prompts and creates #GcrPrompt type objects to display those prompts.
     *
     * Pass the GType of the implementation of [iface`Prompt]` to
     * [ctor`SystemPrompter`.new].
     * @class
     */
    class SystemPrompter extends GObject.Object {
        // Own properties of Gcr-4.Gcr.SystemPrompter

        static name: string;
        static $gtype: GObject.GType<SystemPrompter>;

        // Constructors of Gcr-4.Gcr.SystemPrompter

        constructor(config?: SystemPrompter.ConstructorProperties);
        /**
         * Create a new system prompter service. This prompter won't do anything unless
         * you connect to its signals and show appropriate prompts.
         *
         * If `prompt_type` is zero, then the new-prompt signal must be handled and
         * return a valid prompt object implementing the #GcrPrompt interface.
         *
         * If `prompt_type` is non-zero then the #GType must implement the #GcrPrompt
         * interface.
         * @constructor
         * @param mode the mode for the prompt
         * @param prompt_type the gobject type for prompts created by this prompter
         * @returns a new prompter service
         */
        constructor(mode: SystemPrompterMode, prompt_type: GObject.GType);
        /**
         * Create a new system prompter service. This prompter won't do anything unless
         * you connect to its signals and show appropriate prompts.
         *
         * If `prompt_type` is zero, then the new-prompt signal must be handled and
         * return a valid prompt object implementing the #GcrPrompt interface.
         *
         * If `prompt_type` is non-zero then the #GType must implement the #GcrPrompt
         * interface.
         * @constructor
         * @param mode the mode for the prompt
         * @param prompt_type the gobject type for prompts created by this prompter
         * @returns a new prompter service
         */
        static new(
            mode: SystemPrompterMode,
            prompt_type: GObject.GType
        ): SystemPrompter;
        _init(config?: SystemPrompter.ConstructorProperties): void;
    }

    interface CertificateChainClass {
        // Own fields of Gcr-4.Gcr.CertificateChainClass

        /**
         * The parent class
         * @field
         */
        parent_class: GObject.ObjectClass;
    }

    /**
     * The class for #GcrCertificateChain.
     * @record
     */
    abstract class CertificateChainClass {
        // Own properties of Gcr-4.Gcr.CertificateChainClass

        static name: string;
    }

    interface CertificateChainPrivate {}

    class CertificateChainPrivate {
        // Own properties of Gcr-4.Gcr.CertificateChainPrivate

        static name: string;
    }

    interface CertificateFieldClass {
        // Own fields of Gcr-4.Gcr.CertificateFieldClass

        parent_class: GObject.ObjectClass;
    }

    abstract class CertificateFieldClass {
        // Own properties of Gcr-4.Gcr.CertificateFieldClass

        static name: string;
    }

    interface CertificateIface {
        // Own fields of Gcr-4.Gcr.CertificateIface

        /**
         * the parent interface type
         * @field
         */
        parent: GObject.TypeInterface;
        get_der_data: (self: Certificate) => Uint8Array;
    }

    /**
     * The interface that implementors of #GcrCertificate must implement.
     * @record
     */
    abstract class CertificateIface {
        // Own properties of Gcr-4.Gcr.CertificateIface

        static name: string;
    }

    interface CertificateRequestClass {
        // Own fields of Gcr-4.Gcr.CertificateRequestClass

        parent_class: GObject.ObjectClass;
    }

    abstract class CertificateRequestClass {
        // Own properties of Gcr-4.Gcr.CertificateRequestClass

        static name: string;
    }

    interface CertificateSectionClass {
        // Own fields of Gcr-4.Gcr.CertificateSectionClass

        parent_class: GObject.ObjectClass;
    }

    abstract class CertificateSectionClass {
        // Own properties of Gcr-4.Gcr.CertificateSectionClass

        static name: string;
    }

    interface ImportInteractionInterface {
        // Own fields of Gcr-4.Gcr.ImportInteractionInterface

        /**
         * parent interface
         * @field
         */
        parent: GObject.TypeInterface;
        supplement_prep: (
            interaction: ImportInteraction,
            builder: Gck.Builder
        ) => void;
        supplement: (
            interaction: ImportInteraction,
            builder: Gck.Builder,
            cancellable: Gio.Cancellable | null
        ) => Gio.TlsInteractionResult;
        supplement_async: (
            interaction: ImportInteraction,
            builder: Gck.Builder,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback | null
        ) => void;
        supplement_finish: (
            interaction: ImportInteraction,
            result: Gio.AsyncResult
        ) => Gio.TlsInteractionResult;
    }

    /**
     * Interface implemented by implementations of [iface`ImportInteraction]`.
     * @record
     */
    abstract class ImportInteractionInterface {
        // Own properties of Gcr-4.Gcr.ImportInteractionInterface

        static name: string;
    }

    interface ImporterInterface {
        // Own fields of Gcr-4.Gcr.ImporterInterface

        /**
         * parent interface
         * @field
         */
        parent: GObject.TypeInterface;
        queue_for_parsed: (importer: Importer, parsed: Parsed) => boolean;
        import_async: (
            importer: Importer,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback | null
        ) => void;
        import_finish: (importer: Importer, result: Gio.AsyncResult) => boolean;
    }

    /**
     * Interface implemented for a #GcrImporter.
     * @record
     */
    abstract class ImporterInterface {
        // Own properties of Gcr-4.Gcr.ImporterInterface

        static name: string;
    }

    interface Parsed {
        // Owm methods of Gcr-4.Gcr.Parsed

        /**
         * Get the attributes which make up the parsed item.
         * @returns the attributes for the item; these          are owned by the parsed item and should not be freed
         */
        get_attributes(): Gck.Attributes | null;
        /**
         * Get the raw data block for the parsed item.
         * @returns the raw data of the parsed item, or %NULL
         */
        get_bytes(): GLib.Bytes;
        /**
         * Get the raw data block for the parsed item.
         * @returns the raw data of          the parsed item, or %NULL
         */
        get_data(): Uint8Array | null;
        /**
         * Get the descirption for a parsed item.
         * @returns the description
         */
        get_description(): string | null;
        /**
         * Get the filename of the parsed item.
         * @returns the filename of          the parsed item, or %NULL
         */
        get_filename(): string | null;
        /**
         * Get the format of the parsed item.
         * @returns the data format of the item
         */
        get_format(): DataFormat;
        /**
         * Get the label for the parsed item.
         * @returns the label for the item
         */
        get_label(): string | null;
        /**
         * Add a reference to a parsed item. An item may not be shared across threads
         * until it has been referenced at least once.
         * @returns the parsed item
         */
        ref(): Parsed;
    }

    /**
     * A parsed item parsed by a #GcrParser.
     * @record
     */
    class Parsed {
        // Own properties of Gcr-4.Gcr.Parsed

        static name: string;

        // Constructors of Gcr-4.Gcr.Parsed

        /**
         * Unreferences a parsed item which was referenced with gcr_parsed_ref()
         * @param parsed a parsed item
         */
        static unref(parsed: any | null): void;
    }

    interface ParserClass {
        // Own fields of Gcr-4.Gcr.ParserClass

        /**
         * The parent class
         * @field
         */
        parent_class: GObject.ObjectClass;
        authenticate: (self: Parser, count: number) => boolean;
        parsed: (self: Parser) => void;
    }

    /**
     * The class for #GcrParser
     * @record
     */
    abstract class ParserClass {
        // Own properties of Gcr-4.Gcr.ParserClass

        static name: string;
    }

    interface ParserPrivate {}

    class ParserPrivate {
        // Own properties of Gcr-4.Gcr.ParserPrivate

        static name: string;
    }

    interface Pkcs11CertificateClass {}

    abstract class Pkcs11CertificateClass {
        // Own properties of Gcr-4.Gcr.Pkcs11CertificateClass

        static name: string;
    }

    interface Pkcs11CertificatePrivate {}

    class Pkcs11CertificatePrivate {
        // Own properties of Gcr-4.Gcr.Pkcs11CertificatePrivate

        static name: string;
    }

    interface PromptInterface {
        // Own fields of Gcr-4.Gcr.PromptInterface

        /**
         * parent interface
         * @field
         */
        parent_iface: GObject.TypeInterface;
        prompt_password_async: (
            prompt: Prompt,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback | null
        ) => void;
        prompt_password_finish: (
            prompt: Prompt,
            result: Gio.AsyncResult
        ) => string | null;
        prompt_confirm_async: (
            prompt: Prompt,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback | null
        ) => void;
        prompt_confirm_finish: (
            prompt: Prompt,
            result: Gio.AsyncResult
        ) => PromptReply;
        prompt_close: (prompt: Prompt) => void;
    }

    /**
     * The interface for implementing [iface`Prompt]`.
     * @record
     */
    abstract class PromptInterface {
        // Own properties of Gcr-4.Gcr.PromptInterface

        static name: string;
    }

    interface SecretExchangeClass {
        // Own fields of Gcr-4.Gcr.SecretExchangeClass

        generate_exchange_key: (
            exchange: SecretExchange,
            scheme: string | null,
            public_key: number,
            n_public_key: number
        ) => boolean;
        derive_transport_key: (
            exchange: SecretExchange,
            peer: number,
            n_peer: number
        ) => boolean;
    }

    abstract class SecretExchangeClass {
        // Own properties of Gcr-4.Gcr.SecretExchangeClass

        static name: string;
    }

    interface SecretExchangePrivate {}

    class SecretExchangePrivate {
        // Own properties of Gcr-4.Gcr.SecretExchangePrivate

        static name: string;
    }

    interface SimpleCertificateClass {
        // Own fields of Gcr-4.Gcr.SimpleCertificateClass

        parent_class: GObject.ObjectClass;
    }

    abstract class SimpleCertificateClass {
        // Own properties of Gcr-4.Gcr.SimpleCertificateClass

        static name: string;
    }

    interface SimpleCertificatePrivate {}

    class SimpleCertificatePrivate {
        // Own properties of Gcr-4.Gcr.SimpleCertificatePrivate

        static name: string;
    }

    interface SshAskpassClass {
        // Own fields of Gcr-4.Gcr.SshAskpassClass

        parent_class: GObject.ObjectClass;
    }

    abstract class SshAskpassClass {
        // Own properties of Gcr-4.Gcr.SshAskpassClass

        static name: string;
    }

    interface SystemPromptClass {
        // Own fields of Gcr-4.Gcr.SystemPromptClass

        parent_class: GObject.ObjectClass;
    }

    abstract class SystemPromptClass {
        // Own properties of Gcr-4.Gcr.SystemPromptClass

        static name: string;
    }

    interface SystemPromptPrivate {}

    class SystemPromptPrivate {
        // Own properties of Gcr-4.Gcr.SystemPromptPrivate

        static name: string;
    }

    interface SystemPrompterClass {
        // Own fields of Gcr-4.Gcr.SystemPrompterClass

        /**
         * parent class
         * @field
         */
        parent_class: GObject.ObjectClass;
    }

    /**
     * The class for #GcrSystemPrompter.
     * @record
     */
    abstract class SystemPrompterClass {
        // Own properties of Gcr-4.Gcr.SystemPrompterClass

        static name: string;
    }

    interface SystemPrompterPrivate {}

    class SystemPrompterPrivate {
        // Own properties of Gcr-4.Gcr.SystemPrompterPrivate

        static name: string;
    }

    /**
     * Name of the imported GIR library
     * @see https://gitlab.gnome.org/GNOME/gjs/-/blob/master/gi/ns.cpp#L188
     */
    const __name__: string;
    /**
     * Version of the imported GIR library
     * @see https://gitlab.gnome.org/GNOME/gjs/-/blob/master/gi/ns.cpp#L189
     */
    const __version__: string;
}

export default Gcr;
// END
